<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>GPG 安装与使用</title>
      <link href="/2019/05/29/gpg_an_zhuang_yu_shi_yong/"/>
      <url>/2019/05/29/gpg_an_zhuang_yu_shi_yong/</url>
      <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>最近使用 <code>GitHub</code> 时无意间看见 <code>commit</code> 历史中有些带有 <code>Verified</code> 的标识，而有些没有，如下图，<br><img src="http://img.imtianx.cn/2019/github_log_verify.png" alt></p><blockquote><p>经查看发现 <code>Github</code> 默认使用了 <strong>GPG</strong> 进行签名(用其自己的 key ),来保证提交信息来自可靠的来源。</p></blockquote><p><a href="https://help.github.com/en/articles/managing-commit-signature-verification" target="_blank" rel="noopener">官方说明</a>：</p><blockquote><p>You can sign your work locally using GPG or S/MIME. GitHub will verify these signatures so other people will know that your commits come from a trusted source. GitHub will automatically sign commits you make using the GitHub web interface.</p></blockquote><p><strong>关于 GPG</strong></p><blockquote><p><strong><a href="https://gnupg.org/" target="_blank" rel="noopener">GnuPG</a></strong>（GNU Privacy Guard,GPG）是一种加密软件，它是 PGP 加密软件的满足GPL协议的替代物 。用于加密、数字签章及产生非对称匙对的软件 <a id="more"></a>^[1] 。<strong>用于加密、签名通信内容及管理非对称密码学的密钥</strong>。</p></blockquote><p>这里简记 <code>GPG</code> 安装配置到 <code>Git</code> 中遇到的相关问题及解决办法。</p><h2 id="安装及生成密钥"><a href="#安装及生成密钥" class="headerlink" title="安装及生成密钥"></a>安装及生成密钥</h2><p>官网为：<a href="https://gnupg.org" target="_blank" rel="noopener">https://gnupg.org</a>，软件包有：</p><ul><li>win: <a href="http://www.gpg4win.org/" target="_blank" rel="noopener">Gpg4win</a>，或者 <a href="http://cygwin.org/" target="_blank" rel="noopener">Cygwin</a> 内置的 <code>Gnupg</code>;</li><li>mac : <a href="https://gpgtools.org/" target="_blank" rel="noopener">GPGTools</a>(GUI 界面)；</li><li>linux/unix: 包管理器安装或源码编译。</li></ul><blockquote><p>这里以 <code>brew</code> 安装 <code>gnupg</code> 为例。</p></blockquote><p><strong>1、安装</strong><br>当前安装的软件包为目前最新的：<code>brew info gpg</code></p><pre><code> &gt; brew info gpggnupg: stable 2.2.15 (bottled)GNU Pretty Good Privacy (PGP) packagehttps://gnupg.org//usr/local/Cellar/gnupg/2.2.15 (135 files, 11MB) *  Poured from bottle on 2019-05-29 at 10:17:33From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/gnupg.rb==&gt; DependenciesBuild: pkg-config ✔Required: adns ✔, gettext ✔, gnutls ✔, libassuan ✔, libgcrypt ✔, libgpg-error ✔, libksba ✔, libusb ✔, npth ✔, pinentry ✔==&gt; Analyticsinstall: 30,935 (30 days), 134,827 (90 days), 517,582 (365 days)install_on_request: 25,763 (30 days), 108,154 (90 days), 407,474 (365 days)build_error: 0 (30 days)&gt; </code></pre><p>由于依赖较多，可以给 <code>brew</code> 设置镜像源来加速，然后进行安装：</p><pre><code>brew install gpg</code></pre><blockquote><p>网上有说安装 <code>gpg2</code>,经测试安装的均是 <code>gnupg</code>。</p></blockquote><p><strong>2、生成密钥</strong><br>非新使用 <code>gpg</code> ,可以使用 <code>gpg -k</code> 查看是否有证书，如下为有证书的示例:</p><pre><code> &gt; gpg -k/Users/imtianx/.gnupg/pubring.kbx---------------------------------pub   rsa4096 2019-05-28 [SC]      0A50E2B85C6E124AD0A1701FBFB191F8AFA7E860uid           [ultimate] imtianx (Signed-off-by imtianx on mbp.) &lt;imtianx@gmail.com&gt;sub   rsa4096 2019-05-28 [E]&gt; </code></pre><p>如果没有，使用如下命令进行生成：</p><pre><code>gpg --full-generate-key</code></pre><p>接着会有如下相关的提示，按照步骤设置信息：</p><ol><li>选择加密算法，<code>回车</code> 默认 <code>RSA</code> 和 <code>RSA</code>,或可输入对应的序号选择加密算法；</li><li>输入密钥长度，默认 <code>2048</code>,最大 <code>4096</code>,推荐使用 <code>4096</code>,输入然后回车；</li><li><p>密钥有效期，默认 <code>0</code> 永不过期；</p><pre><code>0 = 密钥永不过期&lt;n&gt; = 密钥在 n 天后过期&lt;n&gt;w = 密钥在 n 周后过期&lt;n&gt;m = 密钥在 n 月后过期&lt;n&gt;y = 密钥在 n 年后过期 </code></pre></li><li><p>确认是否正确；</p></li><li>设置个人信息：姓名、邮箱和注释（这个在以后可以进行添加删除等操作）；</li><li>确认用户标识，若无需修改，确认后即可生成密钥。</li></ol><blockquote><p>由于个人的 <code>gpg</code> 未使用过，这里未给出具体的创建信息。</p></blockquote><p>具体的步骤可参考：</p><ul><li><a href>Github-Generating a new GPG key</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">阮一峰-GPG入门教程</a></li></ul><blockquote><p>如果想要可视化页面操作，Mac 用户可以直接安装 <a href="https://gpgtools.org/" target="_blank" rel="noopener">GPGTools</a>。</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>查看密钥信息，ID 为  <code>BFB191F8AFA7E860</code>:</p><pre><code> &gt; gpg --list-secret-keys --keyid-format LONG/Users/imtianx/.gnupg/pubring.kbx---------------------------------sec   rsa4096/BFB191F8AFA7E860 2019-05-28 [SC]      0A50E2B85C6E124AD0A1701FBFB191F8AFA7E860uid                 [ultimate] imtianx (Signed-off-by imtianx on mbp.) &lt;imtianx@gmail.com&gt;ssb   rsa4096/B331F00185D28960 2019-05-28 [E]</code></pre><p>显示公钥内容;</p><pre><code>gpg --armor --export &lt;gpg_kek_id&gt;</code></pre><p>输出公钥到文件 <code>public-key.txt</code>：</p><pre><code>gpg --armor --output public-key.txt --export &lt;gpg_kek_id&gt;</code></pre><p><code>gpg</code> 加密文件：</p><pre><code>gpg --recipient &lt;gpg_key_id&gt; --output &lt;output_file_name&gt; --encrypt &lt;input_file_name&gt;</code></pre><p><code>gpg</code> 解密：</p><pre><code>gpg --output &lt;output_file_name&gt; --decrypt &lt;input_file_name&gt;</code></pre><blockquote><p>这里需要注意，–output 参数需要放前面。如果未将私钥的密码保存到钥匙串，这里会弹出输入密码窗口。</p></blockquote><p>此外，可以将自己的公钥上传到 GPG server,供他人使用。其他更多命令，可通过 <code>gpg --help</code> 查看。</p><p><strong>添加用户标识信息：</strong></p><pre><code>gpg --edit-key &lt;gpg_key——id&gt;/&lt;email&gt;</code></pre><p>进入 <code>gpg</code> 后可使用 <code>help</code> 查看所有的操作：</p><pre><code>pg&gt; helpquit        quit this menusave        save and quithelp        show this helpfpr         show key fingerprintgrip        show the keygriplist        list key and user IDsuid         select user ID Nkey         select subkey Ncheck       check signaturessign        sign selected user IDs [* see below for related commands]lsign       sign selected user IDs locallytsign       sign selected user IDs with a trust signaturenrsign      sign selected user IDs with a non-revocable signatureadduid      add a user IDaddphoto    add a photo IDdeluid      delete selected user IDsaddkey      add a subkeyaddcardkey  add a key to a smartcardkeytocard   move a key to a smartcardbkuptocard  move a backup key to a smartcarddelkey      delete selected subkeysaddrevoker  add a revocation keydelsig      delete signatures from the selected user IDsexpire      change the expiration date for the key or selected subkeysprimary     flag the selected user ID as primarypref        list preferences (expert)showpref    list preferences (verbose)setpref     set preference list for the selected user IDskeyserver   set the preferred keyserver URL for the selected user IDsnotation    set a notation for the selected user IDspasswd      change the passphrasetrust       change the ownertrustrevsig      revoke signatures on the selected user IDsrevuid      revoke selected user IDsrevkey      revoke key or selected subkeysenable      enable keydisable     disable keyshowphoto   show selected photo IDsclean       compact unusable user IDs and remove unusable signatures from keyminimize    compact unusable user IDs and remove all signatures from key* The &#39;sign&#39; command may be prefixed with an &#39;l&#39; for local signatures (lsign),  a &#39;t&#39; for trust signatures (tsign), an &#39;nr&#39; for non-revocable signatures  (nrsign), or any combination thereof (ltsign, tnrsign, etc.).</code></pre><blockquote><p>修改标识比较麻烦，推荐新建，旧的标识如果未使用可以删除，若有使用可以是指撤销。</p></blockquote><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>对于在 Git 中使用，需要开启签名，设置密钥Id：</p><pre><code>git config --global user.signingkey &lt;key_id&gt;// 如果是 gpg2 ，需对应的更换git config --global gpg.program gpg// 开启提交签名，或者 commit 时添加 -s 参数git config --global commit.gpgsign true</code></pre><p><strong>未使用 GPGTools，添加到环境变量：</strong></p><pre><code>export GPG_TTY=$(tty)</code></pre><blockquote><p>注意需要在对应的 Git 服务网站（GitHub/Gitlab）添加 GPG 公钥；<br>还有用户信息呢需要对应。</p></blockquote><p>然后在使用的时候，commit 记录就会有校验通过的标识，如下:<br><img src="http://img.imtianx.cn/2019/git_verified.png" alt></p><p>在查看 git log 时可以显示相关的签名信息：</p><pre><code>git log --show-signature -1</code></pre><p>输出为：</p><pre><code>commit 6b05e365de6a28b3054a5e6481c8e214552d2010gpg: Signature made Tue May 28 15:53:24 2019 CSTgpg:                using RSA key 0A50E2B85C6E124AD0A1701FBFB191F8AFA7E860gpg: Good signature from &quot;imtianx (Signed-off-by imtianx on mbp.) &lt;imtianx@gmail.com&gt;&quot; [ultimate]Author: imtianx &lt;imtianx@gmail.com&gt;Date:   Tue May 28 15:53:24 2019 +0800    test gpg;</code></pre><p>可以参考 Gtihub 文档：<a href="https://help.github.com/en/articles/telling-git-about-your-signing-key" target="_blank" rel="noopener">Telling Git about your signing key</a></p><blockquote><p>如有问题可参见 <a href="#common_error">常见错误</a></p></blockquote><h2 id="Sourcetree-配置"><a href="#Sourcetree-配置" class="headerlink" title="Sourcetree 配置"></a>Sourcetree 配置</h2><p>与 Git 设置相比，这里较为麻烦。<br>首先，<code>Sourcetree</code> 默认支持 <code>gpg2</code>,这里需要设置 gpg2 的软连接否则 sourcetree 无法识别：</p><pre><code>// 进入 gnupg 安装目录中的bin中cd /usr/local/Cellar/gnupg/2.2.15/binln -s gpg gpg2</code></pre><p>然后设置 gpg 目录，如下图：<br><img src="http://img.imtianx.cn/2019/sourcetree_gpg_folder.png" alt></p><p>接着,开启仓库 gpg 设置：<br><img src="http://img.imtianx.cn/2019/sourcetree_pgp_repo.png" alt></p><p>然后，开启签名设置：<br><img src="http://img.imtianx.cn/2019/sourcetree_commit_sign.png" alt></p><p>在首次提交时，未保存私钥密码，会弹出如下弹框:<br><img src="http://img.imtianx.cn/2019/sourcetree_gpg_pwd.png" alt></p><p>最后，开启签名后的提交信息如下：<br><img src="http://img.imtianx.cn/2019/sourcetree_commit_log.png" alt></p><p>到此，整个 <code>Sourcetree</code> 的配置完成，遇到较多的问题可能就是 commit 加密失败。</p><h2 id="common_error">常见错误</h2><font color="red">1、commit 签名错误：</font><pre><code>error: gpg failed to sign the datafatal: failed to write commit object</code></pre><p>可以在终端输入：</p><pre><code>export GPG_TTY=$(tty)</code></pre><p>然后，测试 gpg ,弹出密码框并确认输入后可暂时解决，如下测试示例：</p><pre><code>echo &quot;test&quot; | gpg --clearsign</code></pre><font color="red">可以使用下面方式彻底解决，会弹出输入密码弹框</font><pre><code>brew install pinentry-macecho &quot;pinentry-program /usr/local/bin/pinentry-mac&quot; &gt;&gt; ~/.gnupg/gpg-agent.confkillall gpg-agent</code></pre><font color="red">2、agent_genkey 错误</font><pre><code>gpg: agent_genkey failed: No such file or directory</code></pre><p>查找该进程并kill 掉：</p><pre><code>ps axu | grep gpg-agentkill -9 &lt;process_id&gt;</code></pre><blockquote><p>如有问题，请留言交流。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPG </tag>
            
            <tag> Git </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OpenGrok 源码阅读环境搭建</title>
      <link href="/2019/05/18/opengrok_yuan_ma_yue_du_huan_jing_da_jian/"/>
      <url>/2019/05/18/opengrok_yuan_ma_yue_du_huan_jing_da_jian/</url>
      <content type="html"><![CDATA[<p>开发过程中，往往需要阅读源码，挑选一个合适的源码阅读方式十分重要。这里简记使用 <a href="https://oracle.github.io/opengrok/" target="_blank" rel="noopener">OpenGrok</a>搭建源码阅读环境。<a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p> 作为一个 <code>Android</code> 开发者，最方便的在线 <code>AOSP</code> 源码阅读环境就是 ：<a href="http://androidxref.com" target="_blank" rel="noopener">androidxref.com</a> 。它使用 <strong><a href>OpenGrok</a></strong> 搭建而成，可以进行快速的检索，如下为 <a href="http://androidxref.com/9.0.0_r3/" target="_blank" rel="noopener">Pie 9.0.0_r3</a> 源码查找页面：<br> <img src="http://img.imtianx.cn/2019/androidxref_900r3.png" alt><br> 除此之外，如下网站也是使用 <code>OpenGrok</code> 搭建而成：</p><ol><li>illumos,Linux - <a href="http://src.illumos.org/source" target="_blank" rel="noopener">http://src.illumos.org/source</a></li><li>libreoffice - <a href="https://opengrok.libreoffice.org" target="_blank" rel="noopener">https://opengrok.libreoffice.org</a></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>由于个人喜欢将此类型的软件部署到 <code>docker</code> 中，这里以 <code>docker</code> 中安装部署为例说明。</p></blockquote><p>如下具体步骤：</p><ol><li><p>获取镜像,若需其他版本，可<a href="https://hub.docker.com/r/opengrok/docker/tags" target="_blank" rel="noopener">访问此处</a>查看：</p><pre><code>docker pull opengrok/docker</code></pre></li><li><p>设置源码目录;</p><p>创建一个存放源码的目录，如 <code>/home/source</code>,使用 git clone 所需源码。</p><blockquote><p>注意使用 Git 仓库，手动创建的目录目前无法显示，但是可以进行搜索。</p></blockquote></li><li><p>启动 <code>OpenGrok</code> ，挂载上述步骤中创建的源码目录，这里为 <code>/home/source</code>：</p><pre><code>docker run -d -v /home/source:/opengrok/src  --privileged=true -p 8080:8080 opengrok/docker</code></pre><blockquote><p>注意 <strong>–privileged=true</strong> 参数设置，否则挂载的目录在镜像内无法访问，导致索引失败;<br><strong>容器内部端口必须是: 8080</strong></p></blockquote></li><li><p>通过浏览器访问：<a href>http://ip:8080</a> 进行访问，如下图：</p><p><img src="http://img.imtianx.cn/2019/opengrok_home.png" alt><br>如果访问显示 error, 可能是源码索引未完成，可以稍后访问，或者手动进行索引:</p><pre><code>docker exec &lt;container_id&gt; /scripts/index.sh</code></pre><p>其中 <code>container_id</code> 为上面启动的容器 id 。</p><blockquote><p>如果以 <code>ip:port</code> 形式访问不方便，可以通过 <code>nginx</code> 配置反向代理，设置域名。</p></blockquote><p>具体的代码查找结果如下图,可以访问 <a href="code.imtianx.cn">code.imtianx.cn</a> 测试:<br><img src="http://img.imtianx.cn/2019/opengrok_code.png" alt></p></li></ol><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p><img src="http://img.imtianx.cn/2019/other_software_source.png" alt><br>对于大部分人而言，使用本地软件比较多，如 <code>idea</code>，<code>sublime</code>、<code>Unserstand</code>/ <code>source insight</code>等都可以，其中 <strong>Unserstand</strong> 的体验相对很好。</p>]]></content>
      
      <categories>
          
          <category> 工具软件 </category>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码阅读 </tag>
            
            <tag> OpenGrok </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>底部导航-BottomNavigationView 的使用及源码分析</title>
      <link href="/2018/09/04/bottomNavigationView_using_source/"/>
      <url>/2018/09/04/bottomNavigationView_using_source/</url>
      <content type="html"><![CDATA[<p>目前市面上很多 APP 都有底部导航的功能，实现底部导航的方式也有很多种,如：</p><ul><li>① 、使用原生控件 ：<code>TabHost</code> 、<code>LinearLayout</code>  /<code>RelativeLayout</code>、<code>RadioButton</code> 等；</li><li>② 、使用 <a href="https://developer.android.com/reference/android/support/design/package-summary" target="_blank" rel="noopener">Design</a> 库中的 <a href>TabLayout</a> 或 <strong><a href="https://developer.android.com/reference/android/support/design/widget/BottomNavigationView" target="_blank" rel="noopener">BottomNavigationView</a></strong> 实现；<a id="more"></a></li><li>③、使用第三方库 (<a href="https://github.com/H07000223/FlycoTabLayout" target="_blank" rel="noopener">FlycoTabLayout</a>/…) 实现；</li><li>④、自定义控件实现;</li><li>…</li></ul><p>总之，根据自己的实际需求可以选择不同的实现方案。这里主要介绍 <a href="https://developer.android.com/reference/android/support/design/widget/BottomNavigationView" target="_blank" rel="noopener">BottomNavigationView</a>  的实现方式，以及 SDK28 前后的差异。</p><h2 id="一、实现底部导航"><a href="#一、实现底部导航" class="headerlink" title="一、实现底部导航"></a>一、实现底部导航</h2><p>首先添加 <code>Design</code> 库的依赖：</p><pre><code>implementation &quot;com.android.support:design:27.1.1&quot;</code></pre><p>然后,在 <code>menu</code> 目录下定义 tab 的菜单,例如 <code>res/menu/menu_navigation_tab.xml</code>：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menu</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/navi_home<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/ic_home_black_24dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>首页<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/navi_order<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/ic_view_list_black_24dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>订单<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/navi_cart<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/ic_local_grocery_store_black_24dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>购物车<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/navi_mine<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/ic_person_black_24dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>我的<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menu</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着添加 <code>BottomNavigationView</code> 到布局中，如下主要代码：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>android.support.design.widget.BottomNavigationView</span>    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/navigation_view<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>?attr/actionBarSize<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:color/white<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>itemIconTint</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@color/color_navigation_item<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>itemTextColor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@color/color_navigation_item<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintBottom_toBottomOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintLeft_toLeftOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintRight_toRightOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintTop_toBottomOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@id/viewpager<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>menu</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@menu/menu_navigation<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>android.support.design.widget.BottomNavigationView</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意 ：<code>menu</code> 指定tab 显示菜单；<code>itemIconTint</code> 和 <code>itemTextColor</code> 对应为指定 tab 的 icon 和文本颜色(通过定义 color ,指定不同选中状态的颜色)。</p></blockquote><p>最后在 对应的 activity 中对 <code>BottomNavigationView</code> 添加 item 选中监听，配合 <code>ViewPager</code> 实现界面切换：</p><p><img src="http://img.imtianx.cn/2018/0904/aty_bnv_init.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2ltdGlhbnguY24v/font/5b6u6L2v6ZuF6buR/fontsize/1200/fill/I0Y4MEIwQg==/dissolve/100/gravity/SouthEast/dx/20/dy/20" alt></p><p>上述实现较为简单，预览效果如下左图所示：</p><p>4个tab： <img src="http://img.imtianx.cn/2018/0904/tab_4_before_28.gif" alt="图一">                3个tab : <img src="http://img.imtianx.cn/2018/0904/tab_3_before_28.gif" alt></p><blockquote><p>注意：如上图所示，当 tab 操作三个，选中的 item 就会有偏移效果，并且只有选中的 item 显示文本。</p></blockquote><h2 id="二、tab-偏移问题"><a href="#二、tab-偏移问题" class="headerlink" title="二、tab 偏移问题"></a>二、tab 偏移问题</h2><p>对于上面所出现的3个以上tab 会出现偏移问题，通过查看源码，<a href="http://androidxref.com/8.1.0_r33/xref/frameworks/support/design/src/android/support/design/widget/BottomNavigationView.java" target="_blank" rel="noopener">BottomNavigationView</a> 的菜单是由 <a href="http://androidxref.com/8.1.0_r33/xref/frameworks/support/design/src/android/support/design/internal/BottomNavigationMenuView.java" target="_blank" rel="noopener">BottomNavigationMenuView</a> 控制的，如下构造方法中对 <code>BottomNavigationMenuView</code> 的初始化及相关属性设置的部分代码 ：</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token function">BottomNavigationView</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> AttributeSet attrs<span class="token punctuation">,</span> <span class="token keyword">int</span> defStyleAttr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> defStyleAttr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Create the menu</span>        mMenu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BottomNavigationMenu</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        mMenuView <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BottomNavigationMenuView</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        FrameLayout<span class="token punctuation">.</span>LayoutParams params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FrameLayout<span class="token punctuation">.</span>LayoutParams</span><span class="token punctuation">(</span>                ViewGroup<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>WRAP_CONTENT<span class="token punctuation">,</span> ViewGroup<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>WRAP_CONTENT<span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span>gravity <span class="token operator">=</span> Gravity<span class="token punctuation">.</span>CENTER<span class="token punctuation">;</span>        mMenuView<span class="token punctuation">.</span><span class="token function">setLayoutParams</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>        mPresenter<span class="token punctuation">.</span><span class="token function">setBottomNavigationMenuView</span><span class="token punctuation">(</span>mMenuView<span class="token punctuation">)</span><span class="token punctuation">;</span>        mPresenter<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>MENU_PRESENTER_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>        mMenuView<span class="token punctuation">.</span><span class="token function">setPresenter</span><span class="token punctuation">(</span>mPresenter<span class="token punctuation">)</span><span class="token punctuation">;</span>        mMenu<span class="token punctuation">.</span><span class="token function">addMenuPresenter</span><span class="token punctuation">(</span>mPresenter<span class="token punctuation">)</span><span class="token punctuation">;</span>        mPresenter<span class="token punctuation">.</span><span class="token function">initForMenu</span><span class="token punctuation">(</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mMenu<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Custom attributes</span>        TintTypedArray a <span class="token operator">=</span> TintTypedArray<span class="token punctuation">.</span><span class="token function">obtainStyledAttributes</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span>                R<span class="token punctuation">.</span>styleable<span class="token punctuation">.</span>BottomNavigationView<span class="token punctuation">,</span> defStyleAttr<span class="token punctuation">,</span>                R<span class="token punctuation">.</span>style<span class="token punctuation">.</span>Widget_Design_BottomNavigationView<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">hasValue</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>styleable<span class="token punctuation">.</span>BottomNavigationView_itemIconTint<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            mMenuView<span class="token punctuation">.</span><span class="token function">setIconTintList</span><span class="token punctuation">(</span>                    a<span class="token punctuation">.</span><span class="token function">getColorStateList</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>styleable<span class="token punctuation">.</span>BottomNavigationView_itemIconTint<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            mMenuView<span class="token punctuation">.</span><span class="token function">setIconTintList</span><span class="token punctuation">(</span>                    <span class="token function">createDefaultColorStateList</span><span class="token punctuation">(</span>android<span class="token punctuation">.</span>R<span class="token punctuation">.</span>attr<span class="token punctuation">.</span>textColorSecondary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">hasValue</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>styleable<span class="token punctuation">.</span>BottomNavigationView_itemTextColor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            mMenuView<span class="token punctuation">.</span><span class="token function">setItemTextColor</span><span class="token punctuation">(</span>                    a<span class="token punctuation">.</span><span class="token function">getColorStateList</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>styleable<span class="token punctuation">.</span>BottomNavigationView_itemTextColor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            mMenuView<span class="token punctuation">.</span><span class="token function">setItemTextColor</span><span class="token punctuation">(</span>                    <span class="token function">createDefaultColorStateList</span><span class="token punctuation">(</span>android<span class="token punctuation">.</span>R<span class="token punctuation">.</span>attr<span class="token punctuation">.</span>textColorSecondary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">hasValue</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>styleable<span class="token punctuation">.</span>BottomNavigationView_elevation<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ViewCompat<span class="token punctuation">.</span><span class="token function">setElevation</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getDimensionPixelSize</span><span class="token punctuation">(</span>                    R<span class="token punctuation">.</span>styleable<span class="token punctuation">.</span>BottomNavigationView_elevation<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> itemBackground <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">getResourceId</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>styleable<span class="token punctuation">.</span>BottomNavigationView_itemBackground<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mMenuView<span class="token punctuation">.</span><span class="token function">setItemBackgroundRes</span><span class="token punctuation">(</span>itemBackground<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">hasValue</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>styleable<span class="token punctuation">.</span>BottomNavigationView_menu<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">inflateMenu</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getResourceId</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>styleable<span class="token punctuation">.</span>BottomNavigationView_menu<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        a<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addView</span><span class="token punctuation">(</span>mMenuView<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而 <code>BottomNavigationMenuView</code> 中的 item 是一个包含图片文本的自定义控件– <a href="http://androidxref.com/8.1.0_r33/xref/frameworks/support/design/src/android/support/design/internal/BottomNavigationItemView.java" target="_blank" rel="noopener">BottomNavigationItemView</a> 类型的数组保存的。在 <code>BottomNavigationItemView</code> 中对于不同的模式和选中状态，设置 item 的 icon 和 label 的显示，如下部分代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 偏移模式，默认 false</span> <span class="token keyword">private</span> <span class="token keyword">boolean</span> mShiftingMode<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">BottomNavigationItemView</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> AttributeSet attrs<span class="token punctuation">,</span> <span class="token keyword">int</span> defStyleAttr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token keyword">int</span> inactiveLabelSize <span class="token operator">=</span>                res<span class="token punctuation">.</span><span class="token function">getDimensionPixelSize</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>dimen<span class="token punctuation">.</span>design_bottom_navigation_text_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 12sp</span>    <span class="token keyword">int</span> activeLabelSize <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getDimensionPixelSize</span><span class="token punctuation">(</span>                R<span class="token punctuation">.</span>dimen<span class="token punctuation">.</span>design_bottom_navigation_active_text_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//14sp</span>    mShiftAmount <span class="token operator">=</span> inactiveLabelSize <span class="token operator">-</span> activeLabelSize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// inactiveLabelSize &lt; activeLabelSize 为 false</span>    mShiftAmount <span class="token operator">=</span> inactiveLabelSize <span class="token operator">-</span> activeLabelSize<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// label 选中缩放比例</span>    mScaleUpFactor <span class="token operator">=</span> <span class="token number">1f</span> <span class="token operator">*</span> activeLabelSize <span class="token operator">/</span> inactiveLabelSize<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// label 隐藏缩放比例</span>    mScaleDownFactor <span class="token operator">=</span> <span class="token number">1f</span> <span class="token operator">*</span> inactiveLabelSize <span class="token operator">/</span> activeLabelSize<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 设置偏移模式</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setShiftingMode</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> enabled<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mShiftingMode <span class="token operator">=</span> enabled<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 设置 title</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setTitle</span><span class="token punctuation">(</span>CharSequence title<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mSmallLabel<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>    mLargeLabel<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ...</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setChecked</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> checked<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mShiftingMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>checked<span class="token punctuation">)</span> <span class="token punctuation">{</span>            LayoutParams iconParams <span class="token operator">=</span> <span class="token punctuation">(</span>LayoutParams<span class="token punctuation">)</span> mIcon<span class="token punctuation">.</span><span class="token function">getLayoutParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            iconParams<span class="token punctuation">.</span>gravity <span class="token operator">=</span> Gravity<span class="token punctuation">.</span>CENTER_HORIZONTAL <span class="token operator">|</span> Gravity<span class="token punctuation">.</span>TOP<span class="token punctuation">;</span>            iconParams<span class="token punctuation">.</span>topMargin <span class="token operator">=</span> mDefaultMargin<span class="token punctuation">;</span>            mIcon<span class="token punctuation">.</span><span class="token function">setLayoutParams</span><span class="token punctuation">(</span>iconParams<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 选中状态，显示文本，设置缩放</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>VISIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setScaleX</span><span class="token punctuation">(</span><span class="token number">1f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setScaleY</span><span class="token punctuation">(</span><span class="token number">1f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            LayoutParams iconParams <span class="token operator">=</span> <span class="token punctuation">(</span>LayoutParams<span class="token punctuation">)</span> mIcon<span class="token punctuation">.</span><span class="token function">getLayoutParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            iconParams<span class="token punctuation">.</span>gravity <span class="token operator">=</span> Gravity<span class="token punctuation">.</span>CENTER<span class="token punctuation">;</span>            iconParams<span class="token punctuation">.</span>topMargin <span class="token operator">=</span> mDefaultMargin<span class="token punctuation">;</span>            mIcon<span class="token punctuation">.</span><span class="token function">setLayoutParams</span><span class="token punctuation">(</span>iconParams<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 未选中状态，隐藏文本，设置缩放一半动画</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>INVISIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setScaleX</span><span class="token punctuation">(</span><span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setScaleY</span><span class="token punctuation">(</span><span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        mSmallLabel<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>INVISIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>checked<span class="token punctuation">)</span> <span class="token punctuation">{</span>            LayoutParams iconParams <span class="token operator">=</span> <span class="token punctuation">(</span>LayoutParams<span class="token punctuation">)</span> mIcon<span class="token punctuation">.</span><span class="token function">getLayoutParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            iconParams<span class="token punctuation">.</span>gravity <span class="token operator">=</span> Gravity<span class="token punctuation">.</span>CENTER_HORIZONTAL <span class="token operator">|</span> Gravity<span class="token punctuation">.</span>TOP<span class="token punctuation">;</span>            iconParams<span class="token punctuation">.</span>topMargin <span class="token operator">=</span> mDefaultMargin <span class="token operator">+</span> mShiftAmount<span class="token punctuation">;</span>            mIcon<span class="token punctuation">.</span><span class="token function">setLayoutParams</span><span class="token punctuation">(</span>iconParams<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 选中，选中 label 显示，未选中 label 隐藏</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>VISIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            mSmallLabel<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>INVISIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setScaleX</span><span class="token punctuation">(</span><span class="token number">1f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setScaleY</span><span class="token punctuation">(</span><span class="token number">1f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mSmallLabel<span class="token punctuation">.</span><span class="token function">setScaleX</span><span class="token punctuation">(</span>mScaleUpFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>            mSmallLabel<span class="token punctuation">.</span><span class="token function">setScaleY</span><span class="token punctuation">(</span>mScaleUpFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            LayoutParams iconParams <span class="token operator">=</span> <span class="token punctuation">(</span>LayoutParams<span class="token punctuation">)</span> mIcon<span class="token punctuation">.</span><span class="token function">getLayoutParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            iconParams<span class="token punctuation">.</span>gravity <span class="token operator">=</span> Gravity<span class="token punctuation">.</span>CENTER_HORIZONTAL <span class="token operator">|</span> Gravity<span class="token punctuation">.</span>TOP<span class="token punctuation">;</span>            iconParams<span class="token punctuation">.</span>topMargin <span class="token operator">=</span> mDefaultMargin<span class="token punctuation">;</span>            mIcon<span class="token punctuation">.</span><span class="token function">setLayoutParams</span><span class="token punctuation">(</span>iconParams<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 未选中，选中 label 隐藏，未选中 label 显示</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>INVISIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            mSmallLabel<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>VISIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setScaleX</span><span class="token punctuation">(</span>mScaleDownFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>            mLargeLabel<span class="token punctuation">.</span><span class="token function">setScaleY</span><span class="token punctuation">(</span>mScaleDownFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>            mSmallLabel<span class="token punctuation">.</span><span class="token function">setScaleX</span><span class="token punctuation">(</span><span class="token number">1f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mSmallLabel<span class="token punctuation">.</span><span class="token function">setScaleY</span><span class="token punctuation">(</span><span class="token number">1f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>mLargeLabel 和 mSmallLabel 均表示 菜单文本，只是前者是选中状态，后者是未选中状态展示；对两个 label 设置相应的缩放比例，实现切换 tab 时的动画视差效果。同时，在 <code>mShiftingMode</code> 为 <strong>false</strong> 下可以保证 label 的一直显示以及 item 的间距均衡。</p></blockquote><p>通过上面的分析，知道了 tab 设置文本显示的根源，但是其 显示与否还与 <code>mShiftingMode</code> 相关，毕竟 tab 数量在3前后不同。</p><p>接着回头查看 <code>BottomNavigationMenuView</code> 源码，<code>mShiftingMode</code> 的设置 如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 偏移模式</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> mShiftingMode <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 菜单 item</span><span class="token keyword">private</span> BottomNavigationItemView<span class="token punctuation">[</span><span class="token punctuation">]</span> mButtons<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> Pools<span class="token punctuation">.</span>Pool<span class="token operator">&lt;</span>BottomNavigationItemView<span class="token operator">></span> mItemPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pools<span class="token punctuation">.</span>SynchronizedPool</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> MenuBuilder mMenu<span class="token punctuation">;</span>mButtons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BottomNavigationItemView</span><span class="token punctuation">[</span>mMenu<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以3为分界线，来设置不同的偏移模式</span>mShiftingMode <span class="token operator">=</span> mMenu<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mMenu<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mPresenter<span class="token punctuation">.</span><span class="token function">setUpdateSuspended</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mMenu<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setCheckable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mPresenter<span class="token punctuation">.</span><span class="token function">setUpdateSuspended</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    BottomNavigationItemView child <span class="token operator">=</span> <span class="token function">getNewItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mButtons<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> child<span class="token punctuation">;</span>    child<span class="token punctuation">.</span><span class="token function">setIconTintList</span><span class="token punctuation">(</span>mItemIconTint<span class="token punctuation">)</span><span class="token punctuation">;</span>    child<span class="token punctuation">.</span><span class="token function">setTextColor</span><span class="token punctuation">(</span>mItemTextColor<span class="token punctuation">)</span><span class="token punctuation">;</span>    child<span class="token punctuation">.</span><span class="token function">setItemBackground</span><span class="token punctuation">(</span>mItemBackgroundRes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置偏移</span>    child<span class="token punctuation">.</span><span class="token function">setShiftingMode</span><span class="token punctuation">(</span>mShiftingMode<span class="token punctuation">)</span><span class="token punctuation">;</span>    child<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">(</span>MenuItemImpl<span class="token punctuation">)</span> mMenu<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    child<span class="token punctuation">.</span><span class="token function">setItemPosition</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    child<span class="token punctuation">.</span><span class="token function">setOnClickListener</span><span class="token punctuation">(</span>mOnClickListener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">addView</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取 item ,mItemPool 的最大值为5 ，限制了最多5个 tab</span><span class="token keyword">private</span> BottomNavigationItemView <span class="token function">getNewItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    BottomNavigationItemView item <span class="token operator">=</span> mItemPool<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        item <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BottomNavigationItemView</span><span class="token punctuation">(</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> item<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的代码，彻底知道了 tab 个数在3前后 菜单的偏移模式不同，所以可以修改 <code>mShiftingMode</code> 属性来保证 tab 操作3个后的显示模式，但是，<code>BottomNavigationMenuView</code> 并未开放相关方法，因此可以通过反射修改 <code>mShiftingMode</code> 的值，以及遍历菜单修改相关属性，如下：</p><pre class="line-numbers language-kotlin"><code class="language-kotlin"><span class="token keyword">object</span> NavigationViewHelper <span class="token punctuation">{</span>    <span class="token annotation builtin">@SuppressLint</span><span class="token punctuation">(</span><span class="token string">"RestrictedApi"</span><span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">disableShiftingMode</span><span class="token punctuation">(</span>view<span class="token operator">:</span> BottomNavigationView<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">val</span> menuView <span class="token operator">=</span> view<span class="token punctuation">.</span><span class="token function">getChildAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">as</span> BottomNavigationMenuView        <span class="token keyword">if</span> <span class="token punctuation">(</span>menuView<span class="token punctuation">.</span>childCount <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">val</span> shiftingMode <span class="token operator">=</span> menuView<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"mShiftingMode"</span><span class="token punctuation">)</span>                shiftingMode<span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span>                    isAccessible <span class="token operator">=</span> <span class="token boolean">true</span>                    <span class="token function">setBoolean</span><span class="token punctuation">(</span>menuView<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>                    isAccessible <span class="token operator">=</span> <span class="token boolean">false</span>                <span class="token punctuation">}</span>                menuView<span class="token punctuation">.</span><span class="token function">forEachChild</span> <span class="token punctuation">{</span>                    <span class="token punctuation">(</span>it <span class="token keyword">as</span> BottomNavigationItemView<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span>                        <span class="token function">setShiftingMode</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">// reset check state to update it</span>                        <span class="token function">setChecked</span><span class="token punctuation">(</span>itemData<span class="token punctuation">.</span>isChecked<span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> NoSuchFieldException<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"tx"</span><span class="token punctuation">,</span> <span class="token string">"NavigationViewHelper: Unable to get shiftMode field"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> IllegalAccessException<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"tx"</span><span class="token punctuation">,</span> <span class="token string">"NavigationViewHelper: Unable to change value of shiftMode"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用上面的工具类可以使 tab 个数在5个内的文本显示、间距相同。</p><h2 id="三、SDK28-以后相关-API-的变更"><a href="#三、SDK28-以后相关-API-的变更" class="headerlink" title="三、SDK28 以后相关 API 的变更"></a>三、SDK28 以后相关 API 的变更</h2><p>最近将项目的 <code>compile sdk</code> 和 <code>support</code> 相关库升级到28以后，上述的工具类失效，编译无法通过，发现源码中 ，移除了 <code>mShiftingMode</code> 属性和 <code>setShiftingMode</code> 方法。<br>这里以 <code>28.0.0-rc01</code> 的 <code>support</code> 库为例进行分析 (如需使用其他版本，请查看 <a href="https://dl.google.com/dl/android/maven2/index.html" target="_blank" rel="noopener">google maven repo</a> )。</p><p><strong>主要的变动有：</strong></p><ul><li>对于 <code>BottomNavigationItemView</code>,原始的 <code>mShiftingMode</code> 换成了 <code>isShifting</code> ,并且添加 <code>labelVisibilityMode</code> 属性。</li><li>对于 <code>BottomNavigationMenuView</code> ,移除了 boolean 类型的 <code>mShiftingMode</code> 属性，取而代之的是 int 类型的 <code>labelVisibilityMode</code>。</li><li>对于 <code>BottomNavigationView</code> ,添加字自定义属性 <code>labelVisibilityMode</code>;</li></ul><p>这里从 <code>BottomNavigationView</code> 源码看起，在 28 以后，新增的自定属性 <code>labelVisibilityMode</code> 取值为：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>declare-styleable</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>BottomNavigationView<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>attr</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>menu<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>attr</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>labelVisibilityMode<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 自动 ，和 menu 的 item 数目有关 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enum</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>auto<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>-1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 选中状态显示 label --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enum</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selected<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 全部显示 label --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enum</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>labeled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 全部不显示 label --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enum</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>unlabeled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，默认为 <code>-1</code>,如下获取自定义属性和设置 menu 的 labelVisibilityMode 的源码：</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">final</span> BottomNavigationMenuView menuView<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取自定义属性值，默认 -1</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setLabelVisibilityMode</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getInteger</span><span class="token punctuation">(</span>styleable<span class="token punctuation">.</span>BottomNavigationView_labelVisibilityMode<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置 menu 的 labelVisibilityMode</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLabelVisibilityMode</span><span class="token punctuation">(</span><span class="token keyword">int</span> labelVisibilityMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>menuView<span class="token punctuation">.</span><span class="token function">getLabelVisibilityMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> labelVisibilityMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>menuView<span class="token punctuation">.</span><span class="token function">setLabelVisibilityMode</span><span class="token punctuation">(</span>labelVisibilityMode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>presenter<span class="token punctuation">.</span><span class="token function">updateMenuView</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着，查看 <code>BottomNavigationMenuView</code> 的相关源码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">boolean</span> shifting <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isShifting</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>labelVisibilityMode<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>menu<span class="token punctuation">.</span><span class="token function">getVisibleItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> menuSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>presenter<span class="token punctuation">.</span><span class="token function">setUpdateSuspended</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>buttons<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">setLabelVisibilityMode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>labelVisibilityMode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置偏移</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>buttons<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">setShifting</span><span class="token punctuation">(</span>shifting<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>buttons<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">(</span>MenuItemImpl<span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>menu<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>presenter<span class="token punctuation">.</span><span class="token function">setUpdateSuspended</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 判断是否需要偏移</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isShifting</span><span class="token punctuation">(</span><span class="token keyword">int</span> labelVisibilityMode<span class="token punctuation">,</span> <span class="token keyword">int</span> childCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> labelVisibilityMode <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> childCount <span class="token operator">></span> <span class="token number">3</span> <span class="token operator">:</span> labelVisibilityMode <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>说明：主要是 <code>isShifting</code> 方法中处理：当 labelVisibilityMode 为默认值 <code>-1</code> 时，菜单数目大于 <code>3</code> 个，会偏移，否则不会偏移；当 labelVisibilityMode 值为 <code>0</code> 时,会偏移；其他取值不会偏移 。</p></blockquote><p>最后来看看 <code>BottomNavigationItemView</code> 中 item 偏移与 label 显示与否的相关设置：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ...</span><span class="token keyword">switch</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>labelVisibilityMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>isShifting<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>checked<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewLayoutParams</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>icon<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMargin<span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>largeLabel<span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewLayoutParams</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>icon<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMargin<span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>largeLabel<span class="token punctuation">,</span> <span class="token number">0.5F</span><span class="token punctuation">,</span> <span class="token number">0.5F</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>smallLabel<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>checked<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewLayoutParams</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>icon<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>defaultMargin <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>shiftAmount<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>largeLabel<span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>smallLabel<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scaleUpFactor<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scaleUpFactor<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewLayoutParams</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>icon<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMargin<span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>largeLabel<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scaleDownFactor<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scaleDownFactor<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>smallLabel<span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>checked<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewLayoutParams</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>icon<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMargin<span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>largeLabel<span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewLayoutParams</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>icon<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMargin<span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>largeLabel<span class="token punctuation">,</span> <span class="token number">0.5F</span><span class="token punctuation">,</span> <span class="token number">0.5F</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>smallLabel<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>checked<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewLayoutParams</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>icon<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>defaultMargin <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>shiftAmount<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>largeLabel<span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>smallLabel<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scaleUpFactor<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scaleUpFactor<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewLayoutParams</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>icon<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMargin<span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>largeLabel<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scaleDownFactor<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scaleDownFactor<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>smallLabel<span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">1.0F</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setViewLayoutParams</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>icon<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultMargin<span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>largeLabel<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>smallLabel<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">refreshDrawableState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setSelected</span><span class="token punctuation">(</span>checked<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ...</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setViewLayoutParams</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> View view<span class="token punctuation">,</span> <span class="token keyword">int</span> topMargin<span class="token punctuation">,</span> <span class="token keyword">int</span> gravity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LayoutParams viewParams <span class="token operator">=</span> <span class="token punctuation">(</span>LayoutParams<span class="token punctuation">)</span>view<span class="token punctuation">.</span><span class="token function">getLayoutParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    viewParams<span class="token punctuation">.</span>topMargin <span class="token operator">=</span> topMargin<span class="token punctuation">;</span>    viewParams<span class="token punctuation">.</span>gravity <span class="token operator">=</span> gravity<span class="token punctuation">;</span>    view<span class="token punctuation">.</span><span class="token function">setLayoutParams</span><span class="token punctuation">(</span>viewParams<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setViewValues</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> View view<span class="token punctuation">,</span> <span class="token keyword">float</span> scaleX<span class="token punctuation">,</span> <span class="token keyword">float</span> scaleY<span class="token punctuation">,</span> <span class="token keyword">int</span> visibility<span class="token punctuation">)</span> <span class="token punctuation">{</span>    view<span class="token punctuation">.</span><span class="token function">setScaleX</span><span class="token punctuation">(</span>scaleX<span class="token punctuation">)</span><span class="token punctuation">;</span>    view<span class="token punctuation">.</span><span class="token function">setScaleY</span><span class="token punctuation">(</span>scaleY<span class="token punctuation">)</span><span class="token punctuation">;</span>    view<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>visibility<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 labelVisibilityMode 的多种取值(-1-2,设置其他值会导致切换时 label 无动画)，上面出现了多种情况，如下简要说明：</p><p><img src="http://img.imtianx.cn/2018/0904/item_view_labelVisibilitymode_des.png" alt></p><blockquote><p>注意：(1)、由于没有源码，AS 自动生成的，代码中有些是具体的值。(2)、对于 View 的显示状态：VISIBLE 为 0、INVISIBLE 为 4、GONE 为 8 ；通过查看 <code>27.1.1</code> 中 BottomNavigationItemView 对应的源码，设置 gravity 参数分别为 : <code>Gravity.CENTER</code> , <code>Gravity.CENTER_HORIZONTAL | Gravity.TOP</code> , 值为 <code>17</code>、 <code>49</code> (通过相应的 <code>|</code> 、<code>&lt;&lt;</code> 运算而得，可在 <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/view/Gravity.java" target="_blank" rel="noopener">Gravity</a> 源码中查看)。上述源码中调用 <code>setViewLayoutParams</code> 时传入的 17/49 的值应该与之前版本一致。</p></blockquote><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>对于 28以前，可以使用上面的工具类，来保证操作3个 tab 的显示不偏移；而 28 以后直接设置 <code>app:labelVisibilityMode=&quot;labeled&quot;</code> 即可。此外，对于项目中的依赖库的升级，需要了解其 api 的变更，然后作出相应的更换。另外，如果项目中自定义了 <code>CoordinatorLayout.Behavior</code>，在 28 以后，也需要注意，对于 <code>layoutDependsOn</code>、 <code>onDependentViewChanged</code>方法参数不能为空，有 <code>@NonNull</code> 注解。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> BottomNavigationView </tag>
            
            <tag> Design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker的使用及镜像编写</title>
      <link href="/2018/07/30/docker_using/"/>
      <url>/2018/07/30/docker_using/</url>
      <content type="html"><![CDATA[<p>随着容器技术的普及，越来越多的事情可以在 <code>Docker</code> 中完成。这里简要记录 docker 的常用命令以及镜像的构建与运用。结合gitlab-ci来构建 android apk。<br><a id="more"></a></p><h2 id="一、docker-安装"><a href="#一、docker-安装" class="headerlink" title="一、docker 安装"></a>一、docker 安装</h2><h3 id="1-Mac-安装"><a href="#1-Mac-安装" class="headerlink" title="1.Mac 安装"></a>1.Mac 安装</h3><p>在 mac 上,通常使用 <a href="https://brew.sh/" target="_blank" rel="noopener">homebrew</a> 包管理器来安装软件，其中 <code>cask</code> 扩展可以安装图形界面程序，这里安装带有图形界面的 <strong>Docker</strong> 软件：</p><pre><code>brew cask install docker</code></pre><p>获取去<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">官网</a>下载对应的安装包安装。</p><p>然后启动后即可在命令行使用。可以运行 <code>docker --version</code> 查看版本信息，检测启动情况。</p><p>由于Docker 的仓库大部分在国外，访问速度会受限，可以设置国内的镜像站点。</p><p>依次打开 ：<code>preferences</code> -&gt; <code>daemon</code> ,然后在 <code>Registry mirrors</code> 中添加：<a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></p><h3 id="2-centos-安装"><a href="#2-centos-安装" class="headerlink" title="2 centos 安装"></a>2 centos 安装</h3><p>由于通常很多的 Docker 镜像 都是在 Centos 服务器上运行，这里简记 Centos 安装。这里采用 <a href="http://yum.baseurl.org/" target="_blank" rel="noopener">yum</a> 安装,如下：(参考 <a href="https://docs.docker.com/install/linux/docker-ce/centos/#uninstall-old-versions" target="_blank" rel="noopener">官方文档</a>)</p><pre><code>// 1. 卸载旧版本sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine// 2.安装相关工具sudo yum install -y yum-utils \  device-mapper-persistent-data \  lvm2// 3.添加docker 软件源 sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo// 如果需要最新版本，可使用如下命令安装sudo yum-config-manager --enable docker-ce-edge// 如果需要最新测试版本，可使用如下命令安装sudo yum-config-manager --enable docker-ce-test// 4.安装sudo yum install docker-ce// 启动docker sudo systemctl start docker// 运行 hello-word 镜像 进行测试docker run hello-word</code></pre><p>同样的，为了提高速度，可以配置国内镜像加速服务,可选的有：</p><ul><li>docker 官方提供的：<a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="noopener">https://registry.docker-cn.com</a></li><li>七牛云提供的：<a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener"> https://registry-mirror.qiniu.com</a></li><li>阿里云提供的:<a href="https://help.aliyun.com/document_detail/60750.html?spm=a2c4g.11186623.6.547.4eb36efcc3Cijq" target="_blank" rel="noopener">登陆阿里云申请</a></li></ul><p>这里以第一种方式为例说明：<br>首先修改或者新建 <code>/etc/docker/daemon.json</code> 为如下内容：</p><pre><code>{  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]}</code></pre><p>保存并重启：</p><pre><code>systemctl daemon-reloadsystemctl restart docker</code></pre><h2 id="二、镜像、容器和仓库"><a href="#二、镜像、容器和仓库" class="headerlink" title="二、镜像、容器和仓库"></a>二、镜像、容器和仓库</h2><p><strong>镜像</strong>：是一个特殊的文件系统，为容器运行提供提供程序、资源、配置文件等，他不包含任何用户态数据，构建完成后不可改变。</p><p><strong>容器</strong>：是镜像运行的实体，可以可以被创建、启动、删除、停止、暂停等。镜像与容器的关系，类似 Java 中的 类 和 实例。</p><p><strong>仓库</strong>：用于存储分发镜像文件。可以使用官方的仓库 <a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">docker hub</a>,或者自己搭建私有仓库。</p><h2 id="三、docker-常用命令"><a href="#三、docker-常用命令" class="headerlink" title="三、docker 常用命令"></a>三、docker 常用命令</h2><pre><code>// 启动/停止  dockersystemctl start dockersystemctl stop docker// 查看镜像docker images // 查找 nginx 镜像docker search nginx// 拉取 nginx 镜像,默认tag为latest，需要仓库中有该标签的镜像方可使用docker pull nginx// 指定拉取 1.15.1 版本的docker pull nginx:1.15.1// 运行一个容器,name 指定名字，d 表示后台运行，p 指定端口，其中前者为主端口，后者为容器端口，可以通过 主机ip:外部端口 访问 docker run --name nginx -d -p 8094:80 nginx// 查看容器 运行日志，-f 实时显示docker logs -f container_id// 通过容器 id 进入容器,i交互模式，t终端，进入bash，使用 exit 退出 docker exec -it container_id bash// 查看docker 容器进程,-a 表示所有的，-q 只显示 iddocker ps // 停止容器 docker stop container_id// 重启容器docker restart container_id// 删除容器 docker rm container_id// 删除镜像，必须先删除对应版本启动的容器docker rmi image_id</code></pre><h2 id="四、docker-镜像编写及-自动构建"><a href="#四、docker-镜像编写及-自动构建" class="headerlink" title="四、docker 镜像编写及 自动构建"></a>四、docker 镜像编写及 自动构建</h2><p>可以根据自己的需求，编写 <code>Dockerfile</code> 文件，构建自己的镜像，然后上传到 <a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">docker hub</a>。为了方便使用 git-runner 来构建项目，这里简单的编写 android SDK 镜像,如下 <a href="https://github.com/imtianx/docker-android-compiler/blob/master/Dockerfile" target="_blank" rel="noopener">Dockerfile</a>：</p><pre><code>FROM openjdk:8-jdkMAINTAINER imtianx &quot;imtianx@gmail.com&quot;# -----------------------set android sdk-----------------start-----# Command line tools only from https://developer.android.com/studio/ARG SDK_TOOLS_VERSION=4333796ARG BUILD_TOOLS_VERSION=27.0.3ARG COMPILE_SDK_VERSION=27# workspace dirWORKDIR /workspace_android# set android env pathENV ANDROID_HOME /workspace_android/sdk# install android sdk .....start....RUN mkdir  sdk &amp;&amp; \    wget http://dl.google.com/android/repository/sdk-tools-linux-${SDK_TOOLS_VERSION}.zip &amp;&amp; \    unzip -qd sdk sdk-tools-linux-${SDK_TOOLS_VERSION}.zip &amp;&amp; \    rm -f sdk-tools-linux-${SDK_TOOLS_VERSION}.zip &amp;&amp; \    (yes | ./sdk/tools/bin/sdkmanager --no_https --update) &amp;&amp; \    (yes | ./sdk/tools/bin/sdkmanager --no_https &quot;build-tools;${BUILD_TOOLS_VERSION}&quot;) &amp;&amp; \    (yes | ./sdk/tools/bin/sdkmanager --no_https &quot;platform-tools&quot;) &amp;&amp; \    (yes | ./sdk/tools/bin/sdkmanager --no_https &quot;platforms;android-${COMPILE_SDK_VERSION}&quot;) &amp;&amp; \    (yes | ./sdk/tools/bin/sdkmanager --no_https &quot;extras;google;m2repository&quot;) &amp;&amp; \    (yes | ./sdk/tools/bin/sdkmanager --no_https &quot;extras;android;m2repository&quot;) &amp;&amp; \    (yes | ./sdk/tools/bin/sdkmanager --no_https &quot;extras;m2repository;com;android;support;constraint;constraint-layout-solver;1.0.2&quot;) &amp;&amp; \    (yes | ./sdk/tools/bin/sdkmanager --no_https &quot;extras;m2repository;com;android;support;constraint;constraint-layout;1.0.2&quot;)# -----------------------set android sdk-------------------end-----</code></pre><p>这里基于 jdk8,然后下载android sdk ，进行构建。构建命令：</p><pre><code>// -t 指定 tagdocker build -t nginx:v1 .// 登陆 docker hub docker login // 推送到 docker hubdocker push nginx:v1</code></pre><blockquote><p>注意，镜像构建是分层的，过多的内容可以分层构建，每一个 <code>RUN</code> 操作都是一层，层之间默认隔离的。具体的 <code>Dockerfile</code> 的编写 参考：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">Best practices for writing Dockerfiles</a>。</p></blockquote><p>通常，如果镜像的构建过程需要下载较多资源(特别是国外资源)，或者不想在自己电脑构建，可以将自己的 <code>Dockerfile</code> 放在 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 或者 <a href="https://bitbucket.org/" target="_blank" rel="noopener">Bitbucket</a> ，然后利用 docker hub 提供的自动构建服务来构建镜像，与相关的仓库关联，然后在构建设置中添加触发的规则。</p><blockquote><p>注意：如果需要使镜像 pull 时不添加 版本号，需要添加 tag 为 <code>latest</code> 的构建任务，保证改镜像的 tag 中有 <code>latest</code></p></blockquote><p>可参考；<a href="https://hub.docker.com/r/imtianx/docker-android-compiler/" target="_blank" rel="noopener">docker-android-compiler</a></p><p>最后可以在 git 项目中添加 <code>.gitlab-ci.yml</code> 文件，指定上面的镜像。如下简单示例：</p><pre><code># gitlab ci for android image: imtianx/docker-android-compilerstages:  - buildbefore_script:  - |-    # Information used for debugging    echo &quot;/---------------------- JOB INFO ----------------------/&quot;    echo &quot;CI_JOB_ID ${CI_JOB_ID}&quot;    echo &quot;CI_JOB_MANUAL ${CI_JOB_MANUAL}&quot;    echo &quot;CI_JOB_NAME ${CI_JOB_NAME}&quot;    echo &quot;CI_JOB_STAGE ${CI_JOB_STAGE}&quot;    echo &quot;/--------------------- RUNNER INFO --------------------/&quot;    echo &quot;CI_RUNNER_ID ${CI_RUNNER_ID}&quot;    echo &quot;CI_RUNNER_TAGS ${CI_RUNNER_TAGS}&quot;    echo &quot;CI_RUNNER_DESCRIPTION ${CI_RUNNER_DESCRIPTION}&quot;    echo &quot;/---------------------- CPU INFO ----------------------/&quot;    cat /proc/cpuinfo # To kwow if CPU supports KVM (for Android emulators), the flags category must contain &quot;vmx&quot; or &quot;svm&quot; ; egrep &#39;^flags.*(vmx|svm)&#39; /proc/cpuinfo    echo &quot;/-------------------- PROJECT INFO --------------------/&quot;    echo &quot;ANDROID_COMPILE_SDK ${ANDROID_COMPILE_SDK}&quot;    echo &quot;ANDROID_BUILD_TOOLS ${ANDROID_BUILD_TOOLS}&quot;    echo &quot;/------------------------------------------------------/&quot;  - chmod +x ./gradlew # Set rights for gradlew project usageandroid_build:  stage: build  script:    - ./gradlew clean assembleRelease  artifacts:    name: &quot;build_${CI_PROJECT_NAME}_${CI_BUILD_REF_NAME}_${CI_JOB_NAME}_${CI_JOB_ID}&quot;    when: always    paths:      - app/build/outputs/apk/      - app/build/outputs/mapping/</code></pre><p>更多gitlab-ci 配置参考 : <a href="https://gitlab.com/imtianx/TestCIAndroid" target="_blank" rel="noopener">TestCIAndroid</a></p><blockquote><p>这里使用 gitlab 官方的，如果是自己搭建的gitlab,需要安装 git-runner,并且对项目进行设置。对于 CI 平台，国外做的比较好还有 <a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 和 <a href="https://circleci.com/" target="_blank" rel="noopener">CircleCI</a>，其中<a href="https://github.com/imtianx/imtianx.github.io" target="_blank" rel="noopener">我的博客</a> 是通过 <code>Travis CI</code> 来自动构建的。</p></blockquote><blockquote><p>记录一个坑：<br>最近使用 <a href="https://www.cnrancher.com/" target="_blank" rel="noopener">rancher</a> 来管理docker容器，折腾了一上午仍然无法启动 rancher 容器，最后发现 <strong>rancher 容器默认只能用 8080 端口</strong>。</p></blockquote><p>参考资料：</p><p><strong>1.<a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">《Docker 技术入门与实践》</a></strong><br><strong>2. <a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker Docs</a></strong></p>]]></content>
      
      <categories>
          
          <category> 工具软件 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> dockerfile </tag>
            
            <tag> gitlab-ci </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AS3.2 和 androidx 爬坑</title>
      <link href="/2018/06/04/as3_2_pre_androix_bug/"/>
      <url>/2018/06/04/as3_2_pre_androix_bug/</url>
      <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>前不久的 <code>Googel IO</code> 大会上亮相的 <a href="https://developer.android.com/jetpack/" target="_blank" rel="noopener">JetPack</a> ,他为android 开发带来了极大地便利，于是开启了尝（爬）鲜（坑）之旅。<a id="more"></a><br>自从接手了一个 <code>MVVM</code> 架构的项目，就喜欢上了这种模式的开发，使用 <code>Kotlin</code> 开发，里面用到了 <a href="https://developer.android.com/topic/libraries/data-binding/" target="_blank" rel="noopener">Databinding</a>，<a href="https://developer.android.com/topic/libraries/architecture/livedata" target="_blank" rel="noopener">LiveData</a>、<a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">Lifecycler</a> 和 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel" target="_blank" rel="noopener">viewmodel</a> 等架构组件，代码简洁，流程清晰，整个开发是十分愉快的，慢慢的习惯了用这些东西。<br>这些组件都是吸引人的，如果还没有了解的可以上手试试。</p><h2 id="二、Jetpack-简介"><a href="#二、Jetpack-简介" class="headerlink" title="二、Jetpack 简介"></a>二、Jetpack 简介</h2><blockquote><p>官网介绍：Jetpack 是一套库、工具和架构指南，可以帮助我们快速轻松的构建优秀的Android应用，它提供了公共基础代码，因此我们可以专注于让自己应用独一无二的东西。</p></blockquote><p>主要有三个有点：</p><ul><li><strong>加速开发</strong><br>组件可以单独使用或者组合是使用，同时利用 Kotlin 语言功能，可以使开发效率更高。</li><li><strong>消除样板代码</strong><br>Android Jetpack管理诸如后台任务，导航和生命周期管理等繁琐的活动，因此您可以专注于什么使您的应用更棒</li><li><strong>构建搞质量健全的应用</strong><br>以现代设计实践为基础，Android Jetpack组件可降低崩溃次数并减少内存泄漏，并向后兼容</li></ul><p>其中包含组件如下图所示：</p><p><img src="http://img.imtianx.cn/2018/0602/0001.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2ltdGlhbnguY24v/font/5b6u6L2v6ZuF6buR/fontsize/1200/fill/I0Y4MEIwQg==/dissolve/100/gravity/SouthEast/dx/20/dy/20" alt></p><p>以下是官方博客中的图，更加直白：</p><p><img src="http://img.imtianx.cn/2018/0602/003.png" alt></p><p>以上内容来自 Google <a href="https://developer.android.com/jetpack/" target="_blank" rel="noopener">官方jetpack文档</a>，更多 jetpack 使用及介绍相关内容请参考官方文档。</p><h2 id="三、AS-3-2-爬坑"><a href="#三、AS-3-2-爬坑" class="headerlink" title="三、AS 3.2 爬坑"></a>三、AS 3.2 爬坑</h2><h3 id="3-1-转换过项目为-androidx"><a href="#3-1-转换过项目为-androidx" class="headerlink" title="3.1 转换过项目为 androidx"></a>3.1 转换过项目为 androidx</h3><p>将项目转换成了 <code>androidx</code> 的，具体转换步骤如下：</p><ul><li>将项目编译的sdk 版本调成 <code>android-P</code></li><li>从AS 菜单栏选择 <code>Refactor</code> -&gt; <code>Refactor to AndroidX ..</code></li></ul><p>如下为转换前gradle文件：</p><p><img src="http://img.imtianx.cn/2018/0602/004.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2ltdGlhbnguY24v/font/5b6u6L2v6ZuF6buR/fontsize/1200/fill/I0Y4MEIwQg==/dissolve/100/gravity/SouthEast/dx/20/dy/20" alt></p><p>如下为转换后gradle文件：</p><p><img src="http://img.imtianx.cn/2018/0602/005.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2ltdGlhbnguY24v/font/5b6u6L2v6ZuF6buR/fontsize/1200/fill/I0Y4MEIwQg==/dissolve/100/gravity/SouthEast/dx/20/dy/20" alt></p><p>官方博客介绍：<a href="https://android-developers.googleblog.com/2018/05/hello-world-androidx.html" target="_blank" rel="noopener">Hello World, AndroidX</a></p><p>更多转换库依赖可参考 <a href="https://dl.google.com/dl/android/maven2/index.html" target="_blank" rel="noopener">Google maven repo</a></p><h3 id="3-2-databinding-kotlin"><a href="#3-2-databinding-kotlin" class="headerlink" title="3.2 databinding + kotlin"></a>3.2 databinding + kotlin</h3><p>习惯使用 kotlin 开发，配合 databinding 进行数据绑定，但是两者生成的 <code>BR</code>会冲突，解决办法是 使用 <code>kapt</code> 依赖 databinding, 如果 项目的是这样的：</p><pre><code>dependencies {        classpath &#39;com.android.tools.build:gradle:3.1.1&#39;}</code></pre><p>那么 model 中的依赖应该是下面的：</p><pre><code>// ...apply plugin: &quot;kotlin-kapt&quot;android {   // ...   databinding {       enabled = true   }   kapt {       generateStubs = true   }}dependencies {    // ...    kapt &quot;com.android.databinding:compiler:3.1.1&quot;}</code></pre><p>$\color{red}{注意： 两者依赖的版本要一致，否者编译时就会抛出异常}$</p><p>然后我的 金丝雀 中 使用的 <code>android plugin version</code> 是 <code>3.2.0-alpha16</code>,但是 <code>databinding compile</code> 的版本却没有与之对应的，导致无法依赖使用，折腾了很久没有解决就只好将其移除，放弃使用。还天真的以为是 AS 的 bug ，然后傻傻的去 <a href="https://issuetracker.google.com/issues" target="_blank" rel="noopener">Issue Tracker </a> 给 Google 提了个 bug 。</p><p>最近在 看官方文档时，发现了 $\color{red}{androidx}$,而且在访问 <a href="https://dl.google.com/dl/android/maven2/index.html" target="_blank" rel="noopener">Google maven repo</a> 时 也看到了很多 <code>androidx</code> 的身影，如下图：</p><p><img src="http://img.imtianx.cn/2018/0602/002.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2ltdGlhbnguY24v/font/5b6u6L2v6ZuF6buR/fontsize/1200/fill/I0Y4MEIwQg==/dissolve/100/gravity/SouthEast/dx/20/dy/20" alt></p><h3 id="3-3-navigation-使用"><a href="#3-3-navigation-使用" class="headerlink" title="3.3 navigation 使用"></a>3.3 navigation 使用</h3><p>由于上面将项目转换成 <code>androidx</code> ,而使用 <code>navigation</code> 时，需要在xml 中使用 <code>fragment</code> 标签，但在运行时会抛出找不到 <code>android.support.v4.app.Fragment</code>的问题，</p><p>在 <a href="https://stackoverflow.com/search?q=androidx" target="_blank" rel="noopener">stackoverflow</a> 上有类似的问题，在 google 的 issuetracker 上有相关bug的反馈，<a href="https://issuetracker.google.com/issues/79667498" target="_blank" rel="noopener">点击查看</a>，官方回复下个版本修复，如下图：</p><p><img src="http://img.imtianx.cn/2018/0602/006.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2ltdGlhbnguY24v/font/5b6u6L2v6ZuF6buR/fontsize/1200/fill/I0Y4MEIwQg==/dissolve/100/gravity/SouthEast/dx/20/dy/20" alt></p><p>$\color{red}{所以： 玩 navigation 的不要用 androidx,或者等下个版本修复}$</p><p>上述项目地址：<a href="https://github.com/imtianx/JetpackLearning" target="_blank" rel="noopener">https://github.com/imtianx/JetpackLearning</a></p><p>这里简记最近体验AS3.2经历的坑！</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> androidx </tag>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vim 常用命令</title>
      <link href="/2018/05/14/vim_command/"/>
      <url>/2018/05/14/vim_command/</url>
      <content type="html"><![CDATA[<p>推荐几个好用的 <code>vim</code> 软件插件：<code>MacVim</code>客户端，<code>cVim</code> chrome插件，<code>ideaVim</code> idea插件，这里简记自己常用的命令。<a id="more"></a></p><h2 id="一、vim-命令"><a href="#一、vim-命令" class="headerlink" title="一、vim 命令"></a>一、vim 命令</h2><table><thead><tr><th style="text-align:left">键</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>a</code></td><td style="text-align:center">插入，<code>ESC</code> 退出</td></tr><tr><td style="text-align:left"><code>o/O</code></td><td style="text-align:center">当前行后/前插入一行</td></tr><tr><td style="text-align:left"><code>cw</code></td><td style="text-align:center">删除光标位置到改单词结束内容</td></tr><tr><td style="text-align:left"><code>x</code></td><td style="text-align:center">删除选中内容</td></tr><tr><td style="text-align:left"><code>:wq</code></td><td style="text-align:center">保存，退出</td></tr><tr><td style="text-align:left"><code>dd</code></td><td style="text-align:center">删除当前行</td></tr><tr><td style="text-align:left"><code>p</code></td><td style="text-align:center">粘贴</td></tr><tr><td style="text-align:left"><code>0</code></td><td style="text-align:center">数字0到行头</td></tr><tr><td style="text-align:left"><code>y</code></td><td style="text-align:center">开始拷贝</td></tr><tr><td style="text-align:left"><code>^</code></td><td style="text-align:center">行头非空处</td></tr><tr><td style="text-align:left"><code>$</code></td><td style="text-align:center">到行尾</td></tr><tr><td style="text-align:left"><code>g_</code></td><td style="text-align:center">到本行最后一个不为空的地方</td></tr><tr><td style="text-align:left"><code>/ 搜索内容</code></td><td style="text-align:center">搜索，有多个时候用 <code>n</code> 切换</td></tr><tr><td style="text-align:left"><code>yy</code></td><td style="text-align:center">拷贝当前行</td></tr><tr><td style="text-align:left"><code>u</code></td><td style="text-align:center">撤销</td></tr><tr><td style="text-align:left"><code>&lt;c-r&gt;</code></td><td style="text-align:center">取消撤销</td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:center">重复上一操作</td></tr><tr><td style="text-align:left"><code>N&lt;command&gt;</code></td><td style="text-align:center">重复一个命令N次</td></tr><tr><td style="text-align:left"><code>N G</code></td><td style="text-align:center">跳转到第 N 行</td></tr><tr><td style="text-align:left"><code>G</code></td><td style="text-align:center">跳转到最后一行</td></tr><tr><td style="text-align:left"><code>gg</code></td><td style="text-align:center">跳转到第一行</td></tr><tr><td style="text-align:left"><code>W</code></td><td style="text-align:center">下一个单词的开头</td></tr><tr><td style="text-align:left"><code>e</code></td><td style="text-align:center">洗衣歌单词的结尾</td></tr><tr><td style="text-align:left"><code>%</code></td><td style="text-align:center">匹配括号</td></tr><tr><td style="text-align:left"><code>#</code></td><td style="text-align:center">匹配光标所在单词的上一个</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:center">匹配光标所在单词的上一个</td></tr><tr><td style="text-align:left"><code>gU</code></td><td style="text-align:center">字母变大写</td></tr><tr><td style="text-align:left"><code>gu</code></td><td style="text-align:center">字母变小写</td></tr><tr><td style="text-align:left"><code>fa</code></td><td style="text-align:center">到下一个为a的位置</td></tr><tr><td style="text-align:left"><code>t,</code></td><td style="text-align:center">到 , 前的一个字符</td></tr><tr><td style="text-align:left"><code>J</code></td><td style="text-align:center">变为一行</td></tr></tbody></table><h2 id="二、cVim-常用命令"><a href="#二、cVim-常用命令" class="headerlink" title="二、cVim 常用命令"></a>二、cVim 常用命令</h2><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>R</code></td><td style="text-align:center">刷新当前网页</td></tr><tr><td style="text-align:center"><code>x</code></td><td style="text-align:center">关闭当前网页</td></tr><tr><td style="text-align:center"><code>X</code></td><td style="text-align:center">打开最后关闭的网页</td></tr><tr><td style="text-align:center"><code>yy</code></td><td style="text-align:center">拷贝当前页面url</td></tr><tr><td style="text-align:center"><code>P</code></td><td style="text-align:center">新标签打开剪切板url,若不是则用Google搜索</td></tr><tr><td style="text-align:center"><code>k / w</code></td><td style="text-align:center">上</td></tr><tr><td style="text-align:center"><code>k / w</code></td><td style="text-align:center">上</td></tr><tr><td style="text-align:center"><code>:</code></td><td style="text-align:center">打开命令栏</td></tr><tr><td style="text-align:center"><code>/</code></td><td style="text-align:center">打开搜索栏</td></tr><tr><td style="text-align:center"><code>a</code></td><td style="text-align:center"><code>tabnew google</code>的别名， Google搜索，可换成 <code>baidu</code></td></tr><tr><td style="text-align:center"><code>I</code></td><td style="text-align:center">历史记录</td></tr><tr><td style="text-align:center"><code>zr</code></td><td style="text-align:center">重启chrome</td></tr><tr><td style="text-align:center"><code>gd</code></td><td style="text-align:center">下载记录</td></tr><tr><td style="text-align:center"><code>ge</code></td><td style="text-align:center">扩展插件</td></tr><tr><td style="text-align:center"><code>t</code></td><td style="text-align:center">tabnew</td></tr><tr><td style="text-align:center"><code>B</code></td><td style="text-align:center">搜索其他选项卡</td></tr><tr><td style="text-align:center"><code>n</code></td><td style="text-align:center">洗衣歌搜索结果</td></tr><tr><td style="text-align:center"><code>gU</code></td><td style="text-align:center">转到基本url</td></tr><tr><td style="text-align:center"><code>v</code></td><td style="text-align:center">插入模式</td></tr></tbody></table><p>持续更新…</p>]]></content>
      
      <categories>
          
          <category> 工具软件 </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> cvim </tag>
            
            <tag> ideaVim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 子模块：git submodule</title>
      <link href="/2018/03/08/git_submodule/"/>
      <url>/2018/03/08/git_submodule/</url>
      <content type="html"><![CDATA[<p>工作中，可能会遇到<strong>在一个Git仓库 中添加 其他 Git 仓库的场景</strong>。比如，在项目中引用第三方库。或者在模块化开发中，某些公共的模块是需要单独维护的，使用单独的仓库比较方便，但是在项目中需要引用，就会出现这样的场景。这里使用 Git 的 <code>git submodule</code> 命令为一个 <code>git 项目</code> 添加 <code>子git项目</code>。<a id="more"></a></p><p>可以使用 <code>git submodule --help</code> 查看所有相关命令。<br>为了方便说明，这里在主项目 <code>MainProject</code> 中加两个子模块 <code>liba</code> 和 <code>libb</code> .</p><h2 id="1-添加子模块"><a href="#1-添加子模块" class="headerlink" title="1. 添加子模块"></a>1. 添加子模块</h2><p>进入 <code>MainProject</code> 使用 <strong><code>git submodule add</code></strong> 进行添加,操作命令：</p><pre><code>git clone https://github.com/imtianx/MainProject.gitcd MainProject/git submodule add https://github.com/imtianx/liba.git</code></pre><p>如下图：<br><img src="http://img.imtianx.cn/18-3-7/40164089.jpg" alt></p><p>使用 <code>git submodule add https://github.com/imtianx/libb.git</code> 添加 <code>libb</code> 子模块。 对于上图，文件夹 <code>liba</code> 为新增加的子模块目录, <code>.gitmodules</code> 中存放的为子模块的信息，使用 <code>cat</code> 或 <code>vim</code> 查看内容为：</p><pre><code>[submodule &quot;liba&quot;]    path = liba    url = https://github.com/imtianx/liba.git[submodule &quot;libb&quot;]    path = libb    url = https://github.com/imtianx/libb.git</code></pre><blockquote><p><strong>.gitmodules文件</strong>：保存项目 URL 与已经拉取的本地目录之间的映射，有多个子模块则含有多条记录，会随着版本控制一起被拉去和推送的。</p></blockquote><p>此时文件目录树如下：</p><pre><code>.├── README.md├── liba│   ├── README.md│   ├── a.txt│   └── a2.txt├── libb│   ├── README.md│   ├── b.txt│   └── b2.txt└── test.text</code></pre><p>最后，<strong>提交添加的子模块到主目录</strong></p><pre><code>$ git commit -m &quot;add liba and libb submodules&quot;[master 6b15e30] add liba and libb submodules 3 files changed, 8 insertions(+) create mode 100644 .gitmodules create mode 160000 liba create mode 160000 libb</code></pre><h2 id="2-更新子模块"><a href="#2-更新子模块" class="headerlink" title="2. 更新子模块"></a>2. 更新子模块</h2><p>往往子模块是单独开发的，这里以更新 <code>liba</code> 为例（为了测试，这里先在liba仓库添加了一个文件）：</p><pre><code>cd liba/git fetchgit merge origin/master</code></pre><p>操作结果如下图，<strong>注意需要进入子模块目录</strong>：<br><img src="http://img.imtianx.cn/18-3-8/31258305.jpg" alt></p><p>此外，还可以在主目录下 直接用下面的命令更新 <code>libb</code>子模块：</p><pre><code>git submodule update --remote liba</code></pre><p>$\color{red}{注意：上面的操作的都 master 分支，无法操作其他分支}$</p><p><strong>使用下面的方式，更新 <code>libb</code> 的 <code>dev</code> 分支：</strong></p><pre><code>git config -f .gitmodules submodule.liba.branch devgit submodule update --remote</code></pre><p>如下图：<br><img src="http://img.imtianx.cn/18-3-8/49923190.jpg" alt></p><blockquote><p>这里对 <code>.gitmodules</code> 加了 <code>-f</code> 参数，修改提交后对所有用户有效。</p></blockquote><h2 id="3-删除子模块"><a href="#3-删除子模块" class="headerlink" title="3. 删除子模块"></a>3. 删除子模块</h2><p>在日常开发中，有添加，当然也会有删除 子模块的需求。<br>这里主项目包含两个子模块：<code>liba</code>、<code>libb</code>，以删除 <code>liba</code> 为例说明：</p><ul><li>使用 <code>git rm --cached liba</code> 将liba 从版本控制中删除（本地仍保留有），若不需要可不带 <code>--cached</code>进行完全删除。</li><li><p>使用 <code>vim .gitmodules</code> 可打开vim编辑,删除对应的内容</p><pre><code>[submodule &quot;liba&quot;]         path = liba         url = https://github.com/imtianx/liba.git         branch = dev</code></pre></li><li><p>使用 <code>vim .git/config</code> 可打开vim编辑,删除对应的内容</p><pre><code>[submodule &quot;liba&quot;]        url = https://github.com/imtianx/liba.git        active = true</code></pre></li><li>使用 <code>rm -rf .git/modules/liba</code>, 删除.git下的缓存模块，最后提交项目。</li></ul><p>经过上面的删除后还可以进行添加子模块。</p><h2 id="4-克隆含子模块的仓库"><a href="#4-克隆含子模块的仓库" class="headerlink" title="4. 克隆含子模块的仓库"></a>4. 克隆含子模块的仓库</h2><p>若需要克隆含有子模块的仓库，直接 进行克隆是无法拉取之模块的代码，可加上 <strong><code>--recursive</code></strong> 参数，如下：</p><pre><code>git clone --recursive https://github.com/imtianx/MainProject.git</code></pre><p>或者使用下面的三部操作：</p><pre><code>git clone  https://github.com/imtianx/MainProject.gitgit submodule initgit submodule update</code></pre><p><br><br>更多子模块的操作，请参考官方文档：<a href="https://git-scm.com/book/zh/v2/Git-工具-子模块" target="_blank" rel="noopener">Git 工具 - 子模块</a></p>]]></content>
      
      <categories>
          
          <category> 版本控制 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Retrofit2链式调用及文件下载</title>
      <link href="/2017/11/02/Retrofit2_flatmap_download/"/>
      <url>/2017/11/02/Retrofit2_flatmap_download/</url>
      <content type="html"><![CDATA[<p>Retrofit2+Rxjava 是当下较为流行的网络请求方式，这里将其结合进行网络请求的链式调用以及文件下载，来解决项目中开屏广告页的设计。<br><a id="more"></a><br>目前，很多APP中启动都有开屏广告，其中广告有静态图片、Gif图片或者短视频等，通常为了更好的用户体验，很多都是采用预下载的形式，即本此下载，下次打开生效。</p><h2 id="一、开屏广告的设计"><a href="#一、开屏广告的设计" class="headerlink" title="一、开屏广告的设计"></a>一、开屏广告的设计</h2><p>近期维护的一个项目中，刚好也有开屏广告，其做法如下图所示，打开app首先进入主页，获取广告路径，然后跳转广告页显示，结束后再跳转回主页。这种做法，可以保证每次打开都是最新的广告，但在显示广告页前会有短暂的几秒显示首页，体验不好。</p><p><img src="/img/article_img/2017/Retrofit2_flatmap_download_1.png" alt></p><p>经过改造，采用预加载的方式，大致流程如下图所示，在首页中获取图片路径并下载到本地，下次打开时显示。</p><p><img src="/img/article_img/2017/Retrofit2_flatmap_download_2.png" alt></p><p>通过上面的方式可以让广告也显示的更加自然，提高用户体验。</p><h2 id="二、Retrofit2-文件下载"><a href="#二、Retrofit2-文件下载" class="headerlink" title="二、Retrofit2 文件下载"></a>二、Retrofit2 文件下载</h2><p>这里，为了开屏广告显示的更加流畅，节省流量，广告图片下载到本地。这里结合Rxjava 和 Rxandroid进行使用，如下代码：</p><pre><code>public class DownloadPicAPI {    public interface DownloadPicService {        @Streaming        @GET        Observable&lt;ResponseBody&gt; downloadPic(@Url String fileUrl);    }    public static Observable&lt;ResponseBody&gt; downloadPic(Context context, String fileUrl) {        DownloadPicService service = RestHelper.getBaseRetrofit(context)        .create(DownloadPicService.class);        return service.downloadPic(fileUrl);    }}</code></pre><p>其中 <code>RestHelper</code> 是对Retrofit和Rxjava进行封装的工具类，避免文件过大下载出错，添加 <code>@Streaming</code> 注解，请求完成将返回的 <code>ResponseBody</code> 保存到文件中。如下代码：</p><pre><code>/** * 保存到本地 * * @param body      * @param dir      目录 * @param fileName 文件名 * @return */private boolean writeResponseBodyToDisk(ResponseBody body, String dir, String fileName) {    try {        File dirFile = new File(dir);        if (!dirFile.exists()) {            dirFile.mkdirs();        }        File saveFile = new File(dir + &quot;/&quot; + fileName);        InputStream inputStream = null;        OutputStream outputStream = null;        try {            byte[] fileReader = new byte[4096];            inputStream = body.byteStream();            outputStream = new FileOutputStream(saveFile);            while (true) {                int read = inputStream.read(fileReader);                if (read == -1) {                    break;                }                outputStream.write(fileReader, 0, read);            }            outputStream.flush();            return true;        } catch (IOException e) {            return false;        } finally {            if (inputStream != null) {                inputStream.close();            }            if (outputStream != null) {                outputStream.close();            }        }    } catch (IOException e) {        return false;    }}</code></pre><h2 id="三、flatMap组合网络请求"><a href="#三、flatMap组合网络请求" class="headerlink" title="三、flatMap组合网络请求"></a>三、flatMap组合网络请求</h2><p>这里，首先要获取广告信息，然后需要下载图片，两次网络请求，会出现嵌套调用，但是 <strong>Rxjava</strong> 的出现，可以让程序链式的调用，采用 <strong>flatMap</strong>操作符，如下代码：</p><pre><code> SplashAdAPI.requestSplashAd (getActivity() ).flatMap (new Func1 &lt; SplashAdModel, Observable&lt;? &gt;&gt; (){    @Override    public Observable&lt;ResponseBody&gt; call (SplashAdModel splashAdModel)    {        if (splashAdModel.bizSucc)        {            String fileName = getActivity().getCacheDir().getAbsolutePath()                              + &quot;/splash_ad_pic.png&quot;;            File file = new File (fileName);            if (file.exists() )            {                /*存在缓存图片*/                if (splashAdModel.url.equals (UserInfoHelper                                              .getSplashAdUrl (getActivity() ) ) )                {                    /*无新url，则不下载图片*/                    return null;                }                else                {                    /*有新url,删除缓存文件，更新本地url,下载图片*/                    file.delete();                    UserInfoHelper.saveSplashAdUrl (getActivity(), splashAdModel.url);                    return DownloadPicAPI.downloadPic (getActivity(), splashAdModel.url);                }            }            else            {                /*不存在缓存问价则下载*/                UserInfoHelper.saveSplashAdUrl (getActivity(), splashAdModel.url);                return DownloadPicAPI.downloadPic (getActivity(), splashAdModel.url);            }        }        return null;    }}).subscribeOn (Schedulers.io() ).observeOn (AndroidSchedulers.mainThread() ).subscribe (new Observer&lt;Object&gt;(){    @Override    public void onCompleted() { }    @Override    public void onError (Throwable e)    {        Log.e (&quot;imtianx&quot;, &quot;onError: ----------&quot;, e);    }    @Override    public void onNext (Object responseBody)    {        /*写入文件*/        writeResponseBodyToDisk ( (ResponseBody) responseBody,                                  getActivity().getCacheDir().getAbsolutePath(),                                  &quot;splash_ad_pic.png&quot;);    }});</code></pre><p>上述代码中，<code>SplashAdAPI</code> 是获取图片url接口，<code>DownloadPicAPI</code> 是步骤二中的下载文件的接口。</p><blockquote><p>使用 <code>getCacheDir()</code> 而非 <code>getExternalCacheDir()</code> 可以避免SD卡权限的问题和部分手机无外部存储而出现的空指针异常。或者，判断SD卡是否可用来选择存放位置。此外，将文件放在该缓存目录下，便于app卸载后清除数据。</p></blockquote><p>使用 flatMap 操作符，轻松的将两次请求链接。这种开屏广告的设计仅是自己的看法，有更好做法的欢迎留言，交流。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> retrofit2 </tag>
            
            <tag> flatMap </tag>
            
            <tag> 文件下载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tomcat 配置https证书</title>
      <link href="/2017/09/22/tomcat_set_https/"/>
      <url>/2017/09/22/tomcat_set_https/</url>
      <content type="html"><![CDATA[<p>HTTPS 是安全套接字层超文本传输协议，在http 的基础上加入了 SSL协议，需要使用证书来校验身份。<a id="more"></a> HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。其默认端口为：443。越来越多的网站使用了https，这里简介其相关配置。</p><h3 id="一、使用jdk创建证书"><a href="#一、使用jdk创建证书" class="headerlink" title="一、使用jdk创建证书"></a>一、使用jdk创建证书</h3><p>这里在安装有 <code>JDK</code> 环境的情况下进行，利用 <code>keytool</code> 工具生成 tomcat 证书，可使用 <code>--help</code> 命令查看相关残数据说明：，具体如下：</p><pre><code> C:\Users\admin_tx&gt;keytool --help密钥和证书管理工具命令: -certreq            生成证书请求 -changealias        更改条目的别名 -delete             删除条目 -exportcert         导出证书 -genkeypair         生成密钥对 -genseckey          生成密钥 -gencert            根据证书请求生成证书 -importcert         导入证书或证书链 -importpass         导入口令 -importkeystore     从其他密钥库导入一个或所有条目 -keypasswd          更改条目的密钥口令 -list               列出密钥库中的条目 -printcert          打印证书内容 -printcertreq       打印证书请求的内容 -printcrl           打印 CRL 文件的内容 -storepasswd        更改密钥库的存储口令使用 &quot;keytool -command_name -help&quot; 获取 command_name 的用法 C:\Users\admin_tx&gt;keytool -genkeypair --helpkeytool -genkeypair [OPTION]...生成密钥对选项: -alias &lt;alias&gt;                  要处理的条目的别名 -keyalg &lt;keyalg&gt;                密钥算法名称 -keysize &lt;keysize&gt;              密钥位大小 -sigalg &lt;sigalg&gt;                签名算法名称 -destalias &lt;destalias&gt;          目标别名 -dname &lt;dname&gt;                  唯一判别名 -startdate &lt;startdate&gt;          证书有效期开始日期/时间 -ext &lt;value&gt;                    X.509 扩展 -validity &lt;valDays&gt;             有效天数 -keypass &lt;arg&gt;                  密钥口令 -keystore &lt;keystore&gt;            密钥库名称 -storepass &lt;arg&gt;                密钥库口令 -storetype &lt;storetype&gt;          密钥库类型 -providername &lt;providername&gt;    提供方名称 -providerclass &lt;providerclass&gt;  提供方类名 -providerarg &lt;arg&gt;              提供方参数 -providerpath &lt;pathlist&gt;        提供方类路径 -v                              详细输出 -protected                      通过受保护的机制的口令使用 &quot;keytool -help&quot; 获取所有可用命令</code></pre><p> 这里使用如下命令生成证书：</p><pre><code>keytool -genkeypair -alias &quot;tomcat&quot; -keyalg &quot;RSA&quot; -keystore &quot;E:\tomcat.keystore&quot;  </code></pre><blockquote><p><em>参数说明</em>：<br> -genkeypair  表示生成密钥对，<br> -alias  表示别名<br> -keyalg 表示密钥算法名称<br> -keystore 表示密钥保存的名称</p></blockquote><p> 然后安装提示输入，但需要注意的是 <span style="color:red;"><strong>名字与姓氏 那个是填写域名的。</strong></span> 此外，尽量前后密码一致，避免后面出现密码错误的问题。</p><p> 如下图：</p><p> <img src="/img/article_img/2017/tomcat_set_https_1.png" alt></p><p> 这里随便写了个域名，是一个不存在的二级域名，为了能够访问，需要在 <code>C:\Windows\System32\drivers\etc</code> 路径下的 <code>hosts</code> 文件添加：</p><pre><code>127.0.0.1     test.imtianx.cn </code></pre><h3 id="二、tomcat-配置-https-证书"><a href="#二、tomcat-配置-https-证书" class="headerlink" title="二、tomcat 配置 https 证书"></a>二、tomcat 配置 https 证书</h3><p>通过上面的步骤，生成了密钥，修改tomcat配置文件：<code>/conf/server.xml</code>, 添加如下设置：</p><pre><code> &lt;Connector port=&quot;443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;               clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;               keystoreFile=&quot;D:\keystore\tomcat.keystore&quot;                    keystorePass=&quot;imtianx&quot; /&gt;</code></pre><p>其中，<code>keystoreFile</code> 指明密钥位置，<code>keystorePass</code> 指明密钥密码。<br>在该配置文件中有 https的 Connector 配置，被注释掉了。<strong>https 默认端口为 443</strong>。</p><p>然后启动tomcat,即可在浏览器中输入：<a href="https://test.imtianx.cn/" target="_blank" rel="noopener">https://test.imtianx.cn/</a> 访问，由于是自己生成的，浏览器会提示不安全，在高级中选择 继续访问即可，如下：</p><p><img src="/img/article_img/2017/tomcat_set_https_2.png" alt></p><h3 id="三、域名绑定-第三方https证书"><a href="#三、域名绑定-第三方https证书" class="headerlink" title="三、域名绑定 第三方https证书"></a>三、域名绑定 第三方https证书</h3><p>上面介绍了自己生成密钥配置https的方法，只适合本地测试，对于真实的域名无法使用。这里，选择第三方 https 证书提供商，在真实的环境中使用。</p><p>这里选择 阿里云 的 <a href="https://common-buy.aliyun.com/?spm=5176.2020520163.cas.1.22f653b7qIs2De&amp;commodityCode=cas#/buy" target="_blank" rel="noopener">云盾证书服务</a> ,在其官网购买免费版——证书类型为 ：免费型DV SSL，然后根据要求补全信息。待审核通过后在控制台下载对应环境的证书，这里提前申请了 <code>mvvm.tech</code> 这个域名。 由于个人习惯使用tomcat作为web服务器，下载 tomcat 的证书，包含如下内容：</p><ul><li>证书文件：214248632560457.pem</li><li>证书私钥文件：214248632560457.key</li><li>PFX格式证书文件：214248632560457.pfx</li><li>PFX格式证书密码文件：pfx-password.txt</li></ul><p>这里采用的是tomcat8.0，支持pfx格式的证书，无需格式转换。<br>将上述文件全部放到 tomcat 目录下的 <code>cert</code> 中，然后按照步骤二中的方式配置，其中 <strong>keystoreFilep指定为 cert 中 pfx 格式证书路径及名称，keystorePass 为 pfx-password.txt 中的密码。</strong></p><pre><code>keystoreFile=&quot;/home/apache-tomcat-8.0.46/cert/214248632560457.pfx&quot;   keystorePass=&quot;214248632560457&quot;</code></pre><p>这里为了简单，建立个空项目，并将其导出 war ,放入 <code>womcat/webapps</code> 中,修改 <code>/conf/server.xml</code>,在 <code>host</code> 节点下添加如下映射文件：</p><pre><code>&lt;Host name=&quot;mvvm.tech&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot;      autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot;  xmlNamespaceAware=&quot;false&quot;&gt;      &lt;Alias&gt;mvvm.tech&lt;/Alias&gt;      &lt;Context path=&quot;&quot; docBase=&quot;./TestHttps&quot; reloadable=&quot;false&quot; /&gt;&lt;/Host&gt;</code></pre><p>此外，需要在域名管理的后台添加与域名解析： 类型为 A 记录，值为 服务器 ip.</p><p>然后，开放 443端口，重启tomcat,在浏览器中输入：<a href="https://mvvm.tech" target="_blank" rel="noopener">https://mvvm.tech</a> 即可访问。如下图:</p><p><img src="/img/article_img/2017/tomcat_set_https_3.png" alt></p><p>这里是在 CentOS中配置的，对于web环境配置不了解的，可<a href="http://imtianx.cn/2017/03/25/Centos%207%20web%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">点击此处</a>查看。</p><p>如果在浏览器输入 mvvm.tech， 依然可以访问，以http的形式，可修改tomcat配置将其转发到 https 。<br>这里 对 https 使用 其默认的 443端口，对80及8009的端口 转发到 443,修改 redirectPort 参数，如下：</p><pre><code> &lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot;  redirectPort=&quot;443&quot; /&gt; &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;443&quot; /&gt;</code></pre><p>此外，需要对 web.xml进行修改，末尾添加如下内容：</p><pre><code>&lt;security-constraint&gt;    &lt;web-resource-collection &gt;           &lt;web-resource-name &gt;SSL&lt;/web-resource-name&gt;           &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/web-resource-collection&gt;   &lt;user-data-constraint&gt;           &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;    &lt;/user-data-constraint&gt; &lt;/security-constraint&gt;</code></pre><p>然后重启tomcat即可。至此，https 配置结束。</p><blockquote><p><strong>本文作者</strong>：<a href="http://imtianx.cn/about" target="_blank" rel="noopener">imtianx</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tomcat </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git常用命令及团队协作</title>
      <link href="/2017/08/22/git_cmd_teamwork/"/>
      <url>/2017/08/22/git_cmd_teamwork/</url>
      <content type="html"><![CDATA[<p>对于版本控制，之前常用的基本都是SVN和CVS之类的，他们都是集中式的版本控制系统，而Git是分布式的。<br><a id="more"></a></p><h2 id="一、Git-简介"><a href="#一、Git-简介" class="headerlink" title="一、Git 简介"></a>一、Git 简介</h2><p>Git 是一款免费、开源的分布式版本控制系统，他是著名的 Linux 发明者 Linus Torvalds 开发的。</p><p>所谓的<strong>集中式版本将控制系统</strong>，版本库放在中央服务器上，实际使用的时候充更改电脑上检出最新版，开发后再提交搞服务器上。这个必须的有网，对于局域网还好，公网上的速度较慢。而<strong>分布式版本控制系统</strong>，没有所谓的中央服务器，每个人电脑上都是一个完整的版本，如果自己或者同事修改了，就会推送给对方，这样就可以协作开发了。为了方便所有的人的修改都可以及时交换，通常有一台作为为”中央服务器”，这个更为安全，每个人都是一个完整的仓库。</p><h2 id="二、Git-常用命令"><a href="#二、Git-常用命令" class="headerlink" title="二、Git 常用命令"></a>二、Git 常用命令</h2><p>首先从 Git 官网下载对应系统的版本，安装。然后可使用如下命令在本地使用：</p><p> <img src="/img/article_img/2017/git_cmd_teamwork_1.png" alt></p><p>(注：该图片来自网络)</p><h2 id="三、Git-协作开发"><a href="#三、Git-协作开发" class="headerlink" title="三、Git 协作开发"></a>三、Git 协作开发</h2><p>在实际的开发中，使用命令协作过程如下（注： develop为项目的主分支，在各自分支上开发，然后合并到主分支）：</p><pre><code>cd 项目文件夹/项目名git add .git commit -m &quot;本地修改信息&quot;git pushgit pull origin develop#本地解决冲突#切换到develop分支，合并自己的代码到develop分支git checkout developgit merage develop_自己分支名git commit git push#将代码提交并push#切换回自己的分支git checkout develop_自己分支名</code></pre><p>如果不习惯使用命令，可以使用 <a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a>——一个可视化的git管理软件，不过安装必须注册，注册需要翻墙。</p><p>对于 AS，IDEA等都可以方便的在编辑器中使用使用Git，使用时，注意要commit 和 push 才能提交到远程仓库。如果不方便自己搭建 Gitlab服务，可以使用Github或者码云来为项目使用Git。</p>]]></content>
      
      <categories>
          
          <category> 版本控制 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gradle 打包不同资源</title>
      <link href="/2017/06/25/gradle_package_dif_res/"/>
      <url>/2017/06/25/gradle_package_dif_res/</url>
      <content type="html"><![CDATA[<p>由于 android 中以 <code>applicationId</code> 作为应用唯一标识，所以不能在手机上安装两个相同 <code>applicationId</code> 的app。在 AS 中，默认创建的项目其 <code>applicationId</code>就是项目的包名。可以在gradle 中配置更改 改 applicationid。<br><a id="more"></a><br>最近，维护的一个项目是一个导流的，一套代码每次打包成5个APP。每个APP除名字、icon、部分资源文件不同外，其他的基本一样。由于是维护项目，之前的同事是将其分成5个项目，那样每次迭代，都要在一个项目中写完测试通过后，拷贝到其他四个项目中，最后一个个项目打包。这样，既麻烦又浪费时间。因此，打算通过配置 gradle，打包时更换不同的 applicationeId、资源文件以及友盟的appkey，从而简化每次迭代的过程。</p><h3 id="一、配置资源文件"><a href="#一、配置资源文件" class="headerlink" title="一、配置资源文件"></a>一、配置资源文件</h3><p>为了方便测试，这里将 <a href="https://github.com/imtianx/DifPackage" target="_blank" rel="noopener">DifPackage</a> 项目打包为 <code>one</code>、<code>two</code>、<code>three</code>三个apk, <code>applicationId</code> 分别为：cn.imtianx.one、cn.imtianx.two 、cn.imtianx.three 。<br>其中，每个apk有不同的icon、不同的名字及界面上显示的文字也不同。</p><p><strong>在 <code>src</code> 下分别建立 one、two、three三个目录存放对应的资源文件，这里主要存放 apk icon、资源文件以及兼容7.0拍照用的 provider配置文件。</strong>(更多7.0拍照适配,请<a href="http://imtianx.cn/2017/03/05/android%207.0-take-photo/" target="_blank" rel="noopener">点击此处查看</a>)<br>具体项目结构如下图所示：</p><p><img src="/img/article_img/2017/grale_dif_package_1.png" alt></p><blockquote><p>说明： 上图中，one、two、three三个问价夹在 src下，与 main 同级。one 中 res 下的文件目录和 main/src/res相同。</p></blockquote><h3 id="二、配置签名文件"><a href="#二、配置签名文件" class="headerlink" title="二、配置签名文件"></a>二、配置签名文件</h3><p>对于签名文件的配置，有两种方式：一是直接写 <code>build.gradle</code> 中，而是写 在 <code>local.properties</code>文件中。后者想丢安全些，local.properties 通常为忽略文件不会提交。如下配置：<br><strong>方法一：在 build.gradle 文件中的 android 下添加如下代码</strong></p><pre><code>signingConfigs{    one {        storeFile file(&quot;E\:\\workspace\\android_temp\\DifPackage\\app\\imtianx_one.jks&quot;)        storePassword 123456        keyAlias imtianx        keyPassword 123456    }  /* two，three配置类似 */}</code></pre><p><strong>方法二：首先在 local.properties 下添加密钥信息，然后在 build.gradle 中读取使用</strong></p><pre><code>/*local.properties */## one keystore filekeystroe_storeFile_1 =E\:\\workspace\\android_temp\\DifPackage\\app\\imtianx_one.jkskeystroe_storePassword_1 =123456keystroe_keyAlias_1 =imtianxkeystroe_keyPassword_1 =123456/* build.gradle */Properties properties = new Properties()properties.load(project.rootProject.file(&#39;local.properties&#39;).newDataInputStream())signingConfigs{    one {        storeFile file(properties.getProperty(&quot;keystroe_storeFile_1&quot;))        storePassword properties.getProperty(&quot;keystroe_storePassword_1&quot;)        keyAlias properties.getProperty(&quot;keystroe_keyAlias_1&quot;)        keyPassword properties.getProperty(&quot;keystroe_keyPassword_1&quot;)    }</code></pre><p>以 one 的配置为例，对于 two和three的配置与此类似。个人通常喜欢第二中配置方式。</p><h3 id="三、配置-AndroidManifest文件"><a href="#三、配置-AndroidManifest文件" class="headerlink" title="三、配置 AndroidManifest文件"></a>三、配置 AndroidManifest文件</h3><p>由于不同的app使用的友盟统计也不同，这里需要设置占位符在gradle中进行动态的替换。此外，对于7.0以后的拍照，provider 的配置要与 applicationId 一样。如下部分代码：</p><pre><code>&lt;application&gt;    &lt;!-- 友盟统计 appkey--&gt;    &lt;meta-data        android:name=&quot;UMENG_APP_KEY&quot;        android:value=&quot;${UMENG_APP_KEY_VALUE}&quot;/&gt;    &lt;!-- 友盟统计 渠道--&gt;    &lt;meta-data        android:name=&quot;UMENG_CHANNEL&quot;        android:value=&quot;${UMENG_CHANNEL_VALUE}&quot;/&gt;    &lt;!-- 7.0 camera provider --&gt;    &lt;provider        android:name=&quot;android.support.v4.content.FileProvider&quot;        android:authorities=&quot;${applicationId}.provider&quot;        android:exported=&quot;false&quot;        android:grantUriPermissions=&quot;true&quot;&gt;        &lt;meta-data            android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;            android:resource=&quot;@xml/provider_paths&quot;/&gt;    &lt;/provider&gt;&lt;/application&gt;</code></pre><blockquote><p>说明：开始两个 meta中的 value，在 gradle进行设置值，provider 中 的 applicationId 直接可以取到 gradle中配置的值。</p></blockquote><h3 id="四、配置-applicationId"><a href="#四、配置-applicationId" class="headerlink" title="四、配置 applicationId"></a>四、配置 applicationId</h3><p>这里主要是利用了多渠道打包的原理，在 productFlavors 中进行配置：</p><pre><code>productFlavors{    one{        applicationId &quot;cn.imtianx.one&quot;        manifestPlaceholders = [UMENG_APP_KEY_VALUE:&quot;111111&quot;,UMENG_CHANNEL_VALUE:&quot;one&quot;]        signingConfig signingConfigs.one    }    two{        applicationId &quot;cn.imtianx.two&quot;        manifestPlaceholders = [UMENG_APP_KEY_VALUE:&quot;222222&quot;,UMENG_CHANNEL_VALUE:&quot;two&quot;]        signingConfig signingConfigs.two    }    three{        applicationId &quot;cn.imtianx.three&quot;        manifestPlaceholders = [UMENG_APP_KEY_VALUE:&quot;333333&quot;,UMENG_CHANNEL_VALUE:&quot;three&quot;]        signingConfig signingConfigs.three    }}</code></pre><blockquote><p>说明：<code>productFlavors</code> 下的 one、two、three这里代表三个渠道。<code>applicationId</code> 用于配置应用 id,<code>manifestPlaceholders</code> 用于给 AndroidManifest 中配置的占位符设置值，这里仅仅为了测试随便写的值。<code>signingConfig signingConfigs.one</code>指定不同app的签名文件。此外，指定签名文件还可以按照下面的方式：</p><pre><code> buildTypes {    productFlavors.one.signingConfig signingConfigs.one    productFlavors.two.signingConfig signingConfigs.two    productFlavors.three.signingConfig signingConfigs.three }</code></pre></blockquote><p>到此整个 配置已经结束。完整 gradle 的配置，请查看 <a href="https://github.com/imtianx/DifPackage/blob/master/app/build.gradle" target="_blank" rel="noopener">build.gradle</a></p><h3 id="五、打包测试"><a href="#五、打包测试" class="headerlink" title="五、打包测试"></a>五、打包测试</h3><p>在 terminal 下输入 <code>gradle assembleRelease</code>进行打包，然后安装测试，可以成功的替换app的icon、名字及其他资源，能够同时安装。<br>如果需要查看 apk的签名信息，可以将其解压后，使用如下命令查看：</p><pre><code>keytool -printcert -file META-INF/CERT.RSA</code></pre><p>为了能够区别，前面创建 key store 时尽量用不同的信息。<br>至此，改打包方式介绍完毕，但是如果用这种方式，则不能进行 <a href="http://imtianx.cn/2016/12/12/android%20%20%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/" target="_blank" rel="noopener">多渠道打包</a>，这里多的 one、two、three类似于三个渠道。</p><p>项目源代码地址：<a href="https://github.com/imtianx/DifPackage" target="_blank" rel="noopener">DifPackage</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WebView 中文乱码</title>
      <link href="/2017/06/17/webview_chinese_garbled/"/>
      <url>/2017/06/17/webview_chinese_garbled/</url>
      <content type="html"><![CDATA[<p>这里主要记录关于<code>WebView</code>加载含中文的<code>url</code>和<code>cookie</code>中设置中文显示乱码的解决方法。<br><a id="more"></a><br>目前，在android 开发中，为了方便程序进行扩展，很多 APP中都采用了  <code>WebView</code> 来加载 H5 页面，这样通过后台更换一个H5地址，程序中就有相应的变化，不用重新打包发布。我参与的项目中，使用 <code>WebView</code> 的场景主要有下面几种：商城类APP中的商品详情、签到、帮助中心、积分抽奖、邀请好友，banner详情等。</p><h3 id="一、简单使用"><a href="#一、简单使用" class="headerlink" title="一、简单使用"></a>一、简单使用</h3><p>在布局文件中添加 <code>WebView</code>  控件，然后在 <code>Activity</code> 总绑定控件，进行相关设置，部分代码如下；</p><pre><code>mWebView = (WebView) findViewById (R.id.wv);WebSettings webSettings = mWebView.getSettings();/*支持JavaScript*/webSettings.setJavaScriptEnabled (true);/*支持缩放*/webSettings.setSupportZoom (true);/*启用内置缩放装置*/webSettings.setBuiltInZoomControls (true);/*设置不缓存*/webSettings.setCacheMode (WebSettings.LOAD_NO_CACHE);/*设置加载网页的url*/mWebView.loadUrl (&quot;http://192.168.0.101/WebViewDemo/index.html&quot;);</code></pre><p>如果希望网页中的连接仍然是用<code>WebView</code>打开，需要进行如下设置：</p><pre><code>mWebView.setWebViewClient (new WebViewClient(){    @Override    public boolean shouldOverrideUrlLoading (WebView view, String url)    {        /*拦截网页中的链接，使其在WebView 中打开*/        view.loadUrl (url);        return true;    }});</code></pre><p>如果打开多个网页，以免按返回键结束当前 Activity，需要监听返回键，具体有如下两种做法:</p><pre><code>/*方法一*/mWebView.setOnKeyListener (new View.OnKeyListener(){    @Override    public boolean onKey (View v, int keyCode, KeyEvent event)    {        if (event.getAction() == KeyEvent.ACTION_DOWN)        {            if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; mWebView.canGoBack() )            {                /*后退*/                mWebView.goBack();                return true;            }        }        return false;    }});/*方法二*/@Overridepublic boolean onKeyDown (int keyCode, KeyEvent event){    if (keyCode == KeyEvent.KEYCODE_BACK)    {        if (mWebView.canGoBack() )        {            /*后退*/            mWebView.goBack();            return true;        }    }    return super.onKeyDown (keyCode, event);}</code></pre><h3 id="二、加载含中文url乱码"><a href="#二、加载含中文url乱码" class="headerlink" title="二、加载含中文url乱码"></a>二、加载含中文url乱码</h3><p>由于加载的网也上需要相关数据，所以后台返回时将其拼接在url中，然后在 H5页面中用js获取。如下样式的url,其中shopName 的值为中文，导致加载该页面时显示一直为乱码。</p><pre><code>http://192.168.0.101/WebViewDemo/index.html?shopName=免单购平台&amp;cell=123456789&amp;qq=2360633699</code></pre><p>由于url的限制，对于中文必须转码后可以使用。这里便将中文部分转码后使用，将中文转成 <code>unicode</code> ，并将其中的 <code>\</code> 换成 <code>%</code>,具体做法如下：</p><pre><code>private String cnToUnicode (String cn){    char[] chars = cn.toCharArray();    String resultStr = &quot;&quot;;    for (int i = 0; i &lt; chars.length; i++)    {        resultStr += &quot;%u&quot; + Integer.toString (chars[i], 16);    }    return resultStr;}</code></pre><p>使用方法可以将 上述 url中shopName 对应的值 “免单购平台” 转为如下：</p><pre><code>%u514d%u5355%u591f%u5e73%u53f0</code></pre><p>将替换出现的中文，即可解决乱码问题。可以通过后台进行处理。然而这种做法，在<code>android</code> 端可以，浏览器也可以，导致 <code>ios</code> 端无法显示网页，最终放弃，换用 <code>cookie</code>的方式。</p><p>关于更多url的资料，可以查看阮一峰的 <a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">关于URL编码</a>这篇文章。</p><h3 id="三、设置cookie-乱码"><a href="#三、设置cookie-乱码" class="headerlink" title="三、设置cookie 乱码"></a>三、设置cookie 乱码</h3><p>由于之前的项目在使用 H5 时，不管 android 还是 ios 都有用过cookie 来传递参数，于是我们换用中这种方式。然而，发现给cookie中设置的中文，在android 上会出现乱码，ios则不会。之前的用法中没有在cookie 中设置中文，便尝试了各种编码，最终使用 <strong><code>URLEncoder 的 encode() 发发进行编码</code></strong>。<br>如下是设置 cookie 的相关代码：</p><pre><code>/** * 设置 cookie * @param url */ private void setCookie(String url) {    CookieSyncManager.createInstance(this);    CookieManager cookieManager = CookieManager.getInstance();    cookieManager.setAcceptCookie(true);    try {        /*对中文编码*/        cookieManager.setCookie(url, &quot;shopName=&quot; + URLEncoder.encode(shopName, &quot;utf-8&quot;));    } catch (UnsupportedEncodingException e) {        e.printStackTrace();    }    cookieManager.setCookie(url, &quot;cell=&quot; + cell);    cookieManager.setCookie(url, &quot;qq=&quot; + qq);    if (Build.VERSION.SDK_INT &lt; 21) {        CookieSyncManager.getInstance().sync();    } else {        CookieManager.getInstance().flush();    }}@Overrideprotected void onDestroy() {    CookieSyncManager.createInstance(this);    CookieManager cookieManager = CookieManager.getInstance();    cookieManager.removeSessionCookie();    if (Build.VERSION.SDK_INT &lt; 21) {        CookieSyncManager.getInstance().sync();    } else {        CookieManager.getInstance().flush();    }    super.onDestroy();}</code></pre><blockquote><p>注：需要在设置 webview 之前调用 setCookie()方法。</p></blockquote><p>最后只要在 H5 页面中使用js来获取即可。</p><p>此外，对于 WebView ,可以加载本地 html文件，可以加载 html 标签 ，可以与js互相调用等。</p><pre><code>/*加载部分片段*/mWebView .loadDataWithBaseURL(&quot;&quot;,data,&quot;text/html&quot;,&quot;utf-8&quot;,&quot;&quot;);</code></pre><p>美团关于 webview 的文章：<br><a href="http://tech.meituan.com/WebViewPerf.html" target="_blank" rel="noopener">WebView性能、体验分析与优化</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> webview </tag>
            
            <tag> 中文乱码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos 7 web 环境搭建</title>
      <link href="/2017/03/25/Centos%207%20web%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/03/25/Centos%207%20web%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>方便配置网站和使用数据库，将服务器配置 web 运行环境。</p><h3 id="1、Xshell-5"><a href="#1、Xshell-5" class="headerlink" title="1、Xshell 5"></a>1、Xshell 5</h3><p>为了方便管理操作服务器，这里采用 <code>xshell 5</code> 来连接服务器，使用ssh证书，端口号 22，对于购买的与主机需要开放相应的端口。<a id="more"></a><br>如下是连接成功的提示：</p><pre><code>[c:\~]$ openConnecting to 115.159.200.102:22...Connection established.To escape to local shell, press &#39;Ctrl+Alt+]&#39;.Last login: Sat Mar 10 18:37:31 2017 from 115.195.220.207[root@imtianx ~]# </code></pre><p>其中 <code>[root@imtianx ~]</code>一句，rooot为登陆账号，<code>imtianx</code> 为主机名。<br>默认主机名一般很长，可以进行修改：</p><pre><code># 设置主机名为namehostnamectl set-hostname name   # 查看是否设置成功hostnamectl status  # 重启 reboot </code></pre><p>重启后提示符才会变。</p><h3 id="2、JDK"><a href="#2、JDK" class="headerlink" title="2、JDK"></a>2、JDK</h3><p>安装jdk，这里采用 <code>rpm</code> 方式安装，</p><pre><code># 下载jdkcurl -O http://download.oracle.com/otn-pub/java/jdk/8u121-b13/jdk-8u121-linux-x64.rpm# 使用 rpm 安装rpm -ivh jdk-8u121-linux-x64.rpm</code></pre><p>然后 可以使用 <code>java -version</code> 、<code>javac</code> 查看是否安装成功。由于 rpm 的安装方式会把jdk安装到 <code>/usr/java/jdk1.8.0_121</code>下，通过三层；链接到 /usr/bin下，环境变量可以不用配置。<br>环境变量配置方法：</p><pre><code>vim /etc/profile   //打开 profile </code></pre><p>添加下面的配置信息:</p><pre><code>#set java environmentJAVA_HOME=/usr/java/jdk1.8.0_121JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH</code></pre><p>若需要立即生效，可执行如下命令：</p><pre><code>source /etc/profile</code></pre><h3 id="3、Tomcat"><a href="#3、Tomcat" class="headerlink" title="3、Tomcat"></a>3、Tomcat</h3><pre><code># 下载 Tomcatwget  http://download.nextag.com/apache/tomcat/tomcat-8/v8.5.12/bin/apache-tomcat-8.5.12.zip# 解压,可使用 rm 移动位子unzip apache-tomcat-8.5.12.zip# tomcat/bin下执行，授予 .sh 文件执行权限chomd +x *.sh# 启动服务，若无法启动 请看后文 使用 systemctl 命令startup.sh</code></pre><p>由于防火墙的限制，需要开放相应的端口，这里选择 <code>iptables</code> 防火墙。</p><pre><code># 安装yum install iptables-services#配置防火墙vim /etc/sysconfig/iptables# 在 22端口号线面添加 如下端口，然后保存并退出 （：wq）-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT#重启防火墙systemctl restart iptables.service#查看 开放端口iptables -L -n</code></pre><blockquote><p>注：这里必须要在 22端口号下面添加，不能添加到最后，为方便将tomcat端口配置为80，mysql 数据库端口为 3306，这里一并开放。</p></blockquote><p>设置Tomcat 为服务，开机自启。<br>首先在 <code>/usr/lib/systemd/system/</code> 目录下添加 <code>tomcat.service</code> 文件，内容如下：</p><pre><code>[unit]Description=TomcatAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/home/tomcat/tomcat.pidExecStart=/home/tomcat/bin/startup.shExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target</code></pre><p>然后在 <code>tomcat/bin/</code> 下添加 <code>setenv.ssh</code>文件，设置pid 及 java内存（可忽略）内容如下：</p><pre class="line-numbers language-`"><code class="language-`">#add tomcat pidCATALINA_PID="$CATALINA_BASE/tomcat.pid"#add java optsJAVA_OPTS="-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=    256m"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后使用 <code>systemctl</code> 相关命令，设置服务，如下：</p><pre><code># 启动服务，stop停止systemctl start tomcat# 查看服务状态systemctl status name# 设置开机自启，disable删除systemctl enable tomcat# 重启服务systemctl restart tomcat</code></pre><h3 id="4、Mysql（Mariadb）"><a href="#4、Mysql（Mariadb）" class="headerlink" title="4、Mysql（Mariadb）"></a>4、Mysql（Mariadb）</h3><p>这里选择了较为轻量级的 Mariadb 安装，与mysql类似。具体安装命令如下：</p><pre><code># 安装yum -y install mariadb mariadb-server# 启动systemctl start mariadb# 设置开机启动systemctl enable mariadb# 接着是对数据库的配置信息# ...# 最后授予 权限grant all privileges on *.* to root@&#39;%&#39; identified by &#39;password&#39;;</code></pre><p>对于设置编码之类的，更多 Mariadb 的安装配置，请 <a href="http://www.linuxidc.com/Linux/2016-03/128880.htm" target="_blank" rel="noopener">点击此处查看</a></p><p>此外，往往需要文件的上传下载，这里选择 <code>lrzsz</code></p><pre><code># 安装yum install lrzsz# 上传rz# 下载sz</code></pre>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> linux </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 常用命令</title>
      <link href="/2017/03/18/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD/"/>
      <url>/2017/03/18/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD/</url>
      <content type="html"><![CDATA[<p>之前，服务器 一直都是 window server 系统，主要是桌面的，方便操作，但是同样的配置 ，Centos要比他好很多，就把服务器换成了 <code>Centos 7</code> ，开始学习使用 linux，并在简短记下。<br><a id="more"></a></p><h3 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1 常用命令"></a>1 常用命令</h3><pre><code>ls　　          显示文件或目录     -l         列出文件详细信息l(list)     -a         列出当前目录下所有文件及目录，包括隐藏的a(all)mkdir           创建目录     -p         创建目录，若无父目录，则创建p(parent)cd              切换目录touch           创建空文件echo            创建带有内容的文件。cat             查看文件内容cp              拷贝mv              移动或重命名rm              删除文件     -r         递归删除，可删除子目录及文件     -f         强制删除find            在文件系统中搜索某文件wc              统计文本中行数、字数、字符数grep            在文本文件中查找某个字符串rmdir           删除空目录tree            树形结构显示目录，需要安装tree包pwd             显示当前目录ln              创建链接文件more、less      分页显示文本文件内容head、tail      显示文件头、尾内容ctrl+alt+F1     命令行全屏模式</code></pre><h3 id="2-系统管理命令"><a href="#2-系统管理命令" class="headerlink" title="2 系统管理命令"></a>2 系统管理命令</h3><pre><code>stat           显示指定文件的详细信息，比ls更详细who            显示在线登陆用户whoami         显示当前操作用户hostname       显示主机名uname          显示系统信息top            动态显示当前耗费资源最多进程信息ps             显示瞬间进程状态 ps -auxdu             查看目录大小 du -h /home带有单位显示目录信息df             查看磁盘大小 df -h 带有单位显示磁盘信息ifconfig       查看网络情况ping           测试网络连通netstat        显示网络状态信息man            命令不会用了，找男人  如：man lsclear          清屏alias          对命令重命名 如：alias showmeit=&quot;ps -aux&quot; ，另外解除使用unaliax showmeitkill           杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。reboot         重启</code></pre><p>这里仅仅是记录了一些常用的，对于不熟悉的 命令可以 使用 <code>man</code> 来查看。</p><h3 id="3-vim-使用"><a href="#3-vim-使用" class="headerlink" title="3 vim 使用"></a>3 vim 使用</h3><p><strong>vim</strong>三种模式：命令模式、插入模式、编辑模式。使用<strong>ESC</strong>或<strong>i</strong>或：来切换模式。</p><p><strong>命令模式</strong>下：</p><pre><code>:q             退出:q!            强制退出:wq            保存并退出:set number    显示行号:set nonumber  隐藏行号/apache        在文档中查找apache 按n跳到下一个，shift+n上一个yyp            复制光标所在行，并粘贴h(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)</code></pre>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 7.0相机拍照适配</title>
      <link href="/2017/03/05/android%207.0-take-photo/"/>
      <url>/2017/03/05/android%207.0-take-photo/</url>
      <content type="html"><![CDATA[<p>最近，之前一个项目的用户反馈APP拍照崩溃，查看了线上Crash日志，发现是  <code>EVA-AL10</code> 和 <code>ZUK Z2131</code> 两款手机，android 版本都是7.0的<a id="more"></a>，看了下具体的错误消息，如下：</p><pre><code>//...Caused by: android.os.FileUriExposedException: file:///storage/emulated/0/1489548204216.jpg exposed beyond app through ClipData.Item.getUri()at android.os.StrictMode.onFileUriExposed(StrictMode.java:1816)//...</code></pre><p>在 Stackoverflow 查了下，发现是google 在 android N 之后，提高了私有文件的安全性，应用私有目录将被限制访问，无法通过  <code>file:// URI 类型的Uri</code> 进行应用间文件共享，必须使用 <code>content:// URI类型的Ur,并授予 URI 临时访问权限。</code></p><p>下面是官方对7.0权限和文件共享的说明：</p><p><img src="http://img.imtianx.cn/android-7.0-permission-file-change.png" alt></p><p>具体内容请查看<a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html#perm" target="_blank" rel="noopener">  官方说明-7.0行为变更</a>(无需翻墙)</p><p>如下是 android N 相机的适配过程：</p><p>一、 <strong>在manifest清单文件中注册provider</strong></p><p> 添加如下代码：</p><pre><code>&lt;provider    android:name=&quot;android.support.v4.content.FileProvider&quot;    android:authorities=&quot;com.puyue.www.moneysteward.provider&quot;    android:exported=&quot;false&quot;    android:grantUriPermissions=&quot;true&quot;&gt;    &lt;meta-data        android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;        android:resource=&quot;@xml/provider_paths&quot;/&gt;&lt;/provider&gt;</code></pre><blockquote><p>说明：<br>exported:要求必须为false，为true则会报安全异，<br>grantUriPermissions:true，表示授予 URI 临时访问权限<br>authorities：<strong>包名.provider</strong>，准确的说应该是 applicationId。</p></blockquote><p>二、 <strong>指定共享的目录</strong></p><p>在 <code>res</code> 下新建 <code>xml</code> 目录，然后新建 <code>file_paths.xml</code>文件，该文件名无限制，但须和上面 provider 中的 resource 指定的一致，内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths&gt;    &lt;external-path        name=&quot;temp_photo&quot;        path=&quot;.&quot;/&gt;&lt;/paths&gt;</code></pre><blockquote><p>说明：<br><strong>path=””</strong>：它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为<strong>path=”pictures”</strong>，<br>那么它代表着根目录下的pictures目录(/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的。</p></blockquote><p>三、<strong>使用 FileProvider</strong></p><p>如下具体的拍照做法：</p><pre><code>tempCameraFilePath = Environment                     .getExternalStorageDirectory() +                     &quot;/takePic/&quot; +                     System.currentTimeMillis() + &quot;.jpg&quot;;File file = new File (tempCameraFilePath);if (!file.exists() ){    file.getParentFile().mkdirs();}Intent intent = new Intent (MediaStore.ACTION_IMAGE_CAPTURE);Uri uri = Uri.fromFile (new File (tempCameraFilePath) );//适配7.0if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.M){    uri = FileProvider          .getUriForFile (this,                          BuildConfig.APPLICATION_ID +                          &quot;.provider&quot;, file);}intent.putExtra (MediaStore.EXTRA_OUTPUT, uri);startActivityForResult (intent, REQUEST_CODE_CAMERA);}</code></pre><p>需要对手机版本进行判断，否则直接用 <code>FileProvider</code> 在低版本手机上会导致相机 停止运行。注意需要申明下面两个权限：</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</code></pre><p>此外，由于拍照指定了 uri ,在 <code>onActivityResult</code>返回的 data 往往是 空的。</p><p>在开发中，除了拍照，经常还会遇见 打开相册选取图片，下面是最近遇到的坑。</p><p>对于大多手机，都可以通过 <code>ACTION_PICK</code> 来打开相册，选取图片，如下：</p><pre><code>Intent intent = new Intent(Intent.ACTION_PICK, null);intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;);startActivityForResult(intent, REQUEST_CODE_ALBUM);</code></pre><p>然而对于小米手机，却无法获取返回的路径，以下是对返回的 URI 的处理办法(来自网络)：</p><pre><code>/** * 解决小米手机 相册 返回 null * * @param intent * @return */public Uri getPictureUri (android.content.Intent intent){    Uri uri = intent.getData();    String type = intent.getType();    if (uri.getScheme().equals (&quot;file&quot;) &amp;&amp; (type.contains (&quot;image/&quot;) ) )    {        String path = uri.getEncodedPath();        if (path != null)        {            path = Uri.decode (path);            ContentResolver cr = this.getContentResolver();            StringBuffer buff = new StringBuffer();            buff.append (&quot;(&quot;).append (MediaStore.Images.ImageColumns.DATA).append (&quot;=&quot;)            .append (&quot;&#39;&quot; + path + &quot;&#39;&quot;).append (&quot;)&quot;);            Cursor cur = cr.query (MediaStore.Images.Media.EXTERNAL_CONTENT_URI,                                   new String[] {MediaStore.Images.ImageColumns._ID},                                   buff.toString(), null, null);            int index = 0;            for (cur.moveToFirst(); !cur.isAfterLast(); cur.moveToNext() )            {                index = cur.getColumnIndex (MediaStore.Images.ImageColumns._ID);                // set _id value                index = cur.getInt (index);            }            if (index == 0)            {                // do nothing            }            else            {                Uri uri_temp = Uri                               .parse (&quot;content://media/external/images/media/&quot;                                       + index);                if (uri_temp != null)                {                    uri = uri_temp;                }            }        }    }    return uri;}</code></pre><p>然后在 <code>onActivityResult</code>进行处理返回的uri:</p><pre><code>@Overrideprotected void onActivityResult (int requestCode, int resultCode, Intent data){    super.onActivityResult (requestCode, resultCode, data);    switch (requestCode)    {    case REQUEST_CODE_ALBUM:   //相册    {        if (resultCode == RESULT_OK)        {            if (data != null)            {                Uri uri = getPictureUri (data); //处理返回的uri                String path = &quot;&quot;;                String[] proj = {MediaStore.Images.Media.DATA};                Cursor cursor = getContentResolver().query (uri, proj, null, null, null);                if (cursor != null)                {                    int index = cursor.getColumnIndexOrThrow (                                    MediaStore.Images.Media.DATA);                    cursor.moveToFirst();                    path = cursor.getString (index);                    cursor.close();                    //do something                }            }        }        break;    }    }}</code></pre><p>自己开发 用nexus6 测试毫无问题，却被测试妹子发现了，国内的手机厂商对room的阉割，导致 android 的适配变得很难，最近在做权限的处理时，又一次遇到了各种坑。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android7.0 </tag>
            
            <tag> 拍照适配 </tag>
            
            <tag> 相册 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tomcat中配置单IP多二级域名方法</title>
      <link href="/2017/01/11/Tomcat%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%8D%95IP%E5%A4%9A%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2017/01/11/Tomcat%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%8D%95IP%E5%A4%9A%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>由于一级域名 <a href="http://imtianx.cn/" target="_blank" rel="noopener">imtianx.cn</a> 作为博客主地址了，为了方便使用，通过二级域名来配置网站。这里简介二级域名的配置方式。<br><a id="more"></a><br>作为学生，为了便宜采用 腾讯云 服务器。在 windows server 2012 服务器上配置网站，使用 toncat。</p><h1 id="一、设置域名解析"><a href="#一、设置域名解析" class="headerlink" title="一、设置域名解析"></a>一、设置域名解析</h1><p>我的域名 imtianx.cn 在阿里的万网购买的。登陆域名管理后台，添加域名解析。这里使用 <code>A 记录</code>，它是指向一个 IP 的。为了方便测试，这里有添加如下两条A记录的二级域名解析。</p><p><img src="http://img.imtianx.cn/domain_jiexi.png" alt></p><p>所对应的是：test2.imtianx.cn 和 test1.imtianx.cn 两个二级域名。</p><p>如下是万网的<strong>记录类型</strong>及其说明，<strong>记录值</strong>受他的影响：</p><ol><li><strong>A记录</strong>：<br>将域名指向一个IPv4地址（例如：10.10.10.10），需要增加A记录。</li><li><strong>CNAME记录</strong><br>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。</li><li><strong>MX记录</strong><br>建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。</li><li><strong>NS记录</strong><br>域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录。</li><li><strong>TXT记录</strong><br>可任意填写（可为空），通常用做SPF记录（反垃圾邮件）使用。</li><li><strong>AAAA记录</strong><br>将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录。</li><li><strong>SRV记录</strong><br>记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。</li><li><strong>显性URL</strong><br>将域名指向一个http（s)协议地址，访问域名时，自动跳转至目标地址（例如：将<a href="http://www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。" target="_blank" rel="noopener">www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。</a></li><li><strong>隐性URL</strong><br>与显性URL类似，但隐性转发会隐藏真实的目标地址（例如：将<a href="http://www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。" target="_blank" rel="noopener">www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。</a></li></ol><p>对于<strong>主机记录</strong>则是域名的前缀，常见的如下：</p><ul><li><strong>www</strong> :将域名解析为<a href="http://www.example.com，填写www；" target="_blank" rel="noopener">www.example.com，填写www；</a></li><li><strong>@</strong> ：<br>将域名解析为example.com（不带www），填写@或者不填写；</li><li><strong>mail</strong> ：<br>将域名解析为mail.example.com，通常用于解析邮箱服务器；</li><li><strong>*</strong> ：<br>泛解析，所有子域名均被解析到统一地址（除单独设置的子域名解析）；</li><li><strong>二级域名</strong> ：<br>如：mail.example.com或abc.example.com，填写mail或abc；</li><li><strong>手机网站</strong> ：<br>如：m.example.com，填写m。</li></ul><h1 id="二、配置tomcat"><a href="#二、配置tomcat" class="headerlink" title="二、配置tomcat"></a>二、配置tomcat</h1><p>首先将网站项目导出 war包放入 webapps ，然后修改Tomcat 的配置文件: <code>conf/server.xml</code>,在 <code>Engine</code>节点下添加host。<br>如下：</p><pre><code>&lt;Host name=&quot;test1.imtianx.cn&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;  &lt;Alias&gt;test1.imtianx.cn&lt;/Alias&gt;  &lt;Context path=&quot;&quot; docBase=&quot;./Test1&quot; reloadable=&quot;false&quot; /&gt;&lt;/Host&gt;&lt;Host name=&quot;test2.imtianx.cn&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;  &lt;Alias&gt;test2.imtianx.cn&lt;/Alias&gt;  &lt;Context path=&quot;&quot; docBase=&quot;./Test2&quot; reloadable=&quot;false&quot; /&gt;&lt;/Host&gt;</code></pre><blockquote><p>配置说明：<br> name ： 指定域名<br> appBase : 虚拟目录的路径<br> path : 访问时的项目web名<br> doBase : 项目的顶级目录</p></blockquote><p>更改Tomcat配置文件后需要将tomcat重启才可生效，然后就可以通过二级域名访问网站了：</p><p><img src="http://img.imtianx.cn/domain_show.png" alt></p><p>这个只是一种二级域名解析方法，设置完就可以方便的使用二级域名了。</p>]]></content>
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 域名配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 域名解析 </tag>
            
            <tag> 二级域名 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AsyncTask 工作原理及线程池</title>
      <link href="/2017/01/06/AsyncTask%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2017/01/06/AsyncTask%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<blockquote><p>读书笔记： 《Android 开发艺术探索》 ——第十一章：android 线程及线程池</p></blockquote><p>在 android 中，线程通常为主线程和子线程，前者主要处理和界面相关的事情，而后者主要用于耗时操作。<br>android 中的线程主要有 <code>Thread</code>、<code>AsyncTask</code>、<code>IntentService</code> 和 <code>HandlerThread</code> 。<br><a id="more"></a></p><h2 id="一、android-中的线程形态"><a href="#一、android-中的线程形态" class="headerlink" title="一、android 中的线程形态"></a>一、android 中的线程形态</h2><p>AsyncTask、IntentService 和 HandlerThread 的底层实现都是线程，但都有特殊的表现形式，各有优缺点。<br><strong>AsyncTask</strong> 封装了 线程池 和 Handler ，主要用于子线程更新UI；<strong>HandlerThread</strong> 是一种具有消息循环的线程，内部可以使用 Handler ； <strong>IntentService</strong> 是一个服务，内部采用 HandlerThread 执行任务，它类似一个后台线程，但是一个服务，不容易被杀死。</p><h3 id="1-1-AsyncTask"><a href="#1-1-AsyncTask" class="headerlink" title="1.1 AsyncTask"></a>1.1 AsyncTask</h3><p>AsyncTask 是一个轻量级的异步线程任务类，它在线程池中执行后台任务，然后把进度和最终结果传递给主线程并在主线程中更新UI，它封装了 Thread 和 Handler，但不适合特别耗时的后台任务，对于特别耗时的任务可以用线程池。</p><p>AsyncTask 是一个<strong>抽象的泛型类</strong>，有 Params, Progress, Result 三个泛型参数，分别表示参数类型、后台任务执行进度类型、后台任务返回结果类型。如果不需要具体的参数，可用 Void 代替。</p><pre><code>public abstract class AsyncTask&lt;Params, Progress, Result&gt; {}</code></pre><p>核心方法如下：</p><ul><li><strong>onPreExecute()</strong><br>在主线程中执行，异步任务之前调用，一般用于做准备工作。</li><li><strong>doInBackground(Params… params)</strong><br>在线程池中执行异步任务，可以通过 publishProgress （最终会调用onProgressUpdate）方法更新任务进度，次啊外该方法需要计算返回结果给onPostExecute。</li><li><strong>onProgressUpdate((Progress… values)</strong><br>在主线程中当任务进度改变后被调用</li><li><strong>onPostExecute(Result result)</strong><br>在主线程中执行，异步任务执行完后，result 是 doInBackground 返回的值。</li></ul><p>使用时注意事项：</p><ul><li>AsyncTask 必须在主线程中加载</li><li>AsyncTask 的对象必须在主线程中创建</li><li>execute 方法必须在UI线程中调用</li><li>不要在程序中直接调用 上述和新方法</li><li>一个 AsyncTask 对象只能调用一次 execute 方法</li><li>AsyncTask 在 android3.0后 ，用一个线程串行执行任务。</li></ul><p>在使用 AsyncTask 时调用了 execute方法，而该方法调用了 executeOnExecutor ，如下源码：</p><pre><code> @MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {        return executeOnExecutor(sDefaultExecutor, params);}@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,        Params... params) {    if (mStatus != Status.PENDING) {        switch (mStatus) {            case RUNNING:                throw new IllegalStateException(&quot;Cannot execute task:&quot;                        + &quot; the task is already running.&quot;);            case FINISHED:                throw new IllegalStateException(&quot;Cannot execute task:&quot;                        + &quot; the task has already been executed &quot;                        + &quot;(a task can be executed only once)&quot;);        }    }    mStatus = Status.RUNNING;    onPreExecute();    mWorker.mParams = params;    exec.execute(mFuture);    return this;}</code></pre><p>sDefaultExecutor 是一个串行的线程池，所有的任务都在该线程池中排队执行。这里也可以发现 AsyncTask 的 onPreExecute 方法是先执行的。mFuture 是一个 FutureTask（一个并发类） 对象，在AsyncTask的构造函数中通过 mWorker 进行实例化，而 mWorker 中 保存的有AsyncTask的参数。<br>如下 AsyncTask 的构造方法：</p><pre><code>public AsyncTask() {    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {        public Result call() throws Exception {            mTaskInvoked.set(true);            Result result = null;            try {                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);                //noinspection unchecked                result = doInBackground(mParams);                Binder.flushPendingCommands();            } catch (Throwable tr) {                mCancelled.set(true);                throw tr;            } finally {                postResult(result);            }            return result;        }    };    mFuture = new FutureTask&lt;Result&gt;(mWorker) {        @Override        protected void done() {            try {                postResultIfNotInvoked(get());            } catch (InterruptedException e) {                android.util.Log.w(LOG_TAG, e);            } catch (ExecutionException e) {                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,                        e.getCause());            } catch (CancellationException e) {                postResultIfNotInvoked(null);            }        }    };}</code></pre><p>下面是线程池的执行过程：</p><pre><code>public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;//...private static class SerialExecutor implements Executor {    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();    Runnable mActive;    public synchronized void execute(final Runnable r) {        mTasks.offer(new Runnable() {            public void run() {                try {                    r.run();                } finally {                    scheduleNext();                }            }        });        if (mActive == null) {            scheduleNext();        }    }    protected synchronized void scheduleNext() {        if ((mActive = mTasks.poll()) != null) {            THREAD_POOL_EXECUTOR.execute(mActive);        }    }}</code></pre><p>在 AsyncTask 执行时，首先将 参数封装成 FutureTask 对象，然后将其传入到 SerialExecutor 的 execute 方法中处理，首先通过  mTasks.offer() 方法将其添加到任务队列中，如果没有正在活动的任务，执行下一个任务 scheduleNext()。这里可以发现 AsyncTask 是串行执行的。 THREAD_POOL_EXECUTOR 是一个 线程池，真正的执行任务，而 SerialExecutor 负责任务的排队，InternalHandler 负责将执行环境从线程池切换到主线程中。</p><p>由于 FutureTask 的run方法最终会调用 mWorker 中call方法，这里回看前面 AsyncTask 的构造方法，在 mWorker 中call方法中 先将 mTaskInvoked 设置为true ，表示当前任务已被调用过，然后执行 doInBackground 方法，并将其结果传给 postResult 方法，而 postResult 方法主要是 通过 sHandler （InternalHandler对象）发送一个  MESSAGE_POST_PROGRESS 消息，最后调用到 AsyncTask 的 finish方法，通过传入的 Result ，在 finish 中 最后确定是调用取消（<code>onCancelled(result)</code>）还是执行完成（<code>onPostExecute(result)</code>）。到此 ，AsyncTask 的整个工作流程结束。</p><p>InternalHandler 是一个 静态的 Handler 对象，为了能将执行环境切换到主线程，则 sHandler 必须在主线程中创建，同时 变相要求了 AsyncTask 要在 主线程中 创建。</p><h3 id="1-2-HandlerThread"><a href="#1-2-HandlerThread" class="headerlink" title="1.2 HandlerThread"></a>1.2 HandlerThread</h3><p><code>HandlerThread</code> 类继承自 Thread ，是一个可以使用 Handler 的 Thread。主要是<strong>在其 run 方法中创建了消息队列和开启消息循环</strong>。这样就可以 在 HandlerThread 中创建Handler。<br>如下其 run方法：</p><pre><code>public void run() {    mTid = Process.myTid();    Looper.prepare();    synchronized (this) {        mLooper = Looper.myLooper();        notifyAll();    }    Process.setThreadPriority(mPriority);    onLooperPrepared();    Looper.loop();    mTid = -1;}</code></pre><p>HandlerThread 的run 方法是一个无线循环方法，在不需要时可以 通过 <code>quit</code> 或者 <code>quitSafely</code> 进行终止。 HandlerThread 主要用在 IntentService 中，</p><h3 id="1-3-IntentService"><a href="#1-3-IntentService" class="headerlink" title="1.3 IntentService"></a>1.3 IntentService</h3><p><code>IntentService</code> 是一个特殊的 service  ，继承自 Service，并且是一个抽象类，使用时必须创建其子类方可使用，它主要用于执行后台耗时任务，完成后自动关闭，它的优先级比普通的线程高，比较适合执行一些高优先级的后台任务。在其内部封装了 <code>HandlerThread</code> 和 <code>Handler（ServiceHandler）</code> 。如下其 <code>onCreate</code> 方法：</p><pre><code>public void onCreate(){    super.onCreate();    HandlerThread thread = new HandlerThread (&quot;IntentService[&quot; + mName + &quot;]&quot;);    thread.start();    mServiceLooper = thread.getLooper();    mServiceHandler = new ServiceHandler (mServiceLooper);}</code></pre><p>IntentService 在初次启动时调用 onCreate 方法，此时创建 HandlerThread ，然后通过它的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最后都在 HandlerThread 中处理，这导致 IntentService 也是顺序执行后台任务的。</p><p>每次启动 IntentService ，它的 onStartCommand 会被调用，处理每一个后台任务，调用了 onStart 方法 ,通过 mServiceHandler 发送一个消息，最后在 HandlerThread 中处理。</p><pre><code>public int onStartCommand (@Nullable Intent intent, int flags, int startId){    onStart (intent, startId);    return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;}public void onStart (@Nullable Intent intent, int startId){    Message msg = mServiceHandler.obtainMessage();    msg.arg1 = startId;    msg.obj = intent;    mServiceHandler.sendMessage (msg);}</code></pre><p>如下是 ServiceHandler 类的定义：</p><pre><code>private final class ServiceHandler extends Handler{    public ServiceHandler (Looper looper)    {        super (looper);    }    @Override    public void handleMessage (Message msg)    {        onHandleIntent ( (Intent) msg.obj);        stopSelf (msg.arg1);    }}</code></pre><p>mServiceHandler 收到消息后会将 Intent 对象传递给 onHandleIntent 处理，这里的 Intent 和 startService(intent) 中的 intent 完全一致，这样通过 这个 intent 就可以解析出外界启动 IntentService 所传递的参数，在 onHandleIntent 方法 中对不同的后台任务做处理。当 onHandleIntent 执行完后 调用 stopSelf ，停止服务。</p><p>上面提到的 onHandleIntent 方法是一个抽象方法，在使用时需要实现。</p><h2 id="二、android中的线程池"><a href="#二、android中的线程池" class="headerlink" title="二、android中的线程池"></a>二、android中的线程池</h2><p>线程池主要有如下几个优点：</p><ul><li>重用线程池中的线程，避免因线程的重复创建和销毁导致的性能开销；</li><li>能有效控制线程池的最大并发数，避免线程相互抢占资源导致阻塞；</li><li>能够对线程进行简单的管理，提供定时执行等功能。</li></ul><h3 id="2-1-ThreadPoolExecutor"><a href="#2-1-ThreadPoolExecutor" class="headerlink" title="2.1  ThreadPoolExecutor"></a>2.1  ThreadPoolExecutor</h3><p>android 中的线程池 源于 java 中的 Exector,Exector是一个接口，真正的线程池的实现类为 ThreadPoolExecutor 类，它提供了一系列的参数来配置线程池，通过不同的参数可以创建不同的线程池。<br>如下他它的一个常用构造方法的声明：</p><pre><code>public ThreadPoolExecutor (int corePoolSize,                           int maximumPoolSize,                           long keepAliveTime,                           TimeUnit unit,                           BlockingQueue&lt;Runnable&gt; workQueue,                           ThreadFactory threadFactory)</code></pre><p>参数说明：</p><ul><li><strong>corePoolSize</strong><br>核心线程数，默认情况下 一直存活着，即使处于闲置状态。将 allowCoreThreadTimeOut 属性设置为 true 时，闲置的核心线程等待新任务到来时会有超时策略，改时间间隔由 keepAliveTime 所指定，当时间超过 keepAliveTime 后，线程会被终止。</li><li><strong>maximumPoolSize</strong><br>最大线程数，当线程数达到该值后，后续的线程会被阻塞。</li><li><strong>keepAliveTime</strong><br>非核心线程闲置的超时时长，超过后就会被回收。</li><li><strong>unit</strong><br>指定 keepAliveTime 参数的时间单位，常用的有 TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）等</li><li><strong>workQueue</strong><br>线程池中的任务队列</li><li><strong>threadFactory</strong><br>线程工厂，为线程池提供创建新线程的功能，是一个 接口。</li></ul><p>如下是 AsyncTask 中 THREAD_POOL_EXECUTOR 线程池的配置：</p><pre><code>//cpu 数private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();//核心线程 private static final int CORE_POOL_SIZE = Math.max (2, Math.min (CPU_COUNT - 1, 4) );//线程池最大线程数 private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;//闲置超时时间 30sprivate static final int KEEP_ALIVE_SECONDS = 30;private static final ThreadFactory sThreadFactory = new ThreadFactory(){    private final AtomicInteger mCount = new AtomicInteger (1);    public Thread newThread (Runnable r)    {        return new Thread (r, &quot;AsyncTask #&quot; + mCount.getAndIncrement() );    }};//任务队列容量 128private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =    new LinkedBlockingQueue&lt;Runnable&gt; (128);public static final Executor THREAD_POOL_EXECUTOR;static{    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor (        CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,        sPoolWorkQueue, sThreadFactory);    threadPoolExecutor.allowCoreThreadTimeOut (true);    THREAD_POOL_EXECUTOR = threadPoolExecutor;}</code></pre><h3 id="2-2-线程池的分类"><a href="#2-2-线程池的分类" class="headerlink" title="2.2 线程池的分类"></a>2.2 线程池的分类</h3><p>除了 前面 的 ThreadPoolExecutor ，android 中还有如下四类线程池，他们都直接或者间接的通过配置 ThreadPoolExecutor 来实现自己的功能，通过 <code>Executors</code> 对应的new方法来创建。</p><ul><li><p><strong>FixedThreadPool</strong><br>通过 <code>Executors.newFixedThreadPool()</code> 创建，线程数固定的线程池，线程空闲时不会被回收，除非线程池被关闭。这种方式创建的线程池中只有核心线程且不会超时，任务队列无大小限制，能够更快的响应外界的请求。</p><pre><code>public static ExecutorService newFixedThreadPool (int nThreads){  return new ThreadPoolExecutor (nThreads, nThreads,                                 0L, TimeUnit.MILLISECONDS,                                 new LinkedBlockingQueue&lt;Runnable&gt;() );}</code></pre></li><li><p><strong>CachedThreadPool</strong><br>通过 <code>Executors.newCachedThreadPool()</code> 创建，是一种线程数不固定的线程池，只有核心线程，最大数为 Integer.MAX_VALUE，超时时间60s。</p><pre><code>public static ExecutorService newCachedThreadPool(){  return new ThreadPoolExecutor (0, Integer.MAX_VALUE,                                 60L, TimeUnit.SECONDS,                                 new SynchronousQueue&lt;Runnable&gt;() );}</code></pre></li><li><p><strong>ScheduledThreadPool</strong><br>通过 <code>Executors.newScheduledThreadPool()</code> 创建，是一种核心线程数固定，非核心线程数不固定的线程池。主要用于执行定时任务和具有固定周期的重复任务。</p><pre><code>public static ScheduledExecutorService newScheduledThreadPool (int corePoolSize){  return new ScheduledThreadPoolExecutor (corePoolSize);}public ScheduledThreadPoolExecutor (int corePoolSize){  super (corePoolSize, Integer.MAX_VALUE,         DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,         new DelayedWorkQueue() );}</code></pre></li><li><p><strong>SingleThreadExecutor</strong><br>通过 <code>Executors.newSingleThreadExecutor()</code> 创建，内部只有一个线程，可以确保所有的任务都在同一个线程中顺序执行，可以统一外界的任务到一个线程中。</p><pre><code>public static ExecutorService newSingleThreadExecutor(){  return new FinalizableDelegatedExecutorService         (new ThreadPoolExecutor (1, 1,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;() ) );}</code></pre><p>这是系统提供的四种常见的 线程池，此外还可以根据自己的实际需要灵活的配置线程池。</p></li></ul><blockquote><p><strong>本文作者</strong>：<a href="http://imtianx.cn/about" target="_blank" rel="noopener">imtianx</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AsyncTask </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 消息机制及其原理</title>
      <link href="/2016/12/27/android%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"/>
      <url>/2016/12/27/android%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote><p>读书笔记： 《Android 开发艺术探索》 ——第十章：android 消息机制</p></blockquote><p>对于 android 中的消息机制，主要是指 <strong>Handler</strong> 的运行机制。在我们平时的开发中 ，对它并不陌生。由于android 是 单线程（UI线程）机制，对于一些耗时操作会在子线程中进行，如文件读取等.<br><a id="more"></a><br>往往在操作完成后会有 UI 的更新，由于 android 中不允许在子线程中更新ui,所以我们 常常用 Handler 来更新UI ，但它的功能不仅仅如此。</p><h2 id="一、消息机制概述"><a href="#一、消息机制概述" class="headerlink" title="一、消息机制概述"></a>一、消息机制概述</h2><p><code>Handler</code> 的运行 需要底层的 <strong>MessageQueue</strong> 和 <strong>Looper</strong> 支撑。<code>MessageQueue</code> 是指消息队列，在他内部存储了一组消息，以队列的形式对外提供增删。虽名为队列，但是其内部的实现是采用 单链表。<code>Looper</code> 主要是用于消息循环，他内部通过无线循环的方式，查看是否有消息，如果有就处理，否则阻塞等待着。 在 Looper 中 利用 <code>ThreadLocal</code> 进行存储数据，它可以保证各个线程中互不干扰的存储和提供数据。<br>如果 使用 Handler 就必须为线程创建 Looper。我们能够在 Activity 只用它，主要是应为在 UI 线程( ActivityThread ) 创建是会初始化 looper。</p><p>android 系统不允许 在子线程中访问UI ，主要是 很多控件时线程不安全的，如果多线程并发访问会出现不可预期的效果；同时由于 锁机制会让 UI 访问逻辑变复杂，并且会阻塞某些线程从而降低 UI 访问效率，并没有对 UI 线程进行加锁 操作。</p><p>如下是 Handler 的 工作过程：</p><p><img src="/img/article_img/2016/Handler 消息机制.png" alt></p><blockquote><p>说明：首先 Handle 通过 <code>sendMessage()</code> 等方法发送一个消息，最终会调用 MessageQueue 的 <strong>enqueueMessage</strong> 方法 将消息添加到消息队列中；而 Looper 的 loop方法发现新消息后，从队列中取出消息，最后将其转发到 Handle 中，最终在 handleMessage 进行处理。而Looper 是运行在创建handler 的线程中，这样将Handler 中的业务逻辑切换到 穿件 Handler 的线程中去了。</p></blockquote><h2 id="二、消息机制分析"><a href="#二、消息机制分析" class="headerlink" title="二、消息机制分析"></a>二、消息机制分析</h2><h3 id="2-1-ThreadLocal-的工作原理"><a href="#2-1-ThreadLocal-的工作原理" class="headerlink" title="2.1 ThreadLocal 的工作原理"></a>2.1 ThreadLocal 的工作原理</h3><p>ThreadLocal 主要是线程内部的数据存储类，他可以在指定的线程中存储数据，然后只有指定的线程可以获取。，而其他线程则无法获取。这里使用它 可以方便的实现 Looper 在线程中的存取，此外，他还可以在复杂的逻辑下进行对象的传递，如监听器的传递。</p><p>由于 api23 前后，ThreadLocal 的内部实现不同，这里不具体介绍。</p><h3 id="2-2-MessageQueue-的工作原理"><a href="#2-2-MessageQueue-的工作原理" class="headerlink" title="2.2  MessageQueue 的工作原理"></a>2.2  MessageQueue 的工作原理</h3><p>在消息队列 MessageQueue 中主要包括两个操作：插入和读取，在读取的同时伴随有删除。 插入和读取分别对应于 <code>enqueueMessage</code> 和 <code>next</code>。 enqueueMessage 是往队列中插入 一条数据，采用非的是单链表的插入操作，其内部采用了锁机制，而 next 是一个无限循环方法，若无消息，那么它将阻塞者，若有消息，则返回该消息并将其从消息队列中移除。</p><h3 id="2-3-Looper-的工作原理"><a href="#2-3-Looper-的工作原理" class="headerlink" title="2.3 Looper 的工作原理"></a>2.3 Looper 的工作原理</h3><p>Looper 是消息循环的角色，不停的从 MessageQueue 中取消息，若存在则立即处理，否则阻塞。在 Looper 的构造方法中会创建一个MessageQueue对象。<br>Handle  的工作需要 looper ，如果没有回报错，可以用 <code>prepare</code> 方法创建Looper：</p><pre><code>// 创建looperLooper.prepare();//....//开启循环Looper.loop();</code></pre><p>才外，还提供了 <code>prepareMainLooper</code> 方法为主线程创建Looper。对于退出循环，则提供了 <code>quit</code> 和 <code>quitSafely</code> 方法，前者是直接退出，后者则是设置个退出标记，等消息处理完后再退出。<br>通常在子线程中创建的looper ,在执行完后应该退出，当执行退出后，次线程会立即终止，若handler 再次发送消息，则会返回 false。<br>由于在 Looper 的 loop 方法中调用用了 MessageQueue 的 next方法，而next 方法是个阻塞的，导致loop阻塞。如下loop方法：</p><pre><code>public static void loop(){    final Looper me = myLooper();    if (me == null)    {        throw new RuntimeException (&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);    }    final MessageQueue queue = me.mQueue;    // Make sure the identity of this thread is that of the local process,    // and keep track of what that identity token actually is.    Binder.clearCallingIdentity();    final long ident = Binder.clearCallingIdentity();    for (;;)    {        Message msg = queue.next(); // might block        if (msg == null)        {            // No message indicates that the message queue is quitting.            return;        }        // This must be in a local variable, in case a UI event sets the logger        final Printer logging = me.mLogging;        //...        final long traceTag = me.mTraceTag;        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled (traceTag) )        {            Trace.traceBegin (traceTag, msg.target.getTraceName (msg) );        }        try        {            msg.target.dispatchMessage (msg);        } finally        {            if (traceTag != 0)            {                Trace.traceEnd (traceTag);            }        }        //...        // Make sure that during the course of dispatching the        // identity of the thread wasn&#39;t corrupted.        final long newIdent = Binder.clearCallingIdentity();        //...        msg.recycleUnchecked();    }}</code></pre><blockquote><p>注意 <code>msg.target.dispatchMessage (msg);</code>一句，msg是一个从MessageQueue 中取出的Message对象，而 target 则是  Message 中的一个 Handler 类型的 成员变量，这样使得 loop方法将消息队列中的消息分发给 Handler 进行处理。</p></blockquote><h3 id="2-4-Handler-的工作原理"><a href="#2-4-Handler-的工作原理" class="headerlink" title="2.4 Handler 的工作原理"></a>2.4 Handler 的工作原理</h3><p>handler 主要包括消息的发送和接受，主要包括一系列的post和send方法实现的,而post最终是通过 send实现的。如下各个方法：</p><pre><code> public final boolean sendMessage(Message msg){    return sendMessageDelayed(msg, 0);} public final boolean sendEmptyMessage(int what){    return sendEmptyMessageDelayed(what, 0);} public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {    Message msg = Message.obtain();    msg.what = what;    return sendMessageDelayed(msg, delayMillis);} public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) {    Message msg = Message.obtain();    msg.what = what;    return sendMessageAtTime(msg, uptimeMillis);} public final boolean sendMessageDelayed(Message msg, long delayMillis){    if (delayMillis &lt; 0) {        delayMillis = 0;    }    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);} public boolean sendMessageAtTime(Message msg, long uptimeMillis) {        MessageQueue queue = mQueue;        if (queue == null) {            RuntimeException e = new RuntimeException(                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);            Log.w(&quot;Looper&quot;, e.getMessage(), e);            return false;        }        return enqueueMessage(queue, msg, uptimeMillis);    }      private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {        msg.target = this;        if (mAsynchronous) {            msg.setAsynchronous(true);        }        return queue.enqueueMessage(msg, uptimeMillis);    }</code></pre><p>通过上面的各个方法，最终是往调用了 <strong>enqueueMessage 方法 往 MessageQueue 中插入一条消息</strong>。在Looper 中 调用了 MessageQueue 的next 方法，取出一条消息，通过 dispatchMessage 方法将消息分发给 Handler 处理,如下其具体实现：</p><pre><code>public void dispatchMessage(Message msg) {    if (msg.callback != null) {        handleCallback(msg);    } else {        if (mCallback != null) {            if (mCallback.handleMessage(msg)) {                return;            }        }        handleMessage(msg);    }}</code></pre><p>这里首先检查 callback 是否为null,不为空就调用 handleCallback 处理，它是一个 Runnable对象；其次检查 mCallback　是否为null ，mCallback　是一个Callback类型的接口，内部只有一个方法：</p><pre><code>public interface Callback {    public boolean handleMessage(Message msg);}</code></pre><p>这里的 Callback 可以用来创建 Handle 对象，常见的创建 Handler 是重写 handleMessage 方法。<br>如下 Handler 的消息处理流程：<br><img src="/img/article_img/2016/Handler消息处理流程.png" alt></p><h2 id="三、主线程消息循环"><a href="#三、主线程消息循环" class="headerlink" title="三、主线程消息循环"></a>三、主线程消息循环</h2><p>主线程即ActivityThread ，其注入口方法为 main,在该方法中，通过 <code>Looper.prepareMainLooper();</code>  创建Looper，最后通过 <code>Looper.loop();</code>开启消息循环。</p><pre><code>public static void main (String[] args){    //...   // 创建主线程的Looper    Looper.prepareMainLooper();    ActivityThread thread = new ActivityThread();    thread.attach (false);    if (sMainThreadHandler == null)    {        sMainThreadHandler = thread.getHandler();    }    if (false)    {        Looper.myLooper().setMessageLogging (new                                             LogPrinter (Log.DEBUG, &quot;ActivityThread&quot;) );    }    // End of event ActivityThreadMain.    Trace.traceEnd (Trace.TRACE_TAG_ACTIVITY_MANAGER);    //开启循环    Looper.loop();    throw new RuntimeException (&quot;Main thread loop unexpectedly exited&quot;);}</code></pre><p>ActivityThread 的内部类 H 继承自 Handler ，其内部定义了一组消息类型，组要包括了四大组件的启动和停止。</p><p><strong>主线程消息循环模型</strong>：ActivityThread 内部通过 ApplicationThread 和 AMS 进行进程间通信，AMS 以进程间通信的方式完成 ActivityThread 的请求后回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 向 H 发送消息， H收到后将 ApplicationThread 中的逻辑切换到 ActivityThread 中去执行。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息机制 </tag>
            
            <tag> Handler </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 自定义View 详解</title>
      <link href="/2016/12/19/android%20%E8%87%AA%E5%AE%9A%E4%B9%89View%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2016/12/19/android%20%E8%87%AA%E5%AE%9A%E4%B9%89View%20%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<blockquote><p>读书笔记： 《Android 开发艺术探索》 ——第四章：View 的工作原理</p></blockquote><p>经过上一节 <a href="http://imtianx.cn/2016/12/17/Android%20View%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/" target="_blank" rel="noopener">Android View 的事件体系</a>的介绍，对 View 的架构及相关的事件分发有了解，本章主要介绍自定义 View 的相关知识。</p><p>对于自定义 View ，主要有： 直接继承View 和 ViewGroup，或者继承现有控件，如 ListView 等。不管使用哪种方式，都要先了解View 的工作原理 ，才能更好的进行自定义 View。<br><a id="more"></a></p><h2 id="一、理解-MeasureSpec"><a href="#一、理解-MeasureSpec" class="headerlink" title="一、理解 MeasureSpec"></a>一、理解 MeasureSpec</h2><p>MeasureSpec 意思是 “度量规格”，它是View 的一个静态内部类，封装了父view传递给子View 的布局要求，<br>在很大程度上确定了一个View 的尺寸。在测量过程中，系统会将 View 的LayoutParams 根据父容器所施加的规则转换成相应的 MeasureSpec，然后通过它测量 View 的宽高。</p><p>MeasureSpec 是一个32 位的int值，高2位代表 <code>SpecModel</code>,低30位代表 <code>SpecSize</code>。 SpecModel 指测量模式，SpecSize指在某种测量模式下的规格大小。这种将来两个个值打包成一个int值，可以避免过多的对象内存分配。对于 <code>SpecModel</code> 主要有如下三种模式：</p><ul><li><strong>UNSPECIFIED</strong><br>该模式下，父容器不对View 有任何限制，要多大给多大，一般用于系统内部。</li><li><strong>EXACTLY</strong><br>该模式下，父容器已经检测出 View 所需的<strong>精确</strong>大小，此时 View  的最终大小就是 <strong>SpecSize</strong>，它对应 LayoutParams 中的 <code>match_parent</code> 和 <code>具体数值</code>。</li><li><strong>AT_MOST</strong><br>View 的大小不能超过父容器指定的可用大小 (<code>SpecSize</code>) ,它对应 LayoutParams 中的 <code>wrap_parent</code>。</li></ul><p>上面提到了 View  的绘制还会和 <code>LayoutParams</code> 相关，对于 <code>DecorView</code> ,他的规则如下：</p><ul><li>LayoutParams.MATCH_PARENT:精确模式，大小就是窗口大小；</li><li>LayoutParams.WARO_CONTENT:最大模式，大小不定，但不能超过窗口大小；</li><li>固定大小：如100dp，精确模式，LayoutParams 中指定的大小。</li></ul><p>对于普通的 View 它的 MeasureSpec 创建规则如下：</p><table><thead><tr><th style="text-align:center">parentSpecMode <br> childLayoutParamsl<br></th><th style="text-align:center">EXACTLY</th><th style="text-align:center">AT_MOST<br></th><th style="text-align:center">UNSPECIFIED<br></th></tr></thead><tbody><tr><td style="text-align:center">dp/px</td><td style="text-align:center">EXACTLY<br>childSize</td><td style="text-align:center">EXACTLY<br>childSize</td><td style="text-align:center">EXACTLY <br>childSize</td></tr><tr><td style="text-align:center">match_parent</td><td style="text-align:center">EXACTLY<br> parentSize</td><td style="text-align:center">AT_MOST <br> parentSize</td><td style="text-align:center">UNSPECIFIED <br> 0</td></tr><tr><td style="text-align:center">wrap_content</td><td style="text-align:center">AT_MOST<br> parentSize</td><td style="text-align:center">AT_MOST<br> parentSize</td><td style="text-align:center">UNSPECIFIED <br> 0</td></tr></tbody></table><blockquote><p>说明：<br>对于普通 View 的 MeasureSpec 是由它父容器的 MeasureSpec 和 其本身的 LayoutParams 决定的。</p></blockquote><blockquote><p>当View 采用固定宽高时，其 MeasureSpec 是精确的，大小是 LayoutParams 指定的大小；<br>当View 的宽高是 match_parent 时，若其父容器是 精确的，则它也是精确的，大小为父布局的剩余空间；若父容器是最大模式，则view也是最大模式且大小不会超过父容器的剩余空间；<br>当 view 的宽高都是 wrap_content时，不管父容器是精确还是最大模式，他都是最大模式，大小不超过父容器的剩余空间。<br>对于 UNSPECIFIED 模式，主要用于系统内部，一般情况下我们不用关注。</p></blockquote><h2 id="二、View-的工作流程"><a href="#二、View-的工作流程" class="headerlink" title="二、View 的工作流程"></a>二、View 的工作流程</h2><p>对于View 它的工作流程主要指<strong>测量(measure)、布局(layout)、绘制(draw)</strong>这三大流程，其中 <code>measure</code> 确定 view 的测量宽高， <code>layout</code> 确定view 的最终宽高和四个顶点的位置，  <code>draw</code> 将 view 绘制在屏幕上。</p><h3 id="2-1-measure-过程"><a href="#2-1-measure-过程" class="headerlink" title="2.1 measure 过程"></a>2.1 measure 过程</h3><p>对于<strong>View 的测量</strong>，是由 <code>measure</code>方法完成的，而该方法是一个final 类型的，其中调用 了 <code>onMeasure</code> 方法，如下 View中 onMeasure方法源码：</p><pre><code>protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec){    //设置view 的测量值    setMeasuredDimension (getDefaultSize (getSuggestedMinimumWidth(), widthMeasureSpec),                          getDefaultSize (getSuggestedMinimumHeight(), heightMeasureSpec) );}</code></pre><p>其中，setMeasuredDimension 方法是设置测量值，而 <code>getDefaultSize</code> 方法是获得测量尺寸，如下源码：</p><pre><code>public static int getDefaultSize (int size, int measureSpec){    int result = size;    int specMode = MeasureSpec.getMode (measureSpec);    int specSize = MeasureSpec.getSize (measureSpec);    switch (specMode)    {    case MeasureSpec.UNSPECIFIED:        result = size;        break;    case MeasureSpec.AT_MOST:    case MeasureSpec.EXACTLY:        result = specSize;        break;    }    return result;}</code></pre><p>注意 <code>MeasureSpec.AT_MOST</code> 和 <code>MeasureSpec.EXACTLY</code> 两个分支语句返回相同结果，他们都是 MeasureSpec 中获取的测量结果。从这里可见 View 的宽高由 spaceSize 决定，所以<strong>自定义控件时直接继承view 需要重写 <code>onMeasure</code> 方法，设置 <code>wrap_content</code> 时的大小，否则 使用 wrap_content 就相当于 match_parent了，都是精确模式。</strong></p><p>在 onMeasure 中用到了 <code>getSuggestedMinimumWidth</code> 方法，如下源码：</p><pre><code>/** * 如果无背景，返回mMinWidth（为 android:minWidth 指定的值）； * 否则，返回 minWidth 指定的值和背景最小宽度两者的最大值 */protected int getSuggestedMinimumWidth(){    return (mBackground == null) ? mMinWidth :           max (mMinWidth, mBackground.getMinimumWidth() );}//获取背景最小宽度,即 Drawable 的原始宽度，如果没有就返回0public int getMinimumWidth(){    final int intrinsicWidth = getIntrinsicWidth();    return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;}</code></pre><p>对于<strong>ViewGroup 的测量过程</strong>，它可以包含多个 View ，所以除了调用自己的测量法法外，还要遍历所有子元素的测量方法。它是一个抽象类，没有onMeasure 方法，但也提供了 <code>measureChildren</code> 方法，在该方法中调用 <code>measureChild</code> 方法，分别测量子view 的宽高。</p><pre><code>protected void measureChildren (int widthMeasureSpec, int heightMeasureSpec){    final int size = mChildrenCount;    final View[] children = mChildren;    //遍历子view ，测量所有不是 GONE 状态的 view    for (int i = 0; i &lt; size; ++i)    {        final View child = children[i];        if ( (child.mViewFlags &amp; VISIBILITY_MASK) != GONE)        {            measureChild (child, widthMeasureSpec, heightMeasureSpec);        }    }}protected void measureChild (View child, int parentWidthMeasureSpec,                             int parentHeightMeasureSpec){    final LayoutParams lp = child.getLayoutParams();    final int childWidthMeasureSpec = getChildMeasureSpec (parentWidthMeasureSpec,                                      mPaddingLeft + mPaddingRight, lp.width);    final int childHeightMeasureSpec = getChildMeasureSpec (parentHeightMeasureSpec,                                       mPaddingTop + mPaddingBottom, lp.height);    //调用 子view 的测量方法    child.measure (childWidthMeasureSpec, childHeightMeasureSpec);}</code></pre><p>由于 ViewGroup 的子布局有不同的特性，这里通过调用子布局的 测量方法来测量每一个具体的View 的宽高，最终将他他们累加在一起，在计算具体的 View 时要考虑到 他的 padding 值。</p><p>由于view 的测量和 activity 的生命周期不是同的，如果要在 activity 中获取 view 的宽高，不能在 <code>onCreate</code> <code>onResume</code> 等方法中获取，可通过下面几种方式获取：</p><ul><li>重写 onWindowFocusChanged(boolean hasFocus)  方法，在 hasFocus 为 true时获取</li><li>使用view.post(Runnable runnable) 发送消息队列</li><li>使用ViewTreeObserver ，添加 <code>addOnGlobalLayoutListener</code> 监听。</li></ul><p>到此，view的测量完成了，接下来就是对其进行布局。</p><h3 id="2-2-layout-过程"><a href="#2-2-layout-过程" class="headerlink" title="2.2 layout 过程"></a>2.2 layout 过程</h3><p><code>layout</code> 方法确定 view 本身的位置，而ViewGroup 的 <code>onLayout</code> 方法确定所有子view 的位置。对于View 的layout 方法，首先是 调用 <code>setFrame</code>方法设置四个点的坐标，然后调用父容器的 <code>onLayout</code> 方法，确定子view 的位置。在布局过程中 view的最终宽高被确定，通常和测量宽高相等，他们只是在赋值的过程中不同。</p><h3 id="2-3-draw-过程"><a href="#2-3-draw-过程" class="headerlink" title="2.3 draw 过程"></a>2.3 draw 过程</h3><p>绘制过程，主要是将view 绘制到屏幕上显示。调用 <code>draw(Canvas canvas)</code>方法，如下源码：</p><pre><code>public void draw (Canvas canvas){    final int privateFlags = mPrivateFlags;    final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;                                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;    /*     * Draw traversal performs several drawing steps which must be executed     * in the appropriate order:     *     *      1. Draw the background     *      2. If necessary, save the canvas&#39; layers to prepare for fading     *      3. Draw view&#39;s content     *      4. Draw children     *      5. If necessary, draw the fading edges and restore layers     *      6. Draw decorations (scrollbars for instance)     */    // Step 1, draw the background, if needed    int saveCount;    if (!dirtyOpaque)    {        drawBackground (canvas);    }    // skip step 2 &amp; 5 if possible (common case)    final int viewFlags = mViewFlags;    boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;    boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;    if (!verticalEdges &amp;&amp; !horizontalEdges)    {        // Step 3, draw the content        if (!dirtyOpaque)        {            onDraw (canvas);        }        // Step 4, draw the children        dispatchDraw (canvas);        // Overlay is part of the content and draws beneath Foreground        if (mOverlay != null &amp;&amp; !mOverlay.isEmpty() )        {            mOverlay.getOverlayView().dispatchDraw (canvas);        }        // Step 6, draw decorations (foreground, scrollbars)        onDrawForeground (canvas);        // we&#39;re done...        return;    }</code></pre><p>主要有四个步骤：</p><ul><li>绘制背景：drawBackground (canvas)；</li><li>绘制自己 ：onDraw (canvas);</li><li>绘制children：dispatchDraw (canvas);</li><li>绘制装饰： onDrawForeground(canvas);</li></ul><p>view 通过 <code>dispatchDraw</code> 方法分发绘制的过程，而该方法会遍历所有子vied 的draw方法。如果View 是继承ViewGroup的并且自身不具备绘制功能时，可以调用 <code>setWillNotDraw</code> 设置标记位，使系统对其进行优化。</p><p>view 的大致工作流程就是这样的，自定义view涉及到View 的层次结构、事件分发和相关工作原理，尽管挺复杂，掌握它对我们的开发有很大的帮助。</p><h2 id="三、自定义View"><a href="#三、自定义View" class="headerlink" title="三、自定义View"></a>三、自定义View</h2><h3 id="3-1-View-的分类"><a href="#3-1-View-的分类" class="headerlink" title="3.1 View 的分类"></a>3.1 View 的分类</h3><p>常见的自定义view的方式主要有如下几种：</p><ol><li>继承view 重写 onDraw方法；<br>这种方式主要用于实现不规则效果，需要自己支持 wrap_content 和 padding的处理</li><li>继承 ViewGroup 派生出特殊的Layout<br>自定义布局，需要合适的处理ViewGroup 的测量和布局。</li><li>继承特定的View（如TextView）<br>扩展现有控件，需要自己支持 wrap_content 和 padding的处理</li><li>继承特定的ViewGroup（如LinearLayout）<br>这种方式和2类似，但不需要自己测量和布局过程。</li></ol><h3 id="3-2-自定义view的注意事项"><a href="#3-2-自定义view的注意事项" class="headerlink" title="3.2 自定义view的注意事项"></a>3.2 自定义view的注意事项</h3><ol><li>让View 支持 wrap_content<br>在 onMeasure 中对其进行处理，否则控件不支持 wrap_content属性</li><li>让View 支持 padding<br>在draw方法中处理 padding，如果是继承自ViewGroup，需要在 onMeasure 中处理 padding 和 margin</li><li>尽量不要使用 Handler ,View 本身提供的有 post方法</li><li>view中如果有线程和动画需要及时停止。</li><li>对于嵌套滑动，要处理好滑动冲突</li></ol><p>至此，View 的相关知识介绍完毕，接下来就是进行具体自定义操作了。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View </tag>
            
            <tag> 自定义 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android View 的事件体系</title>
      <link href="/2016/12/17/Android%20View%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"/>
      <url>/2016/12/17/Android%20View%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/</url>
      <content type="html"><![CDATA[<blockquote><p>本文为读书笔记： 《Android 开发艺术探索 》——第三章 View 的事件体系     </p></blockquote><p>android 系统虽然提供了很多基本的控件，如Button、TextView等，但是很多时候系统提供的view不能满足我们的需求，此时就需要我们根据自己的需求进行自定义控件。这些控件都是继承自View的。<br><a id="more"></a></p><h2 id="一、android-控件架构"><a href="#一、android-控件架构" class="headerlink" title="一、android 控件架构"></a>一、android 控件架构</h2><p>android 中的控件在界面上都会占一块巨型区域，主要分为两类：ViewGroup和View控件。ViewGroup作为父控件可以包含多个View控件，并管理他们，但其也是继承自View。通过Viewgroup，整个控件界面形成了View的控件树，如图1所示。</p><p>上层控件负责字控件的测量与绘制，并传递交互事件。在Activity 中 通过<code>findViewById()</code>方法，就是以树的 <em>深度优先遍历</em>  查找对应的控件。控件树的顶部都有一个ViewParent 对象，对整个视图进行控制。<br><img src="/img/article_img/2016/view.png" alt></p><p>如上面图2 所示，是android 界面的架构图，在activity 中 通过 <code>setContentView()</code> 方法设置为根布局。在每一个Activity 中 都包含一个Window 对象，它由 PhoneWindow来实现，PhoneWindow 讲一个 DecorView 设置为整个应用窗口的根View。DecorView 作为窗口界面的顶层视图，封装了一些窗口操作的通用方法，所有View 的监听事件，都通过<code>WindowManagerService</code> 进行接收，并通过Activity 对象来回调相应的onClickListener。对于DecorView，他由TitleView 和ContentView 组成，<br>前者承载的是一个<code>Actionbar</code>，后者承载的是一个<code>FrameLayout</code>。</p><h2 id="二、View-的基本知识"><a href="#二、View-的基本知识" class="headerlink" title="二、View 的基本知识"></a>二、View 的基本知识</h2><h3 id="2-1、View-的位置参数"><a href="#2-1、View-的位置参数" class="headerlink" title="2.1、View 的位置参数"></a>2.1、View 的位置参数</h3><p>view 的位置由两个顶点坐标来决定，主要是左上（left,top）和右下(right,bottom)坐标。他们是相对于View 的父容器来说的，是相对坐标。如下图他们的关系：<br><img src="/img/article_img/2016/view_zuobiao.png" alt></p><pre><code>width = right - left;height = bottom - top;</code></pre><p>在View 中都有相应的方法来获取他们的值。从android 3.0开始，View增加了几个参数：x,y,translationX和translationY，其中x、y表示View 左上角的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。同样的，他们也有相应的get/set方法，translationX和translationY的默认值均为0。</p><pre><code>x = left + translationX;y = right + translationY;</code></pre><p>在View 的移动过程中top和left 表示原始左上角坐标，并不会改变。</p><h3 id="2-2、MotionEvent和TouchSlop"><a href="#2-2、MotionEvent和TouchSlop" class="headerlink" title="2.2、MotionEvent和TouchSlop"></a>2.2、MotionEvent和TouchSlop</h3><p><strong>（1）、MotionEvent</strong><br>在手指触摸屏幕后，会有一系列的事件，主要事件类型有：</p><pre><code>ACTION_DOWN // 收支接触ACTION_MOVE // 手指在屏幕上移动ACTION_UP //手指从屏幕松开ACTION_CANCEL //取消...</code></pre><p>使用 <code>MotionEvent</code> 对象获取的 点击的 x 和 y ,使用 <code>getX / getY</code> 获取的是相对于当前View左上角的x和y,而 <code>getRawX / getRawY</code> 获取的是相对于手机屏幕左上角的坐标。</p><p><strong>（2）、TouchSlop</strong><br>TouchSlop 是系统所能识别的最小滑动距离，小于它则视未发生滑动，他和设备相关，在不同的设备上获取的值不同。通过 <code>ViewConfiguration.get(getContext()).getScaledTouchSlop();</code> 获取。</p><h3 id="2-3、VelocityTracker、GestureDetector和Scroller"><a href="#2-3、VelocityTracker、GestureDetector和Scroller" class="headerlink" title="2.3、VelocityTracker、GestureDetector和Scroller"></a>2.3、VelocityTracker、GestureDetector和Scroller</h3><p><strong>（1）、VelocityTracker</strong><br>速度追踪，用于追踪滑动过程中的速度，包括水平和竖直速度。如下具体使用步骤：</p><pre><code>//1.在 onTouchEvent 方法中追踪当前事件的速度VelocityTracker  tracker = VelocityTracker.obtain();tracker.addMovement(event);//2.获取当前速度tracker.computeCurrentVelocity(1000);//计算速度int xVelocity = (int) tracker.getXVelocity();int yVelocity = (int) tracker.getYVelocity();//3.在不需要的时候重置回收内存tracker.recycle();</code></pre><p><strong>（2）、GestureDetector</strong><br>手势检测，用于检测单击、滑动、长按、双击等手势。<br>在使用时，首先要实现 <code>GestureDetector.OnGestureListener</code>接口，如果需要双击，则需实现 <code>GestureDetector.OnDoubleTapListener</code> 接口；</p><pre><code>//设置监听mGestureDetector = new GestureDetector(this);//避免长按后无法拖动，自己测试时发现不设置，长按后也可以拖动mGestureDetector.setIsLongpressEnabled(false);</code></pre><p>然后在 onTouchEvent 添加如下代码：</p><pre><code>boolean consume = mGestureDetector.onTouchEvent(event);return consume;</code></pre><p>GestureDetector 类中的 OnGestureListener 接口和 OnDoubleTapListener 接口相关实现方法说明：</p><table><thead><tr><th>方法名</th><th style="text-align:center">描述</th><th style="text-align:center">所属接口</th></tr></thead><tbody><tr><td>onDown</td><td style="text-align:center">手指轻触，一个ACTION_DOWN 触发</td><td style="text-align:center">OnGestureListener</td></tr><tr><td>onShowPress</td><td style="text-align:center">手指轻触，尚未松开或者拖动</td><td style="text-align:center">OnGestureListener</td></tr><tr><td>onSingleTapUp</td><td style="text-align:center">单击：手指（轻触后）松开，伴随一个ACTION_UP触发</td><td style="text-align:center">OnGestureListener</td></tr><tr><td>onScroll</td><td style="text-align:center">拖动：手指按下并拖动，一个ACTION_DOWN，多个ACTION_MOVE</td><td style="text-align:center">OnGestureListener</td></tr><tr><td>onLongPress</td><td style="text-align:center">长按</td><td style="text-align:center">OnGestureListener</td></tr><tr><td>onFling</td><td style="text-align:center">快速滑动：按下快速滑动并松开</td><td style="text-align:center">OnGestureListener</td></tr><tr><td></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>onSingleTapConfirmed</td><td style="text-align:center">严格单击：这个只可能是单击，不会是双击中的一次单击</td><td style="text-align:center">OnDoubleTapListener</td></tr><tr><td>onDoubleTap</td><td style="text-align:center">双击 :与onSingleTapConfirmed 不共存</td><td style="text-align:center">OnDoubleTapListener</td></tr><tr><td>onDoubleTapEvent</td><td style="text-align:center">表示发生了双击行为</td><td style="text-align:center">OnDoubleTapListener</td></tr></tbody></table><p><strong>（3）、Scroller</strong><br>弹性滑动，可是实现有过度效果的滑动，View 的 ScrollTo/ScrollBy 都是瞬间滑动完成的。</p><h2 id="三、View-的滑动"><a href="#三、View-的滑动" class="headerlink" title="三、View 的滑动"></a>三、View 的滑动</h2><p>实现View的滑动主要有如下三种方式:</p><ol><li><strong>scrollTo /scrollBy</strong> :适合对view 的内容改变；</li><li><strong>动画</strong>： 主要用于没有交互的View 和实现复杂的动画效果；</li><li><strong>改变布局参数</strong>：操作稍微复杂，适合有交互的View 。</li></ol><h3 id="3-1-通过View-的-ScrollTo-ScrollBy-方法"><a href="#3-1-通过View-的-ScrollTo-ScrollBy-方法" class="headerlink" title="3.1. 通过View 的 ScrollTo/ScrollBy 方法"></a>3.1. 通过View 的 ScrollTo/ScrollBy 方法</h3><p>View 源码中的相关实现：</p><pre><code>  /**     * Set the scrolled position of your view. This will cause a call to     * {@link #onScrollChanged(int, int, int, int)} and the view will be     * invalidated.     * @param x the x position to scroll to     * @param y the y position to scroll to     */    public void scrollTo(int x, int y) {        if (mScrollX != x || mScrollY != y) {            int oldX = mScrollX;            int oldY = mScrollY;            mScrollX = x;            mScrollY = y;            invalidateParentCaches();            onScrollChanged(mScrollX, mScrollY, oldX, oldY);            if (!awakenScrollBars()) {                postInvalidateOnAnimation();            }        }    }      /**     * Move the scrolled position of your view. This will cause a call to     * {@link #onScrollChanged(int, int, int, int)} and the view will be     * invalidated.     * @param x the amount of pixels to scroll by horizontally     * @param y the amount of pixels to scroll by vertically     */    public void scrollBy(int x, int y) {        scrollTo(mScrollX + x, mScrollY + y);    }</code></pre><p>其中 <code>scrollBy</code> 调用的是 <code>scrollTo</code>，它实现了使用当前位置的相对滑动，而 <code>scrollTo</code> 是基于所传参数的绝对滑动。<strong>在滑动过程中，mScrollX 的值等于 View 左边缘 和 View 内容左边缘在水平方向的距离，而 mScrollY 则是View 上边缘和 View 内容上边缘在竖直方向的距离。他们都是以像素单位。如果从 左往右/从上往下 滑动，mScrollX/mScrollY 为正。</strong></p><p>scrollBy 和 scrollTo 只能改变 View 内容的位置而不能改变View 在布局中的位置。</p><p>如下滑动过程中，mScrollX/mScrollY 取值情况：</p><p><img src="/img/article_img/2016/View 中的scrollTo和scrollBy.png" alt></p><h3 id="3-2-使用动画"><a href="#3-2-使用动画" class="headerlink" title="3.2. 使用动画"></a>3.2. 使用动画</h3><p>通过动画为View 添加平移效果，View 的 tanslationX 和 tanslationY 属性，可以采用传统的动画和属性动画。<br>动画不能真正的改变 View 的位置，只是移动的是他的影像，如果在新位置有点击事件，则无效。但是在android 3.0以后属性动画解决了该问题。</p><h3 id="3-3-改变布局参数"><a href="#3-3-改变布局参数" class="headerlink" title="3.3. 改变布局参数"></a>3.3. 改变布局参数</h3><p>通过改变View 的LayoutParams 使得 View 重新布局实现滑动。<br>这里以 把 Button 水平移动 100px 为例。可以改变 Button 的 <code>marginLeft</code> ,或者在其左边放一个宽度为0 的view,当要平移时改变他的宽度，使其被挤到右边（加入Button的父布局为LinearLayout），实现滑动。</p><p>如下是改变 <code>LayoutParams</code>的方式：</p><pre><code> ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams)                mButton.getLayoutParams();params.width += 100;params.leftMargin += 100;mButton.setLayoutParams(params);  // 或者  mButton.requestLayout();</code></pre><h2 id="四、弹性滑动"><a href="#四、弹性滑动" class="headerlink" title="四、弹性滑动"></a>四、弹性滑动</h2><p>为了避免 滑动的生硬，可以采用弹性滑动，提高用户体验。这里主要有 ：Scroller、动画、延时三种方式。</p><p>如下是 <code>Scroller</code> 的典型使用，主要是 <strong>invalidate</strong>方法起的作用。</p><pre><code>Scroller mScroller = new Scroller(context);/** * 滑动到指定位置 * * @param destX  X 滑动距离 * @param destY  Y 滑动距离 */private void smoothScrollTo(int destX, int destY) {    //滑动起点X    int scrollX = getScrollX();    //滑动起点Y    int scrollY = getScrollY();    //1000 ms内慢慢滑向 （destX，destY）    mScroller.startScroll(scrollX, scrollY, destX, destY, 1000);    //重绘    invalidate();} /** * 使View 不断重绘 */@Overridepublic void computeScroll() {    /**     *  computeScrollOffset 方法通过时间流逝百分比计算 scrollX和scrollY      *  返回true 表示滑动未结束     */    if (mScroller.computeScrollOffset()) {        //滑动到当前位置，通过小幅度滑动实现弹性滑动        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());        //再次重绘        postInvalidate();    }}</code></pre><p>如下 <strong>Scroller 的滑动原理（相关方法的调用过程）</strong>：</p><p><img src="/img/article_img/2016/Scroller滑动机制.png" alt></p><p>对于延时达到弹性滑动，主要是利用 了Handler 或者 View 的 postDelayed 方法，或者线程的 sleep方法。</p><h2 id="五、View-的事件分发机制"><a href="#五、View-的事件分发机制" class="headerlink" title="五、View 的事件分发机制"></a>五、View 的事件分发机制</h2><p>在 view 中事件分发十分重要，了解他的原理，对我们理解View 和解决滑动冲突都十分重要。</p><blockquote><ol><li>所有的Touch事件都封装到 <code>MotionEvent</code> 里面；</li><li>事件处理包括三种情况，分别为：<strong>传递—-dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费—-onTouchEvent()函数和OnTouchListener</strong>；</li><li>事件类型分为 ACTION_DOWN, ACTION_UP, ACTION_MOVE , ACTION_POINTER_DOWN, ACTION_POINTER_UP , ACTION_CANCEL 等，每个事件都是以 ACTION_DOWN 开始 ACTION_UP 结束。</li></ol></blockquote><p>用下面伪代码表示事件分发过程及其关系：</p><pre><code>//事件分发public boolean dispatchTouchEvent(MotionEvent event) {    boolean consume = false;    //是否被拦截    if (onInterceptTouchEvent(event))    {        //被拦截，处理事件        consume = onTouchEvent(event);    } else {        //未被拦截，向下分发        consume = childView.dispatchTouchEvent(event);    }    return consume;}</code></pre><p><strong>事件传递的基本流程</strong>：</p><ul><li>事件都是从Activity.dispatchTouchEvent()开始传递；</li><li>事件由父View传递给子View，ViewGroup可以通过onInterceptTouchEvent()方法对事件拦截，停止其向子view传递；</li><li>如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数；</li><li>如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来，也就是说ACTION_DOWN必须返回true，之后的事件才会传递进来；</li><li>OnTouchListener优先于onTouchEvent()对事件进行消费。</li></ul><h2 id="六、View-的滑动冲突"><a href="#六、View-的滑动冲突" class="headerlink" title="六、View 的滑动冲突"></a>六、View 的滑动冲突</h2><p>滑动冲突的出现是由于内外两个view都是可以滑动的，如 ScrollView 中嵌套 ListView 。常见的滑动冲突场景有：</p><ul><li>场景一：内外滑动方向不一致；</li><li>场景二：内外滑动方向一致；</li><li>场景三：上述两种场景的嵌套。</li></ul><p>对于场景一，可以根据水平竖直方向的滑动距离差判断是哪种滑动，进行相应的拦截；场景二，可以通过自己的业务制定相应的处理规则，然后进行处理；场景三则结合前两种进行。</p><p>有些滑动冲突是采用了不合理的布局导致，可以更换布局，而有些则必须通过自定义控件重写拦截和分发事件处理。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View </tag>
            
            <tag> 事件分发 </tag>
            
            <tag> 滑动冲突 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android IPC 机制及进程通信</title>
      <link href="/2016/12/14/android%20IPC%20%E6%9C%BA%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2016/12/14/android%20IPC%20%E6%9C%BA%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<blockquote><p>本文为读书笔记： 《Android 开发艺术探索 》——第二章 IPC 机制</p></blockquote><p>android  开发中有时候需要用到多进程，那么了解进程间通信对我们开发就尤为重要。往往多进程分为两种情况： 一是一个应用因某些原因需要多进程（如某些模块需要在单独的进程中，或者是为了加大本应用所能使用的内存空间等）；二是当前应用需要想起他应用获取数据。<a id="more"></a></p><h2 id="一、IPC简介"><a href="#一、IPC简介" class="headerlink" title="一、IPC简介"></a>一、IPC简介</h2><p><strong>IPC</strong> 是 <code>Inter-Process Communication</code> 的缩写，含义为进程间通信或者跨进程通信，指两个进程间进行数据交互的过程。<br><strong>进程</strong>:是cpu调度的最小单位，是一种有限的系统资源，一般只一个执行单元。在PC或者移动设备上指一个程序或者一个应用。而一个进程可以包含多个进程。</p><p>IPC 不是android 中所独有的，任何操作系统都有。Windows上可以通过剪切板、管道和邮槽等来进行进程间通信；Linux 上可以通过命名管道、共享内存、信号量等进行通信;而android 他是一种基于linux 内核的移动操作系统，他的进程间通信方式并不完全继承自linux, 却有着自己独特的方式——<code>Binder</code>，此外，还可以使用Socket进行进程间通信。</p><h2 id="二、android-中的多进程模式"><a href="#二、android-中的多进程模式" class="headerlink" title="二、android 中的多进程模式"></a>二、android 中的多进程模式</h2><p>在android 中如果使用多进程，通过给四大组件指定 <code>android:process</code> 属性即可开启多进程，此外还可以通过 JNI 在native 层 fork 一个新的进程。<br>如下activity 配置示例代码：</p><pre><code> &lt;activity android:name=&quot;.activity.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;            &lt;/intent-filter&gt; &lt;/activity&gt;&lt;activity    android:name=&quot;.activity.SecondActivity&quot;    android:configChanges=&quot;screenLayout&quot;    android:label=&quot;@string/app_name&quot;    android:process=&quot;:remote&quot;/&gt;&lt;activity android:name=&quot;.activity.ThirdActivity&quot;    android:configChanges=&quot;screenLayout&quot;    android:label=&quot;@string/app_name&quot;    android:process=&quot;com.imtianx.ipcdemo.remote&quot;/&gt;</code></pre><p>通过 MainActivity 启动 SecondActivity ，SecondActivity 启动 ThirdActivity。<br>这三个activity 分别运行在三个不同的进程中：</p><pre><code>//在as中打开terminal 输入下面命令adb shell//查看进程：ps|grep 包名ps|grep cn.imtianx.ipcdemo//三个进程如下USER      PID   PPID  VSIZE  RSS   WCHAN            PC  NAMEu0_a106   3682  1680  1136428 57512 SyS_epoll_ 00000000 S cn.imtianx.ipcdemou0_a106   3808  1680  1134324 57360 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo:remoteu0_a106   3918  1680  1166916 57920 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo.remote</code></pre><p>或者在monitor界面也可以查看。MainActivity没有指定process属性，则他在应用的包名 <code>cn.imtianx.ipcdemo</code> 对应的进程中,其他两个分别 SecondActivity、ThirdActivity 所在的进程。对于SecondActivity ，他的进程是 以 <strong>：</strong> 申明的，是指在当前的进程名前加上包名，为 <strong>私有进程</strong>，其他应用不可与其在同一进程中；而不以 “ ：”开头的进程，属于 <strong>全局进程</strong> ，则可以。</p><blockquote><p>对于每个进程，都有一个独立的虚拟机，在内存中都有着不同的地址，这会导致不同虚拟机访问同一对象会产生多个副本，互不影响，若在一个进程中修改了数据，在另一个进程中不会变。即多进程下不能通过内存共享数据。</p></blockquote><p>一般多进程会造成如下几个问题：</p><ul><li>静态成员和单利失效</li><li>多线程同步进制失效</li><li>SharedPreference 的可靠性下降<br>底层是通过读写XML实现的，并发读写是会出问题的</li><li>Application 会被多次重建<br>运行在同一进程中的组件属于同一个虚拟机和同一个Application的</li></ul><h2 id="三、IPC-基础概念"><a href="#三、IPC-基础概念" class="headerlink" title="三、IPC 基础概念"></a>三、IPC 基础概念</h2><p>只有明白了 IPC 中的 <strong>Serializable接口、 Parcelable接口 和 Binder</strong>相关的基础概念  ，才能更好的理解跨进程通信。  Serializable接口和 Parcelable接口 是实现序列化的两种方式。对于Intent 和 Binder 传输数据、对象持久化到本地或者网络传输，都需要使用。</p><h3 id="3-1-Serializable接口"><a href="#3-1-Serializable接口" class="headerlink" title="3.1 Serializable接口"></a>3.1 Serializable接口</h3><p>Serializable接口 是java 中的，是一个空的接口，使用时直接实现，添加如下标识，即可自动实现序列化和反序列化操作。在使用过程中开销较大，需要大量操作io。</p><pre><code>private static final long serialVersionUID = 1L;</code></pre><p>对于 <code>transient</code> 标识的属性和静态成员变量 ， 不参与序列化。</p><h3 id="3-2-Parcelable接口"><a href="#3-2-Parcelable接口" class="headerlink" title="3.2 Parcelable接口"></a>3.2 Parcelable接口</h3><p>Parcelable接口 是android 特有的序列化方式，使用起来稍微麻烦，但是效率较高，主要用于内存序列化。如下使用示例：</p><pre><code>public class User implements Parcelable{    private String id;    private String name;    private String sex;    private int age;    protected User(Parcel in) {        id = in.readString();        name = in.readString();        sex = in.readString();        age = in.readInt();    }    //用于反序列化    public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() {        /**         * 从序列化对象中创建原始对象         * @param in         * @return         */        @Override        public User createFromParcel(Parcel in) {            return new User(in);        }        /**         * 创建指定长度的原始对象数组         * @param size         * @return         */        @Override        public User[] newArray(int size) {            return new User[size];        }    };    /**     * 内容功能描述     * 大多数返回0，仅当当前对象中存在文件描述符时返回1     * @return     */    @Override    public int describeContents() {        return 0;    }    /**     * 当前对象写入序列化结构     * @param dest     * @param flags     */    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeString(id);        dest.writeString(name);        dest.writeString(sex);        dest.writeInt(age);    }}</code></pre><p>这里虽然看着很复杂，但这些方法全部可以自动生成，不用手动编写。android 中的 Intent 、Bundle、Bitmap等都实现了Parcelable接口，都是可以进行序列化的。</p><h3 id="3-3-Binder"><a href="#3-3-Binder" class="headerlink" title="3.3 Binder"></a>3.3 Binder</h3><p>Binder 实现了 IBinder接口。从ipc角度，binder是一种跨进程通信方式，还可以理解为一种虚拟的物理设备，其驱动是 /dev/binder ;从 android Framework 角度说，Binder 是 ServiceManager 连接各种 Manager（ActivityManager、WindowManger，…）和相应 ManagerServices的桥梁；从 android 应用层来说，Binder是客户端与服务器端进行通信的媒介。</p><p>android中 Binder 主要用在Services中，包括 AIDL 和 Messenger , Messenger 底层是 AIDL 实现的。</p><p>如下是Binder的工作流程图：</p><p><img src="/img/article_img/2016/Binder 工作机制.png" alt></p><h2 id="四、android-中的IPC-方式"><a href="#四、android-中的IPC-方式" class="headerlink" title="四、android 中的IPC 方式"></a>四、android 中的IPC 方式</h2><p>如下各种 IPC 方式的优缺点对比：</p><table><thead><tr><th>名称</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">使用场景</th></tr></thead><tbody><tr><td>Bundle</td><td style="text-align:center">简单易用</td><td style="text-align:center">只能传输Bundle支持的数据类型</td><td style="text-align:center">四大组件间的进程通信</td></tr><tr><td>文件共享</td><td style="text-align:center">简单易用</td><td style="text-align:center">不适合高并发场景，并且无法做到进程间的即时通讯</td><td style="text-align:center">无并发访问情形，交换简单的数据，实时性不高</td></tr><tr><td>AIDL</td><td style="text-align:center">功能强大，支持一对多并发通信，实时通信</td><td style="text-align:center">使用复杂，需要处理好线程同步</td><td style="text-align:center">一对多通信且有RPC需求</td></tr><tr><td>Messenger</td><td style="text-align:center">功能一般，支持一对多串行通信，实时通信</td><td style="text-align:center">不能很好处理高并发情形，不支持RPC，数据通过Message进行传输（只能传输Bundle支持的数据类型）</td><td style="text-align:center">低并发的一对多即时通讯，无RPC需求，或者无需返回结果</td></tr><tr><td>ContentProvider</td><td style="text-align:center">在数据源访问方面功能强大，支持一对多并发数据共享，可以通过Call方法扩展其他操作</td><td style="text-align:center">可以理解为受约束的AIDL，主要提供数据源的CRUD操作</td><td style="text-align:center">一对多的进程数据共享</td></tr><tr><td>Socket</td><td style="text-align:center">功能强大，可以通过网络传输字节流，支持一对多实时通信</td><td style="text-align:center">实现复杂，不支持直接的RPC</td><td style="text-align:center">网络数据交换</td></tr></tbody></table><h2 id="五、AIDL-的简单使用"><a href="#五、AIDL-的简单使用" class="headerlink" title="五、AIDL 的简单使用"></a>五、AIDL 的简单使用</h2><p>只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。</p><p>使用 AIDL 创建绑定服务的基本步骤如下：</p><ol><li>创建 .aidl 文件<br>在android studio 中 ，可以直接创建 AIDL ，自动创建相关的 aidl 包，这里创建 <code>IAddAidlInterface.aidl</code> 文件，具体内容如下：</li></ol><pre><code> // IAddAidlInterface.aidl package cn.imtianx.ipcdemo; interface IAddAidlInterface { //计算两个数的和 int add(int num1 ,int num2); }</code></pre><p> 编译后会自动生成相应的 java 类，这里是在 <code>build/generated/source/aidl/debug/包名/IAddAidlInterface.java</code> ,它包含一个内部类：Stub,继承自 <code>Binder</code>,实现了我们定义的 AIDL 接口，IAddAidlInterface，是用于定义服务的 RPC 接口。</p><ol start="2"><li><p>实现接口</p><pre><code>private IBinder mIBinder = new IAddAidlInterface.Stub(){    @Override    public int add(int num1, int num2) throws RemoteException {     return num1+num2;    }};</code></pre></li><li><p>向客户端公开接口<br>自定义服务，便于客户端调用。</p><pre><code>public class IAddService extends Service {     public IAddService() {     }     @Override     public IBinder onBind(Intent intent) {         // TODO: Return the communication channel to the service.         return mIBinder;     }     private IBinder mIBinder = new IAddAidlInterface.Stub(){         @Override         public int add(int num1, int num2) throws RemoteException {             return num1+num2;         }     };}</code></pre><p>具体的调用(部分代码)：</p><pre><code>private IAddAidlInterface mIAddAidlInterface; private ServiceConnection mConnection = new ServiceConnection() {     @Override     public void onServiceConnected(ComponentName name, IBinder service) {         //获取远程服务对象         mIAddAidlInterface = IAddAidlInterface.Stub.asInterface(service);     }     @Override     public void onServiceDisconnected(ComponentName name) {         mIAddAidlInterface = null;     } }; //绑定服务 Intent intent = new Intent(AIDLActivity.this,IAddService.class); intent.setAction(IAddService.class.getName()); bindService(intent,mConnection, Context.BIND_AUTO_CREATE); //调用远程服务方法 int result  = mIAddAidlInterface.add(num1,num2); //解绑服务 @Override protected void onDestroy() {     super.onDestroy();     unbindService(mConnection); }</code></pre><p>上述是一个简单的 AIDL 的使用，通过调用远程服务获取 计算结果。</p></li></ol><p>接下来，分析下as 建立aidl文件编译后自动生成的java 类：</p><pre><code>package cn.imtianx.ipcdemo;public interface IAddAidlInterface extends android.os.IInterface{    public static abstract class Stub extends android.os.Binder implements cn.imtianx.ipcdemo.IAddAidlInterface    {        //binder 的唯一标示，一般是binder的类名        private static final java.lang.String DESCRIPTOR = &quot;cn.imtianx.ipcdemo.IAddAidlInterface&quot;;        /** Construct the stub at attach it to the interface. */        public Stub()        {            this.attachInterface (this, DESCRIPTOR);        }        /**         * 用于将服务器端的binder 转换成客户端所需要的AIDL 的接口类型         * @param obj         * @return 如果客户端和服务器端在同一进程，则返回服务端的stub对象，否则返回 Stub.proxy对象        */        public static cn.imtianx.ipcdemo.IAddAidlInterface asInterface (android.os.IBinder obj)        {            if ( (obj == null) )            {                return null;            }            android.os.IInterface iin = obj.queryLocalInterface (DESCRIPTOR);            if ( ( (iin != null) &amp;&amp; (iin instanceof cn.imtianx.ipcdemo.IAddAidlInterface) ) )            {                return ( (cn.imtianx.ipcdemo.IAddAidlInterface) iin);            }            return new cn.imtianx.ipcdemo.IAddAidlInterface.Stub.Proxy (obj);        }        /**         * 返回当前binder对象         * @return         */        @Override public android.os.IBinder asBinder()        {            return this;        }        /**        * 运行在服务端的Binder线程池中        * @param code 确定请求的方法        * @param data 获取目标方法所需参数        * @param reply 写入返回值        * @param flags        * @return 若返回false，则为失败，可以此做权限验证        * @throws android.os.RemoteException        */        @Override public boolean onTransact (int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException        {            switch (code)            {            case INTERFACE_TRANSACTION:            {                reply.writeString (DESCRIPTOR);                return true;            }            case TRANSACTION_add:            {                data.enforceInterface (DESCRIPTOR);                int _arg0;                _arg0 = data.readInt();                int _arg1;                _arg1 = data.readInt();                int _result = this.add (_arg0, _arg1);                reply.writeNoException();                reply.writeInt (_result);                return true;            }            }            return super.onTransact (code, data, reply, flags);        }        //代理对象        private static class Proxy implements cn.imtianx.ipcdemo.IAddAidlInterface        {            private android.os.IBinder mRemote;            Proxy (android.os.IBinder remote)            {                mRemote = remote;            }            @Override public android.os.IBinder asBinder()            {                return mRemote;            }            public java.lang.String getInterfaceDescriptor()            {                return DESCRIPTOR;            }            @Override public int add (int num1, int num2) throws android.os.RemoteException            {                android.os.Parcel _data = android.os.Parcel.obtain();                android.os.Parcel _reply = android.os.Parcel.obtain();                int _result;                try {                    _data.writeInterfaceToken (DESCRIPTOR);                    _data.writeInt (num1);                    _data.writeInt (num2);                    mRemote.transact (Stub.TRANSACTION_add, _data, _reply, 0);                    _reply.readException();                    _result = _reply.readInt();                }                finally {                    _reply.recycle();                    _data.recycle();                }                return _result;            }        }        /**        * 方法标示符        * 格式：TRANSACTION_方法名 = (android.os.IBinder.FIRST_CALL_TRANSACTION +         *       i);其中i按方法数自增        */        static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);    }    public int add (int num1, int num2) throws android.os.RemoteException;}</code></pre><p>更多AIDL 的资料，可参见<a href="https://developer.android.google.cn/guide/components/aidl.html#Defining" target="_blank" rel="noopener">官方文档</a>，对于Socket、ContentProvider等方式，之前接触过，这里不做介绍。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPC </tag>
            
            <tag> AIDL </tag>
            
            <tag> 进程通信 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android  多渠道打包</title>
      <link href="/2016/12/12/android%20%20%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"/>
      <url>/2016/12/12/android%20%20%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>这里介绍使用友盟进行多渠道打包，<a href="http://www.imooc.com/learn/752" target="_blank" rel="noopener">参考慕课视屏</a></p><h2 id="一、-配置环境"><a href="#一、-配置环境" class="headerlink" title="一、 配置环境"></a>一、 配置环境</h2><p>使用 <code>gradle</code> 添加依赖：</p><pre><code>//友盟统计compile &#39;com.umeng.analytics:analytics:latest.integration&#39;</code></pre><a id="more"></a><blockquote><p>注：版本号使用 <strong>latest.integration</strong> 替换， 这种依赖方式可以保证每次使用的都是最新的sdk（但这种使用得sdk支持）；或者在具体版本号后添加 <strong>+</strong> 也可以。</p></blockquote><p>在 manifests文件中添加相关的权限、appkey及渠道号：</p><pre><code>&lt;!--相关权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;&lt;activity &gt;    &lt;meta-data        android:name=&quot;UMENG_APPKEY&quot;        android:value=&quot;    564ac7c1e0f55aff0a000569&quot;/&gt; &lt;!-- 友盟统计app id--&gt;    &lt;meta-data        android:name=&quot;UMENG_CHANNEL&quot;        android:value=&quot;${UMENG_CHANNEL_VALUES}&quot;/&gt; &lt;!--  渠道号--&gt;&lt;/activity&gt;</code></pre><p>更多配置可参见<a href="http://dev.umeng.com/analytics/android-doc/integration?spm=0.0.0.0.RSo52l" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="二、编写配置脚本"><a href="#二、编写配置脚本" class="headerlink" title="二、编写配置脚本"></a>二、编写配置脚本</h2><p>主要是在model的gradle中编写相关的配置脚本，如下：</p><pre><code>defaultConfig{   //...   multiDexEnabled true //突破方法数65536的限制   manifestPlaceholders = [UMENG_CHANNEL_VALUES: &quot;umeng&quot;] //默认渠道号   //...}buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;            //指定签名文件            signingConfig signingConfigs.release        }    }    //添加签名文件信息    signingConfigs {        debug {}        //release 包添加签名文件        release {            storeFile file(&quot;D:/workspace_ide_settings/imtianxappkey.jks&quot;) //签名文件            storePassword &quot;123456&quot; //签名文件密码            keyAlias &quot;imtianx&quot; //别名            keyPassword &quot;123456&quot; //签名密码        }    }    //配置渠道号    productFlavors {        meizu {            //1.在每个渠道中指定渠道号           //manifestPlaceholders = [UMENG_CHANNEL_VALUES: &quot;meizu&quot;]           //指定相应渠道appname,需要将values/string中的 app_name隐藏            //resValue &quot;string&quot;,&quot;app_name&quot;,&quot;testxiaomi&quot;        }        xiaomi {         //manifestPlaceholders = [UMENG_CHANNEL_VALUES: &quot;xiaomi &quot;]        }    }    //2.使用脚本为每个渠道指定渠道号    productFlavors.all {        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUES: name]    }</code></pre><p>到此，脚本配置已经完成，在 terminal 中使用下面命定打包：</p><pre><code>//打release 包gradle assembleRelease//打debug包gradle assembleDebug//打指渠道的release包gradle assemblemeizuRelease</code></pre><p>如果是第一次使用，打造包时会下载一些相应的工具包，速度较慢。打包完成后，在 <code>build/outputs/apk/</code>文件下下就会看见相应的，这里打的是 releas包，名字为：<code>app名-渠道名-release.apk</code></p><p>如果想改变包名，可以配置如下代码进行指定包名：</p><pre><code>  buildTypes {        release {        //...         //指定release包名 为市场名         applicationVariants.all {            variant -&gt;                variant.outputs.each {                    output -&gt;                        def outputFile = output.outputFile                        if (outputFile != null &amp;&amp; outputFile.name.endsWith(&quot;.apk&quot;)) {                            def fileName = &quot;${variant.productFlavors[0].name}&quot; + &quot;.apk&quot;                            output.outputFile = new File(outputFile.parent, fileName);                        }                }        }    }}</code></pre><p>然后在 terminal 中进行执行命令打包。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 多渠道打包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java知识 之 Integer自动拆装箱与缓存</title>
      <link href="/2016/11/27/java%E7%9F%A5%E8%AF%86%20%E4%B9%8B%20Integer%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E4%B8%8E%E7%BC%93%E5%AD%98/"/>
      <url>/2016/11/27/java%E7%9F%A5%E8%AF%86%20%E4%B9%8B%20Integer%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E4%B8%8E%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>在java的数据类型中，包含基本类型 (如:<code>int、double、...</code>) 和包装类型(如: <code>Integer、Double、...</code> )。<br><strong>自动装箱指的是把基本类型的值转换为对应的包装类对象，反之则为自动拆箱。</strong><a id="more"></a></p><p>如下示例代码：</p><pre><code>Integer x = 100;int y = x;</code></pre><p>第一行代码实现了自动装箱，调用了 <code>valueOf(int i)</code> 方法；第二句实现了自动拆箱，调用了 <code>intvalue()</code> 方法。这些都是编译器自动帮我们完成的不用我们自己调用。</p><p>以此类推，其他的装箱拆箱机制类似。</p><p>下面的代码咋一看，输出都为 <code>true</code>,但其实不然：</p><pre><code>Integer a = 100 ;Integer b = 100 ;Integer c = 200 ;Integer d = 200 ;System.out.println(a==b);System.out.println(c==d);</code></pre><p>其中 <code>a==b</code> 结果为 <code>true</code> , <code>c==d</code> 结果为 <code>false</code> 。出现这种情况，主要是在进行自动装箱时， <code>Integer</code>的缓存机制导致的。</p><p>如下Integer部分源码：</p><pre><code>public final class Integer extends Number implements Comparable&lt;Integer&gt; {    @Native    public static final int MIN_VALUE = 0x80000000;    @Native    public static final int MAX_VALUE = 0x7fffffff;    // ...    //缓存类 默认用数组缓存 [-128,127] 的常量    private static class IntegerCache {        static final int low = -128;        static final int high;        static final Integer cache[];        static {            // high value may be configured by property            int h = 127;            //获取Jvm配置的Integer的最大值，可以手动设置            String integerCacheHighPropValue =                    sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);            if (integerCacheHighPropValue != null) {                try {                    //转换成int                    int i = parseInt(integerCacheHighPropValue);                    i = Math.max(i, 127);                    // Maximum array size is Integer.MAX_VALUE                    h = Math.min(i, Integer.MAX_VALUE - (-low) - 1);                } catch (NumberFormatException nfe) {                    // If the property cannot be parsed into an int, ignore it.                }            }            high = h;            //创建缓存常量数组            cache = new Integer[(high - low) + 1];            int j = low;            //设置数组元素值            for (int k = 0; k &lt; cache.length; k++)                cache[k] = new Integer(j++);            //通过断言确保数组最小范围为：[-128,127]            assert IntegerCache.high &gt;= 127;        }        private IntegerCache() {        }    }    //...    /**     * 自动装箱     *     * int -&gt; Integer     *     * @param i     * @return     */    public static Integer valueOf(int i) {        //如果在缓存范围内，直接从缓存中区，        if (i &gt;= Integer.IntegerCache.low &amp;&amp; i &lt;= Integer.IntegerCache.high)            return Integer.IntegerCache.cache[i + (-Integer.IntegerCache.low)];        // 在缓存空间外，重新创建        return new Integer(i);    }    //...}</code></pre><p>在默认情况下，Integer创建的缓存常量为 [-128,127],所以在上面的例子中，<code>Integer a = 100</code> 创建 a 对象是直接从常量数组中获取的，直接找到他的引用，b也是同样的，则 <code>a==b</code> 返回true;对于 <code>Integer c = 200</code> ,在常量池中没有缓存 ，则 通过 <code>new Integer(200)</code> 创建新对象，d也是这样创建的，他们所指向的引用不同，则 <code>c==d</code> 返回为 <code>false</code> 。</p><p>在上面的 缓存类 <code>IntegerCache</code> 中的静态代码块中，使用 <code>sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</code><br>获取设置jvm最大的Integer缓存池范围。可以手动指定该值，通过设置 <code>-XX:AutoBoxCacheMax=2000</code> 属性，如下命令行编译：</p><pre><code>//编译生成字节码javac TestInteger.java//指定范围最最大值为2000，运行java -XX:AutoBoxCacheMax=2000 TestInteger</code></pre><p>此时如下代码输出均为true：</p><pre><code>Integer a = 100 ;Integer b = 100 ;Integer c = 200 ;Integer d = 200 ;System.out.println(a==b);System.out.println(c==d);</code></pre><p>如果使用ide,直接设置 运行时 VM 值即可，如下图</p><p><img src="/img/article_img/2016/setvmintegerMax.png" alt></p><p>此外，在上面的代码中用到了  <code>assert(断言)</code> 关键字，它主要用来保证代码的正确性。<br>使用发方法为 </p><pre><code>assert 表达式;</code></pre><p>若表达式为 <code>true</code> ,则程序正常运行，否则 抛出异常 <code>java.lang.AssertionError</code>。编辑器默认的是将他关闭的，此时就算表达式为false也没有任何效果。<br>在idea中开启断言的方式和上面设置 vm值一样，只是这里设置的 是 <code>-ea</code> 。</p><p>可使用下面代码测试：</p><pre><code>boolean isOpen = false;assert isOpen;System.out.println(isOpen);</code></pre><p>开启前打印为false，开启后打印为true 。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
          <category> 高级知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 拆装箱 </tag>
            
            <tag> Integer缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 知识之 注解的使用和解析</title>
      <link href="/2016/11/26/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/"/>
      <url>/2016/11/26/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>在java中，例如重写父类方法使用的 <code>@Override</code>，就是注解。在开发中使用的框架，大部分也是用了注解。通过注解可以是代码更加简洁，更加清晰。在jdk1.5后，引入了注解。<a id="more"></a><br>官方概念：java提供了已汇总源程序中的元素关联任何信息和任何元数据的途径和方法。</p><h2 id="一-、常见的注解"><a href="#一-、常见的注解" class="headerlink" title="一 、常见的注解"></a>一 、常见的注解</h2><p>在java 中主要有如下三个注解：</p><ul><li>@Override<br>指明被注解的方法需要覆写父类中的方法，该方法在父类或接口中一定定存在，而且定义的一模一样（包括方法名、返回类型、参数），否则会报错误。</li><li>@Deprecated<br>表明该类被废弃，但仍然可以使用，只是使用时方法中间显示一横线。</li><li>@SuppressWarnings(“deprecation”)<br>这个主要是排除因使用了被Deprecated 标记的方法而出现的警告，尽量在方法上使用来压制警告。</li></ul><p>更多java注解类的信息请查看源码 <code>java.lang.annotation</code> 包下面的注解类。</p><p><strong>第三方注解：</strong><br> 如果使用过Spring和Mybatis后台框架，对Spring中的@Autowired、@Service、@Repository以及Mybatis中的@InsertProvider、@UpdateProvider、@Options的使用就较为了解。</p><h2 id="二、-注解的分类"><a href="#二、-注解的分类" class="headerlink" title="二、 注解的分类"></a>二、 注解的分类</h2><p>按照<strong>运行时机制</strong>分为：</p><ul><li><p>源码注解<br>注解只存在源码中，编译后的.class文件中不存在</p></li><li><p>编译时注解<br>在源码和.class中都存在，比如前面java中的 <code>@Override、@Deprecated、@SuppressWarnings(&quot;deprecation&quot;)</code></p></li><li>运行时注解<br>在运行阶段起作用，会影响运行逻辑的注解。</li></ul><p>按照<strong>来源</strong>分为：</p><ul><li>来自jdk的注解</li><li>第三方注解</li><li>自定义注解</li></ul><h2 id="三、自定义注解"><a href="#三、自定义注解" class="headerlink" title="三、自定义注解"></a>三、自定义注解</h2><p>在进行自定义注解时 使用 <code>@interface</code>关键字，与新建类类似。idea中新建java class时类型可以选择为<code>Annotation</code>，可以直接建立注解类。</p><blockquote><p>建立注解类时，若类中只有一个成员时，方法名必须为<strong>value</strong>，使用时可以忽略成员名和赋值号；<br>如果没有成员，则该注解成为标识注解，如 <code>@Inherited</code>；注解中，成员的类型可以为java中的基本类型（int/float/double/…）,也可以是String、Class、Annotation,Enumeration。此外，还可以使用 <code>default</code>关键字指定默认值。</p></blockquote><p>如下简单注解例子：</p><pre><code>@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited//允许子类继承@Documented//生成java doc时包含注解信息public @interface Description {    String desc();    String author();    int age() default 18;//指定默认值}</code></pre><p>上面的注解中，<code>@Target</code>指注解的作用域，包含java中的类、构造方法、属性等，具体参数如下：</p><pre><code>ElementType.METHOD  //方法声明ElementType.TYPE     //类、接口ElementType.CONSTRUCTOR    //构造方法声明ElementType.TYPE.FIELD  //属性声明ElementType.LOCAL_VARIABLE  //局部变量声明ElementType.PACKAGE //包声明ElementType.PARAMETER   //参数声明</code></pre><p><code>@Retention</code> 是指注解的生命周期，可以为：</p><pre><code>RetentionPolicy.RUNTIME     // 运行时，可以通过反射获取；RetentionPolicy.SOURCE      //源码中显示，编译后丢弃；RetentionPolicy.CLASS       //编译时记录到class中，运行时忽略</code></pre><p><code>@Inherited</code> 表示允许子类继承，这个只能用与类，而且子类只能继承父类的类注解，不能继承方法上的注解。<br><code>@Documented</code> 表示生成javadoc时包含注解信息</p><p>在注解类名之前的注解称为元注解。</p><p><strong>自定义注解的使用语法：<br>@注解名(成员名1=XXX,成员名2=XXX,…)；</strong><br>对于只有一个成员的注解，直接用<strong>@注解名(XXX)</strong></p><p>上面的注解可以使用在类和方法上，如下为在方法上的使用：</p><pre><code>@Description(desc = &quot;run&quot;,author = &quot;imtianx&quot;,age = 20)public void run() {}</code></pre><h2 id="四、解析注解"><a href="#四、解析注解" class="headerlink" title="四、解析注解"></a>四、解析注解</h2><p>对于注解的解析，主要用到了反射技术。<br>通过反射获取类、函数或成员上的运行时注解信息，实现动态的控制程序的逻辑。</p><p>这里介绍下注解内容的获取，首先在使用注解到需要的类上：</p><pre><code>@Description(desc = &quot;student&quot;,author = &quot;imtianx&quot;,age = 20)public class Student implements Person {    public String name;    @Description(desc = &quot;run-M&quot;,author = &quot;imtianx-M&quot;,age = 21)    public void run() {    }    @Override    public void sign() {    }}</code></pre><p>测试获取注解内容：</p><pre><code>public class TestDemo01 {    public static void main(String[] args) {        try {            //1.反射获取类信息            Class c = Class.forName(&quot;Student&quot;);            //2.获取类上面的注解            boolean hasCAnno = c.isAnnotationPresent(Description.class);            if (hasCAnno) {                Description d = (Description) c.getAnnotation(Description.class);                System.out.println(d.desc());                System.out.println(d.author());                System.out.println(d.age());            }            //3.获取方法上的注解            Method[] methods = c.getMethods();            for (Method method : methods) {                boolean isMAnno = method.isAnnotationPresent(Description.class);                if (isMAnno) {                    Description md = method.getAnnotation(Description.class);                    System.out.println(md.desc());                    System.out.println(md.author());                    System.out.println(md.age());                }            }            //另一种获取获取注解的方式，以获取类上面的注解为例            for (Method method : methods) {                Annotation[] as = method.getDeclaredAnnotations();                for (Annotation a : as) {                    if (a instanceof Description) {                        Description d = (Description) a;                        System.out.println(d.desc());                        System.out.println(d.author());                        System.out.println(d.age());                    }                }            }        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}</code></pre><p>首先通过反射获取类信息，然后依次获取类、方法上面的注解内容。至于属性上面的注解，可以使用<code>Class.getDeclaredFields()</code>获取所有的属性，然后进行遍历获取。可参见 <a href="http://imtianx.cn/2016/11/25/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">java 知识之 反射的使用</a> 一文了解反射相关的知识。</p><p>当你了解了自定义注解和它的解析，再去看自己项目所用框架中的注解的实现，就十分简单，自己也能实现相同的效果。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
          <category> 高级知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 注解 </tag>
            
            <tag> 自定义注解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 知识之 反射的使用</title>
      <link href="/2016/11/25/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/11/25/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>所谓反射，是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。<a id="more"></a></p><p>反射有如下的功能：</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法；</li><li>在运行时调用任意一个对象的方法；</li><li>生成动态代理。</li></ul><p>这里的反射主要通过<code>Class</code>类来实现。</p><h2 id="一、Class类的使用"><a href="#一、Class类的使用" class="headerlink" title="一、Class类的使用"></a>一、Class类的使用</h2><p><code>Class</code>类的实例表示java 应用运行时的类或者接口，包括数组、基本类型(<code>int/long/Indeger/String/...</code>)、关键字(<code>void/...</code>)等。没有共有构造方法，在使用new创建对象或者加载ClassLoader时，由JVM自动调用。</p><blockquote><p>每个java类运行时都在JVM里表现为一个class对象，可通过类名.class,类型.getClass(),Class.forName(“类名”)等方法获取class对象。</p></blockquote><p>可以通过下面三种方式获得Class对象：</p><p>1.通过 类名.class 获取，可以认为每个类都有一个静态的Class对象。</p><pre><code>Class c1 = Person.class;</code></pre><p>2.通过类的对象获取</p><pre><code> Person person = new Person(); Class c2 = person.getClass();</code></pre><p>3.通过类名获取，<strong>动态加载</strong>（这个再很多地方都有使用，如：加载数据库驱动）</p><pre><code> Class c3 = null;    try {        c3 = Class.forName(&quot;Person&quot;);    } catch (ClassNotFoundException e) {        e.printStackTrace();    }</code></pre><p>上面的<strong>c1/c2是Person的类类型，Person是Class类的对象。可以理解为一切类都是Class的对象</strong>。</p><p>打印上面三种方法获取的Class对象：</p><pre><code>System.out.println(c1 == c2);//trueSystem.out.println(c1 == c3);//trueSystem.out.println(c2 == c3);//true</code></pre><p>上面三种方式获取的Class对象，两两均相等。可见，可以理解为每个对象都有一个静态的Class变量。因为在java 中，<em>Object</em> 是一切类的父类，在Object中有一个获取Class对象的native(由C++或C语言实现，通过java 调用，具体的可参见jni相关的知识)方法。如下部分Object开头源码：</p><pre><code> public class Object {     // ...     /**     * Returns the runtime class of this {@code Object}. The returned     * {@code Class} object is the object that is locked by {@code     * static synchronized} methods of the represented class.     *     * &lt;p&gt;&lt;b&gt;The actual result type is {@code Class&lt;? extends |X|&gt;}     * where {@code |X|} is the erasure of the static type of the     * expression on which {@code getClass} is called.&lt;/b&gt; For     * example, no cast is required in this code fragment:&lt;/p&gt;     * @return The {@code Class} object that represents the runtime     *         class of this object.     *          */    public final native Class&lt;?&gt; getClass();   // ...</code></pre><p>通过上面 getClass 方法前的部分注释，可以清楚的明白他的作用。</p><h2 id="二、动态加载类"><a href="#二、动态加载类" class="headerlink" title="二、动态加载类"></a>二、动态加载类</h2><p>在java 中，使用new创建的对象都是静态加载的，这些类必须存在，不管在实际中是否使用，否则编译不通过。可以通过动态加载类来解决该问题。<br>通过Class类的forName方法进行加载,传入相应的名加载具体的类，可以使程序的扩展性更好，避免编译出错。</p><p>该方法的原型为：</p><pre><code>  public static Class&lt;?&gt; forName(String className)</code></pre><h2 id="三、使用Class获取类信息"><a href="#三、使用Class获取类信息" class="headerlink" title="三、使用Class获取类信息"></a>三、使用Class获取类信息</h2><p>Class类提供的部分获取类信息的方法如下：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:left">getFields()</td><td style="text-align:center">获取所有public类型的成员变量</td></tr><tr><td style="text-align:left">getDeclaredFields()</td><td style="text-align:center">获取该类自己声明的所有变量</td></tr><tr><td style="text-align:left">getConstructors()</td><td style="text-align:center">获取所所有public类型的构造方法</td></tr><tr><td style="text-align:left">getDeclaredConstructors()</td><td style="text-align:center">获取所有的构造方法</td></tr><tr><td style="text-align:left">getMethods()</td><td style="text-align:center">获取所有的public函数，包括父类继承来的</td></tr><tr><td style="text-align:left">getDeclaredMethods</td><td style="text-align:center">获取该类所有声明的方法</td></tr></tbody></table><p>上面分别为获取成员变量、构造方法和成员方法。</p><p><strong>获取成员参数</strong></p><pre><code>public class ClassUtils {    public static void getClassField(Object obj) {            Class c = obj.getClass();            Field[] fs = c.getDeclaredFields();// c.getMethods();            for (Field f : fs) {                Class fieldType = f.getType();                System.out.println(fieldType.getName() + &quot; &quot; + f.getName());            }        }}</code></pre><p>上述代码是获取所有成员变量的，获取的每个成员方法都是 <code>Fidld</code> 类型的对象。<br>如下测试代码获取String类中的成员变量：</p><pre><code>ClassUtils.getClassField(&quot;reflect&quot;);</code></pre><p>运行结果：</p><pre><code>[C valueint hashlong serialVersionUID[Ljava.io.ObjectStreamField; serialPersistentFieldsjava.util.Comparator CASE_INSENSITIVE_ORDER</code></pre><p>其中第一个和第三个表示的是数组。查看String中的源码，成员变量如下：</p><pre><code>public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    private final char value[];    private int hash; // Default to 0    private static final long serialVersionUID = -6849794470754667710L;    private static final ObjectStreamField[] serialPersistentFields =            new ObjectStreamField[0];    //...     public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER                                         = new CaseInsensitiveComparator();    //...}</code></pre><p>同样的可以调用该方法查看其他类中的成员变量。</p><p><strong>获取构造方法和成员方法</strong></p><p>类似于上面获取成员变量的方法，如下获取构造函数和成员方法则很好理解了。</p><pre><code>public class ClassUtils {    //...    /**     * 获取所有的成员方法     *     * @param obj     */    public static void getClassMethods(Object obj) {        Class c = obj.getClass();        System.out.println(&quot;类名为：&quot; + c.getName());        Method[] ms = c.getDeclaredMethods();        for (Method m : ms) {            Class returnType = m.getReturnType();            //返回值的类类型，如String--&gt;String.class            System.out.print(returnType.getName() + &quot; &quot;);            //方法名称            System.out.print(m.getName() + &quot;(&quot;);            //获取参数--参数列表的类类型            Class[] paramTypes = m.getParameterTypes();            int paramsNum = paramTypes.length;            Class paramType;            for (int i = 0; i &lt; paramsNum; i++) {                paramType = paramTypes[i];                if (i == 1 || (i == paramsNum - 1))                    System.out.print(paramType.getName());                else                    System.out.print(paramType.getName() + &quot; ,&quot;);            }            System.out.println(&quot;)&quot;);        }    }    /**     * 获取所有的构造函数     *     * @param obj     */    public static void printConMessage(Object obj) {        Class c = obj.getClass();        Constructor[] cs = c.getDeclaredConstructors();        for (Constructor constructor : cs) {            System.out.print(constructor.getName() + &quot; (&quot;);            Class[] paramTypes = constructor.getParameterTypes();            int paramsNum = paramTypes.length;            Class paramType;            for (int i = 0; i &lt; paramsNum; i++) {                paramType = paramTypes[i];                if (i == 1 || (i == paramsNum - 1))                    System.out.print(paramType.getName());                else                    System.out.print(paramType.getName() + &quot; ,&quot;);            }            System.out.println(&quot;)&quot;);        }    }}</code></pre><p>此处省略测试。</p><h2 id="四、方法反射的基本操作"><a href="#四、方法反射的基本操作" class="headerlink" title="四、方法反射的基本操作"></a>四、方法反射的基本操作</h2><p>对于方法的获取，可以通过方法名称和参数列表来确定某个方法。主要使用了 <code>Method.invoke(对象,参数列表);</code> 操作。</p><p><strong>首先需要获取类信息，然后指定方法名和参数获取方法对象，再通过<code>Method.invoke()</code>进行反射获取方法执行结果。若该方法无返回值，则invoke方法最后返回null,否则返回相应的结果</strong>。</p><p>如下示例代码：</p><pre><code>public class TestDemo {    public static void main(String[] args) {        //1.获取类信息        A a = new A();        Class aClass = a.getClass();        //2.获取方法名称和参数        try {//            Method method = aClass.getMethod(&quot;print&quot;,new Class[]{int.class,int.class});            Method method = aClass.getMethod(&quot;print&quot;, int.class, int.class);            //方法返回结果：若无返回结果则o为null，否则为返回结果，这里返回为30            Object o = method.invoke(a, 10, 20);            System.out.println(o);//30        } catch (NoSuchMethodException e) {            e.printStackTrace();        } catch (InvocationTargetException e) {            e.printStackTrace();        } catch (IllegalAccessException e) {            e.printStackTrace();        }    }}//测试反射方法class A {    public int print(int a, int b) {        System.out.println(a + b);        return a + b;    }    public void print(String a, String b) {        System.out.println(a.toUpperCase() + &quot;-----&quot; + b.toUpperCase());    }}</code></pre><p>其中 Method()和invoke()方法第二个参数为可变数组，可有可无，如果有接写。可以通过new数组的方式或者直接一个个写出。</p><h2 id="五、通过反射了解集合泛型的本质"><a href="#五、通过反射了解集合泛型的本质" class="headerlink" title="五、通过反射了解集合泛型的本质"></a>五、通过反射了解集合泛型的本质</h2><p>我们都知道，在java中，定义集合指定什么泛型，就只能添加该类型的数据到集合中，否则就会报错。</p><p>通过反射可以往集合中添加不同类型的数据，这样虽没有多大意义，不便于遍历。这里主要说明了集合在编译后是去泛型化的，集合的泛型可以防止错误输入，在编译极前有效。</p><p>如下测试代码：</p><pre><code>public class TestDemo04 {    public static void main(String[] args) {        ArrayList&lt;String&gt; l1 = new ArrayList&lt;&gt;();        ArrayList l2 = new ArrayList();        l1.add(&quot;java reflect&quot;);//        datas.add(100);//报错        Class c1 = l1.getClass();        Class c2 = l2.getClass();        System.out.println(c1 == c2);//true        try {            Method method = c2.getMethod(&quot;add&quot;, Object.class);            method.invoke(l1, 100);            System.out.println(&quot;数组大小：&quot;+l1.size());            System.out.println(&quot;数组内容：&quot;+l1.toString());        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>输出结果：</p><pre><code>true数组大小：2数组内容：[java reflect, 100]</code></pre><p>上面的代码，通过反射往String类型的集合中添加了int类型的100。</p><p>通过对反射的学习，发现反射是从.class到.java的过程，感觉像反编译字节码。以 <code>Class c1 = Person.class;</code>为例，Person.java类在编译后生成的字节码文件为Person.class,这里获取的Class正式这样的。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
          <category> 高级知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 知识 之 内存管理</title>
      <link href="/2016/11/24/java%20%E7%9F%A5%E8%AF%86%20%E4%B9%8B%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2016/11/24/java%20%E7%9F%A5%E8%AF%86%20%E4%B9%8B%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote><p>读书笔记：《疯狂java 程序员的基本修养》第四章——java内存管理</p></blockquote><p>java 中的内存管理包括内存分配和内存回收，这些都是由 JVM 帮我们完成的。当创建对象时为其分配内存空间；当失去引用时，GC会自动清除并回收他们所占用的空间。<br><a id="more"></a></p><h2 id="一、java-引用的种类"><a href="#一、java-引用的种类" class="headerlink" title="一、java 引用的种类"></a>一、java 引用的种类</h2><p>当java对象创建完后，垃圾回收机制会实时的监测每个对象的状态，包括对象的申请、引用、被引用。赋值等。当它不存在引用时，对其进行回收。</p><p>当一个对象在堆内存中运行时，根据它对应的有向图的状态，有如下三种状态：</p><ul><li>可达状态<br>当一个对象被创建后，有一个以上的引用变量引用他，在有向图中可以从起点导航到该点，此时可以通过引用变量调用它的属性和方法。</li><li>可恢复状态<br>程序中不再有任何对象引用变量引用它，此时不能从有向图的起点到达它。系统准备回收，再回收之前系统会调用该对象的<code>finalize()</code>方法进行资源清理，如果在finalize 中重新让一个及以上的引用变量引用该对象，则它会再次变为可达状态，否则，进入不可达状态。</li><li>不可达状态<br>所有的关联都被切断，永久性的失去引用，只有在该状态下系统才会真正的回收对象所占用的资源。</li></ul><p>三张状态转换图如下：</p><p><img src="/img/article_img/2016/object_state.png" alt></p><h3 id="a-强引用"><a href="#a-强引用" class="headerlink" title="a. 强引用"></a><strong>a. 强引用</strong></h3><p>在java  中，创建一个对象，并把它赋值给一个引用变量，就是强引用。<strong>被强引用所引用的对象时绝对不会被垃圾回收机制回收的，即使系统非常紧张</strong>，因此它是造成内存泄露的主要原因之一。</p><h3 id="b-软引用"><a href="#b-软引用" class="headerlink" title="b. 软引用"></a><strong>b. 软引用</strong></h3><p>软引用需要用<code>SoftReference</code>类来实现，当一个对象只有软引用时，它有可能被回收。对于软引用，<strong>当系统内存空间足够时，不会被回收，否则会被系统回收，该对象不可再被使用</strong>。<br>软引用是强引用很好的替代，他能避免系统内存不足的异常。具体的使用如下（其中Person类有两个属性和一个tostring方法）：</p><pre><code>public class SoftReferenceTest {    public static void main(String[] args)            throws Exception {        SoftReference&lt;Person&gt;[] people =                new SoftReference[100000];        for (int i = 0; i &lt; people.length; i++) {            people[i] = new SoftReference&lt;Person&gt;(new Person(                    &quot;名字&quot; + i, (i + 1) * 4 % 100));        }        System.out.println(people[2].get());        System.out.println(people[4].get());        // 通知系统进行垃圾回收        System.gc();        System.runFinalization();        // 垃圾回收机制运行之后，SoftReference数组里的元素保持不变        System.out.println(people[2].get());        System.out.println(people[4].get());    }}</code></pre><p>运行结果：</p><pre><code>Person[name=名字2, age=12]Person[name=名字4, age=20]Person[name=名字2, age=12]Person[name=名字4, age=20]</code></pre><p>系统内存足够，在垃圾回收前后结果一样，和强引用并无区别。若指定jvm的内存大小，则软引用所引用的对象会被系统回收，可使用如下命令指定堆内存只有2M，则创建长度为100000的数组可使内存紧张，则会被回收，最终输出均为<br>null：</p><pre><code>java -Xmx2m -Xms2m SoftReferenceTest</code></pre><blockquote><p>Xmx：设置java虚拟机堆内存最大容量；<br>Xms：设置java虚拟机初始容量。 </p></blockquote><p>如果将前面初始化people的方式改为下面的强引用方式，依然指定2M内存，则会抛出<code>java.lang.OutOfMemoryError</code>的内存溢出异常,因而终止程序,此处也体现了前面所说的强引用对象不会回收其所占用的内存，尽管内存不足。</p><pre><code>Person[] people = new Person[100000];</code></pre><h3 id="c-弱引用"><a href="#c-弱引用" class="headerlink" title="c. 弱引用"></a><strong>c. 弱引用</strong></h3><p>弱引用于软引用类似，但他的生存期更短，通过<code>WeakReference</code>类实现。对于只有弱引用的对象，当垃圾机制运行时，<strong>不管内存是否足够，总会回收该对象占用的内存</strong>。<br>如下示例代码：</p><pre><code>public class WeakReferenceTest {    public static void main(String[] args) throws Exception {        // 创建一个字符串对象        String str = new String(&quot;疯狂Java讲义&quot;);        // 创建一个弱引用，让此弱引用引用到&quot;疯狂Java讲义&quot;字符串        WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(str);        // 切断str引用和&quot;疯狂Java讲义&quot;字符串之间的引用        str = null;      //②        // 取出弱引用所引用的对象        System.out.println(wr.get()); //输出：疯狂Java讲义        // 强制垃圾回收        System.gc();        System.runFinalization();        // 再次取出弱引用所引用的对象        System.out.println(wr.get());  //输出：null    }}</code></pre><blockquote><p>注：上面代码中创建字符串对象不可采用 “String str = “疯狂Java讲义”;” 这种方式,因为这样的定义系统会把它缓存为常量，使用强引用来引用它，则不会被回收。</p></blockquote><p>上述代码中的内存分配示意图：</p><p><img src="/img/article_img/2016/weakreference.png" alt></p><p>在实际使用时，可以使用<code>WeakHashMap</code>来保存弱引用对象。</p><h3 id="d-虚引用"><a href="#d-虚引用" class="headerlink" title="d. 虚引用"></a><strong>d. 虚引用</strong></h3><p>虚引用主要是跟踪对象被垃圾回收的状态，可以通过检查与虚引用关联的队列中是否包含指定的引用，了解对象是否被回收。<br>与软引用和弱引用不同，虚引用不能单独使用。<br>虚引用对象在被释放前会将它添加到他关联的引用队列中。通过<code>PhantomReference</code>类实现，结合引用队列<code>ReferenceQuence</code>使用。如下使用示例：</p><pre><code>public class PhantomReferenceTest {    public static void main(String[] args)            throws Exception {        // 创建一个字符串对象        String str = new String(&quot;疯狂Java讲义&quot;);        // 创建一个引用队列        ReferenceQueue&lt;String&gt; rq = new ReferenceQueue&lt;String&gt;();        // 创建一个虚引用，让此虚引用引用到&quot;疯狂Java讲义&quot;字符串        PhantomReference&lt;String&gt; pr =                new PhantomReference&lt;String&gt;(str, rq);        // 切断str引用和&quot;Struts2权威指南&quot;字符串之间的引用        str = null;        // 试图取出虚引用所引用的对象，        // 程序并不能通过虚引用访问被引用的对象        System.out.println(pr.get());  //输出null        // 强制垃圾回收        System.gc();        System.runFinalization();        // 取出引用队列中最先进入队列中引用与pr进行比较        System.out.println(rq.poll() == pr);  //输出：true    }}</code></pre><h2 id="二、java-的内存泄露"><a href="#二、java-的内存泄露" class="headerlink" title="二、java 的内存泄露"></a>二、java 的内存泄露</h2><p>与C++程序员不同，java 程序员无需关注内存释放的问题，这些由JVM帮我们完成。然而如果使用不当，一样会出现内存泄露。如果是可达状态的对象，但程序不访问，他们做占用的空间不会被回收，就会产生内存泄露。<br>yi ArrayList中的remove方法为例，每当删除一个元素时，就会让最后一个元素的引用置为null:</p><pre><code>elementData[--size] = null;</code></pre><p>在ArrayList中采用数组来保存每个元素的。由于集合中每个元素实际上存的是引用，如果不使用上述的代码，则ArrayList中被删除的元素一直被引用着，处于可达状态，导致无法被回收，因而会产生内存泄露。</p><h2 id="三、垃圾回收机制"><a href="#三、垃圾回收机制" class="headerlink" title="三、垃圾回收机制"></a>三、垃圾回收机制</h2><p>垃圾回收主要完成两件事：</p><ul><li>跟踪监控java对象，当它处于不可达时，回收他所占用的内存；</li><li>清理内存分配和回收过程中产生的内存是碎片。</li></ul><p>垃圾回收的基本算法有：</p><ul><li>串行回收和并行回收</li><li>并发执行和应用程序停止</li><li>压缩/不压缩和复制</li></ul><p>现在的垃圾回收机制用分代的方式采用不同的回收机制，根据<strong>对象生存时间的长短</strong>，把堆内存分为三代：<strong>Yong(新生代)、Old(老年代)、Permanent(永生代)</strong>。</p><p>在java中，绝大多数对象不会被长时间引用，他们在Yong期间被回收，很老的对象和很新的对象之间很少存在相互引用的情况。</p><p>当Yong代的内存快要用完时，垃圾回收机制会对其进行回收，此时回收的系统性能开销小。为次要回收；当Old代快要用完时，垃圾回收机制会进行全面的回收，包括Yong和Old，此时回收成本大，为主要回收。</p><p>Permanent时代主要用于装在Class、方法等信息，默认是64MB，通常不会被回收。</p><h2 id="四、内存管理技巧"><a href="#四、内存管理技巧" class="headerlink" title="四、内存管理技巧"></a>四、内存管理技巧</h2><p>只有很好的掌握了垃圾回收及其机制，才能更好的管理java虚拟机，使我们写出更高性能的java代码。避免内存泄露的主要技巧如下：</p><ul><li>使用直接量<br>如使用 <code>String str = &quot;hello;&quot;</code> 代替 <code>String str = new String(&quot;hello&quot;);</code>，前者会在缓存池缓存这个常量</li><li>使用StringBuilder和StringBuffer进行字符串的连接<br>使用String时会生成大量的临时字符串存在内存中。</li><li>及时释放无用对象的引用</li><li>减少静态变量</li><li>避免在经常调用的方法、循环中创建java对象</li><li>缓存经常使用的对象<br>缓存技术是牺牲空间换时间的，主要使用容器保存已使用的对象，其关键在于如何控制缓存容器的空间使其不至于过大并且能够保留大部分已用过的对象。</li><li>尽量不要使用finalize方法</li><li>考虑使用SoftReference<br>当创建长度很大的对象时，可以使用软引用包装数组，便于在内存不足的情况下被回收释放。</li></ul>]]></content>
      
      <categories>
          
          <category> java </category>
          
          <category> 高级知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 内存回收 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 知识 之 常见java集合的实现细节</title>
      <link href="/2016/11/22/java%20%E7%9F%A5%E8%AF%86%20%E4%B9%8B%20%E5%B8%B8%E8%A7%81java%E9%9B%86%E5%90%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
      <url>/2016/11/22/java%20%E7%9F%A5%E8%AF%86%20%E4%B9%8B%20%E5%B8%B8%E8%A7%81java%E9%9B%86%E5%90%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</url>
      <content type="html"><![CDATA[<blockquote><p>读书笔记：《疯狂java 程序员的基本修养》第三章——常见java集合的实现细节</p></blockquote><h2 id="1-java-中集合及其继承关系"><a href="#1-java-中集合及其继承关系" class="headerlink" title="1.java 中集合及其继承关系"></a>1.java 中集合及其继承关系</h2><p><strong>Collection</strong>中常用的集合类类图如下：<a id="more"></a></p><p><img src="/img/article_img/2016/collection_diagram.png" alt></p><p><strong>Map</strong>中常用的集合类类图如下：</p><p><img src="/img/article_img/2016/map_diagram.png" alt></p><p><em>注：在jdk的安装目录下的 <code>src.zip</code>文件中就是jdk的源码，可以解压后查看。可通过NetBeans<br>等软件进行逆向工程查看类图。由于习惯使用idea，加上它对uml有一定的支持（主要是NetBeans新版不能在jdk1.8之后看类图），这里采用Idea生成类图。如下图：</em></p><p><img src="/img/article_img/2016/ide_show_class_diagram.png" alt></p><p>为了方便查看，可以新建工程，将jdk中的src解压放到该项目目录下，避免因为导入的包使有些类重复显示。</p><h2 id="2-Set和Map"><a href="#2-Set和Map" class="headerlink" title="2. Set和Map"></a>2. Set和Map</h2><p><code>Set</code>代表一种集合元素无序、不可重复的集合；<code>Map</code>代表一种由多个<code>key-value</code>对组成的集合。Map是Set集合的扩展。Map的所有的Key都是不可重复的，他们可以组成一个Set集合，对于Map而言，特可以看做是每个元素都是key-value对的集合。</p><p><strong>HashSet和HashMap</strong><br>HashSet:用采用Hash算法来决定集合元素的存储位置，可以保证快速存取集合；<br>HashMap:同样采用Hash算法决定key的存储位置，value紧随key存储。</p><blockquote><p>在java中，虽然集合可以存储对象，但真正存储的是对象的引用，通过这些引用指向具体的对象，与引用类型的数组类似。</p></blockquote><p>HashMap的构造器：</p><ul><li>HashMap()<br>构建初始容量为16，负载因子为0.75的HashMap；</li><li>HashMap(int initialCapacity)<br>指定初始容量（初始化时会找出大于initialCapacity的最小的2的N次方作为实际的容量，通常情况下实际的容量比initialCapacity大，除非指定的initialCapacity是2的n次方，则指定initialCapacity为2的N次方可以减小系统的开销）</li><li>HashMap(int initialCapacity, float loadFactor)<br>指定初始容量和负载因子</li></ul><p>这里的负载因子，增大它会减小Hash表占用的空间，但会增加查询的时间开销；减小负载因子会提高数据查询性能，但会增加内存占用，可以根据实际的需要适当的设置它。</p><p>对于HashSet,大部分方法都是调用HashMap的方法来实现的，在hashset中元素实际上由HashMap的Kkey来保存，value则存的是一个PRESENT——一个静态的Object对象。</p><p>对于<strong>TreeMap</strong>，它底层采用的<strong>红黑树</strong>（一种自平衡二叉树了，树种的每个节点的值都大于或等于它左子树种所有节点的值，小于或等于它右子树种所有节点的值）来保存的，保证了所有的key都是从小到大排列的。</p><p style="color:red;"><strong>HashTable</strong> 是线程安全的。</p><h2 id="3-Map和List"><a href="#3-Map和List" class="headerlink" title="3.Map和List"></a>3.Map和List</h2><p>Map提供了get(K key)方法通过key获取value,List接口提供了get(int index)方法获取指定索引的值。<br>Stack是Vector的子类，是线程安全的，jdk1.6后不推荐使用它，可以使用ArrayQueue替换。</p><h2 id="4-ArrayList和LinkedList"><a href="#4-ArrayList和LinkedList" class="headerlink" title="4.ArrayList和LinkedList"></a>4.ArrayList和LinkedList</h2><p>ArrayList和Vector的实现绝大部分都是相同的，只是Vector的方法使用了<em>synchronized</em>修饰，可以看做Vector是ArrayList的线程安全版本。<br>ArrayList是通过数组保存集合元素的，但在定义数组时用<strong>transient</strong>进行修饰，</p><p>ArrayList是一种顺序存储的线性表，LinkdList则是一种链式存储的线性表（双链表、队列、栈）。ArrayList在插入/删除数据时，需要将数据进行“整体搬家”。LinkedList是一个双链表，如果要获取某个元素必须进行逐个的搜索，但提供的有<code>addFirst(E e)</code>、<code>addLast(E e)</code>等方法，可以快速的定位需要的操作。</p><p>大部分情况下，ArrayList的性能总比LinkedList更优。对于经常需要添加和删除的，可以使用LinkedList.</p><h2 id="5-Iterator迭代器"><a href="#5-Iterator迭代器" class="headerlink" title="5.Iterator迭代器"></a>5.Iterator迭代器</h2><p>Iterator是一个迭代器接口，用于迭代各种Collection集合，这里使用了“迭代器模式”。<br>在迭代过程如果删除元素，若该元素不是最后一个，则会抛出异常。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
          <category> 高级知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java知识 之 对象及其内存管理</title>
      <link href="/2016/11/19/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2016/11/19/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote><p>读书笔记：《疯狂java 程序员的基本修养》第二章——对象及其内存管理</p></blockquote><p>java中的内存管理分为两个方面：</p><ul><li><p><strong>内存分配</strong>：指创建java对象时JVM为该对象在堆空间中所分配的内存空间。</p></li><li><p><strong>内存回收</strong>：指java 对象失去引用，变成垃圾时，JVM的垃圾回收机制自动清理该对象，并回收该对象所占用的内存。<a id="more"></a></p></li></ul><p>虽然JVM 内置了垃圾回收机制，但仍可能导致内存泄露、资源泄露等，所以我们不能肆无忌惮的创建对象。此外，垃圾回收机制是由一个后台线程完成，也是很消耗性能的。</p><h2 id="1-实例变量和类变量"><a href="#1-实例变量和类变量" class="headerlink" title="1.实例变量和类变量"></a>1.实例变量和类变量</h2><p>java程序中的变量，大体可以分为<strong>成员变量</strong>和<strong>局部变量</strong>。其中局部变量可分为如下三类：</p><ul><li><strong>形参</strong>：在方法名中定义的变量，有方法调用者负责为其赋值，随着方法的结束而消亡。</li><li><strong>方法内局部变量</strong>：在方法内定义的变量，必须在方法内对其进行初始化。它从初始化完成后开始生效，随着方法结束而消亡。</li><li><strong>代码块内局部变量</strong>：在代码块内定义的变量，必须在代码块内对其显示初始化。从初始化完成后生效，随着代码块的结束而消亡。</li></ul><p><em>局部变量的作用时间很短暂，他们被存在栈内存中。</em><br>类体内定义的变量为成员变量。如果使用<code>static</code>修饰，则为静态变量或者类变量，否则成为非静态变量或者实例变量。</p><blockquote><p><strong>static</strong>:<br>他的作用是将实例成员编程类成员。只能修饰在类里定义的成员部分，包括变量、方法、内部内（枚举与接口）、初始化块。不能用于修饰外部类、局部变量、局部内部类。</p></blockquote><p><strong>使用static修饰的成员变量是类类型，属于类本身，没有修饰的属于实例变量，属于该类的实例。在同一个JVM中，每个类可以创建多个java对象。同一个JVM中每个类只对应一个Class对象，机类变量只占一块内存空间，但是实例变量，每次创建便会分配一块内存空间。</strong></p><pre><code>class Person{    String name;    int age;    static int eyeNum;    public void info()    {        System.out.println(&quot;我的名字是：&quot; + name            + &quot;， 我的年龄是：&quot; + age);    }}public class FieldTest{    public static void main(String[] args)    {        // 类变量属于该类本身，只要该类初始化完成，        // 程序即可使用类变量。        Person.eyeNum = 2;           //①        // 通过Person类访问eyeNum类变量        System.out.println(&quot;Person的eyeNum属性：&quot;            + Person.eyeNum);        // 创建第一个Person对象        Person p = new Person();        p.name = &quot;猪八戒&quot;;        p.age = 300;        // 通过p访问Person类的eyeNum类变量        System.out.println(&quot;通过p变量访问eyeNum类变量：&quot;            + p.eyeNum);           //②        p.info();        // 创建第二个Person对象        Person p2 = new Person();        p2.name = &quot;孙悟空&quot;;        p2.age = 500;        p2.info();        // 通过p2修改Person类的eyeNum类变量        p2.eyeNum = 3;                //③        // 分别通过p、p2和Person访问Person类的eyeNum类变量        System.out.println(&quot;通过p变量访问eyeNum类变量：&quot;            + p.eyeNum);        System.out.println(&quot;通过p2变量访问eyeNum类变量：&quot;            + p2.eyeNum);        System.out.println(&quot;通过Person类访问eyeNum类变量：&quot;            + Person.eyeNum);    }}</code></pre><p>上述代码中的内存分配如下：</p><p><img src="/img/article_img/2016/对象内存分配1.png" alt></p><p>当Person类初始化完成，类变量也随之初始化完成，不管再创建多少个Person对象，系统都不再为 eyeNum 分配内存，但会为 name 和age 分配内存并初始化。当eyeNum值改变后，通过每个Person对象访问eyeNum的值都随之改变。</p><h3 id="a-实例变量的初始化"><a href="#a-实例变量的初始化" class="headerlink" title="a.实例变量的初始化"></a><strong>a.实例变量的初始化</strong></h3><p>对于实例变量，它属于java对象本身，每次程序创建java对象时都会为其分配内存空间，并初始化。<br>实例变量初始化地方：</p><ul><li>定义实例化变量时；</li><li>非静态初始化块中；</li><li>构造器中。</li></ul><p>其中前两种比第三种更早执行，而前两种的执行顺序与他们在程序中的排列顺序相同。它们三种作用完全类似，经过编译后都会提取到构造器中执行，且位于所有语句之前，定义变量赋值和初始化块赋值的顺序与他们在源代码中一致。</p><p>可以使用 <code>javap</code>命令查看java编译器的机制：</p><pre><code>用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括:-help  --help  -?        输出此用法消息-version                 版本信息-v  -verbose             输出附加信息-l                       输出行号和本地变量表-public                  仅显示公共类和成员-protected               显示受保护的/公共类和成员-package                 显示程序包/受保护的/公共类                       和成员 (默认)-p  -private             显示所有类和成员-c                       对代码进行反汇编-s                       输出内部类型签名-sysinfo                 显示正在处理的类的                       系统信息 (路径, 大小, 日期, MD5 散列)-constants               显示最终常量-classpath &lt;path&gt;        指定查找用户类文件的位置-cp &lt;path&gt;               指定查找用户类文件的位置-bootclasspath &lt;path&gt;    覆盖引导类文件的位置</code></pre><h3 id="b-类变量的初始化"><a href="#b-类变量的初始化" class="headerlink" title="b.类变量的初始化"></a><strong>b.类变量的初始化</strong></h3><p>类变量属于java 类本身，每次运行时才会初始化。<br>类变量的初始化地方：</p><ul><li>定义类变量时初始化；</li><li>静态代码块中初始化</li></ul><p>如下代码，表面上看输出的是：17.2,17.2；但是实际上输出的是：-2.8,17.2</p><pre><code>class Price{    // 类成员是Price实例    final static Price INSTANCE = new Price(2.8);    // 在定义一个类变量。    static double initPrice = 20;    // 定义该Price的currentPrice实例变量    double currentPrice;    public Price(double discount)    {        // 根据静态变量计算实例变量        currentPrice = initPrice - discount;    }}public class PriceTest{    public static void main(String[] args)    {        // 通过Price的INSTANCE访问currentPrice实例变量        System.out.println(Price.INSTANCE.currentPrice);//输出：-2.8        // 显式创建Price实例        Price p = new Price(2.8);        // 通过先是创建的Price实例访问currentPrice实例变量        System.out.println(p.currentPrice);            //输出：17.2    }}</code></pre><p>第一次使用Price 时，程序对其进行初始化，可分为两个阶段：<br>（1）系统为类变量分配内存空间；<br>（2）按初始化代码顺序对变量进行初始化。</p><p>这里的运行结果为：-2.8,17.2<br><strong>说明</strong>：初始化第一阶段，系统先为 INSTANCE，initPrice两个类变量分配内存空间，他们的默认值为null和0.0，接着第二阶段依次为他们赋值。对 INSTANCE 赋值时要调用 Price(2.8),创建Price实例，为currentPrice赋值，此时，还未对 initPrice 赋值，就是用他的默认值0，则 currentPrice 值为-2.8，接着程序再次将 initPrice 赋值为20，但对于 currentPrice 实例变量已经不起作用了。</p><p>以下为在ide中的debug结果截图：</p><p><img src="/img/article_img/2016/对象内存分配-debug.png" alt></p><h2 id="2-父类构造器"><a href="#2-父类构造器" class="headerlink" title="2.父类构造器"></a>2.父类构造器</h2><p>java中，创建对象时，首先会依次调用每个父类的非静态初始化块、构造器（总是先从Object开始），然后再使用本类的非静态初始化块和构造器进行初始化。在调用父类时可以用<code>super</code>进行<strong>显示调用</strong>，也可以<strong>隐式调用</strong>。</p><p>在子类调用父类构造器时，有以下几种场景：</p><ul><li>子类构造器第一行代码是用<strong>super()</strong>进行显示调用父类构造器，则根据super传入的参数调用相应的构造器；</li><li>子类构造器第一行代码是用<strong>this()</strong>进行显示调用本类中重载的构造器，则根据传入this的参数调用相应的构造器；</li><li>之类构造器中没有this和super,则在执行子类构造器前，隐式调用父类无参构造器。</li></ul><blockquote><p>注：super和this都是显示调用构造器，只能在构造器中使用，且必须在第一行，只能使用它们其中之一，最多只能调用一次。</p></blockquote><p>一般情况下，子类对象可以访问父类的实例变量，但父类不能访问子类的，因为父类不知道它会被哪个子类继承，子类又会添加怎样的方法。但在极端的情况下，父类可以访问子类变量的情况，如下实例代码：</p><pre><code>package cn.imtianx.p02;class Base {    private int i = 2;    public Base() {        this.display();//this：运行时是Driver类型，编译时是Base 类型，这里是Driver对象    }    public void display() {        System.out.println(i);    }}// 继承Base的Derived子类class Derived extends Base {    private int i = 22;    public Derived() {        i = 222;    }    public void display() {        System.out.println(i);    }}public class Test {    public static void main(String[] args) {        // 创建Derived的构造器创建实例        new Derived();    }}</code></pre><p>上面的代码执行后，输出的并不是2、22或者222，而是<strong>0</strong>。在调用Derived 的构造器前会隐式调用Base的无参构造器，初始化 i= 2，此时如果输出<code>this.i</code>则为2，它访问的是Base 类中的实例变量，但是当调用<code>this.display()</code>时，表现的为Driver对象的行为，对于driver对象，它的变量i还未赋初始值，仅仅是为其开辟了内存空间，其值为0。</p><p><strong>在java 中，构造器负责实例变量的初始化（即，赋初始值），在执行构造器前，该对象内存空间已经被分配了，他们在内存中存的事其类型所对应的默认值。</strong></p><p><strong>在上面的代码中，出现了变量的编译时类型与运行时类型不同。通过该变量访问他所引用的对象的实例变量时，该实例变量的值由申明该变量的类型决定的，当通过该变量调用它所引用的实例对象的实例方法时，该方法将由它实际所引用的对象来决定</strong></p><p>当子类重写父类方法时，也会出现父类调用之类方法的情形，如下具体代码，通过上面的则很容易理解。</p><pre><code>class Animal{    private String desc;    public Animal()    {        this.desc = getDesc();           }    public String getDesc()    {        return &quot;Animal&quot;;    }    public String toString()    {        return desc;    }}public class Wolf extends Animal{    private String name;    private double weight;    public Wolf(String name , double weight)    {        this.name = name;        this.weight = weight;    }    // 重写父类的getDesc()方法    @Override    public String getDesc()    {        return &quot;Wolf[name=&quot; + name + &quot; , weight=&quot;            + weight + &quot;]&quot;;  //输出：Wolf[name=null , weight=0.0]    }    public static void main(String[] args)    {        System.out.println(new Wolf(&quot;灰太狼&quot; , 32.3));     }}</code></pre><h2 id="3-父子实例的内存控制"><a href="#3-父子实例的内存控制" class="headerlink" title="3.父子实例的内存控制"></a>3.父子实例的内存控制</h2><p>java中的继承，在处理成员变量和方法时是不同的。如果之类重写了父类的方法，则完全覆盖父类的方法，并将其其移到子类中，但如果是完全同名的实例变量，则不会覆盖，不会从父类中移到子类中。所以，对于一个引用类型的变量，如果访问他所引用对象的实例变量时，该实例变量的值取决于申明该变量的类型，而调用方法时，则取决于它实际引用对象的类型。</p><p>在继承中，内存中子类实例保存有父类的变量的实例。</p><pre><code>class Base {    int count = 2;}class Mid extends Base {    int count = 20;}public class Sub extends Mid {    int count = 200;    public static void main(String[] args) {        // 创建一个Sub对象        Sub s = new Sub();        // 将Sub对象向上转型后赋为Mid、Base类型的变量        Mid s2m = s;        Base s2b = s;        // 分别通过3个变量来访问count实例变量        System.out.println(s.count);    //输出：200        System.out.println(s2m.count);    //输出：20        System.out.println(s2b.count);    //输出：2    }}</code></pre><p>内存中的示意图：</p><p><img src="/img/article_img/2016/对象内存分配2.png" alt></p><p>在内存中只有一个Sub对象，并没有Mid和Base对象，但存在3个count的实例变量。</p><p><strong>子类中会隐藏父类的变量可以通过super来获取,对于类变量，也可以通过super来访问。</strong></p><h2 id="4-final-修饰符"><a href="#4-final-修饰符" class="headerlink" title="4.final 修饰符"></a>4.final 修饰符</h2><p>final 的修饰范围：</p><ul><li>修饰变量，被赋初始值后不可重新赋值；</li><li>修饰方法 ，不能被重写；</li><li>修饰类，不能派生出子类。</li></ul><p>对于final 类型的变量，初始化可以在：定义时、非静态代码块和构造器中；对于final 类型的类变量，初始化可以在：定义时和静态代码块中。</p><blockquote><p>当final类型的变量定义时就指定初始值，那么该该变量本质上是一个“宏变量”，编译器会把用到该变量的地方直接用其值替换。</p></blockquote><p>如果在内部内中使用局部变量，必须将其指定为final类型的。普通的变量作用域就是该方法，随着方法的执行结束，局部变量也随之消失，但内部类可能产生隐式的“闭包”，使局部变量脱离它所在的方法继续存在。内部内可能扩大局部变量的作用域，如果内部内中访问的局部变量没有适用final修饰，则可以随意修改它的值，这样将会引起混乱，所以编译器要求被内部访问的局部变量必须使用final 修饰。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
          <category> 高级知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 内存管理 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java知识 之 数组及其内存管理</title>
      <link href="/2016/11/17/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E6%95%B0%E7%BB%84%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2016/11/17/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E6%95%B0%E7%BB%84%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote><p>读书笔记：《疯狂java 程序员的基本修养》第一章——数组及其内存管理</p></blockquote><h2 id="1-数组初始化"><a href="#1-数组初始化" class="headerlink" title="1.数组初始化"></a>1.数组初始化</h2><p>数组是一个复合数据结构，当需要多个类型相同的变量时，可以定义数组惊醒使用。在java中，数组变量是一个引用类型的变量。<a id="more"></a><br>java 中的数组是<strong>静态的</strong>，即初始化后，它索占的内存空间、数组长度是不变的。而且必须先<strong>初始化</strong>后使用。</p><p><strong>数组的初始化方式：</strong></p><ul><li><p><strong>静态初始化：</strong>初始化是指定数组的元素的值，由系统决定其长度。</p><pre><code>String[] datas = new String[]{&quot;java&quot;,&quot;C++&quot;,&quot;html&quot;};</code></pre></li><li><p><strong>动态初始化:</strong>指定长度，由系统为数组元素分配初始值。</p><pre><code>String[] datas = new String[5];//指定长度为5，系统为每个元素指定初始值为null</code></pre><p>初始值分配规则：</p></li></ul><table><thead><tr><th style="text-align:left">数组类型</th><th style="text-align:center">初始化值</th></tr></thead><tbody><tr><td style="text-align:left">byte、short、long</td><td style="text-align:center">0</td></tr><tr><td style="text-align:left">float、double</td><td style="text-align:center">0.0</td></tr><tr><td style="text-align:left">char</td><td style="text-align:center">‘\u0000’</td></tr><tr><td style="text-align:left">boolean</td><td style="text-align:center">false</td></tr><tr><td style="text-align:left">引用类型（类、接口）</td><td style="text-align:center">null</td></tr></tbody></table><p><em>注：不要同时使用静态和动态初始化，即同时指定数组长度和元素初始值</em></p><h2 id="2-数组的内存分析"><a href="#2-数组的内存分析" class="headerlink" title="2.数组的内存分析"></a>2.数组的内存分析</h2><p>如下定义三个数组并初始化：</p><pre><code>//1.静态初始化一String[] books = new String[]{        &quot;疯狂java 讲义&quot;,        &quot;轻量级javaee企业应用实战&quot;,        &quot;疯狂ajax讲义&quot;,        &quot;疯狂XNL讲义&quot;};System.out.println(&quot;第一个数组的长度为：&quot; + books.length);// 4//2.静态初始化二String[] names = {        &quot;孙悟空&quot;,        &quot;猪八戒&quot;,        &quot;白骨精&quot;};System.out.println(&quot;第二个数组的长度为：&quot; + names.length);// 3//3.动态初始化String[] strArr = new String[5];System.out.println(&quot;第三个数组的长度为：&quot; + strArr.length); // 5</code></pre><p>上面采用两种静态和一种动态方式初始化数组，其长度分别为4、3、5，其内存分配如下：</p><p><img src="/img/article_img/2016/数组内存分配1.png" alt></p><p>数组变量存在栈区，数组对象存在堆内存，只能通过引用来访问堆内存中的数据。</p><p>数组一旦初始化完成后，其内存空间即分配结束，无法改变其长度，但可以修改其元素的值。但数组是一中引用类型的变量，他只是指向对内存中的数组对象，可以改变其引用，从而造成其长度可变的假象，如下：</p><pre><code>books = names;System.out.println(&quot;books数组的长度为：&quot; + books.length);strArr = names;System.out.println(&quot;strArr数组的长度为：&quot; + strArr.length);books[1] = &quot;唐僧&quot;;System.out.println(&quot;snames的第三个元素：&quot; + books[1]);</code></pre><blockquote><p>输出结果为：<br>books数组的长度为：3<br>strArr数组的长度为：3<br>strArr数组的长度为：唐僧</p></blockquote><p>books原本长度为4，现在打印出来的是3，这里只是其引用变了导致的，原来books变量引用的数组长度依然是4，只是没有任何引用了，将会被GC回收。内存变化如下：</p><p><img src="/img/article_img/2016/数组内存分配2.png" alt></p><p><strong>java 中的数组变量只是引用变量，他并不是数组的本身，只要让数组变量指向有效的数组对象，即可使用该数组变量.</strong></p><pre><code> int[] nums = new int[]{3,5,20,12};int[] prices;prices = nums;//prices 未初始化，但将其指向nums所引用的数组for (int i = 0; i &lt; prices.length; i++) {    System.out.println(prices[i]);}//为prices第三个元素赋值prices[2] = 34;System.out.println(&quot;nums数组第三个元素为：&quot;+nums[2]);//输出34</code></pre><p>prices数组并没有初始化，但可以使用，执行<code>prices = nums;</code>后，他们指向相同的数组对象，是等价的，因此，修改prices的数组元素值，nums的也会随之改变。<strong>对于数组，只要让其指向有效的数组对象，即可使用该变量。</strong></p><blockquote><p>注意： 引用变量本质上是一个指针，只要通过引用变量访问属性或调用方法，该引用变量就会由它所引用的对象替换。</p></blockquote><h2 id="3-引用类型数组初始化"><a href="#3-引用类型数组初始化" class="headerlink" title="3.引用类型数组初始化"></a>3.引用类型数组初始化</h2><p>引用类型的数组元素依然是一用类型的，它存储的是引用，指向另一块内存，该内存中存储了引用变量所引用的对象（包括数组和java对象）。</p><p>定义一个Person类，用于定义改类型的数组：</p><pre><code>public class Person {    public int age;    public double height;    public void printInfo() {        System.out.println(&quot;年龄是：&quot; + age + &quot;, 身高是：&quot; + height);    }}</code></pre><p>定义person数组：</p><pre><code>Person[] students;students = new Person[2];System.out.println(&quot;students数组长度：&quot; + students.length);Person zhang = new Person();zhang.age = 12;zhang.height = 158;Person lee = new Person();lee.age = 16;lee.height = 161;students[0] = zhang;students[1] = lee;//lee和students[1]指向同一个person的实例，以下两句执行效果一样lee.printInfo();students[1].printInfo();</code></pre><p>上述数组内存分配图：</p><p><img src="/img/article_img/2016/数组内存分配3.png" alt></p><p>student数组的两个元素相当于两个引用，分别指向zhang和lee,lee和studentd[1]是指到同一个对象的，同一块内存，有相同的效果。</p><h2 id="4-数组的使用"><a href="#4-数组的使用" class="headerlink" title="4.数组的使用"></a>4.数组的使用</h2><p>当定义一个数组，初始化后就相当于定义了多个相同类型的变量。通过索引使用数组元素时，可将其作为普通变量的使用。</p><pre><code>class Cat{    double weight;    int age;    public Cat(double weight , int age)    {        this.weight = weight;        this.age = age;    }}public class ArrayTest{    public static void main(String[] args)    {        // 定义，并动态初始化一个int[]数组        int[] pos = new int[5];        // 采用循环为每个数组元素赋值        for (int i = 0; i &lt; pos.length ; i++ )        {            pos[i] = (i + 1) * 2;        }        // 对于pos数组的元素来说，用起来完全等同于普通变量        // 下面即可将数组元素的值赋给int变量，        // 也可将int变量的值赋给数组元素        int a = pos[1];        int b = 20;        pos[2] = b;                     // 定义，并动态初始化一个Cat[]数组        Cat[] cats = new Cat[2];        cats[0] = new Cat(3.34, 2);        // 将cats数组的第1个元素的值赋给c1。        Cat c1 = cats[0];        Cat c2 = new Cat(4.3, 3);        // 将c2的值赋给cats数组的第2个元素        cats[1] = c2;                 }}</code></pre><p>上述代码中，相关的内存分配图示意图：</p><p><img src="/img/article_img/2016/数组内存分配4.png" alt></p><h2 id="5-多维数组"><a href="#5-多维数组" class="headerlink" title="5.多维数组"></a>5.多维数组</h2><p>对于 <code>int</code>类型，添加 <code>[]</code>后就是一个数组类型，若以<code>int[]</code>类型为已有类型，则增加一个<code>[]</code>,<code>int[][]</code>，也是一个数组类型。因此，所谓的多维数组，其数组元素依然是一个数组，即N维数组，是数组元素为N-1维数组的一维数组。<br>如下示例：</p><pre><code>int[][] a = new int[4][];a[0] = new int[2];a[0][1] = 6;</code></pre><p>内存空间分配图：</p><p><img src="/img/article_img/2016/数组内存分配5.png" alt></p><p>如果将其扩展成三维数组，则6所对应的数组元素指向两一个数组。</p><p><strong>多维数组的本质是一维数组。</strong></p>]]></content>
      
      <categories>
          
          <category> java </category>
          
          <category> 高级知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 内存管理 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>activity 生命周期及调用栈详解</title>
      <link href="/2016/11/08/activity%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E8%B0%83%E7%94%A8%E6%A0%88%E8%AF%A6%E8%A7%A3/"/>
      <url>/2016/11/08/activity%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E8%B0%83%E7%94%A8%E6%A0%88%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><code>Activity</code>作为android四大组件之首，是我们是使用最频繁的组件，只有熟练的掌握其生命周期和启动模式，才能使我们在编程中进行合理的控制，在合适的生命周期处理相关的业务，开发出高质量的应用。下面具体的介绍下他的生命周期及启动模式。(<a href="https://developer.android.com/guide/components/activities.html" target="_blank" rel="noopener">android 官方文档-activity</a>)<br><a id="more"></a></p><h3 id="一、activity-的四种状态"><a href="#一、activity-的四种状态" class="headerlink" title="一、activity 的四种状态"></a>一、activity 的四种状态</h3><ol><li><strong>Active/Running</strong>（活动）<br>此时，activity 处于栈顶，可见，与用户进行交互。系统会不惜一切代价保护她的活跃性的，如果需要，会取消栈中靠下的activity来保证它所需要的资源。</li><li><strong>Paused</strong>（暂停）<br>当activity 失去焦点，被一个新的非全屏的activity 或者透明的activity放置在栈顶时，它会进入该状态。此时，它失去了与用户交互的能力，但所有的状态信息、成员变量都还保持着，只有在系统内存极低的情况下会被回收。</li><li><strong>Stopped</strong>（停止）<br>当一个activity 被完全覆盖，完全不可见时会进入此状态。但在系统内存中仍然保存着所有的状态和成员信息。当需要内存时，将直接回收。</li><li><strong>Kill</strong>（销毁）<br>当activity 被回收或者从来没有创建过，处于此状态。改状态的activity 会从activity栈中移除。<h3 id="二、activity-的生命周期"><a href="#二、activity-的生命周期" class="headerlink" title="二、activity 的生命周期"></a>二、activity 的生命周期</h3>如下如，展示activity的整个生命周期及其切换过程。<br><img src="/img/article_img/2016/activity生命周期.png" alt></li></ol><blockquote><p>说明：</p><ol><li>当一个activity 第一次启动，回调方法如下：<strong>onCreate</strong>-&gt;<strong>onStart</strong>-&gt;<strong>onResum</strong>.</li><li>用户打开新的activity或者切换到桌面，回调方法如下：<strong>onPause</strong>-&gt;<strong>onStop</strong>,如果新打开的activity 主题为<strong>透明的</strong>，则不会回调<strong>onStop</strong>。</li><li>用户再次回到原activity，毁掉过程如下：<strong>onRestart</strong>-&gt;<strong>onStart</strong>-&gt;<strong>onResume</strong>。</li><li>对于整个生命周期，onCreatehe onDestroy是配对的，他们标志着activity 的创建和销毁，并且只会调用一次；对于activity 是否可见，onStart和onStop是配对的，随着用户的操作或者屏幕的电量和熄灭，会被调用多次，但是该状态下不能与用户进行交互；从activity 是否在前台来说，onResume 和onPause 是配对的，他们也会被回调多次。</li><li>当前activity 页面打开新的activity，先执行原activity 的 onPause 方法，然后才会启动新activity 。</li></ol></blockquote><h3 id="三、异常情况下的生命周期"><a href="#三、异常情况下的生命周期" class="headerlink" title="三、异常情况下的生命周期"></a>三、异常情况下的生命周期</h3><ol><li><p>资源相关配置改变导致activity销毁并重建<br>对于横竖屏切换导致的activity异常销毁并重建，其创建过程如下图：<br><img src="/img/article_img/2016/activity异常重建.png" alt></p></li><li><p>资源内存不足导致低优先级activity 被杀死<br>优先级从搞到低课分为如下三种情况：</p></li></ol><ul><li>处于前台与用户交互的activity 的优先级最高；</li><li>可见但非前台activity，如弹出的对话框，导致activity可见但无法与用户进行交互；</li><li>后台activity（已被暂停的），如执行了onStop方法，优先级最低。</li></ul><p>当系统内存不足时，按照上面的优先级杀掉activity所在的进程。</p><p><strong>onSaveInstanceState (Bundle outState)</strong><br>当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，具体的有如下几种场景：<br>1、当用户按下HOME键时。<br>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</p><p>2、长按HOME键，选择运行其他的程序时。<br>3、按下电源按键（关闭屏幕显示）时。<br>4、从activity A中启动一个新的activity时。<br>5、屏幕方向切换时，例如从竖屏切换到横屏时。（如果不指定configchange属性） 在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行</p><p>总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用。</p><blockquote><p><strong>注意点</strong>：<br>1.布局中的每一个View默认实现了onSaveInstanceState()方法，这样的话，这个UI的任何改变都会自动的存储和在activity重新创建的时候自动的恢复。但是这种情况只有在你为这个UI提供了唯一的ID之后才起作用，如果没有提供ID，将不会存储它的状态。</p></blockquote><p>2.由于默认的onSaveInstanceState()方法的实现帮助UI存储它的状态，所以如果你需要覆盖这个方法去存储额外的状态信息时，你应该在执行任何代码之前都调用父类的onSaveInstanceState()方法（super.onSaveInstanceState()）。 既然有现成的可用，那么我们到底还要不要自己实现onSaveInstanceState()?这得看情况了，如果你自己的派生类中有变量影响到UI，或你程序的行为，当然就要把这个变量也保存了，那么就需要自己实现，否则就不需要。</p><blockquote><p>3.由于onSaveInstanceState()方法调用的不确定性，你应该只使用这个方法去记录activity的瞬间状态（UI的状态）。不应该用这个方法去存储持久化数据。当用户离开这个activity的时候应该在onPause()方法中存储持久化数据（例如应该被存储到数据库中的数据）。</p></blockquote><blockquote><p>4.onSaveInstanceState()如果被调用，这个方法会在onStop()前被触发，但系统并不保证是否在onPause()之前或者之后触发。</p></blockquote><p><strong>onRestoreInstanceState (Bundle outState)</strong><br>至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的。</p><p>onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。</p><p>另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。 还有onRestoreInstanceState在onstart之后执行。 至于这两个函数的使用，给出示范代码（留意自定义代码在调用super的前或后）：</p><pre><code>@Overridepublic void onSaveInstanceState(Bundle savedInstanceState) {        savedInstanceState.putBoolean(&quot;MyBoolean&quot;, true);        savedInstanceState.putDouble(&quot;myDouble&quot;, 1.9);        savedInstanceState.putInt(&quot;MyInt&quot;, 1);        savedInstanceState.putString(&quot;MyString&quot;, &quot;Welcome back to Android&quot;);        // etc.        super.onSaveInstanceState(savedInstanceState);}@Overridepublic void onRestoreInstanceState(Bundle savedInstanceState) {        super.onRestoreInstanceState(savedInstanceState);        boolean myBoolean = savedInstanceState.getBoolean(&quot;MyBoolean&quot;);        double myDouble = savedInstanceState.getDouble(&quot;myDouble&quot;);        int myInt = savedInstanceState.getInt(&quot;MyInt&quot;);        String myString = savedInstanceState.getString(&quot;MyString&quot;);}</code></pre><p><strong>onSaveInstanceState 方法只适用于保存保存一些临时性的状态，而 onPause 方法适用于数据的持久化保存。</strong></p><h3 id="四、activity-启动模式"><a href="#四、activity-启动模式" class="headerlink" title="四、activity 启动模式"></a>四、activity 启动模式</h3><p><strong>任务栈</strong>是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名。</p><p>在AndroidManifest中可以给声明的activity通过<strong>android:launchMode=”standard|singleInstance|singleTask|singleTop”</strong>属性指定设置如下四种启动的模式：<br><strong>standard</strong><br>默认的启动方式，每次都会创建新的实例，覆盖在原来的activity之上，可以被同时添加到多个任务栈中，并且每一个任务中可以有多个实例。（只有在该模式的activity 才可以使用startActivityForResult方法）<br><strong>singleTop</strong><br>若设置为该模式，在启动activity时，系统会判断当前栈顶的activity是否是要启动的activity，如果是则直接引用这个实例不创建新的，否则创建新的实例。<br><strong>singleTask</strong><br>与singleTop 类似，它是检测整个activity栈中是否存在当前需要启动的activity。如果存在，则将该activity置于栈顶，并销毁在它之上的activity（注：这是在一个app中）。<br>如果其他程序以singleTask模式来启动这个activity，将创建一个新的任务栈，该模式有<strong>clearTop</strong>效果。<br><strong>singleInstance</strong><br>该模式的使用和浏览器的工作原理类似。在多个程序访问浏览器时，如果浏览器没有打开，则打开，否则再当前打开的浏览器中访问。声明为这种模式的activity，会出现在一个新的任务栈中，而且该任务栈只有这一个activity。</p><h3 id="五、Fragment和activity的生命周期关系"><a href="#五、Fragment和activity的生命周期关系" class="headerlink" title="五、Fragment和activity的生命周期关系"></a>五、Fragment和activity的生命周期关系</h3><p>如下图：<br><img src="/img/article_img/2016/fragment_and_activity_lifecycle.jpg" alt></p><p>谷歌官方 fragment 的生命周期如下图：<br><img src="/img/article_img/2016/fragment-life.png" alt></p><blockquote><p>参考文献：<br>《Android 开发艺术探索》<br>《Android 群英传》<br>《深入解析 Android虚拟机》</p></blockquote>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> Activity </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【转】国内一线互联网公司内部面试题库(二)——android 篇</title>
      <link href="/2016/11/06/guo_nei_yi_xian_hu_lian_wang_gong_si_nei_bu_mian_shi_ti_ku_er_android/"/>
      <url>/2016/11/06/guo_nei_yi_xian_hu_lian_wang_gong_si_nei_bu_mian_shi_ti_ku_er_android/</url>
      <content type="html"><![CDATA[<p>本文转自：<a href="https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md" target="_blank" rel="noopener">国内一线互联网公司内部面试题库</a><br>国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库</p><p>熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。<br>下面是 android 部分<br><a id="more"></a></p><h4 id="1-数据库的操作类型有哪些，如何导入外部数据库？"><a href="#1-数据库的操作类型有哪些，如何导入外部数据库？" class="headerlink" title="1.数据库的操作类型有哪些，如何导入外部数据库？"></a><strong>1.数据库的操作类型有哪些，如何导入外部数据库？</strong></h4><p>把原数据库包括在项目源码的 res/raw </p><p>android系统下数据库应该存放在 /data/data/com.<em>.</em>（package name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录.</p><h4 id="2-是否使用过本地广播，和全局广播有什么差别？"><a href="#2-是否使用过本地广播，和全局广播有什么差别？" class="headerlink" title="2.是否使用过本地广播，和全局广播有什么差别？"></a><strong>2.是否使用过本地广播，和全局广播有什么差别？</strong></h4><p>因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。<br>不用担心别的应用伪造广播，造成安全隐患。<br>相比在系统内发送全局广播，它更高效。</p><h4 id="3-是否使用过intentService，作用是什么，AIDL解决了什么问题？-小米"><a href="#3-是否使用过intentService，作用是什么，AIDL解决了什么问题？-小米" class="headerlink" title="3.是否使用过intentService，作用是什么，AIDL解决了什么问题？(小米)"></a><strong>3.是否使用过intentService，作用是什么，AIDL解决了什么问题？</strong>(小米)</h4><p>生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt。</p><p>生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。</p><p>该服务提供了一个onBind()方法的默认实现，它返回null</p><p>提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。</p><p>AIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。<br>AIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。</p><h4 id="4-Activity、Window、View三者的差别，fragment的特点？（360）"><a href="#4-Activity、Window、View三者的差别，fragment的特点？（360）" class="headerlink" title="4.Activity、Window、View三者的差别，fragment的特点？（360）"></a><strong>4.Activity、Window、View三者的差别，fragment的特点？</strong>（360）</h4><p>Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）<br>LayoutInflater像剪刀，Xml配置像窗花图纸。</p><ol><li>在Activity中调用attach，创建了一个Window</li><li>创建的window是其子类PhoneWindow，在attach中创建PhoneWindow</li><li>在Activity中调用setContentView(R.layout.xxx)</li><li>其中实际上是调用的getWindow().setContentView()</li><li>调用PhoneWindow中的setContentView方法</li><li>创建ParentView：作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）</li><li>将指定的R.layout.xxx进行填充通过布局填充器进行填充【其中的parent指的就是DecorView】</li><li>调用到ViewGroup</li><li>调用ViewGroup的removeAllView()，先将所有的view移除掉</li><li>添加新的view：addView()</li></ol><p><strong>fragment 特点</strong></p><ul><li>Fragment可以作为Activity界面的一部分组成出现；</li><li>可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用；</li><li>在Activity运行过程中，可以添加、移除或者替换Fragment；</li><li>Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。</li></ul><h4 id="5-描述一次网络请求的流程（新浪）"><a href="#5-描述一次网络请求的流程（新浪）" class="headerlink" title="5.描述一次网络请求的流程（新浪）"></a><strong>5.描述一次网络请求的流程</strong>（新浪）</h4><p><img src="/img/article_img/2016/http.png" alt></p><h4 id="6-Handler、Thread和HandlerThread的差别（小米）"><a href="#6-Handler、Thread和HandlerThread的差别（小米）" class="headerlink" title="6.Handler、Thread和HandlerThread的差别（小米）"></a><strong>6.Handler、Thread和HandlerThread的差别</strong>（小米）</h4><p><a href="http://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p><p><a href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/" target="_blank" rel="noopener">http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/</a></p><p>从Android中Thread（java.lang.Thread -&gt; java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -&gt; java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。</p><p>android.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也是就HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。</p><h4 id="7-低版本SDK实现高版本api（小米）"><a href="#7-低版本SDK实现高版本api（小米）" class="headerlink" title="7.低版本SDK实现高版本api（小米）"></a><strong>7.低版本SDK实现高版本api</strong>（小米）</h4><p>自己实现或@TargetApi annotation</p><h4 id="8-Ubuntu编译安卓系统（百度）"><a href="#8-Ubuntu编译安卓系统（百度）" class="headerlink" title="8.Ubuntu编译安卓系统（百度）"></a><strong>8.Ubuntu编译安卓系统</strong>（百度）</h4><ol><li>进入源码根目录</li><li>. build/envsetup.sh</li><li>lunch</li><li>full(编译全部)</li><li>userdebug(选择编译版本)</li><li>make -j8(开启8个线程编译)</li></ol><h4 id="9-launch-mode应用场景（百度、小米、乐视）"><a href="#9-launch-mode应用场景（百度、小米、乐视）" class="headerlink" title="9.launch mode应用场景（百度、小米、乐视）"></a><strong>9.launch mode应用场景</strong>（百度、小米、乐视）</h4><p>standard，创建一个新的Activity。</p><p>singleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。</p><p>singleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。</p><p>注意:</p><ol><li>设置了”singleTask”启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在； 如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了”singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。</li><li>如果设置了”singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。</li><li>在一个任务栈中只有一个”singleTask”启动模式的Activity存在。他的上面可以有其他的Activity。这点与singleInstance是有区别的。</li></ol><p>singleInstance，回退栈中，只有这一个Activity，没有其他Activity。</p><p>singleTop适合接收通知启动的内容显示页面。</p><p>例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。</p><p>singleTask适合作为程序入口点。</p><p>例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p><p>singleInstance应用场景：</p><p>闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。</p><h4 id="10-touch-事件传递流程（小米）"><a href="#10-touch-事件传递流程（小米）" class="headerlink" title="10.touch 事件传递流程（小米）"></a><strong>10.touch 事件传递流程</strong>（小米）</h4><p><a href="http://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">http://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</a></p><h4 id="11-view绘制流程（百度）"><a href="#11-view绘制流程（百度）" class="headerlink" title="11.view绘制流程（百度）"></a><strong>11.view绘制流程</strong>（百度）</h4><p><a href="http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f" target="_blank" rel="noopener">http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f</a></p><h4 id="12-多线程（360）"><a href="#12-多线程（360）" class="headerlink" title="12.多线程（360）"></a><strong>12.多线程</strong>（360）</h4><ul><li>Activity.runOnUiThread(Runnable)</li><li>View.post(Runnable),View.postDelay(Runnable,long)</li><li>Handler</li><li>AsyncTask</li></ul><h4 id="13-线程同步（百度）"><a href="#13-线程同步（百度）" class="headerlink" title="13.线程同步（百度）"></a><strong>13.线程同步</strong>（百度）</h4><p><a href="http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more" target="_blank" rel="noopener">http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more</a></p><p><a href="http://www.juwends.com/tech/android/android-inter-thread-comm.html" target="_blank" rel="noopener">http://www.juwends.com/tech/android/android-inter-thread-comm.html</a></p><p>单例</p><pre><code>public class Singleton{private volatile static Singleton mSingleton;private Singleton(){}public static Singleton getInstance(){  if(mSingleton == null){\\A    synchronized(Singleton.class){\\C     if(mSingleton == null)      mSingleton = new Singleton();\\B      }    }    return mSingleton;  }}</code></pre><h4 id="14-什么情况导致内存泄漏（美团）"><a href="#14-什么情况导致内存泄漏（美团）" class="headerlink" title="14.什么情况导致内存泄漏（美团）"></a><strong>14.什么情况导致内存泄漏</strong>（美团）</h4><p>1.资源对象没关闭造成的内存泄漏</p><p>描述：<br>资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。<br>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。</p><p>2.构造Adapter时，没有使用缓存的convertView</p><p>描述：<br>以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：<br>public View getView(int position, ViewconvertView, ViewGroup parent)<br>来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看:<br>android.widget.AbsListView.java –&gt; voidaddScrapView(View scrap) 方法。<br>示例代码：</p><pre><code>public View getView(int position, ViewconvertView, ViewGroup parent) {View view = new Xxx(...); ... ... return view; } </code></pre><p>修正示例代码：</p><pre><code>public View getView(int position, ViewconvertView, ViewGroup parent) {View view = null; if (convertView != null) { view = convertView; populate(view, getItem(position)); ... } else { view = new Xxx(...); ... } return view; } </code></pre><p>3.Bitmap对象不在使用时调用recycle()释放内存</p><p>描述：<br>有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：</p><pre><code>/** Free up the memory associated with thisbitmap&#39;s pixels, and mark the bitmap as &quot;dead&quot;, meaning itwill throw an exception if getPixels() or setPixels() is called, and will drawnothing. This operation cannot be reversed, so it should only be called ifyou are sure there are no further uses for the bitmap. This is anadvanced call, and normally need not be called, since the normal GCprocess will free up this memory when there are no more references to thisbitmap. */ </code></pre><p>4.试着使用关于application的context来替代和activity相关的context</p><p>这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免<br>Android内存泄漏。</p><p>5.注册没取消造成的内存泄漏</p><p>一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。<br>比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。<br>但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。<br>虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。</p><p>6.集合中对象没清理造成的内存泄漏</p><p>我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。</p><h4 id="15-ANR定位和修正"><a href="#15-ANR定位和修正" class="headerlink" title="15.ANR定位和修正"></a><strong>15.ANR定位和修正</strong></h4><p>如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。</p><ul><li>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。</li><li>主线程中存在耗时的计算</li><li>主线程中错误的操作，比如Thread.wait或者Thread.sleep等<br>Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框</li><li>应用在5秒内未响应用户的输入事件（如按键或者触摸）</li><li>BroadcastReceiver未在10秒内完成相关的处理</li><li><p>Service在特定的时间内无法处理完成 20秒</p></li><li><p>使用AsyncTask处理耗时IO操作。</p></li><li>使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。</li><li>使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。</li><li>Activity的onCreate和onResume回调中尽量避免耗时的代码</li><li>BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。</li></ul><h4 id="16-什么情况导致oom（乐视、美团）"><a href="#16-什么情况导致oom（乐视、美团）" class="headerlink" title="16.什么情况导致oom（乐视、美团）"></a><strong>16.什么情况导致oom</strong>（乐视、美团）</h4><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html</a></p><p>1）使用更加轻量的数据结构<br>2）Android里面使用Enum<br>3）Bitmap对象的内存占用<br>4）更大的图片<br>5）onDraw方法里面执行对象的创建<br>6）StringBuilder</p><h4 id="17-Android-Service与Activity之间通信的几种方式"><a href="#17-Android-Service与Activity之间通信的几种方式" class="headerlink" title="17.Android Service与Activity之间通信的几种方式"></a><strong>17.Android Service与Activity之间通信的几种方式</strong></h4><ul><li>通过Binder对象</li><li>通过broadcast(广播)的形式</li></ul><h4 id="18-Android各个版本API的区别"><a href="#18-Android各个版本API的区别" class="headerlink" title="18.Android各个版本API的区别"></a><strong>18.Android各个版本API的区别</strong></h4><p><a href="http://blog.csdn.net/lijun952048910/article/details/7980562" target="_blank" rel="noopener">http://blog.csdn.net/lijun952048910/article/details/7980562</a></p><h4 id="19-Android代码中实现WAP方式联网（360）"><a href="#19-Android代码中实现WAP方式联网（360）" class="headerlink" title="19. Android代码中实现WAP方式联网（360）"></a><strong>19. Android代码中实现WAP方式联网</strong>（360）</h4><p><a href="http://blog.csdn.net/asce1885/article/details/7844159" target="_blank" rel="noopener">http://blog.csdn.net/asce1885/article/details/7844159</a></p><h4 id="20-如何保证service在后台不被kill"><a href="#20-如何保证service在后台不被kill" class="headerlink" title="20.如何保证service在后台不被kill"></a><strong>20.如何保证service在后台不被kill</strong></h4><p>一、onStartCommand方法，返回START_STICKY</p><ol><li><p>START_STICKY<br>在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。</p></li><li><p>START_NOT_STICKY<br>在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。</p></li><li><p>START_REDELIVER_INTENT<br>在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。</p></li></ol><p>二、提升service优先级</p><p>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p><p>三、提升service进程优先级</p><p>Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是:</p><ol><li>前台进程( FOREGROUND_APP)</li><li>可视进程(VISIBLE_APP )</li><li>次要服务进程(SECONDARY_SERVER )</li><li>后台进程 (HIDDEN_APP)</li><li>内容供应节点(CONTENT_PROVIDER)</li><li>空进程(EMPTY_APP)</li></ol><p>当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。</p><p>四、onDestroy方法里重启service</p><p>service +broadcast  方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；</p><p>五、Application加上Persistent属性</p><p>六、监听系统广播判断Service状态</p><p>通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。</p><h4 id="21-Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）"><a href="#21-Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）" class="headerlink" title="21.Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）"></a><strong>21.Requestlayout，onlayout，onDraw，DrawChild区别与联系</strong>（猎豹）</h4><p>requestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。<br>说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制<br>任何视图包括该调用者本身。</p><p>onLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局)</p><p>调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)</p><p>drawChild()去重新回调每个子视图的draw()方法</p><h4 id="22-invalidate-和postInvalidate-的区别及使用（百度）"><a href="#22-invalidate-和postInvalidate-的区别及使用（百度）" class="headerlink" title="22.invalidate()和postInvalidate() 的区别及使用（百度）"></a><strong>22.invalidate()和postInvalidate() 的区别及使用</strong>（百度）</h4><p><a href="http://blog.csdn.net/mars2639/article/details/6650876" target="_blank" rel="noopener">http://blog.csdn.net/mars2639/article/details/6650876</a></p><h4 id="23-Android动画框架实现原理"><a href="#23-Android动画框架实现原理" class="headerlink" title="23.Android动画框架实现原理"></a><strong>23.Android动画框架实现原理</strong></h4><p>Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。</p><h4 id="24-Android为每个应用程序分配的内存大小是多少？（美团）"><a href="#24-Android为每个应用程序分配的内存大小是多少？（美团）" class="headerlink" title="24.Android为每个应用程序分配的内存大小是多少？（美团）"></a><strong>24.Android为每个应用程序分配的内存大小是多少？</strong>（美团）</h4><p>android程序内存一般限制在16M，也有的是24M</p><h4 id="25-Android-View刷新机制（百度、美团）"><a href="#25-Android-View刷新机制（百度、美团）" class="headerlink" title="25.Android View刷新机制（百度、美团）"></a><strong>25.Android View刷新机制</strong>（百度、美团）</h4><p>由ViewRoot对象的performTraversals()方法调用draw()方法发起绘制该View树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。</p><p>调用流程 ：</p><p>mView.draw()开始绘制，draw()方法实现的功能如下：</p><ol><li>绘制该View的背景</li><li>为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框)          </li><li>调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)</li><li>调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。</li></ol><h4 id="26-LinearLayout对比RelativeLayout（百度）"><a href="#26-LinearLayout对比RelativeLayout（百度）" class="headerlink" title="26.LinearLayout对比RelativeLayout（百度）"></a><strong>26.LinearLayout对比RelativeLayout</strong>（百度）</h4><ol><li>RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure</li><li>RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。</li><li>在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。</li></ol><p>最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。</p><h4 id="27-优化自定义view（百度、乐视、小米）"><a href="#27-优化自定义view（百度、乐视、小米）" class="headerlink" title="27.优化自定义view（百度、乐视、小米）"></a><strong>27.优化自定义view</strong>（百度、乐视、小米）</h4><p>为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。</p><p>你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。</p><p>另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。</p><p>如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。</p><h4 id="28-ContentProvider（乐视）"><a href="#28-ContentProvider（乐视）" class="headerlink" title="28.ContentProvider（乐视）"></a><strong>28.ContentProvider</strong>（乐视）</h4><p><a href="http://blog.csdn.net/coder_pig/article/details/47858489" target="_blank" rel="noopener">http://blog.csdn.net/coder_pig/article/details/47858489</a></p><h4 id="29-fragment生命周期"><a href="#29-fragment生命周期" class="headerlink" title="29.fragment生命周期"></a><strong>29.fragment生命周期</strong></h4><p><img src="/img/article_img/2016/fragment-life.png" alt></p><h4 id="30-volley解析（美团、乐视）"><a href="#30-volley解析（美团、乐视）" class="headerlink" title="30.volley解析（美团、乐视）"></a><strong>30.volley解析</strong>（美团、乐视）</h4><p><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</a></p><h4 id="31-Android-Glide源码解析"><a href="#31-Android-Glide源码解析" class="headerlink" title="31.Android Glide源码解析"></a><strong>31.Android Glide源码解析</strong></h4><p><a href="http://www.lightskystreet.com/2015/10/12/glide_source_analysis/" target="_blank" rel="noopener">http://www.lightskystreet.com/2015/10/12/glide_source_analysis/</a><br><a href="http://frodoking.github.io/2015/10/10/android-glide/" target="_blank" rel="noopener">http://frodoking.github.io/2015/10/10/android-glide/</a></p><h4 id="32-Android-设计模式"><a href="#32-Android-设计模式" class="headerlink" title="32.Android 设计模式"></a><strong>32.Android 设计模式</strong></h4><p><a href="http://blog.csdn.net/bboyfeiyu/article/details/44563871" target="_blank" rel="noopener">http://blog.csdn.net/bboyfeiyu/article/details/44563871</a></p><h4 id="33-架构设计（搜狐）"><a href="#33-架构设计（搜狐）" class="headerlink" title="33.架构设计（搜狐）"></a><strong>33.架构设计</strong>（搜狐）</h4><p><img src="/img/article_img/2016/architucture.png" alt></p><p><a href="http://www.tianmaying.com/tutorial/AndroidMVC" target="_blank" rel="noopener">http://www.tianmaying.com/tutorial/AndroidMVC</a></p><h4 id="34-Android属性动画特性（乐视、小米）"><a href="#34-Android属性动画特性（乐视、小米）" class="headerlink" title="34.Android属性动画特性（乐视、小米）"></a><strong>34.Android属性动画特性</strong>（乐视、小米）</h4><p>如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。</p><p>注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。</p><p>然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。</p><p>最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。</p>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【转】国内一线互联网公司内部面试题库(一)——java篇</title>
      <link href="/2016/11/05/guo_nei_yi_xian_hu_lian_wang_gong_si_nei_bu_mian_shi_ti_ku_yi_java/"/>
      <url>/2016/11/05/guo_nei_yi_xian_hu_lian_wang_gong_si_nei_bu_mian_shi_ti_ku_yi_java/</url>
      <content type="html"><![CDATA[<p>本文转自：<a href="https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md" target="_blank" rel="noopener">国内一线互联网公司内部面试题库</a><br>国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库</p><p>熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。<br>下面是java 部分<br><a id="more"></a></p><h4 id="1-接口的意义（百度）"><a href="#1-接口的意义（百度）" class="headerlink" title="1.接口的意义（百度）"></a><strong>1.接口的意义</strong>（百度）</h4><p>规范、扩展、回调</p><h4 id="2-抽象类的意义（乐视）"><a href="#2-抽象类的意义（乐视）" class="headerlink" title="2.抽象类的意义（乐视）"></a><strong>2.抽象类的意义</strong>（乐视）</h4><p>为其子类提供一个公共的类型<br>封装子类中得重复内容<br>定义抽象方法，子类虽然有不同的实现 但是定义是一致的</p><h4 id="3-内部类的作用-百度，乐视"><a href="#3-内部类的作用-百度，乐视" class="headerlink" title="3.内部类的作用(百度，乐视)"></a><strong>3.内部类的作用</strong>(百度，乐视)</h4><ol><li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li><li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li><li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li><li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li><li>内部类提供了更好的封装，除了该外围类，其他类都不能访问</li></ol><h4 id="4-父类的静态方法能否被子类重写，为什么？（猎豹）"><a href="#4-父类的静态方法能否被子类重写，为什么？（猎豹）" class="headerlink" title="4.父类的静态方法能否被子类重写，为什么？（猎豹）"></a><strong>4.父类的静态方法能否被子类重写，为什么？</strong>（猎豹）</h4><p>不能</p><p>子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现.</p><h4 id="5-举1-2个排序算法，并使用java代码实现（美团）"><a href="#5-举1-2个排序算法，并使用java代码实现（美团）" class="headerlink" title="5.举1-2个排序算法，并使用java代码实现（美团）"></a><strong>5.举1-2个排序算法，并使用java代码实现</strong>（美团）</h4><p><a href="http://blog.csdn.net/qy1387/article/details/7752973" target="_blank" rel="noopener">http://blog.csdn.net/qy1387/article/details/7752973</a></p><h4 id="6-列举java的集合和继承关系（百度、美团）"><a href="#6-列举java的集合和继承关系（百度、美团）" class="headerlink" title="6.列举java的集合和继承关系（百度、美团）"></a><strong>6.列举java的集合和继承关系</strong>（百度、美团）</h4><p><img src="/img/article_img/2016/collection.png" alt></p><h4 id="7-java虚拟机的特性（百度、乐视）"><a href="#7-java虚拟机的特性（百度、乐视）" class="headerlink" title="7.java虚拟机的特性（百度、乐视）"></a><strong>7.java虚拟机的特性</strong>（百度、乐视）</h4><p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p><h4 id="8-哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）"><a href="#8-哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）" class="headerlink" title="8.哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）"></a><strong>8.哪些情况下的对象会被垃圾回收机制处理掉</strong>（乐视、美团、小米）</h4><p>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。</p><h4 id="9-进程和线程的区别（猎豹）"><a href="#9-进程和线程的区别（猎豹）" class="headerlink" title="9.进程和线程的区别（猎豹）"></a><strong>9.进程和线程的区别</strong>（猎豹）</h4><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。</p><p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p><p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。</p><h4 id="10-Java中-和equals的区别，equals和hashCode的区别（乐视）"><a href="#10-Java中-和equals的区别，equals和hashCode的区别（乐视）" class="headerlink" title="10.Java中==和equals的区别，equals和hashCode的区别（乐视）"></a><strong>10.Java中==和equals的区别，equals和hashCode的区别</strong>（乐视）</h4><p><a href="http://blog.csdn.net/tiantiandjava/article/details/46988461" target="_blank" rel="noopener">http://blog.csdn.net/tiantiandjava/article/details/46988461</a></p><h4 id="11-常见的排序算法时间复杂度（小米）"><a href="#11-常见的排序算法时间复杂度（小米）" class="headerlink" title="11.常见的排序算法时间复杂度（小米）"></a><strong>11.常见的排序算法时间复杂度</strong>（小米）</h4><p><img src="/img/article_img/2016/algorithm.png" alt></p><h4 id="12-HashMap的实现原理（美团）"><a href="#12-HashMap的实现原理（美团）" class="headerlink" title="12.HashMap的实现原理（美团）"></a><strong>12.HashMap的实现原理</strong>（美团）</h4><ol><li>HashMap概述：<br>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 </li><li>HashMap的数据结构：<br> 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</li></ol><p><img src="/img/article_img/2016/hashmap.jpg" alt></p><p>从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p><h4 id="13-java-状态机"><a href="#13-java-状态机" class="headerlink" title="13.java 状态机"></a><strong>13.java 状态机</strong></h4><p><a href="http://www.jdon.com/designpatterns/designpattern_State.htm" target="_blank" rel="noopener">http://www.jdon.com/designpatterns/designpattern_State.htm</a></p><h4 id="14-java中int-char-long各占多少字节数"><a href="#14-java中int-char-long各占多少字节数" class="headerlink" title="14.java中int char long各占多少字节数"></a><strong>14.java中int char long各占多少字节数</strong></h4><p>byte 位数 8 字节数 1</p><p>short 16 2</p><p>int 32 4</p><p>long 64 8</p><p>float 32 4</p><p>double 64 8</p><p>char 16 2</p><h4 id="15-java-int与integer的区别"><a href="#15-java-int与integer的区别" class="headerlink" title="15.java int与integer的区别"></a><strong>15.java int与integer的区别</strong></h4><p><a href="http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html" target="_blank" rel="noopener">http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html</a></p><h4 id="16-string-stringbuffer-stringbuilder-区别（小米、乐视、百度）"><a href="#16-string-stringbuffer-stringbuilder-区别（小米、乐视、百度）" class="headerlink" title="16.string stringbuffer stringbuilder 区别（小米、乐视、百度）"></a><strong>16.string stringbuffer stringbuilder 区别</strong>（小米、乐视、百度）</h4><p>String 字符串常量</p><p>StringBuffer 字符串变量（线程安全）</p><p>StringBuilder 字符串变量（非线程安全）</p><p>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</p><p>而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p><p>String S1 = “This is only a” + “ simple” + “ test”;</p><p>StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);<br>你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br> String S1 = “This is only a” + “ simple” + “test”; 其实就是：<br> String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：<br> String S2 = “This is only a”;<br>String S3 = “ simple”;<br>String S4 = “ test”;<br>String S1 = S2 +S3 + S4;<br>这时候 JVM 会规规矩矩的按照原来的方式去做</p><p>在大部分情况下 StringBuffer &gt; String</p><p>StringBuffer</p><p>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p><p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。</p><p>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p><p>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。</p><p>在大部分情况下 StringBuilder &gt; StringBuffer</p><p>java.lang.StringBuilder</p><p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同</p><h4 id="17-Java多态（乐视）"><a href="#17-Java多态（乐视）" class="headerlink" title="17.Java多态（乐视）"></a><strong>17.Java多态</strong>（乐视）</h4><p>Java多态性理解</p><p>Java中多态性的实现</p><p>什么是多态</p><p>面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。</p><p>多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p><p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实<br>际类型，根据其实际的类型调用其相应的方法。</p><p>多态的作用：消除类型之间的耦合关系。</p><p>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。<br>下面是多态存在的三个必要条件，要求大家做梦时都能背出来！</p><p>多态存在的三个必要条件<br>一、要有继承；<br>二、要有重写；<br>三、父类引用指向子类对象。</p><p> 多态的好处：</p><p>1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。</p><p>2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。</p><p>3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。</p><p>4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。</p><p>5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p><p>Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。</p><h4 id="18-什么导致线程阻塞（58、美团）"><a href="#18-什么导致线程阻塞（58、美团）" class="headerlink" title="18.什么导致线程阻塞（58、美团）"></a><strong>18.什么导致线程阻塞</strong>（58、美团）</h4><p>线程的阻塞</p><p>为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.</p><p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p><ol><li>sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。<br>典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。</li><li>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</li><li>yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.</li><li>wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</li></ol><p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。</p><p>上述的核心区别导致了一系列的细节上的区别。</p><p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p><p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p><p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。</p><p>关于 wait() 和 notify() 方法最后再说明两点：</p><p>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p><p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p><p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p><p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p><h4 id="19-抽象类接口区别（360）"><a href="#19-抽象类接口区别（360）" class="headerlink" title="19.抽象类接口区别（360）"></a><strong>19.抽象类接口区别</strong>（360）</h4><ol><li><p>默认的方法实现<br>抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现</p></li><li><p>实现<br>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。<br>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</p></li><li><p>构造器<br>抽象类可以有构造器<br>接口不能有构造器</p></li><li><p>与正常Java类的区别<br>除了你不能实例化抽象类之外，它和普通Java类没有任何区<br>接口是完全不同的类型</p></li><li><p>访问修饰符<br>抽象方法可以有public、protected和default这些修饰符<br>接口方法默认修饰符是public。你不可以使用其它修饰符。</p></li><li><p>main方法<br>抽象方法可以有main方法并且我们可以运行它<br>接口没有main方法，因此我们不能运行它。</p></li><li><p>多继承<br>抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。</p></li><li><p>速度<br>它比接口速度要快<br>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</p></li><li><p>添加新方法<br>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。<br>如果你往接口中添加方法，那么你必须改变实现该接口的类。</p></li></ol><h4 id="20-容器类之间的区别（乐视、美团）"><a href="#20-容器类之间的区别（乐视、美团）" class="headerlink" title="20.容器类之间的区别（乐视、美团）"></a><strong>20.容器类之间的区别</strong>（乐视、美团）</h4><p><a href="http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html" target="_blank" rel="noopener">http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html</a><br><a href="http://alexyyek.github.io/2015/04/06/Collection/" target="_blank" rel="noopener">http://alexyyek.github.io/2015/04/06/Collection/</a><br><a href="http://tianmaying.com/tutorial/java_collection" target="_blank" rel="noopener">http://tianmaying.com/tutorial/java_collection</a></p><h4 id="21-java-内部类（小米）"><a href="#21-java-内部类（小米）" class="headerlink" title="21.java 内部类（小米）"></a><strong>21.java 内部类</strong>（小米）</h4><p><a href="http://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3388487.html</a></p><p><strong>22.Java中hashmap和hashtable的区别</strong>（乐视、小米）</p><p><a href="http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html" target="_blank" rel="noopener">http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html</a></p><p><strong>23.ArrayMap VS HashMap</strong></p><p><a href="http://lvable.com/?p=217" target="_blank" rel="noopener">http://lvable.com/?p=217</a></p>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>天盾app项目总结</title>
      <link href="/2016/10/23/tiandun%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2016/10/23/tiandun%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>经过几个星期的努力，天盾app2.0版正式发布。再次记录下自己在开发中遇到的问题：</p><ol><li>拍照图片oom</li><li>listview 图片错位</li><li>xutils 数据库的使用与升级<a id="more"></a></li></ol><h3 id="1-拍照显示图片oom"><a href="#1-拍照显示图片oom" class="headerlink" title="1. 拍照显示图片oom"></a>1. 拍照显示图片oom</h3><p>由于该app中有快递单的采集，用RecyclerView 展示，并且每条可能需要拍照录入三张图片，这些图片需要显示并保存到文件便于上传。<br>目前，各个各个手机拍照后生成的图片比较大，分辨率也很高，直接显示很容易出现oom,使用BitmapFactory创建bitmap显示图片，每次使用都会分配内存，通过设置它的<strong>采样率</strong>，以避免。通过使用下面的工具类来加载图片：</p><pre><code>public class BitmapUtil {private static final boolean DEBUG = false;private static final String TAG = BitmapUtil.class.getSimpleName();private BitmapUtil() {    throw new Error(&quot;Do not need instantiate!&quot;);}/** * 图片压缩处理（使用Options的方法） * &lt;p/&gt; * @param reqWidth  目标宽度 * @param reqHeight 目标高度 */public static BitmapFactory.Options calculateInSampleSize(        final BitmapFactory.Options options, final int reqWidth,        final int reqHeight) {    // 源图片的高度和宽度    final int height = options.outHeight;    final int width = options.outWidth;    int inSampleSize = 1;    if (height &gt; 400 || width &gt; 450) {        if (height &gt; reqHeight || width &gt; reqWidth) {            // 计算出实际宽高和目标宽高的比率            final int heightRatio = Math.round((float) height                    / (float) reqHeight);            final int widthRatio = Math.round((float) width                    / (float) reqWidth);            // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高            // 一定都会大于等于目标的宽和高。            inSampleSize = heightRatio &lt; widthRatio ? heightRatio                    : widthRatio;        }    }    // 设置压缩比例    options.inSampleSize = inSampleSize;    options.inJustDecodeBounds = false;    return options;}/** * 获取一个指定大小的bitmap * * @param reqWidth  目标宽度 * @param reqHeight 目标高度 */public static Bitmap getBitmapFromFile(String pathName, int reqWidth,                                       int reqHeight) {    BitmapFactory.Options options = new BitmapFactory.Options();    options.inJustDecodeBounds = true;    BitmapFactory.decodeFile(pathName, options);    options = calculateInSampleSize(options, reqWidth, reqHeight);    return BitmapFactory.decodeFile(pathName, options);}}</code></pre><p>这里只列出了计算采样率和从文件中加载显示的方法，如需了解更多该工具，请<a href="https://github.com/l123456789jy/Lazy/blob/master/lazylibrary/src/main/java/com/github/lazylibrary/util/BitmapUtil.java" target="_blank" rel="noopener">点击此处查看</a><br>具体使用如下：</p><pre><code>int width = mImageView.getWidth();int height = mImageView.getHeight();//picPath 为图片存储路径mImageView.setImageBitmap(BitmapUtil.getBitmapFromFile(picPath, width, height));</code></pre><p>进过测试，连续拍照10多张并显示，内存的消耗物明显变化，大约有2M的多动，测试手机为Nexus 6,至此，oom完美解决，性能也十分好。</p><h3 id="2-Listview-加载网络图片错位"><a href="#2-Listview-加载网络图片错位" class="headerlink" title="2. Listview 加载网络图片错位"></a>2. Listview 加载网络图片错位</h3><p>在app登陆前，需要选择相应的快递和分部，而快递列表的设计是显示快递图片和快递公司名称，该部分数据是由网络获取的，展示在listView中。当图片地址为空时，无图片的item就会显示其他的图片，而且随着屏幕的滚动而变化，出现错位的现象。这种情况<strong>主要是由于ListView适配器 中getView的convertView复用导致的，解决办法是为imageview设置tag标记，这里以图片的url作为标记。</strong>如下，getView的代码：</p><pre><code>@Overridepublic View getView(int position, View convertView, ViewGroup parent) {    ViewHolder holder;    if (convertView == null) {        convertView = LayoutInflater.from(parent.getContext())                .inflate(R.layout.list_item_express, parent, false);        holder = new ViewHolder(convertView);        convertView.setTag(holder);    } else {        holder = (ViewHolder) convertView.getTag();    }    String imgUrl = mDatas.get(position).getExpressIco();    holder.imgExpressIcon.setTag(imgUrl);    //这里注意图片地址的判断，被 &quot;&quot; 坑了好久    if (holder.imgExpressIcon.getTag() == null || holder.imgExpressIcon.getTag().equals(&quot;&quot;)) {        //若无网络图片，显示错误图片        holder.imgExpressIcon.setImageResource(R.drawable.express_error);    } else if (holder.imgExpressIcon.getTag().equals(imgUrl)) {        x.image().bind(holder.imgExpressIcon, Constants.BASE_URL + imgUrl);    }    holder.tvExpressName.setText(mDatas.get(position).getExpressName());    return convertView;}</code></pre><h3 id="3-xutils3-数据库的使用与升级"><a href="#3-xutils3-数据库的使用与升级" class="headerlink" title="3. xutils3 数据库的使用与升级"></a>3. xutils3 数据库的使用与升级</h3><p>为了节省流量，将采集的数据保存在本地，便于在wifi情况下同一上传，只有该功能需要数据库，加上项目中使用的有xutils，带有数据库模块，便没有自己写或者使用 GreenDao，Ralem等其他的数据库框架。<br>此处简单的记录下改数据库框架的使用。</p><ul><li><p>在Application中配置<br>在自己的application类（或者使用的activity）中添加配置信息，这里为了方便，在Application类中添加，并通过单利类访问使用。<br>如下部分代码：</p><pre><code>public class SNApplication extends Application {  private static DbManager.DaoConfig mDaoConfig = null;  /**   * 获取数据库配置对象   *   * @return   */  public static DbManager.DaoConfig getDaoConfig() {      if (mDaoConfig == null) {          mDaoConfig = new DbManager.DaoConfig()                  .setDbName(&quot;ygjexpress.db&quot;)                  .setDbVersion(2)                  .setDbOpenListener(new DbManager.DbOpenListener() {                      @Override                      public void onDbOpened(DbManager db) {                          // 开启WAL, 提升写入速度                          db.getDatabase().enableWriteAheadLogging();                      }                  })                  .setDbUpgradeListener(new DbManager.DbUpgradeListener() {                      @Override                      public void onUpgrade(DbManager db, int oldVersion, int newVersion) {                          //升级数据库                          try {                              //添加 user_id ，避免同一手机登陆多个账号出现数据混乱                              db.addColumn(PickupDbItem.class,&quot;user_id&quot;);                          } catch (DbException e) {                              e.printStackTrace();                          }                      }                  });      }      return mDaoConfig;  }}</code></pre></li><li><p>创建数据表对应的实体类<br>通过注解，来指定数据表名（Table）和字段名（Column），isId 指定是否为id,property设置是否唯一。</p><pre><code>@Table(name = &quot;pickup_item&quot;)public class PickupDbItem {  @Column(name = &quot;id&quot;, isId = true)  private int id;  @Column(name = &quot;sender_idcrad_id&quot;)  private String senderIdcradID;//身份证id  @Column(name = &quot;express_no&quot;)  private String expressNo;//快递编号  @Column(name = &quot;pic_bale_before&quot;)  private String picBaleBefore;//打包前  @Column(name = &quot;pic_bale_after&quot;)  private String picBaleAfter;//打包后图片  @Column(name = &quot;pic_bale_complete&quot;)  private String picBaleComplete;//贴快递单后图片  @Column(name = &quot;user_id&quot;)  private String userId; //当前登录的用户id //此处省略构造方法和getter和setter方法</code></pre></li><li><p>具体的使用</p><pre><code>//获取数据库配置private static DbManager mDbManager = x.getDb(SNApplication.getDaoConfig());//插入一条mDbManager.save(pickupDbItem);//查找-条pickupDbItem = mDbManager.selector(PickupDbItem.class)                      .where(&quot;express_no&quot;, &quot;=&quot;, expressNo)                      .findFirst();//查找所有mDbManager.selector(PickupDbItem.class).findAll();//更新三个字段mDbManager.update(pickupDbItem, &quot;sender_idcrad_id&quot;, &quot;pic_bale_before&quot;, &quot;pic_bale_after&quot;, &quot;pic_bale_complete&quot;);//删除mDbManager.delete(pickupDbItem);</code></pre><p>用法很简单，负责的查询条件可以使用<code>WhereBuilder</code>类来构造。更多的请参见<a href="https://github.com/imtianx/xUtils3/blob/master/sample/src/main/java/org/xutils/sample/DbFragment.java" target="_blank" rel="noopener">此处</a>。</p></li><li><p>数据库的升级</p></li></ul><p>在配置文件中<strong>增加版本号，在 setDbUpgradeListener 中的 onUpgrade 方法中添加或删除列，最后在实体中添加相应的字段即可</strong>。</p><p>项目比较小，遇到的问题也就这些，需要查看该app的，请访问<a href="https://www.pgyer.com/ygjexpress" target="_blank" rel="noopener">内测平台</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拍照oom </tag>
            
            <tag> 图片错位 </tag>
            
            <tag> xutils3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android studio 生成aar和jar</title>
      <link href="/2016/10/20/android%20studio%20%E7%94%9F%E6%88%90aar%E5%92%8Cjar/"/>
      <url>/2016/10/20/android%20studio%20%E7%94%9F%E6%88%90aar%E5%92%8Cjar/</url>
      <content type="html"><![CDATA[<h3 id="1-aar包"><a href="#1-aar包" class="headerlink" title="1. aar包"></a>1. aar包</h3><p><strong>aar</strong>包是android studio 下打包android 工程中的src、res、lib后生成的aar文件，以便导入到其他的as工程中使用。<br>在as中它的生成方式较为简单，主要步骤如下：</p><blockquote><p>1.新建model，选择 android Library；<br>2.编写好自己的代码后，将gradle中的 <strong>minifyEnabled</strong>属性 设置成<strong>true</strong><a id="more"></a>，重新build下项目（<strong>Build-&gt;Rebuild Project</strong>,或者使用gradle中的build 命令）<br>3.将as的项目调节为project,进入model下，在<strong>build/outputs/aar/</strong>文件夹下会生成相应的aar文件，如下图：</p></blockquote><p><img src="/img/article_img/2016/show_aar.png" alt></p><h3 id="2-jar包"><a href="#2-jar包" class="headerlink" title="2. jar包"></a>2. jar包</h3><p>在as中，不像ec那样可以直接导出jar,需要在gradle 中编写task,主要步骤：</p><blockquote><p>1.新建model 选择 Java Library，<br>2.先写自己的代码<br>3.在当前model 的gradle 中添写如下代码，<strong>rebuid后便会在build/libs下生成相应的jar</strong></p><pre><code>//Copy类型task makeJar(type: Copy) {    //删除存在的    delete &#39;build/libs/javajarlib.jar&#39;    //设置拷贝的文件    from(&#39;build/intermediates/bundles/release/&#39;)    //打进jar包后的文件目录    into(&#39;build/libs/&#39;)    //include ,exclude参数来设置过滤    include(&#39;classes.jar&#39;)    //重命名    rename(&#39;classes.jar&#39;, &#39;javajarlib.jar&#39;)}makeJar.dependsOn(build)</code></pre><p>但是这种方法，生成的jar是和改model 的名字一样的，即使在上面指定了名字。</p></blockquote><h3 id="3-具体使用"><a href="#3-具体使用" class="headerlink" title="3. 具体使用"></a>3. 具体使用</h3><p>在具体的model中使用时，将生成的相应的包拷贝到libs文件夹中，对于jar可以右键 添加到library中，或者手动在 gradle 中添加。而，对于aar,则只能在gradle中手动添加，如下配置代码：</p><pre><code>repositories{    flatDir{        dirs &#39;libs&#39;    }}//在dependencies 中添加，androidlibrary-release值aar包的名字compile(name:&#39;androidlibrary-release&#39;, ext:&#39;aar&#39;)</code></pre><p>通过上面的配置就可以直接在代码中使用了。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> aar </tag>
            
            <tag> jar </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 三大特性：封装、继承和多态</title>
      <link href="/2016/10/15/java%20%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"/>
      <url>/2016/10/15/java%20%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</url>
      <content type="html"><![CDATA[<p>最近项目上线，暂时稍微闲一点，来回顾下java的一些基础。回想下，也是大二上学的java，已经过去两年了，老师教的基本都是那些最基础的，如数据类型、运算符之类的，加上自己又没有好好学，基本算没学，也就后来转向android 的时候，用啥学啥，如集合、多线程和网络通信等等。下面整理下java面向对象的三大特性。</p><h3 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h3><p><strong>封装</strong>是把过程和数据包围起来，对数据的访问只能通过已定义的界面。<a id="more"></a><br>一般是把属性私有，对其的访问只提供<code>getter</code> 和 <code>setter</code> 方法。</p><h3 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h3><p><strong>继承</strong>可以理解为一个对象从另一个对象获取方法和属性的过程。常用的两个关键字为：<code>extends</code> 和 <code>implements</code>,他们决定了一个对象和另一个对象间是否是<strong>IS-A</strong>(是一个)的关系。<br>在Java中，类的继承是<strong>单一继承</strong>，也就是说，一个子类只能拥有一个父类。<br>注：java的类均是由 <code>java.lang.Object</code> 类继承而来的，上面说的一个父类并不包含Object,它并不需要显示的声明。<br><strong>extends</strong>关键字是用于 类直接的继承而<strong> implements</strong>是针对接口的。<br>类只能是单继承的，但是接口可以同时实现多个，也可以同时使用。如：</p><pre><code>public class A extends B implements  C,D {}</code></pre><p>注：在Java中，类的多重继承是不合法，但接口允许多重继承。</p><h3 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h3><p><strong>多态</strong>：同一个行为具有多个不同表现形式或形态的能力。它的必要条件：继承、重写、父类引用指向子类对象。<br>多态性具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p><h3 id="四、重写-Override-与重载-Overload"><a href="#四、重写-Override-与重载-Overload" class="headerlink" title="四、重写(Override)与重载(Overload)"></a>四、重写(Override)与重载(Overload)</h3><p><strong>重写</strong> ：是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。他的好处在于子类可以根据需要，定义特定于自己的行为。</p><p><strong>方法的重写规则</strong></p><ol><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ol><p><strong>Super</strong>：当需要在子类中调用父类的被重写方法时，要使用super关键字。</p><p><strong>重载</strong>：是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<br>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p><strong>重载的重写规则</strong></p><ol><li>被重载的方法必须改变参数列表；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li></ol><p><strong>重写与重载之间的区别</strong><br>| 区别点        | 方法重载   |  方法重写  |<br>| ——–   | :—–:  | :—-:  |<br>| 参数列表     |     必须修改 |   不能修改     |<br>| 返回类型        |   可以修改   |   不能修改   |<br>| 异常        |    可以修改    |  可减少或删除，不能抛出新的或者更广的异常  |<br>| 访问 | 可以修改|可以降低访问限制|</p><h3 id="五、接口（interface）"><a href="#五、接口（interface）" class="headerlink" title="五、接口（interface）"></a>五、接口（interface）</h3><p><strong>接口：</strong>是抽象方法的集合。它并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。<br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><p><strong>接口的特性：</strong></p><ol><li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li><li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。</li><li>接口中的方法都是公有的。</li></ol><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键，与类不同的是他可以多重继承其他接口</p><pre><code>public  interface A  extends InterfaceB,InterfaceC{}</code></pre><p><strong>标记接口</strong>:没有任何方法和属性。起作用如下：</p><ul><li>建立一个公共的父接口；</li><li>向一个类添加数据类型。</li></ul>]]></content>
      
      <categories>
          
          <category> java </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Bluetooth 通信技术深入--聊天小应用</title>
      <link href="/2016/09/24/Android%20Bluetooth%20%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%85%A5--%E8%81%8A%E5%A4%A9%E5%B0%8F%E5%BA%94%E7%94%A8/"/>
      <url>/2016/09/24/Android%20Bluetooth%20%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%85%A5--%E8%81%8A%E5%A4%A9%E5%B0%8F%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>目前，市场上的大部分手机都带有蓝牙，尽管使用的不多，但作为开发者，我们还有必要了解其原理。最近的项目需要用到蓝牙技术，于是写了个 蓝牙的聊天小demo。</p><h3 id="1-效果示意图"><a href="#1-效果示意图" class="headerlink" title="1. 效果示意图"></a>1. 效果示意图</h3><p>这里需要两部手机进行测试。其中一部作为蓝牙服务器，另一部作为蓝牙客户端，进行通信。<a id="more"></a><br>客户端截图：<br><img src="/img/article_img/bluetooth/ble-client.gif" alt="client"><br>服务器截图：<br><img src="/img/article_img/bluetooth/ble-server.gif" alt="server"></p><h3 id="2-开发步骤"><a href="#2-开发步骤" class="headerlink" title="2.开发步骤"></a>2.开发步骤</h3><ol><li>开启蓝牙；</li><li>搜索蓝牙设备；</li><li>创建蓝牙socket，读取输出流；</li><li>读取和写入数据；</li><li>关闭连接和蓝牙。</li></ol><h3 id="3-具体的实现"><a href="#3-具体的实现" class="headerlink" title="3.具体的实现"></a>3.具体的实现</h3><h4 id="3-1-开启蓝牙"><a href="#3-1-开启蓝牙" class="headerlink" title="3.1 开启蓝牙"></a>3.1 开启蓝牙</h4><p>首先获取蓝牙适配器，若存在蓝牙未开则打开蓝牙，如下代码：</p><pre><code>BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();        if (mBluetoothAdapter == null) {            Toast.makeText(getActivity(), &quot;无蓝牙功能&quot;, Toast.LENGTH_SHORT).show();        } else {            if (!mBluetoothAdapter.isEnabled()) {                Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);                startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);            }        }</code></pre><h4 id="3-2-搜索蓝牙"><a href="#3-2-搜索蓝牙" class="headerlink" title="3.2 搜索蓝牙"></a>3.2 搜索蓝牙</h4><p>首先开启蓝牙搜索功能，然后通过注册广播，搜索蓝牙设备，搜索完成后将其加入到蓝牙列表。<br>搜索蓝牙：</p><pre><code>if (mBluetoothAdapter.isDiscovering()) {    mBluetoothAdapter.cancelDiscovery();    mBtnStartSearch.setText(&quot;重新搜索&quot;);} else {    mDatas.clear();    mAdapter.notifyDataSetChanged();    //添加设备信息到列表    init();}mBluetoothAdapter.startDiscovery();mBtnStartSearch.setText(&quot;ֹͣ停止搜索&quot;);</code></pre><p>注册蓝牙广播：</p><pre><code>/**     * 搜索设备广播     */private final BroadcastReceiver mReceiver = new BroadcastReceiver() {    @Override    public void onReceive(Context context, Intent intent) {        String action = intent.getAction();        if (BluetoothDevice.ACTION_FOUND.equals(action)) {            // 获得设备信息            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);            // 绑定的状态不一样则进行添加            if (device.getBondState() != BluetoothDevice.BOND_BONDED) {                mDatas.add(new BtInfo(device.getName(), device.getAddress(), false));                mAdapter.notifyDataSetChanged();                mListView.setSelection(mDatas.size() - 1);            }            // 搜索完成        } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) {            if (mListView.getCount() == 0) {                Toast.makeText(context, &quot;没有发现设备！&quot;, Toast.LENGTH_SHORT).show();            }            mBtnStartSearch.setText(&quot;重新搜索&quot;);        }    }}; /** * 注册广播 */private void registerBroadcast() {    //设备被发现广播    IntentFilter discoveryFilter = new IntentFilter(BluetoothDevice.ACTION_FOUND);    getActivity().registerReceiver(mReceiver, discoveryFilter);    // 设备发现完成    IntentFilter foundFilter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);    getActivity().registerReceiver(mReceiver, foundFilter);}</code></pre><h4 id="3-3-连接蓝牙设备"><a href="#3-3-连接蓝牙设备" class="headerlink" title="3.3 连接蓝牙设备"></a>3.3 连接蓝牙设备</h4><p>这里，使用listview展示蓝牙列表信息，item 的点击事件即为连接相应的蓝牙设备，点击某一项后跳转到会话页面，并通知他刷新信息，为方便，这里使用了EventBus来订阅事件，避免使用接口，如下listview 的item 的点击事件：</p><pre><code>//列表item设置监听，mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {    @Override    public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) {        BtInfo info = mDatas.get(i);        //好友mac地址        MainActivity.FRIEND_MAC_ADDRESS = info.getAddress();        //显示提示对话框        final AlertDialog.Builder dialog = new AlertDialog.Builder(getActivity());        dialog.setTitle(&quot;连接&quot;);        dialog.setMessage(&quot;名称：&quot; + info.getName() + &quot;\n&quot; + &quot;地址：&quot; + info.getAddress());        dialog.setPositiveButton(&quot;连接&quot;, new DialogInterface.OnClickListener() {            @Override            public void onClick(DialogInterface dialogInterface, int i) {                mBluetoothAdapter.cancelDiscovery();                mBtnStartSearch.setText(&quot;重新搜索&quot;);                //连接后，跳转到会话页面                MainActivity.mType = MainActivity.Type.CILENT;                //viewPager 显示第二页                MainActivity.mViewPager.setCurrentItem(1);                //通知 ChatListFragment 刷新信息                EventBus.getDefault().post(new EventMsg(1));                dialogInterface.dismiss();            }        });        dialog.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {            @Override            public void onClick(DialogInterface dialogInterface, int i) {                MainActivity.FRIEND_MAC_ADDRESS = &quot;&quot;;                dialogInterface.dismiss();            }        });        dialog.show();    }});</code></pre><h4 id="3-4-创建蓝牙socket"><a href="#3-4-创建蓝牙socket" class="headerlink" title="3.4 创建蓝牙socket"></a>3.4 创建蓝牙socket</h4><p>由于socketd的操作会阻塞线程，这里在子线程中进行创建。<br><code>BluetoothSocket</code> 客户端线程：</p><pre><code>// 客户端线程private class ClientThread extends Thread {    public void run() {        try {            mSocket = mDevice.createRfcommSocketToServiceRecord(UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));            Message msg = new Message();            msg.obj = &quot;请稍候，正在连接服务器:&quot; + MainActivity.FRIEND_MAC_ADDRESS;            msg.what = STATUS_CONNECT;            mHandler.sendMessage(msg);            mSocket.connect();            msg = new Message();            msg.obj = &quot;已经连接上服务端！可以发送信息。&quot;;            msg.what = STATUS_CONNECT_SUCCESS;            mHandler.sendMessage(msg);            // 启动接受数据            mReadThread = new ReadThread();            mReadThread.start();        } catch (IOException e) {            Message msg = new Message();            msg.obj = &quot;连接服务端异常！断开连接重新试一试。&quot;;            msg.what = STATUS_CONNECT_SUCCESS;            mHandler.sendMessage(msg);        }    }}</code></pre><p>创建蓝牙连接时需要用到<code>UUID</code>,如需查看更多UUID，请点击<a href="http://blog.csdn.net/txadf/article/details/52235851" target="_blank" rel="noopener">这里</a>。<br><code>BluetoothServerSocket</code>蓝牙服务端socket线程：</p><pre><code> // 服务器端线程private class ServerThread extends Thread {    public void run() {        try {            // 创建一个蓝牙服务器 参数分别：服务器名称、UUID            mServerSocket = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(&quot;btserver&quot;,                    UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));            Message msg = new Message();            msg.obj = &quot;请稍候，正在等待客户端的连接...&quot;;            msg.what = STATUS_CONNECT;            mHandler.sendMessage(msg);            /* 接受客户端的连接请求 */            mSocket = mServerSocket.accept();            msg = new Message();            msg.obj = &quot;客户端已经连接上！可以发送信息。&quot;;            msg.what = STATUS_CONNECT;            mHandler.sendMessage(msg);            // 启动接受数据            mReadThread = new ReadThread();            mReadThread.start();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>启动蓝牙客户端和服务端线程方法如下(详情参见<a href>类</a>的<code>onEventMainThread</code>方法)：</p><pre><code>if (MainActivity.mType == MainActivity.Type.CILENT) {    String address = MainActivity.FRIEND_MAC_ADDRESS;//蓝牙地址    if (!TextUtils.isEmpty(address)) {        mDevice = mBluetoothAdapter.getRemoteDevice(address);        mClientThread = new ClientThread();        mClientThread.start();        MainActivity.isOpen = true;    } else {        Toast.makeText(getActivity(), &quot;address is null !&quot;, Toast.LENGTH_SHORT).show();    }} else if (MainActivity.mType == MainActivity.Type.SERVER) {    mServerThread = new ServerThread();    mServerThread.start();    MainActivity.isOpen = true;}</code></pre><h4 id="3-5-读取和写入数据"><a href="#3-5-读取和写入数据" class="headerlink" title="3.5 读取和写入数据"></a>3.5 读取和写入数据</h4><p>这里主要是通过获取输入输出流来读取和发送数据，以读取数据为例，如下现读取数据线程代码：</p><pre><code>// 读取数据private class ReadThread extends Thread {    public void run() {        byte[] buffer = new byte[1024];        int bytes;        InputStream is = null;        try {            is = mSocket.getInputStream();            while (true) {                if ((bytes = is.read(buffer)) &gt; 0) {                    byte[] buf_data = new byte[bytes];                    for (int i = 0; i &lt; bytes; i++) {                        buf_data[i] = buffer[i];                    }                    String s = new String(buf_data);                    Message msg = new Message();                    msg.obj = s;                    msg.what = 1;                    mHandler.sendMessage(msg);                }            }        } catch (IOException e1) {            e1.printStackTrace();        } finally {            try {                is.close();            } catch (IOException e1) {                e1.printStackTrace();            }        }    }}</code></pre><p>发送消息与此类似，具体请参见 会话类 <a href></a>。</p><h4 id="3-6-关闭连接"><a href="#3-6-关闭连接" class="headerlink" title="3.6 关闭连接"></a>3.6 关闭连接</h4><p>主要是关闭各个线程和关闭socket。</p><p>至此，整个蓝牙同信已经完成，测试时需要两个手机，一个座位服务器，一个作为客户端，实现他们间的通信。</p><p><a href="https://github.com/imtianx/StudyDemoForAndroid/blob/master/A05-bluetoothchatdemo" target="_blank" rel="noopener">示例demo下载</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 蓝牙 </tag>
            
            <tag> 聊天 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Bluetooth 蓝牙技术初体验</title>
      <link href="/2016/09/20/Android%20Bluetooth%20%E8%93%9D%E7%89%99%E6%8A%80%E6%9C%AF%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2016/09/20/Android%20Bluetooth%20%E8%93%9D%E7%89%99%E6%8A%80%E6%9C%AF%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>转自：<a href="http://www.jb51.net/article/79334.htm" target="_blank" rel="noopener">http://www.jb51.net/article/79334.htm</a></p><h3 id="1-Bluetooth包简介"><a href="#1-Bluetooth包简介" class="headerlink" title="1.Bluetooth包简介"></a>1.Bluetooth包简介</h3><p>Android平台提供了一个android.bluetooth的包，里面实现蓝牙设备之间通信的蓝牙API。总共有8个类，常用的四个类如下:<br><strong>BluetoothAdapter类</strong><br>代表了一个本地的蓝牙适配器。它是所有蓝牙交互的入口点。利用它你可以发现其他蓝牙设备，查询绑定了的设备，使用已知的MAC地址实例化一个蓝牙设备和建立一个BluetoothServerSocket（作为服务器端）来监听来自其他设备的连接。<a id="more"></a><br><strong>BluetoothDevice类</strong><br>代表了一个远端的蓝牙设备，使用它请求远端蓝牙设备连接或者获取远端蓝牙设备的名称、地址、种类和绑定状态（其信息是封装在BluetoothSocket中）。<br><strong>BluetoothSocket类</strong><br>代表了一个蓝牙套接字的接口（类似于TCP中的套接字），它是应用程序通过输入、输出流与其他蓝牙设备通信的连接点。<br><strong>BlueboothServerSocket类</strong><br>代表打开服务连接来监听可能到来的连接请求（属于server端），为了连接两个蓝牙设备必须有一个设备作为服务器打开一个服务套接字。当远端设备发起连接连接请求的时候，并且已经连接到了的时候，BlueboothServerSocket类将会返回一个BluetoothSocket。</p><h3 id="2-常用类的使用"><a href="#2-常用类的使用" class="headerlink" title="2.常用类的使用"></a>2.常用类的使用</h3><p><strong>BluetoothAdapter：蓝牙适配器</strong></p><blockquote><p>cancelDiscovery()取消探索，当我们正在搜索设备的时候调用这个方法将不再继续搜索<br>disable()关闭蓝牙<br>enable()打开蓝牙，这个方法打开蓝牙不会弹出提示，更多的时候我们需要问下用户是否打开，以下两行代码同样是打开蓝牙，但会提示用户：<br>Intentenabler = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);<br>startActivity(enabler);<br>getAddress()获取本地蓝牙地址<br>getDefaultAdapter()获取默认BluetoothAdapter，实际上，也只有这一种方法获取BluetoothAdapter<br>getName()获取本地蓝牙名称<br>getRemoteDevice(String address)根据蓝牙地址获取远程蓝牙设备<br>getState()获取本地蓝牙适配器当前状态<br>isDiscovering()判断当前是否正在查找设备，是则返回true<br>isEnabled()判断蓝牙是否打开，已打开返回true，否则返回false<br>listenUsingRfcommWithServiceRecord(String name,UUID uuid)根据名称，UUID创建并返回BluetoothServerSocket，这是创建BluetoothSocket服务器端的第一步<br>startDiscovery()开始搜索，这是搜索的第一步</p></blockquote><p><strong>BluetoothDevice：远程蓝牙设备</strong></p><blockquote><p>createRfcommSocketToServiceRecord(UUIDuuid)根据UUID创建并返回一个BluetoothSocket，这个方法也是我们获取BluetoothDevice<br>的目的——创建BluetoothSocket<br>这个类其他的方法，如getAddress()、getName()等，同BluetoothAdapter。</p></blockquote><p><strong>BluetoothSocket：客户端</strong></p><blockquote><p>//这个类一共有6个方法<br>close()关闭<br>connect()连接<br>isConnected()判断是否连接<br>getInptuStream()获取输入流<br>getOutputStream()获取输出流<br>getRemoteDevice()获取BluetoothSocket指定连接的远程蓝牙设备</p></blockquote><p><strong>BluetoothServerSocket：服务端</strong></p><blockquote><p>//这个类一共有4个方法<br>accept()<br>accept(int timeout)<br>close()关闭<br>getChannel()返回这个套接字绑定的通道</p></blockquote><h3 id="3-数据传输"><a href="#3-数据传输" class="headerlink" title="3.数据传输"></a>3.数据传输</h3><p><strong>蓝牙数据传输——服务器端</strong></p><blockquote><p>、获得BluetoothAdapter。<br>2、通过BluetoothAdapter.listenUsingRfcommWithServiceRecord(name,UUID uuid)方法创建BluetoothServerSocket对象。<br>3、通过luetoothServerSocket.accept()方法返回一个BluetoothSocket对象。由于该方法处于阻塞状态，需要开启线程来处理。<br>4、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。<br>5、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。</p></blockquote><p><strong>蓝牙数据传输——客户端</strong></p><blockquote><p>1、获得BluetoothAdapter。<br>2、通过BluetoothAdapter.getRemoteDevice(String address)获得指定地址的BluetoothDevice对象。<br>3、通过BluetoothDevice.createRfcommSocketToServiceRecord (UUID uuid)方法创建BluetoothSocket对象。<br>4、通过BluetoothSocket.connect（）方法来连接蓝牙设备。<br>5、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。<br>6、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。</p></blockquote><p>需要的权限：</p><pre><code>&lt;uses-permissionandroid:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;&lt;uses-permissionandroid:name=&quot;android.permission.BLUETOOTH&quot; /&gt;</code></pre>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 蓝牙 </tag>
            
            <tag> 通信 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据绑定库DataBinding的使用</title>
      <link href="/2016/09/10/using-DataBinding/"/>
      <url>/2016/09/10/using-DataBinding/</url>
      <content type="html"><![CDATA[<p><code>Data Binding</code> 是谷歌提供的 android 数据绑定库，为了而方便开发者实现 MVVM 的架构模式，使用它可以避免我们写大量的<code>findViewByID</code>，降低代码的耦合性。<br><a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="noopener">官方介绍</a>(需翻墙)</p><h3 id="一、使用环境要求"><a href="#一、使用环境要求" class="headerlink" title="一、使用环境要求"></a>一、使用环境要求</h3><p>通过查看官方文档，改数据绑定库的使用环境要求如下：</p><ul><li>下载 SDK Manager 中的支持库： Support repository；<a id="more"></a></li><li>android studio 版本在1.3之后；</li><li>gradle 版本在1.5.0-alpha1之后；</li><li>android sdk在android 2.1（API level7 +）以后。</li></ul><h3 id="二、具体的使用"><a href="#二、具体的使用" class="headerlink" title="二、具体的使用"></a>二、具体的使用</h3><h4 id="2-1、配置-data-binding"><a href="#2-1、配置-data-binding" class="headerlink" title="2.1、配置 data binding."></a>2.1、配置 data binding.</h4><p>在 model 的gradle中的 <code>android</code> 节点下添加如下代码：</p><pre><code>dataBinding{    enabled = true}</code></pre><h4 id="2-2、-建立数据对象"><a href="#2-2、-建立数据对象" class="headerlink" title="2.2、 建立数据对象"></a>2.2、 建立数据对象</h4><p>添加一个POJO类，这里定义的是 User类，添加3个变量（uname，usex，uage）及相应的get,set方法，方便接下来与布局文件惊醒绑定。</p><h4 id="2-3、-修改布局文件"><a href="#2-3、-修改布局文件" class="headerlink" title="2.3、 修改布局文件"></a>2.3、 修改布局文件</h4><p>使用databinding后，布局文件根节点不在是简单的LinearLayout，RelativeLayout等ViewGroup,而是 <code>Layout</code>，同时还增加了 <code>data</code> 元素，来为ui控件提供数据。基本局如下：</p><pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;data&gt;    &lt;/data&gt;    &lt;!--原先的根节点--&gt;    &lt;LinearLayout&gt;    ....    &lt;/LinearLayout&gt;&lt;/layout&gt;</code></pre><p>下面简单举例说明，显示用户信息，包括用户名，性别和年龄，布局文件名为<code>activity_main</code>，使用 databinding 的布局代码如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;data&gt;        &lt;variable            name=&quot;user&quot;            type=&quot;cn.imtianx.databindingdemo.bean.User&quot;&gt;        &lt;/variable&gt;    &lt;/data&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@{user.uname}&quot;/&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@{user.usex}&quot;/&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@{user.uage}&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;</code></pre><p>该布局主要是三个TextView，来显示信息，在<code>data</code>标签中添加了变量<code>variable</code>,其中<code>name</code>是变量名,<code>type</code>使我们定义的java类（注：需要写完整的包名），通过<code>@{}</code>来为 TextView设置显示的文本。<br>此外，这里的<code>data</code>也可以用<code>import</code>进行导入，如下：</p><pre><code> &lt;data&gt;    &lt;import type=&quot;cn.imtianx.databindingdemo.bean.User&quot;/&gt;    &lt;variable        name=&quot;user&quot;        type=&quot;User&quot;/&gt;&lt;/data&gt;</code></pre><p>如果要使用<code>String</code>等<code>java.lang.*</code>下的类，则可以直接使用。</p><h4 id="2-4、绑定变量数据"><a href="#2-4、绑定变量数据" class="headerlink" title="2.4、绑定变量数据"></a>2.4、绑定变量数据</h4><p>编译项目即可根据布局文件名生成相关的Binding类，生成规则是按布局文件名，去掉’_‘，按驼峰法则，并在末尾添加<code>Binding</code>。如，这里的布局文件名为<code>activity_main</code>,则生成的数据绑定类为<code>ActivityMainBinding</code>，它存放在<code>包名.databinding</code>下，然后再 <strong>activity</strong>  的<strong>onCreate</strong>方法中设置变量，代码如如下：</p><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    ActivityMainBinding mainBinding = DataBindingUtil            .setContentView(this, R.layout.activity_main);    User user = new User(&quot;imtianx&quot;, &quot;男&quot;, &quot;20&quot;);    mainBinding.setUser(user);}</code></pre><p><strong>注意：</strong> 这里的 ActivityMainBinding 类会根据布局文件中的 variable 生成相应的 <code>set</code>方法。<br>至此，一个简单的数据绑定就实现了，运行程序，会依次显示user中设置的三个字段的值。</p><h3 id="三、设置见监听事件"><a href="#三、设置见监听事件" class="headerlink" title="三、设置见监听事件"></a>三、设置见监听事件</h3><p>这里可以通过两种方式进行绑定事件：<strong>方法引用</strong>和<strong>监听器引用</strong>。如下代码：</p><pre><code>public class Presenter {    public void onTextChanged(CharSequence s, int start, int before, int count) {        mUserBean.setName(s.toString());        mBinding.setUser(mUserBean);    }    public void onClick(View view) {        Toast.makeText(MainActivity.this, &quot;点击了名字&quot;, Toast.LENGTH_SHORT).show();    }    public void onClickListenerBinding(UserBean bean) {        Toast.makeText(MainActivity.this, bean.getSex(), Toast.LENGTH_SHORT).show();    }}</code></pre><p>使用时首先在xml的data标签下添加变量</p><pre><code>&lt;variable    name=&quot;presenter&quot;    type=&quot;cn.imtianx.databindingdemo.MainActivity.Presenter&quot;&gt;&lt;/variable&gt;</code></pre><h4 id="3-1-方法引用"><a href="#3-1-方法引用" class="headerlink" title="3.1 方法引用"></a>3.1 方法引用</h4><p>必须使用android 已有的监听的方法名及其参数，如上面的onTextChanged，onClick方法，具体的调用如下：</p><pre><code> android:onClick=&quot;@{presenter.onClick}&quot;</code></pre><h4 id="3-2-监听器引用"><a href="#3-2-监听器引用" class="headerlink" title="3.2 监听器引用"></a>3.2 监听器引用</h4><p>可以方便的丛xml中向java代码中传递数据，可使用lambda表达式,如onClickListenerBinding，具体调用如下：</p><pre><code>android:onClick=&quot;@{()-&gt;presenter.onClickListenerBinding(user)}&quot;</code></pre><p>采用了lambda表达式的格式。</p><h3 id="四、在Fragment中的用法"><a href="#四、在Fragment中的用法" class="headerlink" title="四、在Fragment中的用法"></a>四、在Fragment中的用法</h3><p>布局文件与上一个一样，在 Fragment 的 onCreateView 中设置相关的属性，具体代码如下：</p><pre><code>private ActivityMainBinding mMainBinding;    private User user;    @Nullable    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {        View view = inflater.inflate(R.layout.activity_main, container, false);        // 方式1,直接用默认生成的Binding类绑定        mMainBinding = ActivityMainBinding.bind(view);        // 方式2，向上转成ViewDataBinding类型//        ViewDataBinding viewDataBinding = ActivityMainBinding.bind(view);//        mMainBinding = (ActivityMainBinding) viewDataBinding;        //方式3，使用生成的Binding的inflater，//        mMainBinding = ActivityMainBinding.inflate(inflater);        //方式4，使用生成的Binding的inflater,类似Inflater api//        mMainBinding = ActivityMainBinding.inflate(inflater, container, false);        //方式5，某种情况无法生存默认Binding的情况下，并且把对应的layout传入//        ViewDataBinding viewDataBinding = DataBindingUtil.inflate(inflater, R.layout.activity_main, container, false);//        mMainBinding = (ActivityMainBinding) viewDataBinding;        //方式6，某种情况无法生存默认Binding的情况下//        ViewDataBinding viewDataBinding = DataBindingUtil.bind(view);        user = new User(&quot;imtianx&quot;, &quot;男&quot;, &quot;20&quot;);        mMainBinding.setUser(user);        return view;    }</code></pre><p>总之，它都需要初始化Binding类，初始化model类和数据绑定。</p><h3 id="五-、高级用法"><a href="#五-、高级用法" class="headerlink" title="五 、高级用法"></a>五 、高级用法</h3><h4 id="5-1-使用类方法"><a href="#5-1-使用类方法" class="headerlink" title="5.1. 使用类方法"></a>5.1. 使用类方法</h4><p>首先在布局文件的<code>data</code> 使用<code>import</code>导入方法所在的类的全路径，然后再选要的地方调用，具体使用和java一样。</p><h4 id="5-2-类型别名"><a href="#5-2-类型别名" class="headerlink" title="5.2. 类型别名"></a>5.2. 类型别名</h4><p>在开发中可能会遇到两个用名的类，如果在<code>data</code>下同时导入他们，改如何解决？这里不用担心，可以在<code>import</code>节点下添加<code>alias</code>属性,来区别。如下示例：</p><pre><code> &lt;data&gt;    &lt;import type=&quot;cn.imtianx.databindingdemo.bean.User&quot; alias=&quot;User1&quot;/&gt;    &lt;import type=&quot;cn.imtianx.databindingdemo.model.User&quot; /&gt;    &lt;variable        name=&quot;user&quot;        type=&quot;User1&quot;/&gt;    &lt;variable        name=&quot;user2&quot;        type=&quot;User&quot;/&gt;&lt;/data&gt;</code></pre><h4 id="5-3-Null-Coalescing-运算符"><a href="#5-3-Null-Coalescing-运算符" class="headerlink" title="5.3. Null Coalescing 运算符"></a>5.3. Null Coalescing 运算符</h4><p>这个和java中的三木表达式一样</p><pre><code>&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;@{user.uage ??user.uage}&quot;/&gt;</code></pre><p>它等价于：</p><pre><code>&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;@{user.uage!=null?user.uage:0}&quot;/&gt;</code></pre><h4 id="5-4-属性值"><a href="#5-4-属性值" class="headerlink" title="5.4. 属性值"></a>5.4. 属性值</h4><p>使用<code>@{}</code>在xml中使用java 中定义的一些属性值,如下给visibility 设置值，注意需要到如View类，</p><pre><code>&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:visibility=&quot;@{user.display? View.VISIBLE:View.GONE}&quot;    android:text=&quot;@{user.uage&quot;/&gt;</code></pre><h4 id="5-5-使用资源数据"><a href="#5-5-使用资源数据" class="headerlink" title="5.5. 使用资源数据"></a>5.5. 使用资源数据</h4><p>设置<code>padding</code>的值，需要的dime文件中添加largePadding和smallPadding的item。对于引用 <code>String、drawable</code>等资源类似。</p><pre><code> &lt;TextView    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:padding=&quot;@{user.display?(int)@dimen/largePadding : (int)@dimen/smallPadding}&quot;    android:text=&quot;@{user.uage}&quot;/&gt;</code></pre><h4 id="5-6-使用include"><a href="#5-6-使用include" class="headerlink" title="5.6. 使用include"></a>5.6. 使用include</h4><p>使用命名空间来传递variable，将当前 variable 的值传递给 include 进来 的布局中。<br>为 layout 添加命名空间：</p><pre><code>xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;</code></pre><p>在<code>include</code>中使用：</p><pre><code>&lt;include    layout=&quot;@layout/layout_user&quot;    bind:user=&quot;@{user}&quot;&gt;</code></pre><p>注意在 <code>layout_user.xml</code>中也要在 variable 中 定义添加 user 变量。</p><h4 id="5-7-使用表达式"><a href="#5-7-使用表达式" class="headerlink" title="5.7. 使用表达式"></a>5.7. 使用表达式</h4><p>java 中的表达式，在这里也是支持的，</p><ul><li>数学 + - / * %</li><li>字符串连接 +</li><li>逻辑 &amp;&amp; ||</li><li>二进制 &amp; | ^</li><li>一元运算 + - ! ~</li><li>移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li><li>比较 == &gt; &lt; &gt;= &lt;=</li><li>instanceof<br>….<br>Data Binding代码生成时自动检查是否为null来避免出现<code>null pointer exceptions</code>错误,<code>String</code> 类型默认值是<code>null</code> ,<code>int</code>类型默认值是 <code>0</code>，<code>boolean</code> 类型默认值是 <code>false</code>。</li></ul><h4 id="5-8-集合"><a href="#5-8-集合" class="headerlink" title="5.8. 集合"></a>5.8. 集合</h4><p>常用的集合：arrays、lists、sparse，lists以及maps，为了简便都可以使用<code>[]</code>来访问。注意,在使用泛型时<code>&lt;</code>需要转义，用<code>&amp;lt;</code>代替，否则会报错。</p><pre><code>&lt;data&gt;  &lt;import type=&quot;android.util.SparseArray&quot;/&gt;  &lt;import type=&quot;java.util.Map&quot;/&gt;  &lt;import type=&quot;java.util.List&quot;/&gt;  &lt;variable name=&quot;list&quot; type=&quot;List&amp;lt;String&gt;&quot;/&gt;  &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&amp;lt;String&gt;&quot;/&gt;  &lt;variable name=&quot;map&quot; type=&quot;Map&amp;lt;String, String&gt;&quot;/&gt;  &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;  &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;&lt;/data&gt;…android:text=&quot;@{list[index]}&quot;…android:text=&quot;@{sparse[index]}&quot;…android:text=&quot;@{map[key]}&quot;</code></pre><h4 id="5-9-Data对象（数据绑定）"><a href="#5-9-Data对象（数据绑定）" class="headerlink" title="5.9.Data对象（数据绑定）"></a>5.9.Data对象（数据绑定）</h4><p>Data Binding 的强大之处主要在于双向数据绑定，当POJO对象发生变化时，通知改变Data对象，已达到更新UI的效果。有三种不同的数据变化通知机制：<code>Observable</code>对象、<code>ObservableFields</code>以及<code>observable  collections</code>。<br>这里以 Observable 为例，更改User类。使其继承<code>BaseObservable</code>,在<code>getter</code>方法前添加<code>Bindable</code>注解，在<code>setter</code>方法中调用<code>notifyPropertyChanged</code>进行更新数据。如果只更新某一字段，只需将该字段设置为<code>ObservableFields</code>类型的，如boolean,可用ObservableBoolean代替，但对其的使用需要通过get和set方法。具体代码如下：</p><pre><code>public class User extends BaseObservable{    private String uname;    private String usex;    private String uage;    private boolean isDisplay;    public User() {    }    public User(String uname, String usex, String uage, boolean isDisplay) {        this.uname = uname;        this.usex = usex;        this.uage = uage;        this.isDisplay = isDisplay;    }    @Bindable    public String getUname() {        return uname;    }    public void setUname(String uname) {        this.uname = uname;        notifyPropertyChanged(BR.uname);    }    @Bindable    public String getUsex() {        return usex;    }    public void setUsex(String usex) {        this.usex = usex;        notifyPropertyChanged(BR.usex);    }    @Bindable    public String getUage() {        return uage;    }    public void setUage(String uage) {        this.uage = uage;        notifyPropertyChanged(BR.uage);    }    @Bindable    public boolean isDisplay() {        return isDisplay;    }    public void setDisplay(boolean display) {        isDisplay = display;        notifyPropertyChanged(BR.display);    }</code></pre><p>在编译期间，Bindable注解在BR(与R文件类似)类文件中生成一个Entry。BR类文件会在模块包内生成。如果用于Data类的基类不能改变，Observable接口通过方便的PropertyChangeRegistry来实现用于储存和有效地通知监听器。</p><p>Data Binding的基本用法已经介绍完了，但它 的使用知识点较多，暂且写到这里,对于它在ListView/RecyclerView中的用法、事件处理等稍后再做介绍。<br><br></p><p>文中部分资料来源于页底的参考资料。</p><blockquote><p>参考资料：</p><ol><li><a href="https://github.com/LyndonChin/MasteringAndroidDataBinding" target="_blank" rel="noopener">https://github.com/LyndonChin/MasteringAndroidDataBinding</a></li><li><a href="http://www.jianshu.com/p/b1df61a4df77" target="_blank" rel="noopener">http://www.jianshu.com/p/b1df61a4df77</a></li><li><a href="https://realm.io/cn/news/data-binding-android-boyar-mount/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://realm.io/cn/news/data-binding-android-boyar-mount/?utm_source=tuicool&amp;utm_medium=referral</a></li></ol></blockquote>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataBinding </tag>
            
            <tag> 数据绑定 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 异常捕获-UncaughtExceptionHandler</title>
      <link href="/2016/07/10/android-exception-catch-UncaughtExceptionHandler/"/>
      <url>/2016/07/10/android-exception-catch-UncaughtExceptionHandler/</url>
      <content type="html"><![CDATA[<p>在android开发中，异常信息的捕获有多种方式，比如第三方的友盟、蒲公英等，这里主要使用 android 原生的 Thread.UncaughtExceptionHandler 来捕获出现的异常信息<a id="more"></a>,并给出友好的提示，避免出现停止运行，提高用户体验，下面是具体的实现过程。</p><p><a href="http://blog.csdn.net/zly921112/article/details/51867079" target="_blank" rel="noopener">转自： Android 全局异常捕获</a></p><h2 id="1-定义自己的异常处理类"><a href="#1-定义自己的异常处理类" class="headerlink" title="1.定义自己的异常处理类"></a>1.定义自己的异常处理类</h2><p>  新建类 <em>CrashHandler</em> 实现 <em>Thread.UncaughtExceptionHandler</em>接口，如下代码：</p><pre><code>public class CrashHandler implements Thread.UncaughtExceptionHandler {    @Override    public void uncaughtException(Thread thread, Throwable ex) {    //回调函数，处理异常出现后的情况    }}</code></pre><h2 id="2-设置该异常类为系统默认的"><a href="#2-设置该异常类为系统默认的" class="headerlink" title="2.设置该异常类为系统默认的"></a>2.设置该异常类为系统默认的</h2><p>将上面定义的异常处理类设置为系统默认的异常处理类，当出现异常时，有该类处理。</p><pre><code>Thread.setDefaultUncaughtExceptionHandler(crashHandler);</code></pre><h2 id="3-具体的实现"><a href="#3-具体的实现" class="headerlink" title="3.具体的实现"></a>3.具体的实现</h2><p>为了方便查看和修复异常，这里将出现异常的手机信息和异常信息保存在文件，以便传给服务器，具体实现如下：</p><pre><code>import android.content.Context;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.os.Build;import android.os.Environment;import android.os.Looper;import android.util.Log;import android.widget.Toast;import java.io.File;import java.io.FileOutputStream;import java.io.PrintWriter;import java.io.StringWriter;import java.io.Writer;import java.lang.reflect.Field;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Map;/** * 异常管理类 * &lt;p/&gt; * Created by imtianx on 2016-7-10. */public class CrashHandler implements Thread.UncaughtExceptionHandler {    /**     * 系统默认UncaughtExceptionHandler     */    private Thread.UncaughtExceptionHandler mDefaultHandler;    /**     * context     */    private Context mContext;    /**     * 存储异常和参数信息     */    private Map&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;();    /**     * 格式化时间     */    private SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd-HH-mm-ss&quot;);    private String TAG = this.getClass().getSimpleName();    private static CrashHandler mInstance;    private CrashHandler() {    }    /**     * 获取CrashHandler实例     */    public static synchronized CrashHandler getInstance() {        if (null == mInstance) {            mInstance = new CrashHandler();        }        return mInstance;    }    public void init(Context context) {        mContext = context;        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();        //设置该CrashHandler为系统默认的        Thread.setDefaultUncaughtExceptionHandler(this);    }    /**     * uncaughtException 回调函数     */    @Override    public void uncaughtException(Thread thread, Throwable ex) {        if (!handleException(ex) &amp;&amp; mDefaultHandler != null) {            //如果自己没处理交给系统处理            mDefaultHandler.uncaughtException(thread, ex);        } else {            //自己处理            try {//延迟3秒杀进程                Thread.sleep(2000);            } catch (InterruptedException e) {                Log.e(TAG, &quot;error : &quot;, e);            }            //退出程序            AppManager.getAppManager().AppExit(mContext);        }    }    /**     * 收集错误信息.发送到服务器     *     * @return 处理了该异常返回true, 否则false     */    private boolean handleException(Throwable ex) {        if (ex == null) {            return false;        }        //收集设备参数信息        collectDeviceInfo(mContext);        //添加自定义信息        addCustomInfo();        //使用Toast来显示异常信息        new Thread() {            @Override            public void run() {                Looper.prepare();                //在此处处理出现异常的情况                Toast.makeText(mContext, &quot;程序开小差了呢..&quot;, Toast.LENGTH_SHORT).show();                Looper.loop();            }        }.start();        //保存日志文件        saveCrashInfo2File(ex);        return true;    }    /**     * 收集设备参数信息     *     * @param ctx     */    public void collectDeviceInfo(Context ctx) {        //获取versionName,versionCode        try {            PackageManager pm = ctx.getPackageManager();            PackageInfo pi = pm.getPackageInfo(ctx.getPackageName(), PackageManager.GET_ACTIVITIES);            if (pi != null) {                String versionName = pi.versionName == null ? &quot;null&quot; : pi.versionName;                String versionCode = pi.versionCode + &quot;&quot;;                paramsMap.put(&quot;versionName&quot;, versionName);                paramsMap.put(&quot;versionCode&quot;, versionCode);            }        } catch (PackageManager.NameNotFoundException e) {            Log.e(TAG, &quot;an error occured when collect package info&quot;, e);        }        //获取所有系统信息        Field[] fields = Build.class.getDeclaredFields();        for (Field field : fields) {            try {                field.setAccessible(true);                paramsMap.put(field.getName(), field.get(null).toString());            } catch (Exception e) {                Log.e(TAG, &quot;an error occured when collect crash info&quot;, e);            }        }    }    /**     * 添加自定义参数     */    private void addCustomInfo() {        Log.i(TAG, &quot;addCustomInfo: 程序出错了...&quot;);    }    /**     * 保存错误信息到文件中     *     * @param ex     * @return 返回文件名称, 便于将文件传送到服务器     */    private String saveCrashInfo2File(Throwable ex) {        StringBuffer sb = new StringBuffer();        for (Map.Entry&lt;String, String&gt; entry : paramsMap.entrySet()) {            String key = entry.getKey();            String value = entry.getValue();            sb.append(key + &quot;=&quot; + value + &quot;\n&quot;);        }        Writer writer = new StringWriter();        PrintWriter printWriter = new PrintWriter(writer);        ex.printStackTrace(printWriter);        Throwable cause = ex.getCause();        while (cause != null) {            cause.printStackTrace(printWriter);            cause = cause.getCause();        }        printWriter.close();        String result = writer.toString();        sb.append(result);        try {            long timestamp = System.currentTimeMillis();            String time = format.format(new Date());            String fileName = &quot;crash-&quot; + time + &quot;-&quot; + timestamp + &quot;.log&quot;;            if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {                String path = Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/crash/&quot;;                File dir = new File(path);                if (!dir.exists()) {                    dir.mkdirs();                }                FileOutputStream fos = new FileOutputStream(path + fileName);                fos.write(sb.toString().getBytes());                Log.i(TAG, &quot;saveCrashInfo2File: &quot;+sb.toString());                fos.close();            }            return fileName;        } catch (Exception e) {            Log.e(TAG, &quot;an error occured while writing file...&quot;, e);        }        return null;    }}</code></pre><p>注：在上述代码中使用了 AppManager类，是常用的activity 管理类 <a href="https://github.com/txadf/Android_Study_Notes/tree/master/android-tools/AppManager.md" target="_blank" rel="noopener">点此查看</a></p><h2 id="4-实际使用"><a href="#4-实际使用" class="headerlink" title="4.实际使用"></a>4.实际使用</h2><p>在application中初始化，并在配置文件中添加读写权限。</p><pre><code> CrashHandler.getInstance().init(this);</code></pre><p>到此，全局异常捕获已全部完成。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 异常捕获 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 开源库（字体图标，MD控件等）</title>
      <link href="/2016/06/12/android-open-source-connected/"/>
      <url>/2016/06/12/android-open-source-connected/</url>
      <content type="html"><![CDATA[<p>记录自己最近在开发中使用的开源库及部分使用方法，链接地址为个人fork后的地址，可以参见原作者仓库。本文将持续更新，大家有什么好用的可以留言，一起交流学习下。<br><a id="more"></a></p><h3 id="1-android-开发常用工具类"><a href="#1-android-开发常用工具类" class="headerlink" title="1. android 开发常用工具类"></a>1. android 开发常用工具类</h3><p>地址：<a href="https://github.com/txadf/Lazy" target="_blank" rel="noopener">https://github.com/txadf/Lazy</a></p><h3 id="2-字体图标"><a href="#2-字体图标" class="headerlink" title="2. 字体图标"></a>2. 字体图标</h3><p>地址：<a href="https://github.com/txadf/material-icon-lib" target="_blank" rel="noopener">https://github.com/txadf/material-icon-lib</a><br>用法：<br>2.1.添加依赖</p><pre><code>compile &#39;net.steamcrafted:materialiconlib:1.0.9&#39;</code></pre><p>2.2.xml中使用<br>注:需要添加命名空间</p><pre><code>&lt;net.steamcrafted.materialiconlib.MaterialIconView        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;        android:id=&quot;@+id/icon&quot;        android:layout_width=&quot;24dp&quot;        android:layout_height=&quot;24dp&quot;        android:scaleType=&quot;center&quot;        app:materialIcon=&quot;account&quot;        app:materialIconColor=&quot;@color/mainColor&quot;        app:materialIconSize=&quot;24dp&quot;/&gt;</code></pre><p>示例效果：<br><img src="https://camo.githubusercontent.com/802f5408fb1caeae9647d6e72c5905225b24220d/687474703a2f2f692e696d6775722e636f6d2f4b584866586f382e676966" alt></p><h3 id="3-UI-Model"><a href="#3-UI-Model" class="headerlink" title="3. UI Model"></a>3. UI Model</h3><p>地址：<a href="http://genius.qiujuer.net/module/ui.html" target="_blank" rel="noopener">http://genius.qiujuer.net/module/ui.html</a><br>按原作者网上站上的配置。<br>具体使用，按钮的使用：</p><pre><code>&lt;net.qiujuer.genius.ui.widget.Button            xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;            android:id=&quot;@+id/gbtn_login&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_marginTop=&quot;25dp&quot;            android:background=&quot;@color/mainColor&quot;            android:onClick=&quot;LoginClickEvent&quot;            android:text=&quot;@string/login_btn&quot;            android:textColor=&quot;@color/white&quot;            app:gFont=&quot;roboto.ttf&quot;            app:gTouchColor=&quot;@color/black_alpha_32&quot;            app:gTouchDurationRate=&quot;0.7&quot;            app:gTouchEffect=&quot;ripple&quot;/&gt;</code></pre><p>同样需要注意添加命名空间。</p><h3 id="4-xutils3"><a href="#4-xutils3" class="headerlink" title="4. xutils3"></a>4. xutils3</h3><p>地址：<a href="https://github.com/txadf/xUtils3" target="_blank" rel="noopener">https://github.com/txadf/xUtils3</a></p><h3 id="5-进度条"><a href="#5-进度条" class="headerlink" title="5.进度条"></a>5.进度条</h3><p>地址：<a href="https://github.com/txadf/spots-dialog" target="_blank" rel="noopener">https://github.com/txadf/spots-dialog</a><br>效果：<br><img src="https://camo.githubusercontent.com/d8108413298d70047f52cff9ac05603a5fd51988/687474703a2f2f332e62702e626c6f6773706f742e636f6d2f2d6c3155765657694d5341672f564c61355a6657346444492f41414141414141414e54632f7273576f755f71623042632f733332302f593648615453772e676966" alt></p><h3 id="6-对话框"><a href="#6-对话框" class="headerlink" title="6.对话框"></a>6.对话框</h3><p>地址:<a href="https://github.com/txadf/sweet-alert-dialog" target="_blank" rel="noopener">https://github.com/txadf/sweet-alert-dialog</a><br>示例效果：<br><img src="https://github.com/pedant/sweet-alert-dialog/raw/master/change_type.gif" alt></p><h3 id="7-EventBus"><a href="#7-EventBus" class="headerlink" title="7. EventBus"></a>7. EventBus</h3><p>地址：<a href="https://github.com/txadf/EventBus" target="_blank" rel="noopener">https://github.com/txadf/EventBus</a><br>注意：在使用，进行注册订阅时，使用下面的方式，其中“XXX”表示需要订阅的Activity或者Fragment名，避免直接使用“this”：</p><pre><code>EventBus.getDefault().register(XXX.this);</code></pre>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 开源库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 开源框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TabLayout+ViewPager创建tab</title>
      <link href="/2016/05/28/tablayout_viewpager_create_tab/"/>
      <url>/2016/05/28/tablayout_viewpager_create_tab/</url>
      <content type="html"><![CDATA[<p>在degingn库中有TabLayout控件，可以方便的实现tab切换的效果，配合ViewPager.<br><a id="more"></a><br>如下展示效果：<br><img src="/img/article_img/TabLayout+ViewPager-create-tab.gif" alt></p><h3 id="1-添加依design赖库"><a href="#1-添加依design赖库" class="headerlink" title="1. 添加依design赖库"></a>1. 添加依design赖库</h3><pre><code> compile &#39;com.android.support:design:23.4.0&#39;</code></pre><h3 id="2-编写主布局文件。"><a href="#2-编写主布局文件。" class="headerlink" title="2.编写主布局文件。"></a>2.编写主布局文件。</h3><p>使用TabLayout和ViewPager。TabLayout 有以下三个属性，方便我们设置tab的字体颜色，选中时字体的颜色及指示器的颜色：</p><pre><code>app:tabTextColor=&quot;@android:color/black&quot;app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;app:tabIndicatorColor=&quot;@color/colorPrimary&quot;</code></pre><p>具体的使用，如下代码：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    tools:context=&quot;cn.imtianx.tablayoutdemo.MainActivity&quot;&gt;    &lt;android.support.design.widget.TabLayout        android:id=&quot;@+id/tab&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;@android:color/white&quot;        app:tabIndicatorColor=&quot;@color/colorPrimary&quot;        app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;        app:tabTextColor=&quot;@android:color/black&quot;&gt;    &lt;/android.support.design.widget.TabLayout&gt;    &lt;android.support.v4.view.ViewPager        android:id=&quot;@+id/container&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;    &lt;/android.support.v4.view.ViewPager&gt;&lt;/LinearLayout&gt;</code></pre><h3 id="3-编写每个tab的布局。"><a href="#3-编写每个tab的布局。" class="headerlink" title="3. 编写每个tab的布局。"></a>3. 编写每个tab的布局。</h3><p>为了简单，根布局仅使用一个 LinearLayout 并给其背景设置了颜色。</p><h3 id="4-创建适配器"><a href="#4-创建适配器" class="headerlink" title="4. 创建适配器"></a>4. 创建适配器</h3><p>创建 FragmentAdapter类，继承FragmentPagerAdapter。</p><pre><code>/** * Created by imtianx on 2016-5-27. */public class FragmentAdapter extends FragmentPagerAdapter {    private List&lt;String&gt; mTitles; //标题    private List&lt;Fragment&gt; mFragments;//viewpager 显示的页面    public FragmentAdapter(FragmentManager fm, List&lt;String&gt; titles, List&lt;Fragment&gt; fragments) {        super(fm);        mTitles = titles;        mFragments = fragments;    }    @Override    public Fragment getItem(int position) {        return mFragments.get(position);    }    @Override    public int getCount() {        return mFragments.size();    }    /**     * tab 标题     *     * @param position     * @return     */    @Override    public CharSequence getPageTitle(int position) {        return mTitles.get(position);    }}</code></pre><h3 id="5-新建fragment页面"><a href="#5-新建fragment页面" class="headerlink" title="5. 新建fragment页面"></a>5. 新建fragment页面</h3><p>创建3个fragment，加载相应的布局。</p><h3 id="6-绑定控件"><a href="#6-绑定控件" class="headerlink" title="6.绑定控件"></a>6.绑定控件</h3><p>在MainActicity 中绑定控件，设置adapter。</p><pre><code>public class MainActivity extends AppCompatActivity {    List&lt;Fragment&gt; mFragmentList;    List&lt;String&gt; mTitles;    TabFragment1 mFragment1;    TabFragment2 mFragment2;    TabFragment3 mFragment3;    FragmentAdapter mAdapter;    private TabLayout mTabLayout;    private ViewPager mViewPager;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        initView();    }    private void initView() {        mTabLayout = (TabLayout) findViewById(R.id.tab);        mViewPager = (ViewPager) findViewById(R.id.container);        //添加标题        mTitles = new ArrayList&lt;&gt;();        mTitles.add(&quot;报价中&quot;);        mTitles.add(&quot;运输中&quot;);        mTitles.add(&quot;已完成&quot;);        //添加页面        mFragmentList = new ArrayList&lt;&gt;();        mFragment1 = new TabFragment1();        mFragment2 = new TabFragment2();        mFragment3 = new TabFragment3();        mFragmentList.add(mFragment1);        mFragmentList.add(mFragment2);        mFragmentList.add(mFragment3);        //初始化适配器        mAdapter = new FragmentAdapter(getSupportFragmentManager(),                mTitles, mFragmentList);        //设置适配器        mViewPager.setAdapter(mAdapter);        //加载viewpager        mTabLayout.setupWithViewPager(mViewPager);    }}</code></pre><h3 id="7-带icon的tab"><a href="#7-带icon的tab" class="headerlink" title="7. 带icon的tab"></a>7. 带icon的tab</h3><p>效果图如下：<br><img src="/img/article_img/TabLayout+ViewPager-create-tab_icon.gif" alt></p><ul><li>1.布局基本没有变，只是在上面的布局基础下，将ViewPager和TabLayout的上下位置调换下。添加如下属性将TabLayout的指示条高度设为0，不可见：<pre><code>app:tabIndicatorHeight=&quot;0dp&quot;</code></pre></li><li><p>2.为每个tab添加selector。以第一个tab为例，具体如下：<br><code>`</code><br>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p><selector xmlns:android="http://schemas.android.com/apk/res/android"><p>  <item android:drawable="@drawable/home_pressed" android:state_selected="true"></item></p>  <item android:drawable="@drawable/home_normal"></item></selector></li></ul><p></p><pre><code>- 3.IconTabActivity中将定义的selector设置为TabLayout的icon:</code></pre><p>mTabLayout.getTabAt(0).setIcon(getResources().getDrawable(R.drawable.tab_hall_bg));<br>mTabLayout.getTabAt(1).setIcon(getResources().getDrawable(R.drawable.tab_joined_bg));<br>mTabLayout.getTabAt(2).setIcon(getResources().getDrawable(R.drawable.tab_me_bg));<br><code>`</code></p><p>到此，已经完成了，TabLayout的使用和TabHost的使用类似，但它更为方便，使用起来较为简单。<br><a href="https://github.com/imtianx/StudyDemoForAndroid/blob/master/A03-tablayoutdemo" target="_blank" rel="noopener">Demo下载</a><br><br>注：demo中,不带icon:的是MainActivity，带icon的是IconTabActivity。可在AndroidManifest切换运行查看</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5.X新特性 </tag>
            
            <tag> TabLayout </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>属性动画详解（Animator）</title>
      <link href="/2016/04/25/Property-animatorValueAnimator_ObjectAnimation/"/>
      <url>/2016/04/25/Property-animatorValueAnimator_ObjectAnimation/</url>
      <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><p>对于之前介绍的Animation，它属于<strong>视图动画</strong>（View Animation）(可参见：<a href="http://imtianx.cn/2016/04/25/view-Animation/" target="_blank" rel="noopener">Animation 动画详解</a>)，包括<strong>补间动画</strong>（Tween Animation）和<strong>逐帧动画</strong>（Tween Animation）；而在android中还有另一种动画，那就是<strong>属性动画</strong>（Property Animator），它包括<strong>ValueAnimator</strong> 和 <strong>ObjectAnimator</strong>。<br><a id="more"></a><br>两者的<strong>区别</strong>：</p><ul><li>引入时间不同<br>视图动画在API Level 1 引入的，而属性动画在API Level 11（即 android 3.0）引入的； </li><li>所在包不同<br>视图动画在 <strong>android.view.animation.Animation</strong>包下，属性动画在：<strong>android.animation</strong>包下</li><li>动画类的命名不同<br>视图动画中类的名字为：<strong>XXXAnimation</strong>，而在属性动画中是：<strong>XXXAnimator</strong></li><li><strong>作用的对象不同</strong>（这个也是引入属性动画的原因）<br><strong>视图动画是对控件做动画，不能改变控件内部的属性，对所有的控件都可以；而属性动画是通过改变控件的属性来实现动画，但使用ObjectAnimator时要求作用的控件的属性要有get,set方法。如果控件的属性没有get/set方法，可以通过包装类间接的设置get/set方法，或者使用ValueAnimator 实现。</strong></li></ul><h1 id="2、ValueAnimator-的基本使用"><a href="#2、ValueAnimator-的基本使用" class="headerlink" title="2、ValueAnimator 的基本使用"></a>2、ValueAnimator 的基本使用</h1><p>ValueAnimator是动画的核心，但不提供任何动画效果，它更像一个数值发生器，产生具有一定规律的数字，然后让调用者来控制动画的实现过程。用法如下：</p><ul><li><p><strong>创建ValueAnimator实例</strong><br>例：创建0到500的动画，时间为1s:</p><pre><code>ValueAnimator animator = ValueAnimator.ofInt(0,500);  animator.setDuration(1000); </code></pre><p>代码中可以看出，它不与任何控件关联，只对动画做运算。</p></li><li><p><strong>添加它的监听事件</strong><br>下面是给它添加监听事件，实现动画的。</p><pre><code>animator.addUpdateListener(new ValueAnimator.                     AnimatorUpdateListener() {                 @Override                 public void onAnimationUpdate(ValueAnimator animation) {                     //具体处理动画逻辑                 }             });             //开启动画             animator.start();</code></pre><p>具体示例：<br>点击按钮使textView从(200,200)移动到（600，,600）</p><pre><code>btnStartAnim = (Button) findViewById(R.id.btn);tv = (TextView) findViewById(R.id.tv);btnStartAnim.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) {     //设置数据     ValueAnimator animator = ValueAnimator.ofInt(200, 600);     animator.setDuration(1000);     //监听动画     animator.addUpdateListener(new ValueAnimator.             AnimatorUpdateListener() {         @Override         public void onAnimationUpdate(ValueAnimator animation) {             //获取当前动画的值             int curValue = (int) animation.getAnimatedValue();             //设置tv的位置             tv.layout(curValue, curValue,                     curValue + tv.getWidth(),                     curValue + tv.getHeight());         }     });     //开启动画     animator.start(); }});</code></pre><p>示例效果：<br><img src="/img/article_img/ValueAnimator-simple-demo.gif" alt></p></li></ul><h1 id="3、ValueAnimator-常用方法"><a href="#3、ValueAnimator-常用方法" class="headerlink" title="3、ValueAnimator 常用方法"></a>3、ValueAnimator 常用方法</h1><pre><code>/*** 设置动画参数，参数类型为可变参数*/ValueAnimator ofInt(int... values);ValueAnimator ofFloat(int... values);/*** 设置动画时长，单位是毫秒*/ValueAnimator setDuration(long duration);/*** 获取 ValueAnimator 在运动时，当前运动点的值*/Object getAnimatedValue();/*** 开始动画*/void start();/*** 设置循环次数,设置为 INFINITE 表示无限循环*/void setRepeatCount(int value);/*** 设置循环模式* value 取值有 RESTART，REVERSE（分别为：重新开始，倒序重新开始）*/void setRepeatMode(int value);/*** 取消动画*/void cancel();</code></pre><p>通过源码，发现ofInt和ofFloat方法内部实现一样的，他们的区别在于传入的参数类型不同，需要注意的是在使用<strong>getAnimatedValue</strong>方法时，如果前面<strong>使用的是ofInt,要强转成int 类型</strong>，否则，转为float类型。<br>此外，如果不需要动画，可以调用移除动画监听方法，但需要先调用cancel方法取消动画。</p><h1 id="4、ObjectAnimator-的基本使用"><a href="#4、ObjectAnimator-的基本使用" class="headerlink" title="4、ObjectAnimator 的基本使用"></a>4、ObjectAnimator 的基本使用</h1><p>ObjectAnimator 类继承自ValueAnimator，使用时通过静态工厂类直接返回一个对象，参数包括对象和对象的属性名，但该属性必须要有get和set函数，这样可以真实的控制一个view的属性值，因此它基本可以实现所有的动画效果。<br>使用示例：<br>使textView的translationX从0变化到200在变化到500，持续时间为1s,代码如下：</p><pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(textView,            &quot;translationX&quot;,new float[]{200,500});    animator.setDuration(1000);    animator.start();</code></pre><p>ofFloat的参数：第一个是要操纵的View；第二个是要操纵的属性；第三个是参数，是一个可变数组。同样的，可以给它设置显示时长，插值器等。<br>在开始提到了，ObjectAnimator用于有get，set属性的控件，对于没有的可以通过一个包装类来实现，如下：</p><pre><code>/** * 包装类，给width添加get，set方法 */public static class WrapperView {    private View mTarget;    public WrapperView(View target) {        mTarget = target;    }    public int getWidth() {        return mTarget.getLayoutParams().width;    }    public void setWidth(int width) {        mTarget.getLayoutParams().width = width;        mTarget.requestLayout();    }}</code></pre><p>使用时，直接操纵包装类，如下：</p><pre><code>WrapperView mWrapperView = new WrapperView(btnStartAnim);ObjectAnimator animator = ObjectAnimator.ofInt(        mWrapperView,&quot;width&quot;,500).setDuration(500);animator.start();</code></pre><p>通过上面，可以知道，ObjectAnimator 实现动画主要是通过set方法来设置控件的对应的属性实现动画。</p><h1 id="5、ObjectAnimator-的常用方法"><a href="#5、ObjectAnimator-的常用方法" class="headerlink" title="5、ObjectAnimator 的常用方法"></a>5、ObjectAnimator 的常用方法</h1><p>除了上面的ofInt,ofFloat方法，对于要改变背景色的，可以使用<strong>ArgbEvaluator</strong>，用法如下,给textView设置背景色在三种颜色间变化：</p><pre><code>ObjectAnimator animator = ObjectAnimator.ofInt(textView,        &quot;BackgroundColor&quot;,0xffff00ff, 0xffffff00, 0xffff00ff);animator.setDuration(2000);animator.setEvaluator(new ArgbEvaluator());animator.start();</code></pre><p>其他常用函数如下：<br>摘抄于：<a href="http://wiki.jikexueyuan.com/project/android-animation/7.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/android-animation/7.html</a></p><pre><code>/**  * 设置动画时长，单位是毫秒  */  ValueAnimator setDuration(long duration)  /**  * 获取 ValueAnimator 在运动时，当前运动点的值  */  Object getAnimatedValue();  /**  * 开始动画  */  void start()  /**  * 设置循环次数,设置为 INFINITE 表示无限循环  */  void setRepeatCount(int value)  /**  * 设置循环模式  * value 取值有 RESTART，REVERSE，  */  void setRepeatMode(int value)  /**  * 取消动画  */  void cancel() </code></pre><p>监听相关的方法：</p><pre><code>/**  * 监听器一：监听动画变化时的实时值  */  public static interface AnimatorUpdateListener {      void onAnimationUpdate(ValueAnimator animation);  }  //添加方法为：public void addUpdateListener(AnimatorUpdateListener listener)  /**  * 监听器二：监听动画变化时四个状态  */  public static interface AnimatorListener {      void onAnimationStart(Animator animation);      void onAnimationEnd(Animator animation);      void onAnimationCancel(Animator animation);      void onAnimationRepeat(Animator animation);  }  //添加方法为：public void addListener(AnimatorListener listener)</code></pre><p>插值器与 Evaluator:</p><pre><code>/**  * 设置插值器  */  public void setInterpolator(TimeInterpolator value)  /**  * 设置 Evaluator  */  public void setEvaluator(TypeEvaluator value) </code></pre><p>更多方法可以查看api</p><h1 id="6、AnimatorSet的使用"><a href="#6、AnimatorSet的使用" class="headerlink" title="6、AnimatorSet的使用"></a>6、AnimatorSet的使用</h1><p>在视图动画中  AnimationSet 来处理混合动画，同样的，这里的AnimatorSet来处理多个动画的。它出了实现多种动画，还可以精确的进行顺序控制。<br>示例代码：</p><pre><code>ObjectAnimator animator1 = ObjectAnimator.ofFloat(textView, &quot;translationX&quot;, 300);ObjectAnimator animator2 = ObjectAnimator.ofFloat(textView, &quot;scaleX&quot;, 1, 0, 1);ObjectAnimator animator3 = ObjectAnimator.ofFloat(textView, &quot;scaleY&quot;, 1, 0, 1);AnimatorSet animatorSet = new AnimatorSet();animatorSet.setDuration(1000);animatorSet.playTogether(animator1, animator2, animator3);animatorSet.start();</code></pre><p>示例效果：<br><img src="/img/article_img/AnimatorSet.gif" alt></p><p>以上示例设置textView在x轴方向移动300，x和y方向先缩小到一倍再还原到一倍三种动画是同时执行。<br>若需要按顺序执行，可以调用Animator的<strong>playSequentially</strong>方法。</p><h1 id="7、PropertyValuesHolder-的使用"><a href="#7、PropertyValuesHolder-的使用" class="headerlink" title="7、PropertyValuesHolder 的使用"></a>7、PropertyValuesHolder 的使用</h1><p>除了上面讲的AnimatorSet 实现多种动画，还可以通过PropertyValuesHolder来实现，比如上面的例子在平移的过程中实现x,y轴的缩放。如下代码;</p><pre><code>PropertyValuesHolder valuesHolder1 = PropertyValuesHolder    .ofFloat(&quot;translationX&quot;, 300);PropertyValuesHolder valuesHolder2 = PropertyValuesHolder    .ofFloat(&quot;scaleX&quot;, 1, 0, 1);PropertyValuesHolder valuesHolder3 = PropertyValuesHolder    .ofFloat(&quot;scaleY&quot;, 1, 0, 1);ObjectAnimator.ofPropertyValuesHolder(tv, valuesHolder1,    valuesHolder2, valuesHolder3).setDuration(1000).start();</code></pre><p>运行效果同AnimatorSet中的示例。<br>它的实现是先分别用PropertyValuesHolder的对象来控制不同的属性，最后调用ofPropertyValuesHolder方法实现多个属性动画的共同作用。</p><h1 id="8、在XML文件中实现属性动画"><a href="#8、在XML文件中实现属性动画" class="headerlink" title="8、在XML文件中实现属性动画"></a>8、在XML文件中实现属性动画</h1><p>先在xml文件中定义属性，如下示例：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    android:duration=1000&quot;    android:propertyName=&quot;scaleX&quot;    android:valueFrom=&quot;1.0&quot;    android:valueTo=&quot;2.0&quot;    android:valueType=&quot;floatType&quot;&lt;/objectAnimator&gt;</code></pre><p>在java代码代码中使用：</p><pre><code>Animator animator = AnimatorInflater.        loadAnimator(MainActivity.this,        R.animator.scalex);animator.setTarget(tv);animator.start();</code></pre><p>需要注意的是，xml文件的定义需要放在res/animator下，而且根节点只能是：set,objectAnimator,valueAnimator三者之一。如果使用的set，可以为其指定播放的方式，属性名为：ordering=[“together”]|[“sequentially”]，<br>默认值为：“together”，对于其他具体的属性这里不再赘述了，可以参见文档。<br>在实际开发中建议使用代码实现动画，比较简单，而且很多时候某些属性的起始值无法确定。</p><h1 id="8、View的animate方法"><a href="#8、View的animate方法" class="headerlink" title="8、View的animate方法"></a>8、View的animate方法</h1><p>在android3.0之后，添加了animate方法来直接驱动属性动画，它其实是对属性动画的简写，如下示例：</p><pre><code> view.animate()        .alpha(0)        .y(300)        .setDuration(1000)        .withStartAction(new Runnable() {            @Override            public void run() {            }        })        .withEndAction(new Runnable() {            @Override            public void run() {            }        }).start();</code></pre><p>上面的例子很好理解，可以通过属性来确定他的含义。<br>总之，在实现动画时，可以根据自己的实际情况选择相应的方式实现动画，必要的时候还可以自定义实现动画，往往在使用时，不只是一种动画，我们要选择合适的方式实现多种动画。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> Animator </tag>
            
            <tag> 属性动画 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Animation 动画详解</title>
      <link href="/2016/04/25/view-Animation/"/>
      <url>/2016/04/25/view-Animation/</url>
      <content type="html"><![CDATA[<p>在android 开发中，适当的添加动画可以使界面的交互变得更加的友好，特别是在提示，引导类的场景中，合理的使用动画可以带来更好的用户体验。这里，介绍<strong>Animation</strong> 框架的用法。<a id="more"></a></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Animation动画框架中提供了四中动画方式，分别为：</p><ul><li>透明    <a href="https://developer.android.com/reference/android/view/animation/AlphaAnimation.html" target="_blank" rel="noopener">AlphaAnimation</a></li><li>旋转    <a href="https://developer.android.com/reference/android/view/animation/RotateAnimation.html" target="_blank" rel="noopener">RotateAnimation</a></li><li>缩放    <a href="https://developer.android.com/reference/android/view/animation/ScaleAnimation.html" target="_blank" rel="noopener">ScaleAnimation</a></li><li>平移   <a href="https://developer.android.com/reference/android/view/animation/TranslateAnimation.html" target="_blank" rel="noopener">TranslateAnimation</a><br>此外，还提供了<a href="https://developer.android.com/reference/android/view/animation/AnimationSet.html" target="_blank" rel="noopener">AnimationSet</a>动画集合，混合使用多种动画。<br>它们对应的 <strong>xml</strong>  的标签分别为：<strong>alpha,rotate,scale,translate和set。</strong><br><strong>Animation</strong>是他们的基类，有如下的标签和对应的函数：<br><strong>android:duration setDuration(long)</strong> 动画持续时间，以毫秒为单位<br><strong>android:fillAfter setFillAfter(boolean)</strong> 如果设置为 true，控件动画结束时，将保持动画最后时的状态<br><strong>android:fillBefore setFillBefore(boolean)</strong> 如果设置为 true,控件动画结束时，还原到开始动画前的状态<br><strong>android:fillEnabled setFillEnabled(boolean)</strong> 与 android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态<br><strong>android:repeatCount setRepeatCount(int)</strong> 重复次数<br><strong>android:repeatMode setRepeatMode(int)</strong> 重复类型，有 reverse 和 restart 两个值，取值为 RESTART 或 REVERSE，必须与 repeatCount 一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。<br><strong>android:interpolator setInterpolator(Interpolator)</strong> 设定插值器，其实就是指定的动作效果，比如弹跳效果等</li></ul><h2 id="2-Interpolator-插值器"><a href="#2-Interpolator-插值器" class="headerlink" title="2. Interpolator 插值器"></a>2. Interpolator 插值器</h2><p>对于动画，它的速率变化有快又慢，谷歌给出了<strong>插值器</strong>，来方便我们控制动画的变化。在不同的插值器的作用下，其变化也不一样。官方给的插值器有（谷歌官方）：<br><img src="/img/article_img/Interpolator.jpg" alt><br>部分资源id为(改图来自网络)：<br><img src="/img/article_img/Interpolator-resource-id.png" alt></p><h2 id="3-xm实现动画"><a href="#3-xm实现动画" class="headerlink" title="3. xm实现动画"></a>3. xm实现动画</h2><p>以<strong>scale</strong>标签为例，其他类似。scale有以下几个属性：</p><ul><li><strong>android:fromXScale</strong> 起始的 X方向上相对自身的缩放比例，浮点值，比如 1.0 代表自身无变化，0.5 代表起始时缩小一倍，2.0 代表放大一倍；</li><li><strong>android:toXScale</strong> 结尾的 X 方向上相对自身的缩放比例，浮点值；</li><li><strong>android:fromYScale</strong> 起始的 Y方向上相对自身的缩放比例，浮点值，</li><li><strong>android:toYScale</strong> 结尾的 Y 方向上相对自身的缩放比例，浮点值；</li><li><strong>android:pivotX</strong> 缩放起点 X 轴坐标，可以是数值、百分数、百分数 p。 三种样式，比如 50、50%、50%p，当为数值时，表示在当前 View的左上角，即原点处加上 50px，做为起始缩放点；如果是 50%，表示在当前控件的左上角加上自己宽度的 50%做为起始点；如果是 50%p，那么就是表示在当前的左上角加上父控件宽度的 50%做为起始点 x 轴坐标。</li><li><strong>android:pivotY</strong> 缩放起点 Y 轴坐标，取值及意义跟android:pivotX 一样。</li><li><strong>android:interpolator</strong> 就是添加的插值器，通过不同的Resource ID引用不同的插值器类。</li><li><strong>android：fillAfter</strong> 保持动画结束的状态，同样的可以保存初始化状态（<strong>fileBefore</strong>）</li><li><strong>android:repeatMode</strong> 设定回放类型，重新开始/倒退（restart /reverse）<br>在res下新建anim 文件夹，新建scaleanim.xml文件，如下代码（宽高从0放大到1.5倍，开开始和结束速度慢，中间快，停留在结束状态，重复一次）：<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;scale  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;  android:fromXScale=&quot;0.0&quot;  android:fromYScale=&quot;0.0&quot;  android:pivotX=&quot;50&quot;  android:pivotY=&quot;50&quot;  android:toXScale=&quot;1.5&quot;  android:toYScale=&quot;1.5&quot;  android：fillAfter=&quot;true&quot;  android:repeatCount=&quot;1&quot;    android:repeatMode=&quot;restart&quot;  &gt;&lt;/scale&gt;</code></pre>上面定义好了动画，下面就是具体的使用，这里以给textView设置上面的scale动画为例，代码如下：<pre><code>Animation mAnimation = AnimationUtils.loadAnimation(this,R.anim.scaleanim);  textView.startAnimation(mAnimation);</code></pre>注：对于其他的标签及其属性可以参见<a href="https://developer.android.com/reference/android/view/animation/Animation.html" target="_blank" rel="noopener">官方文档</a>,这些标签可以放在一个<strong>set标签</strong>中，来定义动画集合。<h2 id="4-java-代码实现动画"><a href="#4-java-代码实现动画" class="headerlink" title="4. java 代码实现动画"></a>4. java 代码实现动画</h2>这里以<strong>AlphaAnimation</strong>为例，若xml代码为：<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  &lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:interpolator=&quot;@android:anim/bounce_interpolator&quot;  android:fromAlpha=&quot;1.0&quot;    android:toAlpha=&quot;0.1&quot;    android:duration=&quot;3000&quot;    android:fillBefore=&quot;true&quot;&gt;  &lt;/alpha&gt;</code></pre>与其有相同效果的java代码为：<pre><code>alphaAnim = new AlphaAnimation(1.0f,0.1f);  alphaAnim.setDuration(3000);  alphaAnim.setFillBefore(true); alphaAnim.setInterpolator(new BounceInterpolator());//设置插值器</code></pre>最后，就是给相应的控件设置动画，如下：<pre><code>textView.startAnimation(alphaAnim);</code></pre></li></ul><h2 id="5-动画回调监听事件"><a href="#5-动画回调监听事件" class="headerlink" title="5. 动画回调监听事件"></a>5. 动画回调监听事件</h2><p>对于上面的两中方法设置动画，可以添加相应的监听回调，获得动画的开始，结束和重复事件，并对不同的事件作出相应的处理。</p><pre><code>mAnimation.setAnimationListener(new Animation.AnimationListener() {        @Override        public void onAnimationStart(Animation animation) {            //动画开始前的回调处理        }        @Override        public void onAnimationEnd(Animation animation){            //动画结束时的回调处理        }        @Override        public void onAnimationRepeat(Animation animation) {            //动画重复的回调处理        }    });</code></pre><p>更多：<a href="http://imtianx.cn/2016/04/25/Property-animatorValueAnimator_ObjectAnimation" target="_blank" rel="noopener">属性动画（ValueAnimator 和 ObjectAnimation）</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> Animation </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SwipeRefreshLayout+RecyclerView实现下拉刷新</title>
      <link href="/2016/04/23/SwipeRefreshLayout-RecyclerView/"/>
      <url>/2016/04/23/SwipeRefreshLayout-RecyclerView/</url>
      <content type="html"><![CDATA[<p>SwipeRefreshLayout+RecyclerView实现下拉刷新<br>另外还使用了CardView（一个容器类布局，它继承自FrameLayout）。<br><a id="more"></a><br>效果图如下：<br><img src="http://img.blog.csdn.net/20160411115226554" alt="这里写图片描述"></p><h2 id="具体的使用："><a href="#具体的使用：" class="headerlink" title="具体的使用："></a>具体的使用：</h2><h4 id="1-CardView"><a href="#1-CardView" class="headerlink" title="1.CardView"></a>1.CardView<br></h4><p>首先，引入依赖：<br></p><pre><code>```compile &#39;com.android.support:cardview-v7:23.3.0&#39;```</code></pre><p> 接着，在布局中引用，需要添加新的名字空间<br></p><pre><code>```xmlns:card_view=&quot;http://schemas.android.com/apk/res-auto&quot;```</code></pre><p> 通过名字空间添加两个新的属性,通过名字很容易知道，第一个是设置背景颜色，第二个是设置圆角<br></p><pre><code>```card_view:cardBackgroundColor=&quot;#b911e8&quot;card_view:cardCornerRadius=&quot;4dp&quot;```</code></pre><p>这里，RecyclerView 的每一个item都是一个CardView<br><br></p><h4 id="2-SwipeRefreshLayout"><a href="#2-SwipeRefreshLayout" class="headerlink" title="2.SwipeRefreshLayout"></a>2.SwipeRefreshLayout</h4><p>它在V4 包下，使用代码如下：<a href="https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fres%2Flayout%2Factivity_main.xml" target="_blank" rel="noopener">activity_main.xml</a></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.SwipeRefreshLayoutxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:id=&quot;@+id/swipe_container&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;android.support.v7.widget.RecyclerViewandroid:layout_width=&quot;match_parent&quot;android:layout_height=&quot;wrap_content&quot;android:id=&quot;@+id/relv&quot;&gt;&lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;</code></pre><p>在activity中设置相关的方法：</p><pre><code>//设置进度条颜色,最多可以有四个颜色setColorSchemeResources(int… colorResIds);//设置进度圈背景颜色setProgressBackgroundColorSchemeColor(int color);//设置监听,在OnRefresh()中处理结果setOnRefreshListener(SwipeRefreshLayout.OnRefreshListener);//设置刷新状态setRefreshing(Boolean refreshing);</code></pre><h4 id="3-RecyclerView"><a href="#3-RecyclerView" class="headerlink" title="3.RecyclerView"></a>3.RecyclerView</h4><p>它是谷歌对ListView的升级，效率更高，并对ViewHolder进行了封装。使用时，同样，需要依赖库:</p><pre><code>compile &#39;com.android.support:recyclerview-v7:23.3.0&#39;</code></pre><p>编写自己的adapter，继承自 RecyclerView.Adapter ，实现三个方法：(具体内容见：<a href="https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fjava%2Fcn%2Fimtianx%2Fswrvdemo%2FRvAdapter.java" target="_blank" rel="noopener">RvAdapter.java</a>)</p><pre><code>/** * 将布局转换成view 并传递给RecyclerView 封装好的 ViewHolder * * @param parent * @param viewType * @return */@Overridepublic ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {    View view = LayoutInflater.from(parent.getContext()).inflate(            R.layout.rv_item_cardview, parent, false);    return new ViewHolder(view);}/** * 建立ViewHolder中视图与数据的关联 * * @param holder * @param position */@Overridepublic void onBindViewHolder(ViewHolder holder, int position) {    holder.imageView.setImageResource(R.mipmap.img);    holder.textView.setText(datas.get(position));}  </code></pre><p>添加内部内ViewHolder继承自RecyclerView.ViewHolder, 由于android没有给RecyclerView设置点击事件，需要我们自己使用接口回调，设置监听。</p><pre><code>public class ViewHolder extends RecyclerView.ViewHolder{    public ImageView imageView;    public TextView textView;    public ViewHolder (final View itemView)    {        super (itemView);        imageView = (ImageView) itemView.findViewById (R.id.img_head);        textView = (TextView) itemView.findViewById (R.id.tv_title);        itemView.setOnClickListener (new View.OnClickListener()        {            @Override            public void onClick (View v)            {                itemClickListener.onItemClick (v, getPosition() );            }        });        textView.setOnClickListener (            new View.OnClickListener()        {            @Override            public void onClick (View v)            {                if (itemClickListener != null)                {                    itemClickListener.onTextClick (v, getPosition() );                }            }        });    }}public OnItemClickListener itemClickListener;/** * 设置接口 * * @param itemClickListener */public void setItemClickListener (OnItemClickListener itemClickListener){    this.itemClickListener = itemClickListener;}/** * 点击事件接口 */public interface OnItemClickListener{    //item的点击事件    void onItemClick (View view, int position);    //item中文字的点击事件    void onTextClick (View view, int position);}</code></pre><p>最后在activity中设置监听，具体见：<a href="https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo/src/main/java/cn/imtianx/swrvdemo/MainActivity.java" target="_blank" rel="noopener">MainActivity.java</a></p><p> <strong><a href="https://github.com/imtianx/StudyDemoForAndroid/tree/master/A02-swrvdemo" target="_blank" rel="noopener">demon地址</a></strong></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5.X新特新 </tag>
            
            <tag> RecyclerView </tag>
            
            <tag> CardView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Gradle发布项目到JCenter仓库</title>
      <link href="/2016/04/23/put-libary-to-jcenter/"/>
      <url>/2016/04/23/put-libary-to-jcenter/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://zhengxiaopeng.com/2015/02/02/%E4%BD%BF%E7%94%A8Gradle%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0JCenter%E4%BB%93%E5%BA%93/" target="_blank" rel="noopener">使用Gradle发布项目到JCenter仓库</a><br>这里介绍了使用gradle发布项目到jcenter的具体流程，方便项目的依赖。<br><a id="more"></a></p><h3 id="申请Bintray账号"><a href="#申请Bintray账号" class="headerlink" title="申请Bintray账号"></a>申请Bintray账号</h3><p>Bintray的基本功能类似于Maven Central，一样的我们需要一个账号，<a href="https://bintray.com/" target="_blank" rel="noopener">Bintray传送门</a>，注册完成后第一步算完成了。</p><h3 id="生成项目的JavaDoc和source-JARs"><a href="#生成项目的JavaDoc和source-JARs" class="headerlink" title="生成项目的JavaDoc和source JARs"></a>生成项目的JavaDoc和source JARs</h3><p>简单的说生成的这两样东西就是我们在下一步中上传到远程仓库JCenter上的文件了。这一步需要android-maven-plugin插件，所以我们需要在项目的build.gradle（Top-level build file，项目最外层的build.gradle文件）中添加这个构建依赖，如下：</p><pre><code>buildscript {    repositories {        jcenter()    }    dependencies {        classpath &#39;com.android.tools.build:gradle:1.0.0&#39;        classpath &#39;com.github.dcendents:android-maven-plugin:1.2&#39;        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    }}allprojects {    repositories {        jcenter()    }}</code></pre><p>注：如果编译出现问题 ，可将maven 的依赖改为1.3，如下：</p><pre><code>classpath &#39;com.github.dcendents:android-maven-plugin:1.3&#39;</code></pre><p>然后在你需要发布的那个module（我这里的即是library）的build.gradle里配置如下内容：</p><pre><code>apply plugin: &#39;com.android.library&#39;apply plugin: &#39;com.github.dcendents.android-maven&#39;apply plugin: &#39;com.jfrog.bintray&#39;// This is the library version used when deploying the artifactversion = &quot;1.0.0&quot;android {    compileSdkVersion 21    buildToolsVersion &quot;21.1.2&quot;    resourcePrefix &quot;bounceprogressbar__&quot;    //这个随便填    defaultConfig {        minSdkVersion 9        targetSdkVersion 21        versionCode 1        versionName version    }    buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;        }    }}dependencies {    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    compile &#39;com.nineoldandroids:library:2.4.0+&#39;}def siteUrl = &#39;https://github.com/zhengxiaopeng/BounceProgressBar&#39; // 项目的主页def gitUrl = &#39;https://github.com/zhengxiaopeng/BounceProgressBar.git&#39; // Git仓库的urlgroup = &quot;org.rocko.bpb&quot; // Maven Group ID for the artifact，一般填你唯一的包名install {    repositories.mavenInstaller {        // This generates POM.xml with proper parameters        pom {        project {        packaging &#39;aar&#39;        // Add your description here        name &#39;Android BounceProgressBar Widget&#39; //项目描述        url siteUrl        // Set your license        licenses {            license {            name &#39;The Apache Software License, Version 2.0&#39;            url &#39;http://www.apache.org/licenses/LICENSE-2.0.txt&#39;            }        }        developers {        developer {        id &#39;zhengxiaopeng&#39;    //填写的一些基本信息        name &#39;Rocko&#39;        email &#39;zhengxiaopeng.china@gmail.com&#39;        }        }        scm {        connection gitUrl        developerConnection gitUrl        url siteUrl        }        }        }    }}task sourcesJar(type: Jar) {    from android.sourceSets.main.java.srcDirs    classifier = &#39;sources&#39;}task javadoc(type: Javadoc) {    source = android.sourceSets.main.java.srcDirs    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))}task javadocJar(type: Jar, dependsOn: javadoc) {    classifier = &#39;javadoc&#39;    from javadoc.destinationDir}artifacts {    archives javadocJar    archives sourcesJar}Properties properties = new Properties()properties.load(project.rootProject.file(&#39;local.properties&#39;).newDataInputStream())bintray {    user = properties.getProperty(&quot;bintray.user&quot;)    key = properties.getProperty(&quot;bintray.apikey&quot;)    configurations = [&#39;archives&#39;]    pkg {        repo = &quot;maven&quot;            name = &quot;BounceProgressBar&quot;    //发布到JCenter上的项目名字        websiteUrl = siteUrl        vcsUrl = gitUrl        licenses = [&quot;Apache-2.0&quot;]        publish = true    }}</code></pre><p>配置好上述后需要在你的项目的根目录上的local.properties文件里（一般这文件需gitignore，防止泄露账户信息）配置你的bintray账号信息，your_user_name为你的用户名，your_apikey为你的账户的apikey，可以点击进入你的账户信息里再点击Edit即有查看API Key的选项，把他复制下来。</p><pre><code>bintray.user=your_user_namebintray.apikey=your_apikey</code></pre><p>Rebuild一下项目，顺利的话，就可以在module里的build文件夹里生成相关文件了。这一步为止，就可以把你项目生成到本地的仓库中了，Android Studio中默认即在Android\sdk\extras\android\m2repository这里，所以我们可以通过如下命令(Windows中，可能还需要下载一遍Gradle，之后就不需要了)执行生成:</p><pre><code>gradlew install</code></pre><h3 id="上传到Bintray"><a href="#上传到Bintray" class="headerlink" title="上传到Bintray"></a>上传到Bintray</h3><p>上传到Bintray需要gradle-bintray-plugin的支持，所以在最外层的build.gradle里添加构建依赖：</p><pre><code>buildscript {    repositories {        jcenter()    }    dependencies {        classpath &#39;com.android.tools.build:gradle:1.0.0&#39;        classpath &#39;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0&#39;        classpath &#39;com.github.dcendents:android-maven-plugin:1.2&#39;        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    }}allprojects {    repositories {        jcenter()    }}</code></pre><p>Rebuild一下，然后执行如下命令(Windows中)完成上传：</p><pre><code>gradlew bintrayUpload</code></pre><p>上传完成即可在Bintray网站上找到你的Repo，我们需要完成最后一步工作，<strong>申请你的Repo添加到JCenter</strong>。可以进入这个页面,输入你的项目名字点击匹配到的项目，然后写一写Comments再send即可，然后就等管理员批准了，我是大概等了40分钟，然后网站上会给你一条通过信息，然后就OK了，大功告成。在bintray的maven厂库中即可查看。此外，如果添加其他版本的，可以按照上述步骤操作，注意改版本号。<br>如下bintray厂库详情：<br><img src="http://img.blog.csdn.net/20160404173839075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>最后在其他项目中引用：</p><p>1.使用Gradle：</p><pre><code>dependencies {    compile &#39;org.rocko.bpb:library:1.0.0&#39;}</code></pre><p>2.使用maven：<br>按图中操作。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
            <tag> jcenter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android真机测试之offline或unauthorized错误</title>
      <link href="/2016/04/23/erroe-of-offline-or-unauthorized/"/>
      <url>/2016/04/23/erroe-of-offline-or-unauthorized/</url>
      <content type="html"><![CDATA[<p>在开发中，使用真机测试较为方便，然而在ide连接手机时，adb device 提示 <strong>offline</strong> 或者 <strong>unauthorized</strong>(中文：未授权的)会令大家非常困扰。<a id="more"></a>我也同样为此而浪费了很多时间。这里，介绍一种较为方便的解决方法（亲测有效）：<br>先删除.android 文件夹下的adbkey文件夹,再连接数据线，让其重新授权。<br>对于.android 文件夹，一般在电脑c盘的用户/用户名 下，它是用于存放android虚拟机的。如果将sdk配置到了环境变量中，则.android文件夹在相应的sdk目录下。<br>此外，网上还有其他的方法，不过都没有解决：</p><ol><li>用数据线连接手机，在设备管理器中把手机的驱动卸载了，然后重启，重新连接数据线；</li><li>打开手机设置，进入 开发人员选项，关闭 usb调试 ，撤销usb授权，最后重新打开；</li><li>重启adb：①在编辑器中重启或者关掉编辑器，同时在任务管理器中结束adb.exe;<br>②使用命令行：windows下，（win+R）–&gt;cmd 进入命令行，输入一次以下命令：</li></ol><pre><code>adb kill-server;adb start-server;</code></pre><ol start="4"><li>使用第三方的软件，如豌豆荚（曾经用过，可用）<br>总之，不同的人有不同的方法，选择一种自己可以接受的，能够有效解决问题就行。</li></ol>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 真机调试 </tag>
            
            <tag> offline </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ListView的优化技巧</title>
      <link href="/2016/04/23/listview-optimize/"/>
      <url>/2016/04/23/listview-optimize/</url>
      <content type="html"><![CDATA[<p>在实际的应用开发时，往往有很多地方需要使用listview,当然我们得了解它的一些技巧。<a id="more"></a></p><h3 id="1-ListView的优化技巧"><a href="#1-ListView的优化技巧" class="headerlink" title="1.ListView的优化技巧"></a>1.ListView的优化技巧</h3><p>主要使用ViewHolder来提高效率，利用它的视图缓存机制，避免每次在调用方getView()方法时通过findViewById()实例化控件。使用时，只需在自定义的adapter中定义内部类ViewHolder，将ListView的item中的控件作为其成员变量。</p><p>如下getView()方法：</p><pre><code>    @Override       public View getView(int position, View convertView, ViewGroup parent) {         ViewHolder holder = null;           // 判断是否缓存           if (convertView == null) {               holder = new ViewHolder();               // 通过LayoutInflater实例化布局               convertView = mInflater.inflate(R.layout.notify_item, null);               holder.img = (ImageView) convertView.findViewById(R.id.imageView);               holder.title = (TextView) convertView.findViewById(R.id.textView);               convertView.setTag(holder);           } else {               // 通过tag找到缓存的布局               holder = (ViewHolder) convertView.getTag();           }           // 设置布局中控件要显示的视图           holder.img.setBackgroundResource(R.drawable.ic_launcher);           holder.title.setText(mData.get(position));           return convertView;       }    //定义内部类       public final class ViewHolder {           public ImageView img;           public TextView title;       }</code></pre><h3 id="2-ListView的常用属性"><a href="#2-ListView的常用属性" class="headerlink" title="2.ListView的常用属性"></a>2.ListView的常用属性</h3><p>设置分割线</p><pre><code>android:divider=&quot;@null&quot;</code></pre><p>隐藏滚动条</p><pre><code>android:scrollbars=&quot;none&quot;</code></pre><p>设置要显示在第N项</p><pre><code>//瞬间完成listView.setSelection(N);//平滑完成listView.smoothScrollBy(distance,duration);listView.smoothScrollByOffset(offset);listView.smoothScrollToPosition(n);</code></pre><p>动态修改</p><pre><code>//改变llist后调用mAdapter.notifyDataSetChanged();</code></pre><h3 id="3-动态改变ListView的布局"><a href="#3-动态改变ListView的布局" class="headerlink" title="3.动态改变ListView的布局"></a>3.动态改变ListView的布局</h3><p>如：实现聊天界面，加载连个布局的。<br>主要是比普通的adapter多实现getItemViewType()和getViewType()两个方法，然后再getView()中作出相应的处理。<br>如下部分主要代码：</p><pre><code>//返回第position个item是何种类型    @Override    public int getItemViewType(int position) {        ChatItemListViewBean bean = mData.get(position);        return bean.getType();    }    //返回不同布局的总数    @Override    public int getViewTypeCount() {        return 2;    }&lt;/span&gt;    @Override    public View getView(int position, View convertView, ViewGroup parent) {        ViewHolder holder;        if (convertView == null) {            //判断布局类型            if (getItemViewType(position) == 0) {                holder = new ViewHolder();                convertView = mInflater.inflate(                        R.layout.chat_item_itemin, null);                holder.icon = (ImageView) convertView.findViewById(                        R.id.icon_in);                holder.text = (TextView) convertView.findViewById(                        R.id.text_in);            } else {                holder = new ViewHolder();                convertView = mInflater.inflate(                        R.layout.chat_item_itemout, null);                holder.icon = (ImageView) convertView.findViewById(                        R.id.icon_out);                holder.text = (TextView) convertView.findViewById(                        R.id.text_out);            }            convertView.setTag(holder);        } else {            holder = (ViewHolder) convertView.getTag();        }        holder.icon.setImageBitmap(mData.get(position).getIcon());        holder.text.setText(mData.get(position).getText());        return convertView;    }</code></pre><p>此外，ListView还能设置滑动监听，有OnTouchListener和OnScrollListener监听事件。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Listview </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ScrollView嵌套ListView的解决方案</title>
      <link href="/2016/04/23/listView-in-scrollView/"/>
      <url>/2016/04/23/listView-in-scrollView/</url>
      <content type="html"><![CDATA[<p>在android开发中，有时会遇到ScrollView嵌套ListView的相关问题，然而直接使用ScrollView 嵌套ListView，会导致界面卡顿无法滚动，或者listview只希显示1行（设置lisview的高度为400dp课以解决）。<a id="more"></a>网上也有不同的解决方案，但主要有以下几种。</p><h3 id="1、不使用ScrollView"><a href="#1、不使用ScrollView" class="headerlink" title="1、不使用ScrollView"></a>1、不使用ScrollView</h3><p>这种做法是直接将scrollview中除lisview的部分单独写到一个布局文件中，将其加入到listview的头部（即：position==0 的位置）。</p><pre><code>listView.addHeaderView(LayoutInflater.from(getApplicationContext()).                    inflate(R.layout.list_top_view, null));或者在adapter的getview中加：if(position==0){        convertView = LayoutInflater.from(context).inflate(R.layout.list_top_view, null);    return convertView;}</code></pre><p>注：“这种方法不推荐使用，使用它就破会listview 使用ViewHolder的结构，不能达到优化的目的。</p><h3 id="2、动态测量ListView"><a href="#2、动态测量ListView" class="headerlink" title="2、动态测量ListView"></a>2、动态测量ListView</h3><p>在执行完listView.setAdapter(myAdapter);后调用下面的方法；</p><pre><code>    /** 动态设置ListView的高度     * @param listView     */    public  void setListViewHeightBasedOnChildren(ListView listView) {        if(listView == null) return;        ListAdapter listAdapter = listView.getAdapter();        if (listAdapter == null) {            return;        }        int totalHeight = 0;        for (int i = 0; i &lt; listAdapter.getCount(); i++) {            View listItem = listAdapter.getView(i, null, listView);            listItem.measure(0, 0);            totalHeight += listItem.getMeasuredHeight();        }        ViewGroup.LayoutParams params = listView.getLayoutParams();        params.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1));        listView.setLayoutParams(params);    }}</code></pre><p>但是这样，界面显示的是以listview开始的，他上的内容不会显示，需手动设置ScrollView定位到顶部，或者让listview失去焦点（listView.setFocusable(false);）也可显示顶部内容。<br>scrollView定位到顶部代码：</p><pre><code>scrollView.smoothScrollTo(0, 20);scrollView.fullScroll(ScrollView.FOCUS_UP);//此处无效scrollView.scrollTo(0, 0);//此处无效</code></pre><p>注：这种方法不用更改控件，但是它必须要求getview返回的view的布局是LinearLayout的，否则会抛出异常，而且使用时，会把所有lisview的所有item 绘制出来。</p><h3 id="3、自定义ListView"><a href="#3、自定义ListView" class="headerlink" title="3、自定义ListView"></a>3、自定义ListView</h3><p>自定义listview，继承自ListView，添加原有的三个构造方法，重写onMeasure() 方法，在布局文件处使用自定义的Listview，具体代码如下：</p><pre><code>import android.content.Context;import android.util.AttributeSet;import android.widget.ListView;public class MyListView extends ListView {    public MyListView(Context context) {        super(context);        // TODO Auto-generated constructor stub    }    public MyListView(Context context, AttributeSet attrs) {        super(context, attrs);        // TODO Auto-generated constructor stub    }    public MyListView(Context context, AttributeSet attrs, int defStyle) {        super(context, attrs, defStyle);        // TODO Auto-generated constructor stub    }    /**     * 重写原方法，使ListView适应ScrollView的效果     */    @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2,                MeasureSpec.AT_MOST);        super.onMeasure(widthMeasureSpec, expandSpec);    }}</code></pre><p>注：这种方法使用起来较为方便，它保正了lisview的所有方法，个人就是这样用的。<br>除此之外，还有使用linearLayout替代lisview，个人没有进行测试，感兴趣的的可以尝试下。对上面的各种方法，个人都经过测试，进行事件的监听也不会出先问题，可以放心使用。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ScrollView </tag>
            
            <tag> ListView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2015年终总结及android学习路线</title>
      <link href="/2016/04/23/sum-up-2015/"/>
      <url>/2016/04/23/sum-up-2015/</url>
      <content type="html"><![CDATA[<p>转眼间，一年又过去了，距离毕业也越来越近了。回想过去，感觉自己什么都还不会，顿时感到紧迫感。那么，在接下来的日子里，就要充分利用每分每秒，学习充实自己。我们搞it的就得时刻记着：活到老，学到老。<a id="more"></a><br>回想这一年，自己独自学习android，从开始安装配置开发环境，到后来的指导别人并参加实际的项目开发，经历了各种酸甜苦辣。在此，总结下学习的经历。对于android，是个开发上手入门很快的语言，但后期在其他方面需要注意和学习的事情还有很多很多。自己在android学习之路上还有伸长的路要走，但不管怎么样，还是要脚踏实地，一点点的学习，不可骄傲浮躁。下面谈谈android的学习路线(来自网络)：</p><h3 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h3><p>基本知识点：比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术等。<br>参考书籍：《第一行代码 Android》、《疯狂Android》</p><h3 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h3><p>稍微深入的知识点：AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义View、消息队列等。</p><ul><li>AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别；</li><li>Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用；</li><li>多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等；</li><li>事件分发：弹性滑动、滑动冲突等；</li><li>玩转View：View的绘制原理、各种自定义View；</li><li>动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理；</li><li>懂性能优化、熟悉mat等工具</li><li>懂点常见的设计模式<br>学习方法<br>阅读进阶书籍，阅读Android源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有2个点是比较困扰大家的，一个是阅读源码，另一个是自定义View以及滑动冲突。<br>学习view需要注意的地方：</li><li>搞懂view的滑动原理</li><li>搞懂如何实现弹性滑动</li><li>搞懂view的滑动冲突</li><li>搞懂view的measure、layout和draw<br>然后再学习几个已有的自定义view的例子，最后就可以搞定自定义view了，所谓万变不离其宗。<br>书籍推荐：《Android开发艺术探索》、《Android群英传》</li></ul><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>需要懂的知识：</p><ul><li>了解系统核心机制：</li></ul><ol><li>了解SystemServer的启动过程</li><li>了解主线程的消息循环模型</li><li>了解AMS和PMS的工作原理</li><li>能够回答问题”一个应用存在多少个Window？“</li><li>了解四大组件的大概工作流程</li><li>…</li></ol><ul><li>基本知识点的细节</li></ul><ol><li>Activity的启动模式以及异常情况下不同Activity的表现</li><li>Service的onBind和onReBind的关联</li><li>onServiceDisconnected(ComponentName className)和binderDied的区别</li><li>AsyncTask在不同版本上的表现细节</li><li>线程池的细节和参数配置</li><li>…</li></ol><ul><li><p>熟悉设计模式，有架构意识</p><p>书籍推荐<br>《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》</p></li></ul><p>除此之外，还可以学习一些好的开源框架的使用（如：Eventbuss），还有第三方sdk的接入使用（如:百度地图）；总之，不管怎么说，需要我们不断地学习，接受新知识，愿在新的一年里不断提高。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习路线 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eventbus 开源库的使用</title>
      <link href="/2016/04/23/Eventbus-simple-use/"/>
      <url>/2016/04/23/Eventbus-simple-use/</url>
      <content type="html"><![CDATA[<p>EventBus是一款用用于android上的事件分发/订阅的总线，包含发布者、订阅者、事件和总线。主要用于android中intent,handler等在activity，fragment等组件间传递消息。<a id="more"></a>它极好的将消息的发送者和接收者解耦，方便组件间的通信。<br>下载地址：<br>            原地址：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus</a><br>            涛哥的地址：<a href="https://github.com/kymjs/EventBus" target="_blank" rel="noopener">https://github.com/kymjs/EventBus</a> （包含部分中文注释）</p><h3 id="1、简单使用"><a href="#1、简单使用" class="headerlink" title="1、简单使用"></a>1、简单使用</h3><p>首先下载改开源库，导入项目中。接下来就是具体的使用了。如下几个方法：</p><ul><li>EventBus.getDefault().register(this);注册订阅者</li><li>EventBus.getDefault().post(“点击按钮，发送消息”);发送消息，传入的是自己的事件类对象</li><li>重写 onEventMainThread(Object object) 方法；接收处理消息，这里参数与发送消息的类型一致。</li><li>在 onDestroy()中注销当订阅者。</li></ul><p>这里仅仅为了说明用法，简单的实现代码如下：</p><pre><code>package com.tx.eventbusdemo;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.TextView;import de.greenrobot.event.EventBus;public class MainActivity extends Activity {    private Button mbtnSend;    private TextView mtvShowmsg;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //当前类注册为事件订阅者        EventBus.getDefault().register(this);        mbtnSend = (Button) findViewById(R.id.btn);        mtvShowmsg = (TextView) findViewById(R.id.show);        mbtnSend.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                //发送消息            EventBus.getDefault().post(&quot;点击按钮，发送消息&quot;);            }        });    }    //接收处理消息    public void onEventMainThread(Object object) {          mtvShowmsg.setText(object.toString());    }    @Override    protected void onDestroy() {        super.onDestroy();        //注销注册        EventBus.getDefault().unregister(this);    }}</code></pre><p>效果图：<br><img src="http://img.blog.csdn.net/20151230182722984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><h3 id="2、解析实现过程"><a href="#2、解析实现过程" class="headerlink" title="2、解析实现过程"></a>2、解析实现过程</h3><p>首先在oncreate方法中注册订阅者，它就会扫描当前类，把onEvent开头的方法记录到map中（Key为方法的参数类型，Value中包含我们的方法）；<br>当子线程执行完毕后，调用post方法，根据其参数查找对应的方法，通过反射来执行相关的方法。</p><p>EventBus包含4个ThreadMode：PostThread，MainThread，BackgroundThread，Async。<br>对应的方法及功能为：<br><strong>onEventPostThread</strong>   在当前发布事件的线程中执行<br><strong>onEventMainThread</strong>   在ui线程中执行<br><strong>onEventAsync</strong>   加入后台任务队列，使用线程池调用。<br><strong>onEventBackgroundThread</strong>   在非UI线程发布的事件，则直接执行；否则，加入后台任务队列，使用线程池一个接一个调用。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eventbus </tag>
            
            <tag> 开源框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Studio 快捷键</title>
      <link href="/2016/04/23/androidstudio-keaymap/"/>
      <url>/2016/04/23/androidstudio-keaymap/</url>
      <content type="html"><![CDATA[<p>原官方快捷键：<a href="https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf" target="_blank" rel="noopener">https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf</a><br>Alt+回车 导入包,自动修正<br>Ctrl+N   查找类<br>Ctrl+Shift+N 查找文件<br>Ctrl+Alt+L  格式化代码<br>Ctrl+Alt+O 优化导入的类和包<br>Alt+Insert 生成代码(如get,set方法,构造函数等<a id="more"></a><br>Ctrl+E或者Alt+Shift+C  最近更改的代码<br>Ctrl+R 替换文本<br>Ctrl+F 查找文本<br>Ctrl+Shift+Space 自动补全代码<br>Ctrl+空格 代码提示<br>Ctrl+Alt+Space 类名或接口名提示<br>Ctrl+P 方法参数提示<br>Ctrl+Shift+Alt+N 查找类中的方法或变量<br>Alt+Shift+C 对比最近修改的代码</p><p>Shift+F6  重构-重命名<br>Ctrl+Shift+先上键<br>Ctrl+Y 删除行（ctrl+x不是删除行，是剪切。如果不选中，则为剪切当行。ths for 貌似掉线）<br>Ctrl+D 复制行<br>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）<br>Ctrl+J  自动代码<br>Ctrl+E 最近打开的文件<br>Ctrl+H 显示类结构图<br>Ctrl+Q 显示注释文档<br>Alt+F1 查找代码所在位置<br>Alt+1 快速打开或隐藏工程面板<br>Ctrl+Alt+ left/right 返回至上次浏览的位置<br>Alt+ left/right 切换代码视图<br>Alt+ Up/Down 在方法间快速移动定位<br>Ctrl+Shift+Up/Down 代码向上/下移动。<br>F2 或Shift+F2 高亮错误或警告快速定位</p><p>代码标签输入完成后，按Tab，生成代码。<br>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。<br>Ctrl+W 选中代码，连续按会有其他效果<br>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。<br>Ctrl+Up/Down 光标跳转到第一行或最后一行下<br>Ctrl+B 快速打开光标处的类或方法<br>最常用快捷键<br>1.Ctrl＋E，可以显示最近编辑的文件列表<br>2.Shift＋Click可以关闭文件<br>3.Ctrl＋[或]可以跳到大括号的开头结尾<br>4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方<br>5.Ctrl＋F12，可以显示当前文件的结构<br>6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择<br>7.Ctrl＋N，可以快速打开类<br>8.Ctrl＋Shift＋N，可以快速打开文件<br>9.Alt＋Q可以看到当前方法的声明<br>10.Ctrl＋W可以选择单词继而语句继而行继而函数<br>11.Alt＋F1可以将正在编辑的元素在各个面板中定位<br>12.Ctrl＋P，可以显示参数信息<br>13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入<br>14.Alt＋Insert可以生成构造器/Getter/Setter等<br>15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量<br>16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch<br>17.Alt＋Up and Alt＋Down可在方法间快速移动<br>下面的不是很有用<br>18.在一些地方按Alt＋Enter可以得到一些Intention Action，例如将”==”改为”equals()”<br>19.Ctrl＋Shift＋Alt＋N可以快速打开符号<br>20.Ctrl＋Shift＋Space在很多时候都能够给出Smart提示<br>21.Alt＋F3可以快速寻找<br>22.Ctrl＋/和Ctrl＋Shift＋/可以注释代码<br>23.Ctrl＋Alt＋B可以跳转到抽象方法的实现<br>24.Ctrl＋O可以选择父类的方法进行重写<br>25.Ctrl＋Q可以看JavaDoc<br>26.Ctrl＋Alt＋Space是类名自动完成<br>27.快速打开类/文件/符号时，可以使用通配符，也可以使用缩写<br>28.Live Templates! Ctrl＋J<br>29.Ctrl＋Shift＋F7可以高亮当前元素在当前文件中的使用<br>30.Ctrl＋Alt＋Up /Ctrl＋Alt＋Down可以快速跳转搜索结果<br>31.Ctrl＋Shift＋J可以整合两行<br>32.Alt＋F8是计算变量值</p><p>IntelliJ IDEA使用技巧一览表<br>在使用 InelliJ IDEA 的过程中，通过查找资料以及一些自己的摸索，发现这个众多 Java 程序员喜欢的 IDE 里有许多值得一提的小窍门，如果能熟练的将它们应用于实际开发过程中，相信它会大大节省你的开发时间，而且随之而来的还会有那么一点点成就感：） Try it ！ </p><p>1 、写代码时用 Alt-Insert （ Code|Generate… ）可以创建类里面任何字段的 getter 与 setter 方法。<br>&lt;?xml:namespace prefix = v ns = “urn:schemas-microsoft-com:vml” /&gt; </p><p>2 、右键点击断点标记（在文本的左边栏里）激活速查菜单，你可以快速设置 enable/disable 断点或者条件它的属性。</p><p>3 、 CodeCompletion （代码完成）属性里的一个特殊的变量是，激活 Ctrl-Alt-Space 可以完成在或不在当前文件里的类名。如果类没有引入则 import 标志会自动创建。</p><p>4 、使用 Ctrl-Shift-V 快捷键可以将最近使用的剪贴板内容选择插入到文本。使用时系统会弹出一个含有剪贴内容的对话框，从中你可以选择你要粘贴的部分。 </p><p>5 、利用 CodeCompletion （代码完成）属性可以快速地在代码中完成各种不同地语句，方法是先键入一个类名地前几个字母然后再用 Ctrl-Space 完成全称。如果有多个选项，它们会列在速查列表里。 </p><p>6 、用 Ctrl-/ 与 Ctrl-Shift-/ 来注释 / 反注释代码行与代码块。 </p><p>-/ 用单行注释标记（“ //… ”）来注释 / 反注释当前行或者选择地代码块。而 Ctrl-Shift-/ 则可以用块注释标记（“ /<em>…</em>/ ”）把所选块包围起来。要反注释一个代码块就在块中任何一个地方按 Ctrl-Shift-/ 即可。</p><p>7 、按 Alt-Q （ View|Context Info ）可以不需要移动代码就能查看当前方法地声明。连续按两次会显示当前所编辑的类名。 </p><p>8 、使用 Refactor|Copy Class… 可以创建一个所选择的类的“副本”。这一点很有用，比如，在你想要创建一个大部分内容都和已存在类相同的类时。 </p><p>9 、在编辑器里 Ctrl-D 可以复制选择的块或者没有所选块是的当前行。 </p><p>10 、 Ctrl-W （选择字）在编辑器里的功能是先选择脱字符处的单词，然后选择源代码的扩展区域。举例来说，先选择一个方法名，然后是调用这个方法的表达式，然后是整个语句，然后包容块，等等。</p><p>11 、如果你不想让指示事件细节的“亮球”图标在编辑器上显示，通过按 Alt-Enter 组合键打开所有事件列表然后用鼠标点击它就可以把这个事件文本附件的亮球置成非活动状态。 </p><p>这样以后就不会有指示特殊事件的亮球出现了，但是你仍然可以用 Alt-Enter 快捷键使用它。</p><p>12 、在使用 CodeCompletion 时，可以用逗点（ . ）字符，逗号（，）分号（；），空格和其它字符输入弹出列表里的当前高亮部分。选择的名字会随着输入的字符自动输入到编辑器里。 </p><p>13 、在任何工具窗口里使用 Escape 键都可以把焦点移到编辑器上。 </p><p>Shift-Escape 不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口。 </p><p>F12 键把焦点从编辑器移到最近使用的工具窗口。 </p><p>14 、在调试程序时查看任何表达式值的一个容易的方法就是在编辑器中选择文本（可以按几次 Ctrl-W 组合键更有效地执行这个操作）然后按 Alt-F8 。 </p><p>15 、要打开编辑器脱字符处使用的类或者方法 Java 文档的浏览器，就按 Shift-F1 （右键菜单的 External JavaDoc ）。 </p><p>要使用这个功能须要把加入浏览器的路径，在“ General ”选项中设置（ Options | IDE Settings ），另外还要把创建的 Java 文档加入到工程中（ File | Project Properties ）。 </p><p>16 、用 Ctrl-F12 （ View | File Structure Popup ）键你可以在当前编辑的文件中快速导航。 </p><p>这时它会显示当前类的成员列表。选中一个要导航的元素然后按 Enter 键或 F4 键。要轻松地定位到列表中的一个条目，只需键入它的名字即可。 </p><p>17 、在代码中把光标置于标记符或者它的检查点上再按 Alt-F7 （右键菜单中的 Find Usages… ）会很快地查找到在整个工程中使用地某一个类、方法或者变量的位置。</p><p>18 、按 Ctrl-N （ Go to | Class… ）再键入类的名字可以快速地在编辑器里打开任何一个类。从显示出来的下拉列表里选择类。<br>同样的方法你可以通过使用 Ctrl-Shift-N （ Go to | File… ）打开工程中的非 Java 文件。</p><p>19 、要导航代码中一些地方使用到的类、方法或者变量的声明，把光标放在查看项上再按 Ctrl-B 即可。也可以通过按 Ctrl 键的同时在查看点上单击鼠标键调转到声明处。 </p><p>20 、把光标放到查看点上再按 Ctrl-Alt-B 可以导航到一个抽象方法的实现代码。</p><p>21 、要看一个所选择的类的继承层次，按 Ctrl-H （ Browse Type Hierarchy ）即可。也可以激活编辑器中的继承关系视图查看当前编辑类的继承关系。22 、使用 Ctrl-Shift-F7 （ Search | Highlight Usages in File ）可以快速高亮显示当前文件中某一变量的使用地方。按 Escape 清除高亮显示。 </p><p>23 、用 Alt-F3 （ Search | Incremental Search ）在编辑器中实现快速查查找功能。 </p><p>在“ Search for: ”提示工具里输入字符，使用箭头键朝前和朝后搜索。按 Escape 退出。</p><p>24 、按 Ctrl-J 组合键来执行一些你记不起来的 Live Template 缩写。比如，键“ it ”然后按 Ctrl-J 看看有什么发生。</p><p>25 、 Introduce Variable 整合帮助你简化代码中复杂的声明。举个例子，在下面的代码片断里，在代码中选择一个表达式：然后按 Ctrl-Alt-V 。</p><p>26 、 Ctrl-Shift-J 快捷键把两行合成一行并把不必要的空格去掉以匹配你的代码格式。</p><p>27 、 Ctrl-Shift-Backspace （ Go to | Last Edit Location ）让你调转到代码中所做改变的最后一个地方。 </p><p>多按几次 Ctrl-Shift-Backspace 查看更深的修改历史。 </p><p>28 、用 Tools | Reformat Code… 根据你的代码样式参考（查看 Options | IDE Setting | Code Style ）格式化代码。 </p><p>使用 Tools | Optimize Imports… 可以根据设置（查看 Options | IDE Setting | Code Style | Imports ）自动“优化” imports （清除无用的 imports 等）。</p><p>29 、使用 IDEA 的 Live Templates | Live Templates 让你在眨眼间创建许多典型代码。比如，在一个方法里键入 </p><p>再按 Tab 键看有什么事情发生了。<br>用 Tab 键在不同的模板域内移动。查看 Options | Live Templates 获取更多的细节。</p><p>30 、要查看一个文件中修改的本地历史，激活右键菜单里的 Local VCS | Show History… 。也许你可以导航不同的文件版本，看看它们的不同之处再回滚到以前的任何一个版本吧。 </p><p>使用同样的右键菜单条目还可以看到一个目录里修改的历史。有了这个特性你就不会丢失任何代码了。</p><p>31 、如果要了解主菜单里每一个条目的用途，把鼠标指针移到菜单条目上再应用程序框架的底部的状态栏里就会显示它们的一些简短描述，也许会对你有帮助。 </p><p>32 、要在编辑器里显示方法间的分隔线，打开 Options | IDE Settings | Editor ，选中“ Show method separators ”检查盒（ checkbox ）。 </p><p>33 、用 Alt-Up 和 Alt-Down 键可以在编辑器里不同的方法之间快速移动。 </p><p>34 、用 F2/Shift-F2 键在高亮显示的语法错误间跳转。 </p><p>用 Ctrl-Alt-Down/Ctrl-Alt-Up 快捷键则可以在编译器错误信息或者查找操作结果间跳转。</p><p>35 、通过按 Ctrl-O （ Code | Override Methods… ）可以很容易地重载基本类地方法。 </p><p>要完成当前类 implements 的（或者抽象基本类的）接口的方法，就使用 Ctrl-I （ Code | Implement Methods… ）。 </p><p>36 、如果光标置于一个方法调用的括号间，按 Ctrl-P 会显示一个可用参数的列表。</p><p>37 、要快速查看编辑器脱字符处使用的类或方法的 Java 文档，按 Ctrl-Q （在弹出菜单的 Show Quick JavaDoc 里）即可。 </p><p>38 、像 Ctrl-Q （ Show Quick JavaDoc 显示简洁 Java 文档）， Ctrl-P （ Show Parameter Info 显示参数信息）， Ctrl-B （ Go to Declaration 跳转到声明）， Shift-F1 （ External JavaDoc 外部 Java 文档）以及其它一些快捷键不仅可以在编辑器里使用，也可以应用在代码完成右键列表里。 </p><p>39 、 Ctrl-E （ View | Recent Files ）弹出最近访问的文件右键列表。选中文件按 Enter 键打开。 </p><p>40 、在 IDEA 中可以很容易地对你的类，方法以及变量进行重命名并在所有使用到它们的地方自动更正。 </p><p>试一下，把编辑器脱字符置于任何一个变量名字上然后按 Shift-F6 （ Refactor | Rename… ）。在对话框里键入要显示地新名字再按 Enter 。你会浏览到使用这个变量地所有地方然后按“ Do Refactor ”按钮结束重命名操作。 </p><p>41 、要在任何视图（ Project View 工程视图， Structure View 结构视图或者其它视图）里快速 </p><p>选择当前编辑地部分（类，文件，方法或者字段），按 Alt-F1 （ View | Select in… ）。 </p><p>42 、在“ new ”字符后实例化一个已知类型对象时也许你会用到 SmartType 代码完成这个特性。比如，键入 </p><p>再按 Ctrl-Shift-Space ：</p><p>43 、通过使用 SmartType 代码完成，在 IDEA 中创建接口的整个匿名 implementation 也是非常容易的，比如，对于一些 listener （监听器），可以键入 </p><p>Component component; </p><p>component.addMouseListener( </p><p>  new <caret is here>   </caret></p><p>); </p><p>然后再按 Ctrl-Shift-Space 看看有什么发生了。 </p><p>44 、在你需要设置一个已知类型的表达式的值时用 SmartType 代码完成也很有帮助。比如，键入 </p><p>String s = ( <caret is here>   </caret></p><p>再按 Ctrl-Shift-Space 看看会有什么出现。 </p><p>45 、在所有视图里都提供了速查功能：在树里只需键入字符就可以快速定位到一个条目。 </p><p>46 、当你想用代码片断捕捉异常时，在编辑器里选中这个片断，按 Ctrl-Alt-T （ Code | Surround with… ）然后选择“ try/catch ”。它会自动产生代码片断中抛出的所有异常的捕捉块。在 Options | File Templates | Code tab 中你还可以自己定制产生捕捉块的模板。 </p><p>用列表中的其它项可以包围别的一些结构。 </p><p>47 、在使用代码完成时，用 Tab 键可以输入弹出列表里的高亮显示部分。 </p><p>不像用 Enter 键接受输入，这个选中的名字会覆盖掉脱字符右边名字的其它部分。这一点在用一个方法或者变量名替换另一个时特别有用。 </p><p>48 、在声明一个变量时代码完成特性会给你显示一个建议名。比如，开始键入“ private FileOutputStream ”然后按 Ctrl-Space </p><p>在 Options | IDE Setting | Code Style 中还可以为本地变量，参数，实例及静态字段定制名字。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidstudio </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识widget桌面小组件</title>
      <link href="/2016/04/23/first-use-widget/"/>
      <url>/2016/04/23/first-use-widget/</url>
      <content type="html"><![CDATA[<p>学习android widget的使用，使用高德地图的定位功能中的天气api来获取天气，做了个简单的demo。<a id="more"></a>widget的开发步骤如下：</p><ol><li>编写widget布局和配置文件；</li><li>编写自己的provider继承自AppWidgetProvider；</li><li>使用服务来更新widget；</li><li>修改配置文件。</li></ol><p>开发之前先导入高德定位jar包，修改配置文件添加自己的appkey和相关的权限。（详情请参照：<a href="http://lbs.amap.com/api/android-location-sdk/guide/weather/）" target="_blank" rel="noopener">http://lbs.amap.com/api/android-location-sdk/guide/weather/）</a></p><h3 id="一、编写widget布局文件和配置文件"><a href="#一、编写widget布局文件和配置文件" class="headerlink" title="一、编写widget布局文件和配置文件"></a>一、编写widget布局文件和配置文件</h3><p>这里就添加了一个TextView来显示天气信息；<br>widget配置文件： src/xml/widgetconfig </p><pre><code>&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:initialLayout=&quot;@layout/widget&quot;    android:minHeight=&quot;100dp&quot;    android:minWidth=&quot;200dp&quot;    android:updatePeriodMillis=&quot;860000&quot; &gt;&lt;/appwidget-provider&gt;&lt;/span&gt;</code></pre><h3 id="二、AppWidgetProvider的编写，启动与停止服务。"><a href="#二、AppWidgetProvider的编写，启动与停止服务。" class="headerlink" title="二、AppWidgetProvider的编写，启动与停止服务。"></a>二、AppWidgetProvider的编写，启动与停止服务。</h3><p>在AppWidgetProvider中的主要方法有：<br>onEnabled(Context context)–第一个widget添加时调用<br>onDeleted(Context context, int[] appWidgetIds)–widget被从屏幕移除时调用<br>onDisabled(Context context) –widget 最后一个被从屏幕移除<br>onUpdate(Context context,<br>AppWidgetManager appWidgetManager,<br>int[] appWidgetIds)—刷新widget</p><p>代码：</p><pre><code>package com.tx.weatherwidget;import android.appwidget.AppWidgetManager;import android.appwidget.AppWidgetProvider;import android.content.Context;import android.content.Intent;public class WeatherProvider extends AppWidgetProvider {    /**     * widget第一个添加到桌面执行     */    @Override    public void onEnabled(Context context) {        // TODO Auto-generated method stub        super.onEnabled(context);        Intent intent = new Intent(context, WeatherService.class);        context.startService(intent);    }    /**     * 最后一个widget移除桌面执行     */    @Override    public void onDisabled(Context context) {        // TODO Auto-generated method stub        super.onDisabled(context);        Intent intent = new Intent(context, WeatherService.class);        context.stopService(intent);    }    /**     * 更新数据     */    @Override    public void onUpdate(Context context, AppWidgetManager appWidgetManager,            int[] appWidgetIds) {        // TODO Auto-generated method stub        super.onUpdate(context, appWidgetManager, appWidgetIds);    }}</code></pre><h3 id="三、service的编写，获取天气，widget更新。"><a href="#三、service的编写，获取天气，widget更新。" class="headerlink" title="三、service的编写，获取天气，widget更新。"></a>三、service的编写，获取天气，widget更新。</h3><p>主要代码在updateView中，这里使用RemoteViews，AppWidgetManager的updateAppWidget来通知widget更新。<br>代码：</p><pre><code>package com.tx.weatherwidget;/** * 调用高德地图的天气api获取天气 *  */import android.app.Service;import android.appwidget.AppWidgetManager;import android.content.ComponentName;import android.content.Intent;import android.os.IBinder;import android.widget.RemoteViews;import android.widget.Toast;import com.amap.api.location.AMapLocalWeatherForecast;import com.amap.api.location.AMapLocalWeatherListener;import com.amap.api.location.AMapLocalWeatherLive;import com.amap.api.location.LocationManagerProxy;import com.tx.weatherwidget.R;public class WeatherService extends Service implementsAMapLocalWeatherListener{    private LocationManagerProxy mLocationManagerProxy;    @Override    public IBinder onBind(Intent arg0) {        // TODO Auto-generated method stub        return null;    }    @Override    public void onCreate() {        // TODO Auto-generated method stub        super.onCreate();        init();    }    /**     * 注册天气监听     */    private void init() {        mLocationManagerProxy = LocationManagerProxy.getInstance(this);        mLocationManagerProxy.requestWeatherUpdates(                LocationManagerProxy.WEATHER_TYPE_LIVE, this);    }    @Override    public void onWeatherForecaseSearched(AMapLocalWeatherForecast arg0) {        // TODO Auto-generated method stub    }    @Override    public void onWeatherLiveSearched(AMapLocalWeatherLive aMapLocalWeatherLive) {        // TODO Auto-generated method stub        if(aMapLocalWeatherLive!=null &amp;&amp; aMapLocalWeatherLive.getAMapException().getErrorCode() == 0){            String city = aMapLocalWeatherLive.getCity();//城市            String weather = aMapLocalWeatherLive.getWeather();//天气情况            String windDir = aMapLocalWeatherLive.getWindDir();//风向            String windPower = aMapLocalWeatherLive.getWindPower();//风力            String humidity = aMapLocalWeatherLive.getHumidity();//空气湿度            String reportTime = aMapLocalWeatherLive.getReportTime();//数据发布时间            updateView(&quot;城市： &quot;+city+&#39;\n&#39;+                    &quot;风向： &quot;+windDir+&#39;\n&#39;+                    &quot;风力： &quot;+windPower+&#39;\n&#39;+                    &quot;天气情况： &quot;+weather+&#39;\n&#39;+                    &quot;空气湿度： &quot;+humidity+&#39;\n&#39;+                    &quot;数据发布时间： &quot;+reportTime+&#39;\n&#39;);        }else{            // 获取天气预报失败            Toast.makeText(this,&quot;获取天气预报失败:&quot;+ aMapLocalWeatherLive.getAMapException().getErrorMessage(), Toast.LENGTH_SHORT).show();        }    }    private void updateView(String info){        RemoteViews remoteViews = new RemoteViews(getPackageName(),                R.layout.widget);        remoteViews.setTextViewText(R.id.weather, info);        AppWidgetManager manager = AppWidgetManager.                getInstance(getApplicationContext());        ComponentName provider = new ComponentName(                getApplicationContext(), WeatherProvider.class);        manager.updateAppWidget(provider, remoteViews);    }}</code></pre><h3 id="四、修改配置文件，注册服务。"><a href="#四、修改配置文件，注册服务。" class="headerlink" title="四、修改配置文件，注册服务。"></a>四、修改配置文件，注册服务。</h3><p>代码：</p><pre><code>&lt;receiver android:name=&quot;com.tx.weatherwidget.WeatherProvider&quot; &gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;            &lt;/intent-filter&gt;            &lt;meta-data                android:name=&quot;android.appwidget.provider&quot;                android:resource=&quot;@xml/widgetconfig&quot; /&gt;        &lt;/receiver&gt;        &lt;service android:name=&quot;com.tx.weatherwidget.WeatherService&quot; &gt;        &lt;/service&gt;</code></pre><p>源代码下载：<a href="http://download.csdn.net/detail/txadf/9267497" target="_blank" rel="noopener">weatherWidget</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> widget </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PLSQL安装、连接服务器及字符编码更改</title>
      <link href="/2016/04/23/plsql-install-config/"/>
      <url>/2016/04/23/plsql-install-config/</url>
      <content type="html"><![CDATA[<p>在学习时用oracle时，使用PLSQL客户端来操作数据库，这里简单介绍了它安装相关问题。<a id="more"></a></p><h3 id="一、下载PLSQL并破解"><a href="#一、下载PLSQL并破解" class="headerlink" title="一、下载PLSQL并破解"></a>一、下载PLSQL并破解</h3><p>（看不惯英文的可以安装汉化文件）,下载地址：<a href="http://download.csdn.net/detail/txadf/9259051" target="_blank" rel="noopener">PLSQL+instantclient</a></p><h3 id="二、解压开始安装，"><a href="#二、解压开始安装，" class="headerlink" title="二、解压开始安装，"></a>二、解压开始安装，</h3><p>如下图介绍；并将instantclient放到自己安装的文件位置，便于之后使用。</p><p><img src="http://img.blog.csdn.net/20151110212717528?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><h3 id="三、破解软件"><a href="#三、破解软件" class="headerlink" title="三、破解软件"></a>三、破解软件</h3><p>填写instantclient文件的位置；<br>   （1）、安装完成后运行PLSQL，在弹出的登陆界面直接点击取消，进入；<br>   （2）、帮助—&gt;注册，运行破解文件，将产品编号、序列和口令（密码）对应的填入；<br>   （3）、工具—&gt;首选项，如下图，在‘1’处填      入：D:\software_Study\oracle\instantclient_11_2\network\admin；在‘2’处填入：D:\software_Study\oracle\instantclient_11_2\oci.dll<br>注：如果连接的是服务器端的oracle，需要将‘1’文件夹下的’tnsnames.ora’,用记事本打开，更改第二行的host的值为服务器的ip地址。</p><h3 id="四、配置环境变量（可选操作）"><a href="#四、配置环境变量（可选操作）" class="headerlink" title="四、配置环境变量（可选操作）"></a>四、配置环境变量（可选操作）</h3><p>完成上述步骤后，退出登陆，这里使用在服务器端创建的用户名和密码，数据库选择‘XE’，连接为‘Normal’，便可登陆。<br>如果需要更改字符编码，需配置环境变量，<br>查看服务器编码：select userenv(‘language’) from dual;<br>查看PLSQL客户端编码：select * from V$NLS_PARAMETERS; 看NLS_LANGUAGE值与上一语句值是否相等；<br>我们服务器编码是utf-8，这里不匹配，添加如下环境变量：</p><p>变量名：NLS_LANG<br>值：AMERICAN_AMERICA.AL32UTF8</p>]]></content>
      
      <categories>
          
          <category> 工具软件 </category>
          
          <category> PL/SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> PL/SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android开发较好的blog</title>
      <link href="/2016/04/23/excellent-blog-author-of-android/"/>
      <url>/2016/04/23/excellent-blog-author-of-android/</url>
      <content type="html"><![CDATA[<p>作为初学者，跟着大神的脚步才能成为大神，少走弯路。以下是个人收藏的一些blog。<a id="more"></a><br>CSDN博客：<br>    郭霖:<a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog</a><br>    鸿洋：<a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791</a><br>    IT_xiao小巫：<a href="http://blog.csdn.net/wwj_748" target="_blank" rel="noopener">http://blog.csdn.net/wwj_748</a><br>    Mr.Simple：<a href="http://blog.csdn.net/bboyfeiyu" target="_blank" rel="noopener">http://blog.csdn.net/bboyfeiyu</a><br>    爱哥：<a href="http://blog.csdn.net/aigestudio" target="_blank" rel="noopener">http://blog.csdn.net/aigestudio</a><br>   老罗：<a href="http://blog.csdn.net/luoshengyang" target="_blank" rel="noopener">http://blog.csdn.net/luoshengyang</a><br>    任玉刚：<a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="noopener">http://blog.csdn.net/singwhatiwanna</a><br>    夏安明：<a href="http://blog.csdn.net/xiaanming" target="_blank" rel="noopener">http://blog.csdn.net/xiaanming</a><br>    徐医生：<a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="noopener">http://blog.csdn.net/eclipsexys</a><br>    郭神：<a href="http://blog.csdn.net/sinyu890807/" target="_blank" rel="noopener">http://blog.csdn.net/sinyu890807/</a><br>    张兴业：<a href="http://blog.csdn.net/xyz_lmn/" target="_blank" rel="noopener">http://blog.csdn.net/xyz_lmn/</a><br>    咪当系欧巴：<a href="http://blog.csdn.net/hellogv" target="_blank" rel="noopener">http://blog.csdn.net/hellogv</a><br>个人Blog<br>    张涛：<a href="http://www.kymjs.com/" target="_blank" rel="noopener">http://www.kymjs.com/</a><br>    码农明明桑：<a href="http://blog.isming.me/" target="_blank" rel="noopener">http://blog.isming.me/</a><br>     张明云：<a href="http://zmywly8866.github.io/pages/archive.html" target="_blank" rel="noopener">http://zmywly8866.github.io/pages/archive.html</a><br>    郝锡强：<a href="http://www.haoxiqiang.info/static/timing.html" target="_blank" rel="noopener">http://www.haoxiqiang.info/static/timing.html</a><br>    胡凯：<a href="http://hukai.me/blog/archives/" target="_blank" rel="noopener">http://hukai.me/blog/archives/</a><br>    农民伯伯：<a href="http://www.cnblogs.com/over140/" target="_blank" rel="noopener">http://www.cnblogs.com/over140/</a><br>    Trinea：<a href="http://www.trinea.cn/" target="_blank" rel="noopener">http://www.trinea.cn/</a><br>    daimajia：<a href="http://blog.daimajia.com/" target="_blank" rel="noopener">http://blog.daimajia.com/</a><br>    stay4it：<a href="http://www.cnblogs.com/stay/" target="_blank" rel="noopener">http://www.cnblogs.com/stay/</a><br>    stormzhang：<a href="http://stormzhang.com/posts.html" target="_blank" rel="noopener">http://stormzhang.com/posts.html</a><br>    Coder Robin：<a href="http://coderrobin.com/" target="_blank" rel="noopener">http://coderrobin.com/</a> </p><p>更多资料：<br><a href="http://blog.csdn.net/txadf/article/details/49965053" target="_blank" rel="noopener">Android学习资源网站大全</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PhotoView与GifView的使用</title>
      <link href="/2016/04/23/PhotoView_GifView/"/>
      <url>/2016/04/23/PhotoView_GifView/</url>
      <content type="html"><![CDATA[<p>为了解决图片的缩放和gif格式的图片显示问题，这里采用了开源库PhototView(处理图片缩放问题)和GifView(显示gif格式图片)。<a id="more"></a><br><a href="http://download.csdn.net/detail/txadf/9204419" target="_blank" rel="noopener">PhototView下载路径</a>，<a href="http://download.csdn.net/detail/txadf/9204413" target="_blank" rel="noopener">GifView下载路径</a>，<a href="http://download.csdn.net/detail/txadf/9204481" target="_blank" rel="noopener">Demo下载路径</a></p><h3 id="1、PhotoView加载本地图片"><a href="#1、PhotoView加载本地图片" class="headerlink" title="1、PhotoView加载本地图片"></a>1、PhotoView加载本地图片</h3><pre><code>/** * PhotoView 加载本地图片 */private ImageView mImageView;private PhotoViewAttacher mPhotoViewAttacher;protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    requestWindowFeature(Window.FEATURE_NO_TITLE);    setContentView(R.layout.photoview_local);    mImageView = (ImageView) findViewById(R.id.iv_img);    mPhotoViewAttacher = new PhotoViewAttacher(mImageView);    try {        InputStream inputStream = getAssets().open(&quot;testPhotoView.jpg&quot;);        Bitmap bitmap = BitmapFactory.decodeStream(inputStream);        mImageView.setImageBitmap(bitmap);&lt;/span&gt;    } catch (IOException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}</code></pre><h3 id="2、PhotoView加载网络图片："><a href="#2、PhotoView加载网络图片：" class="headerlink" title="2、PhotoView加载网络图片："></a>2、PhotoView加载网络图片：</h3><pre><code>/** * PhotoView 加载网络图片 */private PhotoView mImageView;private PhotoViewAttacher mPhotoViewAttacher;private ImageLoader mImageLoader;private  String URL = &quot;http://pic3.nipic.com/20090525/2416945_231841034_2.jpg&quot;;@Overrideprotected void onCreate(Bundle savedInstanceState) {    // TODO Auto-generated method stub    super.onCreate(savedInstanceState);    requestWindowFeature(Window.FEATURE_NO_TITLE);    setContentView(R.layout.photoview_network);    mImageView = (PhotoView) findViewById(R.id.iv_img);    mPhotoViewAttacher = new PhotoViewAttacher(mImageView);    mImageLoader = ImageLoader.getInstance();    mImageLoader.displayImage(URL, mImageView);    mImageView.setOnPhotoTapListener(new OnPhotoTapListener() {        @Override        public void onPhotoTap(View arg0, float arg1, float arg2) {            // TODO Auto-generated method stub        }    });}</code></pre><p>布局文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot; &gt;    &lt;uk.co.senab.photoview.PhotoView        android:id=&quot;@+id/iv_img&quot;        android:layout_width=&quot;fill_parent&quot;        android:layout_height=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt;&lt;/span&gt;</code></pre><h3 id="3、GifView加载本地图片："><a href="#3、GifView加载本地图片：" class="headerlink" title="3、GifView加载本地图片："></a>3、GifView加载本地图片：</h3><pre><code>private GifView mGifView;@Overrideprotected void onCreate(Bundle savedInstanceState) {    // TODO Auto-generated method stub    super.onCreate(savedInstanceState);    requestWindowFeature(Window.FEATURE_NO_TITLE);    setContentView(R.layout.gifview);    mGifView = (GifView) findViewById(R.id.gifview);    //加载本地图片    mGifView.setGifImage(R.drawable.gifview);}</code></pre><p>布局文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:gravity=&quot;center&quot;    android:orientation=&quot;vertical&quot; &gt;    &lt;com.ant.liao.GifView        android:id=&quot;@+id/gifview&quot;        android:layout_width=&quot;fill_parent&quot;        android:layout_height=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt;&lt;/span&gt;</code></pre>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 图片缩放 </tag>
            
            <tag> gif </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 打开其他应用</title>
      <link href="/2016/04/23/open-other-app/"/>
      <url>/2016/04/23/open-other-app/</url>
      <content type="html"><![CDATA[<p>在开发中，有时需要在自己的应用中打开其他应用，自己写了两个方法来获取手机上安装的所有应用。这里主要以打开支付宝为例。<a id="more"></a><br>（1）、获取手机上的所有应用，将其放在一个list中。</p><pre><code>private List&lt;PackageInfo&gt; getAllApps() {         List&lt;PackageInfo&gt; apps = new ArrayList&lt;PackageInfo&gt;();         PackageManager packageManager = this.getPackageManager();         //获取手机内所有应用         List&lt;PackageInfo&gt; paklist = packageManager.getInstalledPackages(0);         for (int i = 0; i &lt; paklist.size(); i++) {             PackageInfo pak = (PackageInfo) paklist.get(i);             //判断是否为非系统预装的应用  (大于0为系统预装应用，小于等于0为非系统应用)           if ((pak.applicationInfo.flags &amp; pak.applicationInfo.FLAG_SYSTEM) &lt;= 0) {                 apps.add(pak);             }         }         return apps;     }  </code></pre><p>（2）、打开指定的app(这里打开的是支付宝)。下面的方法是在知道支付宝app的包名的情况下进行判断的，通常情况下不知道包名，可以通过appLabel可以获取应用的名称，以此来匹配。在不存在的情况下，使用手机自带浏览器打开指定的网页。</p><pre><code>private static final String PAY_PACKAGE_NAME = &quot;com.eg.android.AlipayGphone&quot;;private static final String PAY_WEB_URL = &quot;https://auth.alipay.com/login/index.htm&quot;;private void launchApp() {       PackageManager packageManager = this.getPackageManager();       List&lt;PackageInfo&gt; packages = getAllApps();       PackageInfo pa = null;       for(int i=0;i&lt;packages.size();i++){           pa = packages.get(i);           //获得应用名           String appLabel = packageManager.getApplicationLabel(pa.applicationInfo).toString();           //获得包名           String appPackage = pa.packageName;         Log.e(&quot;test&quot;, &quot;&quot;+i+&quot;----&quot;+appLabel+&quot;  &quot;+appPackage);           //安装支付宝，打开支付宝        if(appPackage.equals(PAY_PACKAGE_NAME)){            mIntent = packageManager.getLaunchIntentForPackage(PAY_PACKAGE_NAME);            startActivity(mIntent);             return;        }    }     //为安装支付宝，打开支付宝登陆的网页    mIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(PAY_WEB_URL));    mIntent.setClassName(&quot;com.android.browser&quot;, &quot;com.android.browser.BrowserActivity&quot;);    startActivity(mIntent);}   </code></pre><p>最后，注意添加网络访问的权限。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 打开应用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android自动获取短信验证码</title>
      <link href="/2016/04/23/auto-filin-smscode/"/>
      <url>/2016/04/23/auto-filin-smscode/</url>
      <content type="html"><![CDATA[<p>这里主要使用了<strong>ContentObserver</strong>类（观察者模式类）来监听短信的变化，然后通过<strong>正则表达式</strong>，提取出短信，然后在子线程中更新UI，显示验证码。<a id="more"></a><br>所谓的观察者模式，它是软件设计模式的一种，在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。观察者模式（Observer）完美的将观察者和被观察的对象分离开，在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。观察者设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。<br>ContentObserver,内容观察者，目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当 ContentObserver 所观察的Uri发生变化时，便会触发它。<br>观察特定Uri的步骤如下：</p><ol><li>、创建我们特定的 ContentObserver 派生类，必须重载父类构造方法，必须重载 onChange() 方法去处理回调后的功能实现。</li><li>利用 context.getContentResolover() 获得 ContentResolove 对象，接着调用 registerContentObserver() 方法去注册内容观察者。</li><li>由于 ContentObserver 的生命周期不同步于 Activity 和 Service 等，因此，在不需要时，需要手动的调用 unregisterContentObserver() 去取消注册。</li></ol><p><em>具体使用：</em></p><h3 id="1、继承ContentObserver，重写onChange方法"><a href="#1、继承ContentObserver，重写onChange方法" class="headerlink" title="1、继承ContentObserver，重写onChange方法"></a>1、继承ContentObserver，重写onChange方法</h3><pre><code>package com.tx.testsms;/** * 自动读取短信验证码 */import java.util.regex.Matcher;import java.util.regex.Pattern;import android.content.Context;import android.database.ContentObserver;import android.database.Cursor;import android.net.Uri;import android.os.Handler;import android.util.Log;public class SmsObserver extends ContentObserver {    private Context mContext;    private Handler mHandler;    private String tel_phone = &quot;&quot;;    private String code;    public void setTel_phone(String tel_phone) {        this.tel_phone = tel_phone;    }    public SmsObserver(Context mContext, Handler handler) {        super(handler);        this.mContext = mContext;        this.mHandler = handler;    }    @Override    public void onChange(boolean selfChange, Uri uri) {        // TODO Auto-generated method stub        super.onChange(selfChange, uri);        if(uri.toString().equals(&quot;content:://sms//raw&quot;)){            return;        }        Uri inboxUri = Uri.parse(&quot;content://sms//inbox&quot;);        Cursor cursor = mContext.getContentResolver().                query(inboxUri, null, null, null, &quot;date desc&quot;);        if(cursor!=null){            if(cursor.moveToFirst()){                String address = cursor.getString(cursor.getColumnIndex(&quot;address&quot;));                Log.i(&quot;test&quot;, &quot;短信验证码为：--------&quot;+address);                String body = cursor.getString(cursor.getColumnIndex(&quot;body&quot;));                Log.i(&quot;test&quot;, &quot;uri---------&quot;+inboxUri);                if(address.equals(tel_phone)){                    Pattern pattern = Pattern.compile(&quot;(\\d{4})&quot;);                    Matcher matcher = pattern.matcher(body);                    if(matcher.find()){                        code = matcher.group(0);                        Log.i(&quot;test&quot;, &quot;短信验证码为：--------&quot;+code);                        mHandler.obtainMessage(                                MainActivity.MSG_RECEIVED_CODE,code).sendToTarget();                    }                }            }            cursor.close();        }    }}</code></pre><h3 id="2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册"><a href="#2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册" class="headerlink" title="2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册"></a>2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册</h3><pre><code>package com.tx.testsms;import android.app.Activity;import android.net.Uri;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.view.View;import android.view.View.OnClickListener;import android.view.Window;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends Activity {    public static final int MSG_RECEIVED_CODE = 1;    private SmsObserver mSmsObserver;    private Handler mHandler;    private EditText metPhone;    private TextView mtvCode;    private Button mbtnButton;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        requestWindowFeature(Window.FEATURE_NO_TITLE);        setContentView(R.layout.activity_main);        metPhone = (EditText) findViewById(R.id.phone);        mbtnButton = (Button) findViewById(R.id.btn);        mtvCode = (TextView) findViewById(R.id.code);        /**         * 设置手机号，拦截固定的手机号         */        mbtnButton.setOnClickListener(new OnClickListener() {            @Override            public void onClick(View arg0) {                // TODO Auto-generated method stub                mSmsObserver.setTel_phone(metPhone.getText().toString());            }        });        /**         * 在子线程中更新UI         */        mHandler = new Handler(){            @Override            public void handleMessage(Message msg) {                // TODO Auto-generated method stub                super.handleMessage(msg);                if(msg.what == MSG_RECEIVED_CODE){                    mtvCode.setText(&quot;四位短信验证码为：&quot;+msg.obj.toString());                    Toast.makeText(getApplicationContext(), msg.obj.toString(), Toast.LENGTH_SHORT).show();                }            }        };        &lt;span style=&quot;color:#ff0000;&quot;&gt;/**         * 实例化ContentObserver,注册短信监听         */        mSmsObserver = new SmsObserver(getApplicationContext(), mHandler);        Uri  uri = Uri.parse(&quot;content://sms&quot;);        getContentResolver().registerContentObserver(uri, true, mSmsObserver);&lt;/span&gt;    }    /**     * 由于 ContentObserver 的生命周期不同步于 Activity 和 Service ，     * 因此需要手动取消注册     *      */    @Override    protected void onDestroy() {        // TODO Auto-generated method stub        super.onDestroy();        &lt;span style=&quot;color:#ff0000;&quot;&gt;getContentResolver().unregisterContentObserver(mSmsObserver);&lt;/span&gt;    }}</code></pre><h3 id="3、注意在配置文件中添加读取短信的权限："><a href="#3、注意在配置文件中添加读取短信的权限：" class="headerlink" title="3、注意在配置文件中添加读取短信的权限："></a>3、注意在配置文件中添加读取短信的权限：</h3><pre><code> &lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt;</code></pre><p><strong>注意：最小sdk为16.</strong></p><h3 id="4、如下运行截图："><a href="#4、如下运行截图：" class="headerlink" title="4、如下运行截图："></a>4、如下运行截图：</h3><p><img src="http://img.blog.csdn.net/20151017130345615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br>控制台打印出的Log：<br><img src="http://img.blog.csdn.net/20151017130527628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>例子源代码：<a href="http://download.csdn.net/detail/txadf/9188791" target="_blank" rel="noopener">http://download.csdn.net/detail/txadf/9188791</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 验证码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android SQLite学习手册</title>
      <link href="/2016/04/23/android-sqlite-notebook/"/>
      <url>/2016/04/23/android-sqlite-notebook/</url>
      <content type="html"><![CDATA[<p> 在实际的应用中，SQLite作为目前最为流行的开源嵌入式关系型数据库，在系统的架构设计中正在扮演着越来越为重要的角色。和很多其它嵌入式NoSQL数据库不同的是，SQLite支持很多关系型数据库的基本特征，这在数据移植、程序演示等应用中有着不可替代的优势。<a id="more"></a>从官方文档中我们可以获悉到，SQLite支持的数据量和运行效率都是非常骄人的，因此在海量数据的解决方案中，SQLite可以作为数据预计算的桥头堡，从而显著减少存储在关系型数据库服务器中的数据数量，最终提高系统的查询效率和运行期效率，同时也可以显著的降低数据备份的磁盘开销</p><h4 id="SQLite学习手册-开篇"><a href="#SQLite学习手册-开篇" class="headerlink" title="SQLite学习手册(开篇)"></a>SQLite学习手册(开篇)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/09/2317603.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/09/2317603.html</a><br>一、简介<br>二、SQLite的主要优点<br>三、和RDBMS相比SQLite的一些劣势<br>四、个性化特征</p><h4 id="SQLite学习手册-C-C-接口简介"><a href="#SQLite学习手册-C-C-接口简介" class="headerlink" title="SQLite学习手册(C/C++接口简介)"></a>SQLite学习手册(C/C++接口简介)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321386.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321386.html</a><br>一、概述<br>二、核心对象和接口<br>三、参数绑定</p><h4 id="SQLite学习手册-数据表和视图"><a href="#SQLite学习手册-数据表和视图" class="headerlink" title="SQLite学习手册(数据表和视图)"></a>SQLite学习手册(数据表和视图)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321668.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321668.html</a><br>一、创建数据表<br>二、表的修改<br>三、表的删除<br>四、创建视图<br>五、删除视图</p><h4 id="SQLite学习手册-内置函数"><a href="#SQLite学习手册-内置函数" class="headerlink" title="SQLite学习手册(内置函数)"></a>SQLite学习手册(内置函数)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2322027.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2322027.html</a><br>一、聚合函数<br>二、核心函数<br>三、日期和时间函数</p><h4 id="SQLite学习手册-索引和数据分析-清理"><a href="#SQLite学习手册-索引和数据分析-清理" class="headerlink" title="SQLite学习手册(索引和数据分析/清理)"></a>SQLite学习手册(索引和数据分析/清理)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322335.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322335.html</a><br>一、创建索引<br>二、删除索引<br>三、重建索引<br>四、数据分析<br>五、数据清理</p><h4 id="SQLite学习手册-数据库和事物"><a href="#SQLite学习手册-数据库和事物" class="headerlink" title="SQLite学习手册(数据库和事物)"></a>SQLite学习手册(数据库和事物)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322575.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322575.html</a><br>一、Attach数据库<br>二、Detach数据库<br>三、事物</p><h4 id="SQLite学习手册-表达式"><a href="#SQLite学习手册-表达式" class="headerlink" title="SQLite学习手册(表达式)"></a>SQLite学习手册(表达式)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/16/2323907.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/16/2323907.html</a><br>一、常用表达式<br>二、条件表达式<br>三、转换表达式</p><h4 id="SQLite学习手册-数据类型"><a href="#SQLite学习手册-数据类型" class="headerlink" title="SQLite学习手册(数据类型)"></a>SQLite学习手册(数据类型)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325258.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325258.html</a><br>一、存储种类和数据类型<br>二、类型亲缘性<br>三、比较表达式<br>四、操作符</p><h4 id="SQLite学习手册-命令行工具"><a href="#SQLite学习手册-命令行工具" class="headerlink" title="SQLite学习手册(命令行工具)"></a>SQLite学习手册(命令行工具)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325981.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325981.html</a></p><h4 id="SQLite学习手册-在线备份"><a href="#SQLite学习手册-在线备份" class="headerlink" title="SQLite学习手册(在线备份)"></a>SQLite学习手册(在线备份)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/19/2326309.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/19/2326309.html</a><br>一、常用备份<br>二、在线备份APIs简介<br>三、高级应用技巧</p><h4 id="SQLite学习手册-内存数据库"><a href="#SQLite学习手册-内存数据库" class="headerlink" title="SQLite学习手册(内存数据库)"></a>SQLite学习手册(内存数据库)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/20/2328348.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/20/2328348.html</a><br>一、内存数据库<br>二、临时数据库</p><h4 id="SQLite学习手册-临时文件"><a href="#SQLite学习手册-临时文件" class="headerlink" title="SQLite学习手册(临时文件)"></a>SQLite学习手册(临时文件)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/21/2328483.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/21/2328483.html</a><br>一、简介<br>二、具体说明<br>三、相关的编译时参数和指令<br>四、其它优化策略</p><h4 id="SQLite学习手册-锁和并发控制"><a href="#SQLite学习手册-锁和并发控制" class="headerlink" title="SQLite学习手册(锁和并发控制)"></a>SQLite学习手册(锁和并发控制)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/22/2328753.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/01/22/2328753.html</a><br>一、概述<br>二、文件锁<br>三、回滚日志<br>四、数据写入<br>五、SQL级别的事物控制</p><h4 id="SQLite学习手册-实例代码-lt-一-gt"><a href="#SQLite学习手册-实例代码-lt-一-gt" class="headerlink" title="SQLite学习手册(实例代码&lt;一&gt;)"></a>SQLite学习手册(实例代码&lt;一&gt;)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2340780.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2340780.html</a><br>一、获取表的Schema信息<br>二、常规数据插入</p><h4 id="SQLite学习手册-实例代码-lt-二-gt"><a href="#SQLite学习手册-实例代码-lt-二-gt" class="headerlink" title="SQLite学习手册(实例代码&lt;二&gt;)"></a>SQLite学习手册(实例代码&lt;二&gt;)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2341480.html" target="_blank" rel="noopener">http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2341480.html</a><br>三、高效的批量数据插入<br>四、数据查询</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> SQLit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> SQLit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQLit相关类的介绍及使用</title>
      <link href="/2016/04/23/android-sqlite-use/"/>
      <url>/2016/04/23/android-sqlite-use/</url>
      <content type="html"><![CDATA[<p>本文主要介绍了SQLit中相关的几个类（SQLiteDatabase、ContentValues、SQLiteOpenHelper）中的常用的方法及其作用。<br><a id="more"></a></p><h2 id="1-SQLiteDatabase类"><a href="#1-SQLiteDatabase类" class="headerlink" title="1. SQLiteDatabase类"></a><strong>1. SQLiteDatabase类</strong></h2><p>（对 SQLite数据库增、删、改、查的操作）<br> 常用方法</p><pre><code>execSQL(String  sql);execSQL(String sql, String[] args);</code></pre><p>示例：删除 person表中personId＝1的记录：</p><pre><code>SQLiteDatabase db=this.getWritableDatabase();db.execSQL(“delete from  person where personId=?”,newString[]{“1”});db.execSQL(“delete from  person where personId=1”);</code></pre><p>提示：this是 SQLiteOpenHelper类的实例，该类稍后介绍。</p><h4 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h4><pre><code>Context.openOrCreateDatabase(Stringdbname,int mode);</code></pre><p>作用：打开数据库，若数据库未创建则创建数据库。<br>参数－dbname：数据库文件名。<br>参数－mode：访问权限，有以下常量选择：<br>1、MODE_PRIVATE：不允许其它应用程序访问本数据库。<br>2、MODE_WORLD_READABLE：允许其它应用程序读本数据库。<br>3、MODE_WORLD_WRITEABLE：允许其它应用程序写本数据库。<br>4、MODE_APPEND：若数据库已存在，则允向数据库中许添加数据。</p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><pre><code>long insert(TABLE_NAME, String nullColumnHack, ContentValues   contentValues);</code></pre><p>作用：添加记录。<br>参数－TABLE_NAME：表名。<br>参数－nullColumnHack：若插入的数据是空行，则本参数必须设置为 null。<br>参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre><code>int delete(TABLE_NAME, String  where, String[]  whereValue);</code></pre><p>作用：删除记录。<br>参数－TABLE_NAME：表名。<br>参数－where：删除的条件，相当于 SQL语句中的where部分的 SQL命令。<br>参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。<br>示例：删除当前数据库中表peson中，字段 personId值为1的行，代码如下：</p><pre><code>delete(“person”,”personId=?”,newString[]{“1”});</code></pre><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><pre><code>int update(TABLE_NAME, contentValues,String  where, String[] whereValue) ;</code></pre><p>作用：更新记录。<br>参数－TABLE_NAME：表名。<br>参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据。可<br>存放多个键－值对数据，代表需要更新的数据。<br>参数－where：更新的条件，相当于 SQL语句中的where部分的 SQL命令。<br>参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。<br>示例：更新当前数据库的person表中,personId＝1的记录，代码如下：</p><pre><code>ContentValues  values=new ContentValues();//创建可存操作的键－值对的对象values.put(“name”,”李四”);//存放姓名数据values.put(“phone”,”13315577889”);//存放电话数据//实例化SQLiteDatabase对象SQLiteDatabase db=this.getWritableDatabase();db.update(“person” ,values,”personId=?”，new String[]{“1”);//更新数据</code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code>Cursor rawQuery(String sql,String[]selectionArgs);</code></pre><p>作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。<br>参数－sql：查询的 SQL命令。<br>参数－selectionArgs：查询的条件数据。<br>提示：<br>(1)Cursor类稍后介绍。<br>(2)若 sql中没有占位符，则第二个参数设置为 null。<br>(3)对数据表进行变更操作时，使用execSQL，对数据表进行查询时，使用rawQuery<br>方法。</p><pre><code>Cursorquery(table,projection,selection,selectionArgs,groupby,having,orderby);</code></pre><p>作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。<br>cursor :返回值类型，返回查询结果游标对象。<br>  table : String ,要查询的表名。<br>  projection : String[]，要查询的列名，如果为 null，则查询所有列。<br>  selection : String,查询条件。<br>  selectionArgs:String[]为selection中的？补值的数组。<br>  groupby : String,分组列的列名。<br>  having:String,分组在查询的条件。<br>  orderby:String排序列的列名。</p><h2 id="2、ContentValues类"><a href="#2、ContentValues类" class="headerlink" title="2、ContentValues类"></a>2、ContentValues类</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ContentValues类包装了HashMap类，该类用于存取键－值对的数据，每个键－值对数<br>据表示一列的列名和该列的数据。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>ContentValues();</code></pre><p>作用：无参构造方法，创建一个内部成员变量为 HashMap&lt;String,Object&gt;的对象。</p><pre><code>void put(String key,Object value);</code></pre><p>作用：向成员变量 mValues中存放一个键－值对数据。<br>提示：value可以是 Java的所有基本数据类型、数组、对象的类型。</p><pre><code>Object** get(String key);</code></pre><p>作用：获取键名 key对应的值。</p><pre><code>XXX getAsXXX(String key);</code></pre><p>作用：返回 XXX类型的值。<br>提示：XXX可以是所有基本类型的包装类，如 Integer，还有AsByteArray（字节数组类型）。</p><h2 id="3-、SQLiteOpenHelper类"><a href="#3-、SQLiteOpenHelper类" class="headerlink" title="3 、SQLiteOpenHelper类"></a>3 、SQLiteOpenHelper类</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>SQLiteOpenHelper类是Android提供的用于操作 SQLite数据库的工具类，该工具类能<br>方便地创建数据库、表，以及管理数据库版本。</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>synchronized SQLiteDatabasegetReadableDatabase();</code></pre><p>作用：以读写的方式打开数据库对应的 SQLiteDatabase类的对象。<br>提示：synchronized关键字定义该方法为线程同步。</p><pre><code>synchronized SQLiteDatabasegetWriteableDatabase();</code></pre><p>作用：以写的方式创建或打开数据库对应的 SQLiteDatabase类的对象。</p><pre><code> abstract onCreate(SQLiteDatabase db);</code></pre><p>作用：首次创建数据库时，回调本方法。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> SQLit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> SQLit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 开源项目分类汇总</title>
      <link href="/2016/04/23/open-source/"/>
      <url>/2016/04/23/open-source/</url>
      <content type="html"><![CDATA[<p>在github上看见的开源android 代码，十分全面，内容如下：</p><p>目前包括：<br>Android 开源项目第一篇——个性化控件(View)篇<br>  包括ListView、ActionBar、Menu、ViewPager、Gallery、GridView、ImageView<a id="more"></a>、ProgressBar、TextView、ScrollView、TimeView、TipView、FlipView、ColorPickView、GraphView、UI Style、其他<br>Android 开源项目第二篇——工具库篇<br>  包括依赖注入、图片缓存、网络请求、数据库 ORM 工具包、Android 公共库、高版本向低版本兼容库、多媒体、事件总线、传感器、安全、插件化、文件、其他<br>Android 开源项目第三篇——优秀项目篇<br>  比较有意思的完整的 Android 项目<br>Android 开源项目第四篇——开发及测试工具篇<br>  包括开发效率工具、开发自测相关、测试工具、开发及编译环境、其他<br>Android 开源项目第五篇——优秀个人和团体篇<br>  乐于分享并且有一些很不错的开源项目的个人和组织，包括 JakeWharton、Chris Banes、Koushik Dutta 等大牛<br>github地址：<a href="https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6view" target="_blank" rel="noopener">https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6view</a><br>希望对大家有帮助。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 开源框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>收集的Android开源框架及其地址</title>
      <link href="/2016/04/23/open-source-frame/"/>
      <url>/2016/04/23/open-source-frame/</url>
      <content type="html"><![CDATA[<h3 id="1、volley"><a href="#1、volley" class="headerlink" title="1、volley"></a>1、volley</h3><p>项目地址 <a href="https://github.com/smanikandan14/Volley-demo" target="_blank" rel="noopener">https://github.com/smanikandan14/Volley-demo</a><br>JSON，图像等的异步下载；<br>网络请求的排序（scheduling）<br>网络请求的优先级处理<br>缓存<br>多级别取消请求和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）<br><a id="more"></a></p><h3 id="2、android-async-http"><a href="#2、android-async-http" class="headerlink" title="2、android-async-http"></a>2、android-async-http</h3><p>项目地址：<a href="https://github.com/loopj/android-async-http，文档介绍：http://loopj.com/android-async-http/" target="_blank" rel="noopener">https://github.com/loopj/android-async-http，文档介绍：http://loopj.com/android-async-http/</a> </p><p>在匿名回调中处理请求结果<br>在UI线程外进行http请求<br>文件断点上传<br>智能重试<br>默认gzip压缩<br>支持解析成Json格式<br>可将Cookies持久化到SharedPreferences</p><h3 id="3、Afinal框架"><a href="#3、Afinal框架" class="headerlink" title="3、Afinal框架"></a>3、Afinal框架</h3><p>项目地址：<a href="https://github.com/yangfuhai/afinal" target="_blank" rel="noopener">https://github.com/yangfuhai/afinal</a></p><p>主要有四大模块：</p><p>数据库模块：Android中的orm框架，使用了线程池对sqlite进行操作。<br>注解模块：Android中的ioc框架，完全注解方式就可以进行UI绑定和事件绑定。无需findViewById和setClickListener等。<br>网络模块：通过httpclient进行封装http数据请求，支持Ajax方式加载，支持下载、上传文件功能。<br>图片缓存模块：通过FinalBitmap，imageview加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。<br>　　FinalBitmap可以配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。FinalBitmap的内存管理使用lru算法，没有使用弱引用（Android2.3以后Google已经不建议使用弱引用，Android2.3后强行回收软引用和弱引用，详情查看Android官方文档），更好的管理bitmap内存。FinalBitmap可以自定义下载器，用来扩展其他协议显示网络图片，比如ftp等。同时可以自定义bitmap显示器，</p><p>　　在imageview显示图片的时候播放动画等（默认是渐变动画显示）。</p><h3 id="4、xUtils框架"><a href="#4、xUtils框架" class="headerlink" title="4、xUtils框架"></a>4、xUtils框架</h3><p>项目地址：<a href="https://github.com/wyouflf/xUtils，主要有四大模块：" target="_blank" rel="noopener">https://github.com/wyouflf/xUtils，主要有四大模块：</a><br><strong>数据库模块：</strong><br>Android 中的 orm 框架，一行代码就可以进行增删改查；<br>支持事务，默认关闭；<br>可通过注解自定义表名，列名，外键，唯一性约束，NOT NULL约束，CHECK约束等（需要混淆的时候请注解表名和列名）；<br>支持绑定外键，保存实体时外键关联实体自动保存或更新；<br>自动加载外键关联实体，支持延时加载；<br>支持链式表达查询，更直观的查询语义，参考下面的介绍或sample中的例子。<br><strong>注解模块：</strong></p><p>Android中的 ioc 框架，完全注解方式就可以进行 UI，资源和事件绑定；<br>新的事件绑定方式，使用混淆工具混淆后仍可正常工作；<br>目前支持常用的20种事件绑定，参见 View Common Event Listener 类和包com.lidroid.xutils.view.annotation.event。<br><strong>网络模块：</strong></p><p>支持同步，异步方式的请求；<br>支持大文件上传，上传大文件不会oom；<br>支持GET，POST，PUT，MOVE，COPY，DELETE，HEAD，OPTIONS，TRACE，CONNECT请求；<br>下载支持301/302重定向，支持设置是否根据Content-Disposition重命名下载的文件；<br>返回文本内容的请求（默认只启用了GET请求）支持缓存，可设置默认过期时间和针对当前请求的过期时间。<br><strong>图片缓存模块：</strong></p><p>加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象；<br>支持加载网络图片和本地图片；<br>内存管理使用lru算法，更好的管理bitmap内存；<br>可配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。</p><h3 id="5、ThinkAndroid"><a href="#5、ThinkAndroid" class="headerlink" title="5、ThinkAndroid"></a>5、ThinkAndroid</h3><p>项目地址：<a href="https://github.com/white-cat/ThinkAndroid" target="_blank" rel="noopener">https://github.com/white-cat/ThinkAndroid</a></p><p>主要有以下模块：</p><p><strong>MVC模块：</strong>实现视图与模型的分离。<br><strong>ioc模块：</strong> Android中的ioc模块，完全注解方式就可以进行UI绑定、res中的资源的读取、以及对象的初始化。<br><strong>数据库模块：</strong> Android中的orm框架，使用了线程池对sqlite进行操作。<br><strong>http模块：</strong> 通过httpclient进行封装http数据请求，支持异步及同步方式加载。<br><strong>缓存模块：</strong> 通过简单的配置及设计可以很好的实现缓存，对缓存可以随意的配置<br><strong>图片缓存模块：</strong> i mageview加载图片的时候无需考虑图片加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。<br><strong>配置器模块：</strong> 可以对简易的实现配对配置的操作，目前配置文件可以支持Preference、Properties对配置进行存取。<br><strong>日志打印模块</strong>：可以较快的轻易的是实现日志打印，支持日志打印的扩展，目前支持对sdcard写入本地打印、以及控制台打印<br><strong>下载器模块</strong>：可以简单的实现多线程下载、后台下载、断点续传、对下载进行控制、如开始、暂停、删除等等。<br><strong>网络状态检测模块</strong>：当网络状态改变时，对其进行检。</p><h3 id="6、LoonAndroid"><a href="#6、LoonAndroid" class="headerlink" title="6、LoonAndroid"></a>6、LoonAndroid</h3><p>项目地址：<a href="https://github.com/gdpancheng/LoonAndroid" target="_blank" rel="noopener">https://github.com/gdpancheng/LoonAndroid</a></p><p>主要有以下模块：<br>自动注入框架（只需要继承框架内的APP既可）<br>图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性）<br>网络请求模块（继承了基本上现在所有的http请求）<br>eventbus（集成一个开源的框架）<br>验证框架（集成开源框架）<br>Json解析（支持解析成集合或者对象）<br>数据库（不知道是哪位写的 忘记了）<br>多线程断点下载（自动判断是否支持多线程，判断是否是重定向）<br>自动更新模块<br>一系列工具类</p><h3 id="7、图片加载："><a href="#7、图片加载：" class="headerlink" title="7、图片加载："></a>7、图片加载：</h3><p> Universal Image Loader - <a href="https://github.com/onlyTan/Android-Universal-Image-Loader" target="_blank" rel="noopener">https://github.com/onlyTan/Android-Universal-Image-Loader</a></p><p>用法参考 -<a href="http://blog.csdn.net/xiaanming/article/details/26810303" target="_blank" rel="noopener">http://blog.csdn.net/xiaanming/article/details/26810303</a></p><h3 id="8、动画框架："><a href="#8、动画框架：" class="headerlink" title="8、动画框架："></a>8、动画框架：</h3><p>  nineoldandroids -  <a href="https://github.com/JakeWharton/NineOldAndroids" target="_blank" rel="noopener">https://github.com/JakeWharton/NineOldAndroids</a><br>用法参考 -<a href="http://blog.csdn.net/lmj623565791/article/details/38067475" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/38067475</a></p><h3 id="9、进程间通信框架："><a href="#9、进程间通信框架：" class="headerlink" title="9、进程间通信框架："></a>9、进程间通信框架：</h3><p>   eventBus -  <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus</a><br>用法参考 - <a href="http://blog.csdn.net/lmj623565791/article/details/40794879" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/40794879</a></p><h3 id="10、SQLite数据库："><a href="#10、SQLite数据库：" class="headerlink" title="10、SQLite数据库："></a>10、SQLite数据库：</h3><p>LitePal - </p><p><a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">https://github.com/LitePalFramework/LitePal</a></p><h3 id="11、百分比布局："><a href="#11、百分比布局：" class="headerlink" title="11、百分比布局："></a>11、百分比布局：</h3><p>android-percent-support-extend  -  </p><p><a href="https://github.com/hongyangAndroid/android-percent-support-extend" target="_blank" rel="noopener">https://github.com/hongyangAndroid/android-percent-support-extend</a></p><p>百分比布局：<br>android-percent-support-extend  -  </p><p><a href="https://github.com/hongyangAndroid/android-percent-support-extend" target="_blank" rel="noopener">https://github.com/hongyangAndroid/android-percent-support-extend</a></p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 开源框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 屏幕适配dp,sp</title>
      <link href="/2016/04/23/screen-adaptation-dp_sp/"/>
      <url>/2016/04/23/screen-adaptation-dp_sp/</url>
      <content type="html"><![CDATA[<p>相关的概念：</p><h4 id="dp"><a href="#dp" class="headerlink" title="dp"></a><strong>dp</strong></h4><p>即dip，设备独立像素，device independent pixels的缩写，密度无关像素，Android特有的单位，在屏幕密度dpi= 160屏幕上，1dp = 1px。1dp 在屏幕上总是1/160 英寸。<br>它常用在设置镖局，内边距或任何不打算按照像素值指定尺寸的情况下。<br><a id="more"></a></p><h4 id="sp"><a href="#sp" class="headerlink" title="sp"></a><strong>sp</strong></h4><p>和dp很类似，英文为：scale-independent pixel ，缩放无关像素，与密度无关。一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。</p><h4 id="px"><a href="#px" class="headerlink" title="px"></a><strong>px</strong></h4><p>是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素。<br> 在设计领域中，像素是用来计算数码影像的最小单位。计算机中显示的图像并非连续的线条组成，而是由许多肉眼看不见的小点组成。如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小点所组成，这些小点就是构成影像的最小单位“像素”。由于是最小的独立显示单位，px均为整数，不会出现0.5px的情况。</p><h4 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a><strong>dpi</strong></h4><p>dpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。比如320X480分辨率的手机，宽2英寸，高3英寸, 每英寸包含的像素点的数量为320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi，横向和纵向的这个值都是相同的，原因是大部分手机屏幕使用正方形的像素点。</p><h4 id="Android-Drawable"><a href="#Android-Drawable" class="headerlink" title="Android Drawable"></a><strong>Android Drawable</strong></h4><p>我们新建一个Android项目后应该可以看到很多drawable文件夹，分别对应不同的dpi</p><pre><code>drawable-ldpi (dpi=120, density=0.75)drawable-mdpi (dpi=160, density=1)drawable-hdpi (dpi=240, density=1.5)drawable-xhdpi (dpi=320, density=2)drawable-xxhdpi (dpi=480, density=3)</code></pre><p>首先必须清楚一个自动渲染的概念，Android SDK会自动屏幕尺寸选择对应的资源文件进行渲染，如SDK检测到你手机dpi是160的话会优先到drawable-mdpi文件夹下找对应的图片资源，注意只是优先，假设你手机dpi是160，但是你只在xhpdi文件夹下有对应的图片资源文件，程序一样可以正常运行。所以理论上来说只需要提供一种规格的图片资源就ok了，如果只提供ldpi规格的图片，对于大分辨率的手机如果把图片放大就会不清晰，所以需要提供一套你需要支持的最大dpi的图片，这样即使用户的手机分辨率很小，这样图片缩小依然很清晰。</p><p><strong>xhdpi成为首选</strong><br>上面说了只需要提供一套大的dpi的图片就ok了，现在市面手机分辨率最大可达到1080X1920的分辨率，如Nexus5，dpi属于xxhdpi，但是毕竟还没普及，目前市面上最普遍的高端机的分辨率还多集中在720X1080范围，也就是多集中在xhdpi，所以目前来看xhpdi规则的图片成为了首选。当然随着技术规格的提高以后发展，以后可能市场上xxdpi的手机会越来越普遍，但这是后话。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 屏幕适配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 中webview的屏幕适配问题</title>
      <link href="/2016/04/23/webview-Screen-adaptation/"/>
      <url>/2016/04/23/webview-Screen-adaptation/</url>
      <content type="html"><![CDATA[<p>两行代码解决WebView的屏幕适配问题<br><a id="more"></a><br>一个简单的方法，让网页快速适应手机屏幕，代码如下</p><pre><code>WebSettings webSettings= webView.getSettings();webSettings.setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN);</code></pre><p>说明：<br><em>LayoutAlgorithm</em>  是一个枚举，用来控制html的布局，总共有三种类型：<br> <strong>NORMAL</strong>：正常显示，没有渲染变化。<br> <strong>SINGLE_COLUMN</strong>：把所有内容放到WebView组件等宽的一列中。<br> <strong>NARROW_COLUMNS</strong>：可能的话，使所有列的宽度不超过屏幕宽度。</p>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 屏幕适配 </tag>
            
            <tag> webview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo 编写发布博客</title>
      <link href="/2016/04/23/hexo-%20write-blog/"/>
      <url>/2016/04/23/hexo-%20write-blog/</url>
      <content type="html"><![CDATA[<p>上一篇 :<a href="http://imtianx.cn/2016/04/20/Hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">Hexo+github搭建个人博客</a><br>我们介绍了博客的搭建过程，这里说明如何编写博客及发布.<br><a id="more"></a></p><h2 id="1、编写博客"><a href="#1、编写博客" class="headerlink" title="1、编写博客"></a>1、编写博客</h2><ul><li><h5 id="a、使用hexo-命令"><a href="#a、使用hexo-命令" class="headerlink" title="a、使用hexo 命令"></a>a、使用hexo 命令</h5><pre><code>  hexo new [layout] blogName</code></pre>  这里layout默认的是 <strong>post</strong>,可以为文章指定标题，日期，分类，标签等，方便博客的管理。其中分类和标签若有多个，可放在“<strong>[ ]</strong>”中，用“<strong>，</strong>”。隔开具体如下：<pre><code>  ---      title: {{ title }}      date: {{ date }}      categories: [分类1,子分类]      tags: [标签1,标签2,]  ---</code></pre>需要注意的是是：“<strong>title：</strong>”标签<strong>冒号</strong>后有<strong>空格</strong>，其他的同样。<br>此外，为了界面美观，可以添加 显示”<strong>read more</strong>“,如：只显示第一段，则在第一段后添加：<pre><code>  &lt;!--more--&gt;</code></pre></li><li><h5 id="b、直接用编辑器编写"><a href="#b、直接用编辑器编写" class="headerlink" title="b、直接用编辑器编写"></a>b、直接用编辑器编写</h5><p>  博客的编写支持markdown 语法，个人使用的是<strong>作业部落</strong>的Cmd Markdown 编辑器，非常好用，语法简单，方便，具体用法参见<a href="https://www.zybuluo.com/mdeditor#345522" target="_blank" rel="noopener">这里</a>。<br>  这种方式需要在写好的文件开头添加<strong>post</strong>文件，方法同上。然后吧写好的文件放到“<strong>_posts</strong>” 文件夹下，如果没有准备发布，作为草稿可以放在“<strong>_data</strong>”文件夹下。</p></li></ul><h2 id="2、发布博客"><a href="#2、发布博客" class="headerlink" title="2、发布博客"></a>2、发布博客</h2><p>打开gitshell 进入博客根目录，生成静态页面：</p><pre><code>```    hexo g```</code></pre><p>然后起动服务就可以在网页上预览了。</p><p>最后就是将页面提交github。</p>]]></content>
      
      <categories>
          
          <category> 工具软件 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 写博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo+github 搭建个人博客</title>
      <link href="/2016/04/23/hexo_github_build_my_blog/"/>
      <url>/2016/04/23/hexo_github_build_my_blog/</url>
      <content type="html"><![CDATA[<p>最近，看见很多人在使用hexo+github搭建自己的博客，为了方便记录平时的学习内容。在此，我也学习搭建一个个人博客，记下自己的搭建过程，方便自己，也方便他人。<br><a id="more"></a></p><h2 id="1、安装前准备"><a href="#1、安装前准备" class="headerlink" title="1、安装前准备"></a>1、安装前准备</h2><blockquote><ul><li>安装 <strong>Node.js</strong> ，(可以去 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a> 下载相应的版本，并安装。</li><li>安装Git (或者安装github客户端)</li></ul></blockquote><hr><h2 id="2、安装hexo"><a href="#2、安装hexo" class="headerlink" title="2、安装hexo"></a>2、安装hexo</h2><p>windows下进入命令行，执行如下命令：</p><pre><code>    npm install-g hexo</code></pre><p>然后启动 git shell 初始化hexo。这里，我打算把hexo放在自己新建的 “myblog” 文件夹下，则需要先进入该文件夹下，然后进行初始化，如下命令：</p><pre><code>    E:\GitHub&gt; cd myblog            //进入目录    E:\GitHub\myblog&gt; hexo init    //进行初始化</code></pre><p>注：我的git shell 的根目录为 E:\Github ,myblog 文件夹在它下面。<br>然后就是静静的等待它下载完成，可能需要几分钟。<br>最后就可以生成静态界面：</p><pre><code>    hexo g</code></pre><p>启动服务：</p><pre><code>    hexo s</code></pre><p>打开浏览器，输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可成功打开。<br>到此，你已经成功的弄好博客页面了。</p><hr><h2 id="3、配置到github"><a href="#3、配置到github" class="headerlink" title="3、配置到github"></a>3、配置到github</h2><p>上面生成的 博客页面仅限本机使用，别人无法访问。有服务器的可以把它配置到服务器上。但这里采用的是提交到github，由它托管，就可以方便的访问了。<br>在github 上建立  <strong><em>用户名.github.io</em></strong> 的仓库。如我的github用户名为：txadf,仓库为：<strong>txadf.github.io</strong>  地址为 ：<a href="https://github.com/txadf/txadf.github.io.git" target="_blank" rel="noopener">https://github.com/txadf/txadf.github.io.git</a><br>然后打开blog 文件夹下的 _config.yml 文件，在最后修改为如下代码：</p><pre><code>    deploy:      type: git      repo: https://github.com/txadf/txadf.github.io.git      branch: master</code></pre><p>最后，提交博客文件到gtihub,执行如下命令：</p><pre><code>    hexo d</code></pre><p>如果不出错，那么就可以在浏览器用 txadf.github.进行访问了。</p><hr><h2 id="4、hexo-相关命令"><a href="#4、hexo-相关命令" class="headerlink" title="4、hexo 相关命令"></a>4、hexo 相关命令</h2><pre><code>    cls             清屏    hexo clean      清理项目    hexo g          生成静态界面    hexo s          启动服务器    hexo d          提交到github    hexo help       全部的命令</code></pre><p>新建文章：</p><pre><code>hexo new &quot;blogname&quot;</code></pre><p>博客支持markdown语法，可以用相关的编辑器写好后放在<strong>_posts</strong>文件下。对于markdown语法，如有不懂课自行百度。</p><hr><h2 id="5、主题推荐"><a href="#5、主题推荐" class="headerlink" title="5、主题推荐"></a>5、主题推荐</h2><p>对于主题的修改，只需要修改 blog 文件夹下的 <strong>_config.yml</strong> 中的<strong>theme</strong>属性为指定的主题名，并将主题放到theme文件夹下。<br>然后 进行部署（hexo g） 和提交 （hexo d）<br>注：对于其他的属性，修改 方法类似，如网站标题，作者等。</p><p>这里推荐几个个人比较喜欢的主题：</p><ol><li><a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism" target="_blank" rel="noopener">我的博客主题</a>  </li><li><a href="https://github.com/txadf/hexo-theme-spfk" target="_blank" rel="noopener">hexo-theme-spfk</a></li></ol><p>更多主题，请访问<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      <categories>
          
          <category> 工具软件 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> gihub </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
