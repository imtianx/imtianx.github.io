<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[java知识 之 Integer自动拆装箱与缓存]]></title>
      <url>http://imtianx.cn/2016/11/27/java%E7%9F%A5%E8%AF%86%20%E4%B9%8B%20Integer%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E4%B8%8E%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>在java的数据类型中，包含基本类型 (如:<code>int、double、...</code>) 和包装类型(如: <code>Integer、Double、...</code> )。<br><strong>自动装箱指的是把基本类型的值转换为对应的包装类对象，反之则为自动拆箱。</strong><a id="more"></a></p>
<p>如下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = 100;</span><br><span class="line">int y = x;</span><br></pre></td></tr></table></figure>
<p>第一行代码实现了自动装箱，调用了 <code>valueOf(int i)</code> 方法；第二句实现了自动拆箱，调用了 <code>intvalue()</code> 方法。这些都是编译器自动帮我们完成的不用我们自己调用。</p>
<p>以此类推，其他的装箱拆箱机制类似。</p>
<p>下面的代码咋一看，输出都为 <code>true</code>,但其实不然：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 100 ;</span><br><span class="line">Integer b = 100 ;</span><br><span class="line">Integer c = 200 ;</span><br><span class="line">Integer d = 200 ;</span><br><span class="line">System.out.println(a==b);</span><br><span class="line">System.out.println(c==d);</span><br></pre></td></tr></table></figure>
<p>其中 <code>a==b</code> 结果为 <code>true</code> , <code>c==d</code> 结果为 <code>false</code> 。出现这种情况，主要是在进行自动装箱时， <code>Integer</code>的缓存机制导致的。</p>
<p>如下Integer部分源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final class Integer extends Number implements Comparable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Native</span><br><span class="line">    public static final int MIN_VALUE = 0x80000000;</span><br><span class="line">    @Native</span><br><span class="line">    public static final int MAX_VALUE = 0x7fffffff;</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    //缓存类 默认用数组缓存 [-128,127] 的常量</span><br><span class="line">    private static class IntegerCache &#123;</span><br><span class="line">        static final int low = -128;</span><br><span class="line">        static final int high;</span><br><span class="line">        static final Integer cache[];</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            // high value may be configured by property</span><br><span class="line">            int h = 127;</span><br><span class="line">            //获取Jvm配置的Integer的最大值，可以手动设置</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                    sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">            if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //转换成int</span><br><span class="line">                    int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, 127);</span><br><span class="line">                    // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) - 1);</span><br><span class="line">                &#125; catch (NumberFormatException nfe) &#123;</span><br><span class="line">                    // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            //创建缓存常量数组</span><br><span class="line">            cache = new Integer[(high - low) + 1];</span><br><span class="line">            int j = low;</span><br><span class="line">            //设置数组元素值</span><br><span class="line">            for (int k = 0; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">            //通过断言确保数组最小范围为：[-128,127]</span><br><span class="line">            assert IntegerCache.high &gt;= 127;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private IntegerCache() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自动装箱</span><br><span class="line">     *</span><br><span class="line">     * int -&gt; Integer</span><br><span class="line">     *</span><br><span class="line">     * @param i</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Integer valueOf(int i) &#123;</span><br><span class="line">        //如果在缓存范围内，直接从缓存中区，</span><br><span class="line">        if (i &gt;= Integer.IntegerCache.low &amp;&amp; i &lt;= Integer.IntegerCache.high)</span><br><span class="line">            return Integer.IntegerCache.cache[i + (-Integer.IntegerCache.low)];</span><br><span class="line">        // 在缓存空间外，重新创建</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在默认情况下，Integer创建的缓存常量为 [-128,127],所以在上面的例子中，<code>Integer a = 100</code> 创建 a 对象是直接从常量数组中获取的，直接找到他的引用，b也是同样的，则 <code>a==b</code> 返回true;对于 <code>Integer c = 200</code> ,在常量池中没有缓存 ，则 通过 <code>new Integer(200)</code> 创建新对象，d也是这样创建的，他们所指向的引用不同，则 <code>c==d</code> 返回为 <code>false</code> 。</p>
<p>在上面的 缓存类 <code>IntegerCache</code> 中的静态代码块中，使用 <code>sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</code><br>获取设置jvm最大的Integer缓存池范围。可以手动指定该值，通过设置 <code>-XX:AutoBoxCacheMax=2000</code> 属性，如下命令行编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//编译生成字节码</span><br><span class="line">javac TestInteger.java</span><br><span class="line">//指定范围最最大值为2000，运行</span><br><span class="line">java -XX:AutoBoxCacheMax=2000 TestInteger</span><br></pre></td></tr></table></figure>
<p>此时如下代码输出均为true：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 100 ;</span><br><span class="line">Integer b = 100 ;</span><br><span class="line">Integer c = 200 ;</span><br><span class="line">Integer d = 200 ;</span><br><span class="line">System.out.println(a==b);</span><br><span class="line">System.out.println(c==d);</span><br></pre></td></tr></table></figure>
<p>如果使用ide,直接设置 运行时 VM 值即可，如下图</p>
<p><img src="/img/article_img/2016/setvmintegerMax.png" alt=""></p>
<p>此外，在上面的代码中用到了  <code>assert(断言)</code> 关键字，它主要用来保证代码的正确性。<br>使用发方法为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 表达式;</span><br></pre></td></tr></table></figure>
<p>若表达式为 <code>true</code> ,则程序正常运行，否则 抛出异常 <code>java.lang.AssertionError</code>。编辑器默认的是将他关闭的，此时就算表达式为false也没有任何效果。<br>在idea中开启断言的方式和上面设置 vm值一样，只是这里设置的 是 <code>-ea</code> 。</p>
<p>可使用下面代码测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean isOpen = false;</span><br><span class="line">assert isOpen;</span><br><span class="line">System.out.println(isOpen);</span><br></pre></td></tr></table></figure>
<p>开启前打印为false，开启后打印为true 。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java 知识之 注解的使用和解析]]></title>
      <url>http://imtianx.cn/2016/11/26/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>在java中，例如重写父类方法使用的 <code>@Override</code>，就是注解。在开发中使用的框架，大部分也是用了注解。通过注解可以是代码更加简洁，更加清晰。在jdk1.5后，引入了注解。<a id="more"></a><br>官方概念：java提供了已汇总源程序中的元素关联任何信息和任何元数据的途径和方法。</p>
<h2 id="一-、常见的注解"><a href="#一-、常见的注解" class="headerlink" title="一 、常见的注解"></a>一 、常见的注解</h2><p>在java 中主要有如下三个注解：</p>
<ul>
<li>@Override<br>指明被注解的方法需要覆写父类中的方法，该方法在父类或接口中一定定存在，而且定义的一模一样（包括方法名、返回类型、参数），否则会报错误。</li>
<li>@Deprecated<br>表明该类被废弃，但仍然可以使用，只是使用时方法中间显示一横线。</li>
<li>@SuppressWarnings(“deprecation”)<br>这个主要是排除因使用了被Deprecated 标记的方法而出现的警告，尽量在方法上使用来压制警告。</li>
</ul>
<p>更多java注解类的信息请查看源码 <code>java.lang.annotation</code> 包下面的注解类。</p>
<p><strong>第三方注解：</strong><br> 如果使用过Spring和Mybatis后台框架，对Spring中的@Autowired、@Service、@Repository以及Mybatis中的@InsertProvider、@UpdateProvider、@Options的使用就较为了解。</p>
<h2 id="二、-注解的分类"><a href="#二、-注解的分类" class="headerlink" title="二、 注解的分类"></a>二、 注解的分类</h2><p>按照<strong>运行时机制</strong>分为：</p>
<ul>
<li><p>源码注解<br>注解只存在源码中，编译后的.class文件中不存在</p>
</li>
<li><p>编译时注解<br>在源码和.class中都存在，比如前面java中的 <code>@Override、@Deprecated、@SuppressWarnings(&quot;deprecation&quot;)</code></p>
</li>
<li>运行时注解<br>在运行阶段起作用，会影响运行逻辑的注解。</li>
</ul>
<p>按照<strong>来源</strong>分为：</p>
<ul>
<li>来自jdk的注解</li>
<li>第三方注解</li>
<li>自定义注解</li>
</ul>
<h2 id="三、自定义注解"><a href="#三、自定义注解" class="headerlink" title="三、自定义注解"></a>三、自定义注解</h2><p>在进行自定义注解时 使用 <code>@interface</code>关键字，与新建类类似。idea中新建java class时类型可以选择为<code>Annotation</code>，可以直接建立注解类。</p>
<blockquote>
<p>建立注解类时，若类中只有一个成员时，方法名必须为<strong>value</strong>，使用时可以忽略成员名和赋值号；<br>如果没有成员，则该注解成为标识注解，如 <code>@Inherited</code>；注解中，成员的类型可以为java中的基本类型（int/float/double/…）,也可以是String、Class、Annotation,Enumeration。此外，还可以使用 <code>default</code>关键字指定默认值。</p>
</blockquote>
<p>如下简单注解例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited//允许子类继承</span><br><span class="line">@Documented//生成java doc时包含注解信息</span><br><span class="line">public @interface Description &#123;</span><br><span class="line"></span><br><span class="line">    String desc();</span><br><span class="line"></span><br><span class="line">    String author();</span><br><span class="line"></span><br><span class="line">    int age() default 18;//指定默认值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的注解中，<code>@Target</code>指注解的作用域，包含java中的类、构造方法、属性等，具体参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ElementType.METHOD  //方法声明</span><br><span class="line">ElementType.TYPE     //类、接口</span><br><span class="line">ElementType.CONSTRUCTOR    //构造方法声明</span><br><span class="line">ElementType.TYPE.FIELD  //属性声明</span><br><span class="line">ElementType.LOCAL_VARIABLE  //局部变量声明</span><br><span class="line">ElementType.PACKAGE //包声明</span><br><span class="line">ElementType.PARAMETER   //参数声明</span><br></pre></td></tr></table></figure></p>
<p><code>@Retention</code> 是指注解的生命周期，可以为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RetentionPolicy.RUNTIME     // 运行时，可以通过反射获取；</span><br><span class="line">RetentionPolicy.SOURCE      //源码中显示，编译后丢弃；</span><br><span class="line">RetentionPolicy.CLASS       //编译时记录到class中，运行时忽略</span><br></pre></td></tr></table></figure></p>
<p><code>@Inherited</code> 表示允许子类继承，这个只能用与类，而且子类只能继承父类的类注解，不能继承方法上的注解。<br><code>@Documented</code> 表示生成javadoc时包含注解信息</p>
<p>在注解类名之前的注解称为元注解。</p>
<p><strong>自定义注解的使用语法：<br>@注解名(成员名1=XXX,成员名2=XXX,…)；</strong><br>对于只有一个成员的注解，直接用<strong>@注解名(XXX)</strong></p>
<p>上面的注解可以使用在类和方法上，如下为在方法上的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Description(desc = &quot;run&quot;,author = &quot;imtianx&quot;,age = 20)</span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、解析注解"><a href="#四、解析注解" class="headerlink" title="四、解析注解"></a>四、解析注解</h2><p>对于注解的解析，主要用到了反射技术。<br>通过反射获取类、函数或成员上的运行时注解信息，实现动态的控制程序的逻辑。</p>
<p>这里介绍下注解内容的获取，首先在使用注解到需要的类上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Description(desc = &quot;student&quot;,author = &quot;imtianx&quot;,age = 20)</span><br><span class="line">public class Student implements Person &#123;</span><br><span class="line"></span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    @Description(desc = &quot;run-M&quot;,author = &quot;imtianx-M&quot;,age = 21)</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sign() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试获取注解内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //1.反射获取类信息</span><br><span class="line">            Class c = Class.forName(&quot;Student&quot;);</span><br><span class="line"></span><br><span class="line">            //2.获取类上面的注解</span><br><span class="line">            boolean hasCAnno = c.isAnnotationPresent(Description.class);</span><br><span class="line">            if (hasCAnno) &#123;</span><br><span class="line">                Description d = (Description) c.getAnnotation(Description.class);</span><br><span class="line">                System.out.println(d.desc());</span><br><span class="line">                System.out.println(d.author());</span><br><span class="line">                System.out.println(d.age());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            //3.获取方法上的注解</span><br><span class="line">            Method[] methods = c.getMethods();</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                boolean isMAnno = method.isAnnotationPresent(Description.class);</span><br><span class="line">                if (isMAnno) &#123;</span><br><span class="line">                    Description md = method.getAnnotation(Description.class);</span><br><span class="line">                    System.out.println(md.desc());</span><br><span class="line">                    System.out.println(md.author());</span><br><span class="line">                    System.out.println(md.age());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //另一种获取获取注解的方式，以获取类上面的注解为例</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                Annotation[] as = method.getDeclaredAnnotations();</span><br><span class="line">                for (Annotation a : as) &#123;</span><br><span class="line">                    if (a instanceof Description) &#123;</span><br><span class="line">                        Description d = (Description) a;</span><br><span class="line"></span><br><span class="line">                        System.out.println(d.desc());</span><br><span class="line">                        System.out.println(d.author());</span><br><span class="line">                        System.out.println(d.age());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先通过反射获取类信息，然后依次获取类、方法上面的注解内容。至于属性上面的注解，可以使用<code>Class.getDeclaredFields()</code>获取所有的属性，然后进行遍历获取。可参见 <a href="http://imtianx.cn/2016/11/25/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8/">java 知识之 反射的使用</a> 一文了解反射相关的知识。</p>
<p>当你了解了自定义注解和它的解析，再去看自己项目所用框架中的注解的实现，就十分简单，自己也能实现相同的效果。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java 知识之 反射的使用]]></title>
      <url>http://imtianx.cn/2016/11/25/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>所谓反射，是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。<a id="more"></a></p>
<p>反射有如下的功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>生成动态代理。</li>
</ul>
<p>这里的反射主要通过<code>Class</code>类来实现。</p>
<h2 id="一、Class类的使用"><a href="#一、Class类的使用" class="headerlink" title="一、Class类的使用"></a>一、Class类的使用</h2><p><code>Class</code>类的实例表示java 应用运行时的类或者接口，包括数组、基本类型(<code>int/long/Indeger/String/...</code>)、关键字(<code>void/...</code>)等。没有共有构造方法，在使用new创建对象或者加载ClassLoader时，由JVM自动调用。</p>
<blockquote>
<p>每个java类运行时都在JVM里表现为一个class对象，可通过类名.class,类型.getClass(),Class.forName(“类名”)等方法获取class对象。</p>
</blockquote>
<p>可以通过下面三种方式获得Class对象：</p>
<p>1.通过 类名.class 获取，可以认为每个类都有一个静态的Class对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Person.class;</span><br></pre></td></tr></table></figure></p>
<p>2.通过类的对象获取<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person person = new Person();</span><br><span class="line">Class c2 = person.getClass();</span><br></pre></td></tr></table></figure></p>
<p>3.通过类名获取，<strong>动态加载</strong>（这个再很多地方都有使用，如：加载数据库驱动）<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c3 = null;</span><br><span class="line">   try &#123;</span><br><span class="line">       c3 = Class.forName(&quot;Person&quot;);</span><br><span class="line">   &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<strong>c1/c2是Person的类类型，Person是Class类的对象。可以理解为一切类都是Class的对象</strong>。</p>
<p>打印上面三种方法获取的Class对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(c1 == c2);//true</span><br><span class="line">System.out.println(c1 == c3);//true</span><br><span class="line">System.out.println(c2 == c3);//true</span><br></pre></td></tr></table></figure>
<p>上面三种方式获取的Class对象，两两均相等。可见，可以理解为每个对象都有一个静态的Class变量。因为在java 中，<em>Object</em> 是一切类的父类，在Object中有一个获取Class对象的native(由C++或C语言实现，通过java 调用，具体的可参见jni相关的知识)方法。如下部分Object开头源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Object &#123;</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line">     </span><br><span class="line">    /**</span><br><span class="line">    * Returns the runtime class of this &#123;@code Object&#125;. The returned</span><br><span class="line">    * &#123;@code Class&#125; object is the object that is locked by &#123;@code</span><br><span class="line">    * static synchronized&#125; methods of the represented class.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;&lt;b&gt;The actual result type is &#123;@code Class&lt;? extends |X|&gt;&#125;</span><br><span class="line">    * where &#123;@code |X|&#125; is the erasure of the static type of the</span><br><span class="line">    * expression on which &#123;@code getClass&#125; is called.&lt;/b&gt; For</span><br><span class="line">    * example, no cast is required in this code fragment:&lt;/p&gt;</span><br><span class="line">   </span><br><span class="line">    * @return The &#123;@code Class&#125; object that represents the runtime</span><br><span class="line">    *         class of this object.</span><br><span class="line">    *         </span><br><span class="line">*/</span><br><span class="line">   public final native Class&lt;?&gt; getClass();</span><br><span class="line">   </span><br><span class="line">  // ...</span><br></pre></td></tr></table></figure>
<p>通过上面 getClass 方法前的部分注释，可以清楚的明白他的作用。</p>
<h2 id="二、动态加载类"><a href="#二、动态加载类" class="headerlink" title="二、动态加载类"></a>二、动态加载类</h2><p>在java 中，使用new创建的对象都是静态加载的，这些类必须存在，不管在实际中是否使用，否则编译不通过。可以通过动态加载类来解决该问题。<br>通过Class类的forName方法进行加载,传入相应的名加载具体的类，可以使程序的扩展性更好，避免编译出错。</p>
<p>该方法的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String className)</span><br></pre></td></tr></table></figure>
<h2 id="三、使用Class获取类信息"><a href="#三、使用Class获取类信息" class="headerlink" title="三、使用Class获取类信息"></a>三、使用Class获取类信息</h2><p>Class类提供的部分获取类信息的方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getFields()</td>
<td style="text-align:center">获取所有public类型的成员变量</td>
</tr>
<tr>
<td style="text-align:left">getDeclaredFields()</td>
<td style="text-align:center">获取该类自己声明的所有变量</td>
</tr>
<tr>
<td style="text-align:left">getConstructors()</td>
<td style="text-align:center">获取所所有public类型的构造方法</td>
</tr>
<tr>
<td style="text-align:left">getDeclaredConstructors()</td>
<td style="text-align:center">获取所有的构造方法</td>
</tr>
<tr>
<td style="text-align:left">getMethods()</td>
<td style="text-align:center">获取所有的public函数，包括父类继承来的</td>
</tr>
<tr>
<td style="text-align:left">getDeclaredMethods</td>
<td style="text-align:center">获取该类所有声明的方法</td>
</tr>
</tbody>
</table>
<p>上面分别为获取成员变量、构造方法和成员方法。</p>
<p><strong>获取成员参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ClassUtils &#123;</span><br><span class="line">    public static void getClassField(Object obj) &#123;</span><br><span class="line">            Class c = obj.getClass();</span><br><span class="line">            Field[] fs = c.getDeclaredFields();// c.getMethods();</span><br><span class="line">            for (Field f : fs) &#123;</span><br><span class="line">                Class fieldType = f.getType();</span><br><span class="line">                System.out.println(fieldType.getName() + &quot; &quot; + f.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是获取所有成员变量的，获取的每个成员方法都是 <code>Fidld</code> 类型的对象。<br>如下测试代码获取String类中的成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassUtils.getClassField(&quot;reflect&quot;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[C value</span><br><span class="line">int hash</span><br><span class="line">long serialVersionUID</span><br><span class="line">[Ljava.io.ObjectStreamField; serialPersistentFields</span><br><span class="line">java.util.Comparator CASE_INSENSITIVE_ORDER</span><br></pre></td></tr></table></figure>
<p>其中第一个和第三个表示的是数组。查看String中的源码，成员变量如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    </span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    private int hash; // Default to 0</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -6849794470754667710L;</span><br><span class="line"></span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields =</span><br><span class="line">            new ObjectStreamField[0];</span><br><span class="line">            </span><br><span class="line">    //...</span><br><span class="line">     public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">                                         = new CaseInsensitiveComparator();</span><br><span class="line">    </span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的可以调用该方法查看其他类中的成员变量。</p>
<p><strong>获取构造方法和成员方法</strong></p>
<p>类似于上面获取成员变量的方法，如下获取构造函数和成员方法则很好理解了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class ClassUtils &#123;</span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取所有的成员方法</span><br><span class="line">     *</span><br><span class="line">     * @param obj</span><br><span class="line">     */</span><br><span class="line">    public static void getClassMethods(Object obj) &#123;</span><br><span class="line">        Class c = obj.getClass();</span><br><span class="line">        System.out.println(&quot;类名为：&quot; + c.getName());</span><br><span class="line">        Method[] ms = c.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        for (Method m : ms) &#123;</span><br><span class="line">            Class returnType = m.getReturnType();</span><br><span class="line">            //返回值的类类型，如String--&gt;String.class</span><br><span class="line">            System.out.print(returnType.getName() + &quot; &quot;);</span><br><span class="line">            //方法名称</span><br><span class="line">            System.out.print(m.getName() + &quot;(&quot;);</span><br><span class="line">            //获取参数--参数列表的类类型</span><br><span class="line">            Class[] paramTypes = m.getParameterTypes();</span><br><span class="line">            int paramsNum = paramTypes.length;</span><br><span class="line">            Class paramType;</span><br><span class="line">            for (int i = 0; i &lt; paramsNum; i++) &#123;</span><br><span class="line">                paramType = paramTypes[i];</span><br><span class="line">                if (i == 1 || (i == paramsNum - 1))</span><br><span class="line">                    System.out.print(paramType.getName());</span><br><span class="line">                else</span><br><span class="line">                    System.out.print(paramType.getName() + &quot; ,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取所有的构造函数</span><br><span class="line">     *</span><br><span class="line">     * @param obj</span><br><span class="line">     */</span><br><span class="line">    public static void printConMessage(Object obj) &#123;</span><br><span class="line">        Class c = obj.getClass();</span><br><span class="line">        Constructor[] cs = c.getDeclaredConstructors();</span><br><span class="line">        for (Constructor constructor : cs) &#123;</span><br><span class="line">            System.out.print(constructor.getName() + &quot; (&quot;);</span><br><span class="line">            Class[] paramTypes = constructor.getParameterTypes();</span><br><span class="line">            int paramsNum = paramTypes.length;</span><br><span class="line">            Class paramType;</span><br><span class="line">            for (int i = 0; i &lt; paramsNum; i++) &#123;</span><br><span class="line">                paramType = paramTypes[i];</span><br><span class="line">                if (i == 1 || (i == paramsNum - 1))</span><br><span class="line">                    System.out.print(paramType.getName());</span><br><span class="line">                else</span><br><span class="line">                    System.out.print(paramType.getName() + &quot; ,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处省略测试。</p>
<h2 id="四、方法反射的基本操作"><a href="#四、方法反射的基本操作" class="headerlink" title="四、方法反射的基本操作"></a>四、方法反射的基本操作</h2><p>对于方法的获取，可以通过方法名称和参数列表来确定某个方法。主要使用了 <code>Method.invoke(对象,参数列表);</code> 操作。</p>
<p><strong>首先需要获取类信息，然后指定方法名和参数获取方法对象，再通过<code>Method.invoke()</code>进行反射获取方法执行结果。若该方法无返回值，则invoke方法最后返回null,否则返回相应的结果</strong>。</p>
<p>如下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.获取类信息</span><br><span class="line">        A a = new A();</span><br><span class="line">        Class aClass = a.getClass();</span><br><span class="line">        //2.获取方法名称和参数</span><br><span class="line">        try &#123;</span><br><span class="line">//            Method method = aClass.getMethod(&quot;print&quot;,new Class[]&#123;int.class,int.class&#125;);</span><br><span class="line">            Method method = aClass.getMethod(&quot;print&quot;, int.class, int.class);</span><br><span class="line">            //方法返回结果：若无返回结果则o为null，否则为返回结果，这里返回为30</span><br><span class="line">            Object o = method.invoke(a, 10, 20);</span><br><span class="line">            System.out.println(o);//30</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试反射方法</span><br><span class="line">class A &#123;</span><br><span class="line">    public int print(int a, int b) &#123;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print(String a, String b) &#123;</span><br><span class="line">        System.out.println(a.toUpperCase() + &quot;-----&quot; + b.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 Method()和invoke()方法第二个参数为可变数组，可有可无，如果有接写。可以通过new数组的方式或者直接一个个写出。</p>
<h2 id="五、通过反射了解集合泛型的本质"><a href="#五、通过反射了解集合泛型的本质" class="headerlink" title="五、通过反射了解集合泛型的本质"></a>五、通过反射了解集合泛型的本质</h2><p>我们都知道，在java中，定义集合指定什么泛型，就只能添加该类型的数据到集合中，否则就会报错。</p>
<p>通过反射可以往集合中添加不同类型的数据，这样虽没有多大意义，不便于遍历。这里主要说明了集合在编译后是去泛型化的，集合的泛型可以防止错误输入，在编译极前有效。</p>
<p>如下测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; l1 = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList l2 = new ArrayList();</span><br><span class="line">        l1.add(&quot;java reflect&quot;);</span><br><span class="line">//        datas.add(100);//报错</span><br><span class="line">        Class c1 = l1.getClass();</span><br><span class="line">        Class c2 = l2.getClass();</span><br><span class="line">        System.out.println(c1 == c2);//true</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method = c2.getMethod(&quot;add&quot;, Object.class);</span><br><span class="line">            method.invoke(l1, 100);</span><br><span class="line">            System.out.println(&quot;数组大小：&quot;+l1.size());</span><br><span class="line">            System.out.println(&quot;数组内容：&quot;+l1.toString());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">数组大小：2</span><br><span class="line">数组内容：[java reflect, 100]</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，通过反射往String类型的集合中添加了int类型的100。</p>
<p>通过对反射的学习，发现反射是从.class到.java的过程，感觉像反编译字节码。以 <code>Class c1 = Person.class;</code>为例，Person.java类在编译后生成的字节码文件为Person.class,这里获取的Class正式这样的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java 知识 之 内存管理]]></title>
      <url>http://imtianx.cn/2016/11/24/java%20%E7%9F%A5%E8%AF%86%20%E4%B9%8B%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>读书笔记：《疯狂java 程序员的基本修养》第四章——java内存管理</p>
</blockquote>
<p>java 中的内存管理包括内存分配和内存回收，这些都是由 JVM 帮我们完成的。当创建对象时为其分配内存空间；当失去引用时，GC会自动清除并回收他们所占用的空间。<br><a id="more"></a></p>
<h2 id="一、java-引用的种类"><a href="#一、java-引用的种类" class="headerlink" title="一、java 引用的种类"></a>一、java 引用的种类</h2><p>当java对象创建完后，垃圾回收机制会实时的监测每个对象的状态，包括对象的申请、引用、被引用。赋值等。当它不存在引用时，对其进行回收。</p>
<p>当一个对象在堆内存中运行时，根据它对应的有向图的状态，有如下三种状态：</p>
<ul>
<li>可达状态<br>当一个对象被创建后，有一个以上的引用变量引用他，在有向图中可以从起点导航到该点，此时可以通过引用变量调用它的属性和方法。</li>
<li>可恢复状态<br>程序中不再有任何对象引用变量引用它，此时不能从有向图的起点到达它。系统准备回收，再回收之前系统会调用该对象的<code>finalize()</code>方法进行资源清理，如果在finalize 中重新让一个及以上的引用变量引用该对象，则它会再次变为可达状态，否则，进入不可达状态。</li>
<li>不可达状态<br>所有的关联都被切断，永久性的失去引用，只有在该状态下系统才会真正的回收对象所占用的资源。</li>
</ul>
<p>三张状态转换图如下：</p>
<p><img src="/img/article_img/2016/object_state.png" alt=""></p>
<h3 id="a-强引用"><a href="#a-强引用" class="headerlink" title="a. 强引用"></a><strong>a. 强引用</strong></h3><p>在java  中，创建一个对象，并把它赋值给一个引用变量，就是强引用。<strong>被强引用所引用的对象时绝对不会被垃圾回收机制回收的，即使系统非常紧张</strong>，因此它是造成内存泄露的主要原因之一。</p>
<h3 id="b-软引用"><a href="#b-软引用" class="headerlink" title="b. 软引用"></a><strong>b. 软引用</strong></h3><p>软引用需要用<code>SoftReference</code>类来实现，当一个对象只有软引用时，它有可能被回收。对于软引用，<strong>当系统内存空间足够时，不会被回收，否则会被系统回收，该对象不可再被使用</strong>。<br>软引用是强引用很好的替代，他能避免系统内存不足的异常。具体的使用如下（其中Person类有两个属性和一个tostring方法）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SoftReferenceTest &#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        SoftReference&lt;Person&gt;[] people =</span><br><span class="line">                new SoftReference[100000];</span><br><span class="line">        for (int i = 0; i &lt; people.length; i++) &#123;</span><br><span class="line">            people[i] = new SoftReference&lt;Person&gt;(new Person(</span><br><span class="line">                    &quot;名字&quot; + i, (i + 1) * 4 % 100));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(people[2].get());</span><br><span class="line">        System.out.println(people[4].get());</span><br><span class="line">        // 通知系统进行垃圾回收</span><br><span class="line">        System.gc();</span><br><span class="line">        System.runFinalization();</span><br><span class="line">        // 垃圾回收机制运行之后，SoftReference数组里的元素保持不变</span><br><span class="line">        System.out.println(people[2].get());</span><br><span class="line">        System.out.println(people[4].get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person[name=名字2, age=12]</span><br><span class="line">Person[name=名字4, age=20]</span><br><span class="line">Person[name=名字2, age=12]</span><br><span class="line">Person[name=名字4, age=20]</span><br></pre></td></tr></table></figure></p>
<p>系统内存足够，在垃圾回收前后结果一样，和强引用并无区别。若指定jvm的内存大小，则软引用所引用的对象会被系统回收，可使用如下命令指定堆内存只有2M，则创建长度为100000的数组可使内存紧张，则会被回收，最终输出均为<br>null：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx2m -Xms2m SoftReferenceTest</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Xmx：设置java虚拟机堆内存最大容量；<br>Xms：设置java虚拟机初始容量。 </p>
</blockquote>
<p>如果将前面初始化people的方式改为下面的强引用方式，依然指定2M内存，则会抛出<code>java.lang.OutOfMemoryError</code>的内存溢出异常,因而终止程序,此处也体现了前面所说的强引用对象不会回收其所占用的内存，尽管内存不足。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] people = new Person[100000];</span><br></pre></td></tr></table></figure></p>
<h3 id="c-弱引用"><a href="#c-弱引用" class="headerlink" title="c. 弱引用"></a><strong>c. 弱引用</strong></h3><p>弱引用于软引用类似，但他的生存期更短，通过<code>WeakReference</code>类实现。对于只有弱引用的对象，当垃圾机制运行时，<strong>不管内存是否足够，总会回收该对象占用的内存</strong>。<br>如下示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class WeakReferenceTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 创建一个字符串对象</span><br><span class="line">        String str = new String(&quot;疯狂Java讲义&quot;);</span><br><span class="line">        // 创建一个弱引用，让此弱引用引用到&quot;疯狂Java讲义&quot;字符串</span><br><span class="line">        WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(str);</span><br><span class="line">        // 切断str引用和&quot;疯狂Java讲义&quot;字符串之间的引用</span><br><span class="line">        str = null;      //②</span><br><span class="line">        // 取出弱引用所引用的对象</span><br><span class="line">        System.out.println(wr.get()); //输出：疯狂Java讲义</span><br><span class="line">        // 强制垃圾回收</span><br><span class="line">        System.gc();</span><br><span class="line">        System.runFinalization();</span><br><span class="line">        // 再次取出弱引用所引用的对象</span><br><span class="line">        System.out.println(wr.get());  //输出：null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：上面代码中创建字符串对象不可采用 “String str = “疯狂Java讲义”;” 这种方式,因为这样的定义系统会把它缓存为常量，使用强引用来引用它，则不会被回收。</p>
</blockquote>
<p>上述代码中的内存分配示意图：</p>
<p><img src="/img/article_img/2016/weakreference.png" alt=""></p>
<p>在实际使用时，可以使用<code>WeakHashMap</code>来保存弱引用对象。</p>
<h3 id="d-虚引用"><a href="#d-虚引用" class="headerlink" title="d. 虚引用"></a><strong>d. 虚引用</strong></h3><p>虚引用主要是跟踪对象被垃圾回收的状态，可以通过检查与虚引用关联的队列中是否包含指定的引用，了解对象是否被回收。<br>与软引用和弱引用不同，虚引用不能单独使用。<br>虚引用对象在被释放前会将它添加到他关联的引用队列中。通过<code>PhantomReference</code>类实现，结合引用队列<code>ReferenceQuence</code>使用。如下使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class PhantomReferenceTest &#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        // 创建一个字符串对象</span><br><span class="line">        String str = new String(&quot;疯狂Java讲义&quot;);</span><br><span class="line">        // 创建一个引用队列</span><br><span class="line">        ReferenceQueue&lt;String&gt; rq = new ReferenceQueue&lt;String&gt;();</span><br><span class="line">        // 创建一个虚引用，让此虚引用引用到&quot;疯狂Java讲义&quot;字符串</span><br><span class="line">        PhantomReference&lt;String&gt; pr =</span><br><span class="line">                new PhantomReference&lt;String&gt;(str, rq);</span><br><span class="line">        // 切断str引用和&quot;Struts2权威指南&quot;字符串之间的引用</span><br><span class="line">        str = null;</span><br><span class="line">        // 试图取出虚引用所引用的对象，</span><br><span class="line">        // 程序并不能通过虚引用访问被引用的对象</span><br><span class="line">        System.out.println(pr.get());  //输出null</span><br><span class="line">        // 强制垃圾回收</span><br><span class="line">        System.gc();</span><br><span class="line">        System.runFinalization();</span><br><span class="line">        // 取出引用队列中最先进入队列中引用与pr进行比较</span><br><span class="line">        System.out.println(rq.poll() == pr);  //输出：true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、java-的内存泄露"><a href="#二、java-的内存泄露" class="headerlink" title="二、java 的内存泄露"></a>二、java 的内存泄露</h2><p>与C++程序员不同，java 程序员无需关注内存释放的问题，这些由JVM帮我们完成。然而如果使用不当，一样会出现内存泄露。如果是可达状态的对象，但程序不访问，他们做占用的空间不会被回收，就会产生内存泄露。<br>yi ArrayList中的remove方法为例，每当删除一个元素时，就会让最后一个元素的引用置为null:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementData[--size] = null;</span><br></pre></td></tr></table></figure>
<p>在ArrayList中采用数组来保存每个元素的。由于集合中每个元素实际上存的是引用，如果不使用上述的代码，则ArrayList中被删除的元素一直被引用着，处于可达状态，导致无法被回收，因而会产生内存泄露。</p>
<h2 id="三、垃圾回收机制"><a href="#三、垃圾回收机制" class="headerlink" title="三、垃圾回收机制"></a>三、垃圾回收机制</h2><p>垃圾回收主要完成两件事：</p>
<ul>
<li>跟踪监控java对象，当它处于不可达时，回收他所占用的内存；</li>
<li>清理内存分配和回收过程中产生的内存是碎片。</li>
</ul>
<p>垃圾回收的基本算法有：</p>
<ul>
<li>串行回收和并行回收</li>
<li>并发执行和应用程序停止</li>
<li>压缩/不压缩和复制</li>
</ul>
<p>现在的垃圾回收机制用分代的方式采用不同的回收机制，根据<strong>对象生存时间的长短</strong>，把堆内存分为三代：<strong>Yong(新生代)、Old(老年代)、Permanent(永生代)</strong>。</p>
<p>在java中，绝大多数对象不会被长时间引用，他们在Yong期间被回收，很老的对象和很新的对象之间很少存在相互引用的情况。</p>
<p>当Yong代的内存快要用完时，垃圾回收机制会对其进行回收，此时回收的系统性能开销小。为次要回收；当Old代快要用完时，垃圾回收机制会进行全面的回收，包括Yong和Old，此时回收成本大，为主要回收。</p>
<p>Permanent时代主要用于装在Class、方法等信息，默认是64MB，通常不会被回收。</p>
<h2 id="四、内存管理技巧"><a href="#四、内存管理技巧" class="headerlink" title="四、内存管理技巧"></a>四、内存管理技巧</h2><p>只有很好的掌握了垃圾回收及其机制，才能更好的管理java虚拟机，使我们写出更高性能的java代码。避免内存泄露的主要技巧如下：</p>
<ul>
<li>使用直接量<br>如使用 <code>String str = &quot;hello;&quot;</code> 代替 <code>String str = new String(&quot;hello&quot;);</code>，前者会在缓存池缓存这个常量</li>
<li>使用StringBuilder和StringBuffer进行字符串的连接<br>使用String时会生成大量的临时字符串存在内存中。</li>
<li>及时释放无用对象的引用</li>
<li>减少静态变量</li>
<li>避免在经常调用的方法、循环中创建java对象</li>
<li>缓存经常使用的对象<br>缓存技术是牺牲空间换时间的，主要使用容器保存已使用的对象，其关键在于如何控制缓存容器的空间使其不至于过大并且能够保留大部分已用过的对象。</li>
<li>尽量不要使用finalize方法</li>
<li>考虑使用SoftReference<br>当创建长度很大的对象时，可以使用软引用包装数组，便于在内存不足的情况下被回收释放。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java 知识 之 常见java集合的实现细节]]></title>
      <url>http://imtianx.cn/2016/11/22/java%20%E7%9F%A5%E8%AF%86%20%E4%B9%8B%20%E5%B8%B8%E8%A7%81java%E9%9B%86%E5%90%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</url>
      <content type="html"><![CDATA[<blockquote>
<p>读书笔记：《疯狂java 程序员的基本修养》第三章——常见java集合的实现细节</p>
</blockquote>
<h2 id="1-java-中集合及其继承关系"><a href="#1-java-中集合及其继承关系" class="headerlink" title="1.java 中集合及其继承关系"></a>1.java 中集合及其继承关系</h2><p><strong>Collection</strong>中常用的集合类类图如下：<a id="more"></a></p>
<p><img src="/img/article_img/2016/collection_diagram.png" alt=""></p>
<p><strong>Map</strong>中常用的集合类类图如下：</p>
<p><img src="/img/article_img/2016/map_diagram.png" alt=""></p>
<p><em>注：在jdk的安装目录下的 <code>src.zip</code>文件中就是jdk的源码，可以解压后查看。可通过NetBeans<br>等软件进行逆向工程查看类图。由于习惯使用idea，加上它对uml有一定的支持（主要是NetBeans新版不能在jdk1.8之后看类图），这里采用Idea生成类图。如下图：</em></p>
<p><img src="/img/article_img/2016/ide_show_class_diagram.png" alt=""></p>
<p>为了方便查看，可以新建工程，将jdk中的src解压放到该项目目录下，避免因为导入的包使有些类重复显示。</p>
<h2 id="2-Set和Map"><a href="#2-Set和Map" class="headerlink" title="2. Set和Map"></a>2. Set和Map</h2><p><code>Set</code>代表一种集合元素无序、不可重复的集合；<code>Map</code>代表一种由多个<code>key-value</code>对组成的集合。Map是Set集合的扩展。Map的所有的Key都是不可重复的，他们可以组成一个Set集合，对于Map而言，特可以看做是每个元素都是key-value对的集合。</p>
<p><strong>HashSet和HashMap</strong><br>HashSet:用采用Hash算法来决定集合元素的存储位置，可以保证快速存取集合；<br>HashMap:同样采用Hash算法决定key的存储位置，value紧随key存储。</p>
<blockquote>
<p>在java中，虽然集合可以存储对象，但真正存储的是对象的引用，通过这些引用指向具体的对象，与引用类型的数组类似。</p>
</blockquote>
<p>HashMap的构造器：</p>
<ul>
<li>HashMap()<br>构建初始容量为16，负载因子为0.75的HashMap；</li>
<li>HashMap(int initialCapacity)<br>指定初始容量（初始化时会找出大于initialCapacity的最小的2的N次方作为实际的容量，通常情况下实际的容量比initialCapacity大，除非指定的initialCapacity是2的n次方，则指定initialCapacity为2的N次方可以减小系统的开销）</li>
<li>HashMap(int initialCapacity, float loadFactor)<br>指定初始容量和负载因子</li>
</ul>
<p>这里的负载因子，增大它会减小Hash表占用的空间，但会增加查询的时间开销；减小负载因子会提高数据查询性能，但会增加内存占用，可以根据实际的需要适当的设置它。</p>
<p>对于HashSet,大部分方法都是调用HashMap的方法来实现的，在hashset中元素实际上由HashMap的Kkey来保存，value则存的是一个PRESENT——一个静态的Object对象。</p>
<p>对于<strong>TreeMap</strong>，它底层采用的<strong>红黑树</strong>（一种自平衡二叉树了，树种的每个节点的值都大于或等于它左子树种所有节点的值，小于或等于它右子树种所有节点的值）来保存的，保证了所有的key都是从小到大排列的。</p>
<p style="color:red;"><strong>HashTable</strong> 是线程安全的。</p>


<h2 id="3-Map和List"><a href="#3-Map和List" class="headerlink" title="3.Map和List"></a>3.Map和List</h2><p>Map提供了get(K key)方法通过key获取value,List接口提供了get(int index)方法获取指定索引的值。<br>Stack是Vector的子类，是线程安全的，jdk1.6后不推荐使用它，可以使用ArrayQueue替换。</p>
<h2 id="4-ArrayList和LinkedList"><a href="#4-ArrayList和LinkedList" class="headerlink" title="4.ArrayList和LinkedList"></a>4.ArrayList和LinkedList</h2><p>ArrayList和Vector的实现绝大部分都是相同的，只是Vector的方法使用了<em>synchronized</em>修饰，可以看做Vector是ArrayList的线程安全版本。<br>ArrayList是通过数组保存集合元素的，但在定义数组时用<strong>transient</strong>进行修饰，</p>
<p>ArrayList是一种顺序存储的线性表，LinkdList则是一种链式存储的线性表（双链表、队列、栈）。ArrayList在插入/删除数据时，需要将数据进行“整体搬家”。LinkedList是一个双链表，如果要获取某个元素必须进行逐个的搜索，但提供的有<code>addFirst(E e)</code>、<code>addLast(E e)</code>等方法，可以快速的定位需要的操作。</p>
<p>大部分情况下，ArrayList的性能总比LinkedList更优。对于经常需要添加和删除的，可以使用LinkedList.</p>
<h2 id="5-Iterator迭代器"><a href="#5-Iterator迭代器" class="headerlink" title="5.Iterator迭代器"></a>5.Iterator迭代器</h2><p>Iterator是一个迭代器接口，用于迭代各种Collection集合，这里使用了“迭代器模式”。<br>在迭代过程如果删除元素，若该元素不是最后一个，则会抛出异常。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java知识 之 对象及其内存管理]]></title>
      <url>http://imtianx.cn/2016/11/19/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>读书笔记：《疯狂java 程序员的基本修养》第二章——对象及其内存管理</p>
</blockquote>
<p>java中的内存管理分为两个方面：</p>
<ul>
<li><p><strong>内存分配</strong>：指创建java对象时JVM为该对象在堆空间中所分配的内存空间。</p>
</li>
<li><p><strong>内存回收</strong>：指java 对象失去引用，变成垃圾时，JVM的垃圾回收机制自动清理该对象，并回收该对象所占用的内存。<a id="more"></a></p>
</li>
</ul>
<p>虽然JVM 内置了垃圾回收机制，但仍可能导致内存泄露、资源泄露等，所以我们不能肆无忌惮的创建对象。此外，垃圾回收机制是由一个后台线程完成，也是很消耗性能的。</p>
<h2 id="1-实例变量和类变量"><a href="#1-实例变量和类变量" class="headerlink" title="1.实例变量和类变量"></a>1.实例变量和类变量</h2><p>java程序中的变量，大体可以分为<strong>成员变量</strong>和<strong>局部变量</strong>。其中局部变量可分为如下三类：</p>
<ul>
<li><strong>形参</strong>：在方法名中定义的变量，有方法调用者负责为其赋值，随着方法的结束而消亡。</li>
<li><strong>方法内局部变量</strong>：在方法内定义的变量，必须在方法内对其进行初始化。它从初始化完成后开始生效，随着方法结束而消亡。</li>
<li><strong>代码块内局部变量</strong>：在代码块内定义的变量，必须在代码块内对其显示初始化。从初始化完成后生效，随着代码块的结束而消亡。</li>
</ul>
<p><em>局部变量的作用时间很短暂，他们被存在栈内存中。</em><br>类体内定义的变量为成员变量。如果使用<code>static</code>修饰，则为静态变量或者类变量，否则成为非静态变量或者实例变量。</p>
<blockquote>
<p><strong>static</strong>:<br>他的作用是将实例成员编程类成员。只能修饰在类里定义的成员部分，包括变量、方法、内部内（枚举与接口）、初始化块。不能用于修饰外部类、局部变量、局部内部类。</p>
</blockquote>
<p><strong>使用static修饰的成员变量是类类型，属于类本身，没有修饰的属于实例变量，属于该类的实例。在同一个JVM中，每个类可以创建多个java对象。同一个JVM中每个类只对应一个Class对象，机类变量只占一块内存空间，但是实例变量，每次创建便会分配一块内存空间。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">	String name;</span><br><span class="line">	int age;</span><br><span class="line">	static int eyeNum;</span><br><span class="line">	public void info()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;我的名字是：&quot; + name</span><br><span class="line">			+ &quot;， 我的年龄是：&quot; + age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FieldTest</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		// 类变量属于该类本身，只要该类初始化完成，</span><br><span class="line">		// 程序即可使用类变量。</span><br><span class="line">		Person.eyeNum = 2; 		  //①</span><br><span class="line">		// 通过Person类访问eyeNum类变量</span><br><span class="line">		System.out.println(&quot;Person的eyeNum属性：&quot;</span><br><span class="line">			+ Person.eyeNum);</span><br><span class="line">		// 创建第一个Person对象</span><br><span class="line">		Person p = new Person();</span><br><span class="line">		p.name = &quot;猪八戒&quot;;</span><br><span class="line">		p.age = 300;</span><br><span class="line">		// 通过p访问Person类的eyeNum类变量</span><br><span class="line">		System.out.println(&quot;通过p变量访问eyeNum类变量：&quot;</span><br><span class="line">			+ p.eyeNum);           //②</span><br><span class="line">		p.info();</span><br><span class="line">		// 创建第二个Person对象</span><br><span class="line">		Person p2 = new Person();</span><br><span class="line">		p2.name = &quot;孙悟空&quot;;</span><br><span class="line">		p2.age = 500;</span><br><span class="line">		p2.info();</span><br><span class="line">		// 通过p2修改Person类的eyeNum类变量</span><br><span class="line">		p2.eyeNum = 3;     		   //③</span><br><span class="line">		// 分别通过p、p2和Person访问Person类的eyeNum类变量</span><br><span class="line">		System.out.println(&quot;通过p变量访问eyeNum类变量：&quot;</span><br><span class="line">			+ p.eyeNum);</span><br><span class="line">		System.out.println(&quot;通过p2变量访问eyeNum类变量：&quot;</span><br><span class="line">			+ p2.eyeNum);</span><br><span class="line">		System.out.println(&quot;通过Person类访问eyeNum类变量：&quot;</span><br><span class="line">			+ Person.eyeNum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的内存分配如下：</p>
<p><img src="/img/article_img/2016/对象内存分配1.png" alt=""></p>
<p>当Person类初始化完成，类变量也随之初始化完成，不管再创建多少个Person对象，系统都不再为 eyeNum 分配内存，但会为 name 和age 分配内存并初始化。当eyeNum值改变后，通过每个Person对象访问eyeNum的值都随之改变。</p>
<h3 id="a-实例变量的初始化"><a href="#a-实例变量的初始化" class="headerlink" title="a.实例变量的初始化"></a><strong>a.实例变量的初始化</strong></h3><p>对于实例变量，它属于java对象本身，每次程序创建java对象时都会为其分配内存空间，并初始化。<br>实例变量初始化地方：</p>
<ul>
<li>定义实例化变量时；</li>
<li>非静态初始化块中；</li>
<li>构造器中。</li>
</ul>
<p>其中前两种比第三种更早执行，而前两种的执行顺序与他们在程序中的排列顺序相同。它们三种作用完全类似，经过编译后都会提取到构造器中执行，且位于所有语句之前，定义变量赋值和初始化块赋值的顺序与他们在源代码中一致。</p>
<p>可以使用 <code>javap</code>命令查看java编译器的机制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">-help  --help  -?        输出此用法消息</span><br><span class="line">-version                 版本信息</span><br><span class="line">-v  -verbose             输出附加信息</span><br><span class="line">-l                       输出行号和本地变量表</span><br><span class="line">-public                  仅显示公共类和成员</span><br><span class="line">-protected               显示受保护的/公共类和成员</span><br><span class="line">-package                 显示程序包/受保护的/公共类</span><br><span class="line">                       和成员 (默认)</span><br><span class="line">-p  -private             显示所有类和成员</span><br><span class="line">-c                       对代码进行反汇编</span><br><span class="line">-s                       输出内部类型签名</span><br><span class="line">-sysinfo                 显示正在处理的类的</span><br><span class="line">                       系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">-constants               显示最终常量</span><br><span class="line">-classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">-cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">-bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure></p>
<h3 id="b-类变量的初始化"><a href="#b-类变量的初始化" class="headerlink" title="b.类变量的初始化"></a><strong>b.类变量的初始化</strong></h3><p>类变量属于java 类本身，每次运行时才会初始化。<br>类变量的初始化地方：</p>
<ul>
<li>定义类变量时初始化；</li>
<li>静态代码块中初始化</li>
</ul>
<p>如下代码，表面上看输出的是：17.2,17.2；但是实际上输出的是：-2.8,17.2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Price</span><br><span class="line">&#123;</span><br><span class="line">    // 类成员是Price实例</span><br><span class="line">    final static Price INSTANCE = new Price(2.8);</span><br><span class="line">    // 在定义一个类变量。</span><br><span class="line">    static double initPrice = 20;</span><br><span class="line">    // 定义该Price的currentPrice实例变量</span><br><span class="line">    double currentPrice;</span><br><span class="line">    public Price(double discount)</span><br><span class="line">    &#123;</span><br><span class="line">        // 根据静态变量计算实例变量</span><br><span class="line">        currentPrice = initPrice - discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class PriceTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        // 通过Price的INSTANCE访问currentPrice实例变量</span><br><span class="line">        System.out.println(Price.INSTANCE.currentPrice);//输出：-2.8</span><br><span class="line">        // 显式创建Price实例</span><br><span class="line">        Price p = new Price(2.8);</span><br><span class="line">        // 通过先是创建的Price实例访问currentPrice实例变量</span><br><span class="line">        System.out.println(p.currentPrice);            //输出：17.2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一次使用Price 时，程序对其进行初始化，可分为两个阶段：<br>（1）系统为类变量分配内存空间；<br>（2）按初始化代码顺序对变量进行初始化。</p>
<p>这里的运行结果为：-2.8,17.2<br><strong>说明</strong>：初始化第一阶段，系统先为 INSTANCE，initPrice两个类变量分配内存空间，他们的默认值为null和0.0，接着第二阶段依次为他们赋值。对 INSTANCE 赋值时要调用 Price(2.8),创建Price实例，为currentPrice赋值，此时，还未对 initPrice 赋值，就是用他的默认值0，则 currentPrice 值为-2.8，接着程序再次将 initPrice 赋值为20，但对于 currentPrice 实例变量已经不起作用了。</p>
<p>以下为在ide中的debug结果截图：</p>
<p><img src="/img/article_img/2016/对象内存分配-debug.png" alt=""></p>
<h2 id="2-父类构造器"><a href="#2-父类构造器" class="headerlink" title="2.父类构造器"></a>2.父类构造器</h2><p>java中，创建对象时，首先会依次调用每个父类的非静态初始化块、构造器（总是先从Object开始），然后再使用本类的非静态初始化块和构造器进行初始化。在调用父类时可以用<code>super</code>进行<strong>显示调用</strong>，也可以<strong>隐式调用</strong>。</p>
<p>在子类调用父类构造器时，有以下几种场景：</p>
<ul>
<li>子类构造器第一行代码是用<strong>super()</strong>进行显示调用父类构造器，则根据super传入的参数调用相应的构造器；</li>
<li>子类构造器第一行代码是用<strong>this()</strong>进行显示调用本类中重载的构造器，则根据传入this的参数调用相应的构造器；</li>
<li>之类构造器中没有this和super,则在执行子类构造器前，隐式调用父类无参构造器。</li>
</ul>
<blockquote>
<p>注：super和this都是显示调用构造器，只能在构造器中使用，且必须在第一行，只能使用它们其中之一，最多只能调用一次。</p>
</blockquote>
<p>一般情况下，子类对象可以访问父类的实例变量，但父类不能访问子类的，因为父类不知道它会被哪个子类继承，子类又会添加怎样的方法。但在极端的情况下，父类可以访问子类变量的情况，如下实例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package cn.imtianx.p02;</span><br><span class="line"></span><br><span class="line">class Base &#123;</span><br><span class="line">    private int i = 2;</span><br><span class="line">    public Base() &#123;</span><br><span class="line">        this.display();//this：运行时是Driver类型，编译时是Base 类型，这里是Driver对象</span><br><span class="line">    &#125;</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承Base的Derived子类</span><br><span class="line">class Derived extends Base &#123;</span><br><span class="line">    private int i = 22;</span><br><span class="line">    public Derived() &#123;</span><br><span class="line">        i = 222;</span><br><span class="line">    &#125;</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建Derived的构造器创建实例</span><br><span class="line">        new Derived();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码执行后，输出的并不是2、22或者222，而是<strong>0</strong>。在调用Derived 的构造器前会隐式调用Base的无参构造器，初始化 i= 2，此时如果输出<code>this.i</code>则为2，它访问的是Base 类中的实例变量，但是当调用<code>this.display()</code>时，表现的为Driver对象的行为，对于driver对象，它的变量i还未赋初始值，仅仅是为其开辟了内存空间，其值为0。</p>
<p><strong>在java 中，构造器负责实例变量的初始化（即，赋初始值），在执行构造器前，该对象内存空间已经被分配了，他们在内存中存的事其类型所对应的默认值。</strong></p>
<p><strong>在上面的代码中，出现了变量的编译时类型与运行时类型不同。通过该变量访问他所引用的对象的实例变量时，该实例变量的值由申明该变量的类型决定的，当通过该变量调用它所引用的实例对象的实例方法时，该方法将由它实际所引用的对象来决定</strong></p>
<p>当子类重写父类方法时，也会出现父类调用之类方法的情形，如下具体代码，通过上面的则很容易理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">	private String desc;</span><br><span class="line">	public Animal()</span><br><span class="line">	&#123;</span><br><span class="line">		this.desc = getDesc();       </span><br><span class="line">	&#125;</span><br><span class="line">	public String getDesc()</span><br><span class="line">	&#123;</span><br><span class="line">		return &quot;Animal&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	public String toString()</span><br><span class="line">	&#123;</span><br><span class="line">		return desc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Wolf extends Animal</span><br><span class="line">&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private double weight;</span><br><span class="line">	public Wolf(String name , double weight)</span><br><span class="line">	&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line">	// 重写父类的getDesc()方法</span><br><span class="line">	@Override</span><br><span class="line">	public String getDesc()</span><br><span class="line">	&#123;</span><br><span class="line">		return &quot;Wolf[name=&quot; + name + &quot; , weight=&quot;</span><br><span class="line">			+ weight + &quot;]&quot;;  //输出：Wolf[name=null , weight=0.0]</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(new Wolf(&quot;灰太狼&quot; , 32.3)); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-父子实例的内存控制"><a href="#3-父子实例的内存控制" class="headerlink" title="3.父子实例的内存控制"></a>3.父子实例的内存控制</h2><p>java中的继承，在处理成员变量和方法时是不同的。如果之类重写了父类的方法，则完全覆盖父类的方法，并将其其移到子类中，但如果是完全同名的实例变量，则不会覆盖，不会从父类中移到子类中。所以，对于一个引用类型的变量，如果访问他所引用对象的实例变量时，该实例变量的值取决于申明该变量的类型，而调用方法时，则取决于它实际引用对象的类型。</p>
<p>在继承中，内存中子类实例保存有父类的变量的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">    int count = 2;</span><br><span class="line">&#125;</span><br><span class="line">class Mid extends Base &#123;</span><br><span class="line">    int count = 20;</span><br><span class="line">&#125;</span><br><span class="line">public class Sub extends Mid &#123;</span><br><span class="line">    int count = 200;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建一个Sub对象</span><br><span class="line">        Sub s = new Sub();</span><br><span class="line">        // 将Sub对象向上转型后赋为Mid、Base类型的变量</span><br><span class="line">        Mid s2m = s;</span><br><span class="line">        Base s2b = s;</span><br><span class="line">        // 分别通过3个变量来访问count实例变量</span><br><span class="line">        System.out.println(s.count);    //输出：200</span><br><span class="line">        System.out.println(s2m.count);    //输出：20</span><br><span class="line">        System.out.println(s2b.count);    //输出：2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存中的示意图：</p>
<p><img src="/img/article_img/2016/对象内存分配2.png" alt=""></p>
<p>在内存中只有一个Sub对象，并没有Mid和Base对象，但存在3个count的实例变量。</p>
<p><strong>子类中会隐藏父类的变量可以通过super来获取,对于类变量，也可以通过super来访问。</strong></p>
<h2 id="4-final-修饰符"><a href="#4-final-修饰符" class="headerlink" title="4.final 修饰符"></a>4.final 修饰符</h2><p>final 的修饰范围：</p>
<ul>
<li>修饰变量，被赋初始值后不可重新赋值；</li>
<li>修饰方法 ，不能被重写；</li>
<li>修饰类，不能派生出子类。</li>
</ul>
<p>对于final 类型的变量，初始化可以在：定义时、非静态代码块和构造器中；对于final 类型的类变量，初始化可以在：定义时和静态代码块中。</p>
<blockquote>
<p>当final类型的变量定义时就指定初始值，那么该该变量本质上是一个“宏变量”，编译器会把用到该变量的地方直接用其值替换。</p>
</blockquote>
<p>如果在内部内中使用局部变量，必须将其指定为final类型的。普通的变量作用域就是该方法，随着方法的执行结束，局部变量也随之消失，但内部类可能产生隐式的“闭包”，使局部变量脱离它所在的方法继续存在。内部内可能扩大局部变量的作用域，如果内部内中访问的局部变量没有适用final修饰，则可以随意修改它的值，这样将会引起混乱，所以编译器要求被内部访问的局部变量必须使用final 修饰。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java知识 之 数组及其内存管理]]></title>
      <url>http://imtianx.cn/2016/11/17/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E6%95%B0%E7%BB%84%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>读书笔记：《疯狂java 程序员的基本修养》第一章——数组及其内存管理</p>
</blockquote>
<h2 id="1-数组初始化"><a href="#1-数组初始化" class="headerlink" title="1.数组初始化"></a>1.数组初始化</h2><p>数组是一个复合数据结构，当需要多个类型相同的变量时，可以定义数组惊醒使用。在java中，数组变量是一个引用类型的变量。<a id="more"></a><br>java 中的数组是<strong>静态的</strong>，即初始化后，它索占的内存空间、数组长度是不变的。而且必须先<strong>初始化</strong>后使用。</p>
<p><strong>数组的初始化方式：</strong></p>
<ul>
<li><p><strong>静态初始化：</strong>初始化是指定数组的元素的值，由系统决定其长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] datas = new String[]&#123;&quot;java&quot;,&quot;C++&quot;,&quot;html&quot;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态初始化:</strong>指定长度，由系统为数组元素分配初始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] datas = new String[5];//指定长度为5，系统为每个元素指定初始值为null</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>初始值分配规则：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数组类型</th>
<th style="text-align:center">初始化值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">byte、short、long</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:left">float、double</td>
<td style="text-align:center">0.0</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:center">‘\u0000’</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:left">引用类型（类、接口）</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
<p><em>注：不要同时使用静态和动态初始化，即同时指定数组长度和元素初始值</em></p>
<h2 id="2-数组的内存分析"><a href="#2-数组的内存分析" class="headerlink" title="2.数组的内存分析"></a>2.数组的内存分析</h2><p>如下定义三个数组并初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//1.静态初始化一</span><br><span class="line">String[] books = new String[]&#123;</span><br><span class="line">        &quot;疯狂java 讲义&quot;,</span><br><span class="line">        &quot;轻量级javaee企业应用实战&quot;,</span><br><span class="line">        &quot;疯狂ajax讲义&quot;,</span><br><span class="line">        &quot;疯狂XNL讲义&quot;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(&quot;第一个数组的长度为：&quot; + books.length);// 4</span><br><span class="line">//2.静态初始化二</span><br><span class="line">String[] names = &#123;</span><br><span class="line">        &quot;孙悟空&quot;,</span><br><span class="line">        &quot;猪八戒&quot;,</span><br><span class="line">        &quot;白骨精&quot;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(&quot;第二个数组的长度为：&quot; + names.length);// 3</span><br><span class="line">//3.动态初始化</span><br><span class="line">String[] strArr = new String[5];</span><br><span class="line">System.out.println(&quot;第三个数组的长度为：&quot; + strArr.length); // 5</span><br></pre></td></tr></table></figure></p>
<p>上面采用两种静态和一种动态方式初始化数组，其长度分别为4、3、5，其内存分配如下：</p>
<p><img src="/img/article_img/2016/数组内存分配1.png" alt=""></p>
<p>数组变量存在栈区，数组对象存在堆内存，只能通过引用来访问堆内存中的数据。</p>
<p>数组一旦初始化完成后，其内存空间即分配结束，无法改变其长度，但可以修改其元素的值。但数组是一中引用类型的变量，他只是指向对内存中的数组对象，可以改变其引用，从而造成其长度可变的假象，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">books = names;</span><br><span class="line">System.out.println(&quot;books数组的长度为：&quot; + books.length);</span><br><span class="line">strArr = names;</span><br><span class="line">System.out.println(&quot;strArr数组的长度为：&quot; + strArr.length);</span><br><span class="line">books[1] = &quot;唐僧&quot;;</span><br><span class="line">System.out.println(&quot;snames的第三个元素：&quot; + books[1]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果为：<br>books数组的长度为：3<br>strArr数组的长度为：3<br>strArr数组的长度为：唐僧</p>
</blockquote>
<p>books原本长度为4，现在打印出来的是3，这里只是其引用变了导致的，原来books变量引用的数组长度依然是4，只是没有任何引用了，将会被GC回收。内存变化如下：</p>
<p><img src="/img/article_img/2016/数组内存分配2.png" alt=""></p>
<p><strong>java 中的数组变量只是引用变量，他并不是数组的本身，只要让数组变量指向有效的数组对象，即可使用该数组变量.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> int[] nums = new int[]&#123;3,5,20,12&#125;;</span><br><span class="line">int[] prices;</span><br><span class="line">prices = nums;//prices 未初始化，但将其指向nums所引用的数组</span><br><span class="line">for (int i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    System.out.println(prices[i]);</span><br><span class="line">&#125;</span><br><span class="line">//为prices第三个元素赋值</span><br><span class="line">prices[2] = 34;</span><br><span class="line">System.out.println(&quot;nums数组第三个元素为：&quot;+nums[2]);//输出34</span><br></pre></td></tr></table></figure>
<p>prices数组并没有初始化，但可以使用，执行<code>prices = nums;</code>后，他们指向相同的数组对象，是等价的，因此，修改prices的数组元素值，nums的也会随之改变。<strong>对于数组，只要让其指向有效的数组对象，即可使用该变量。</strong></p>
<blockquote>
<p>注意： 引用变量本质上是一个指针，只要通过引用变量访问属性或调用方法，该引用变量就会由它所引用的对象替换。</p>
</blockquote>
<h2 id="3-引用类型数组初始化"><a href="#3-引用类型数组初始化" class="headerlink" title="3.引用类型数组初始化"></a>3.引用类型数组初始化</h2><p>引用类型的数组元素依然是一用类型的，它存储的是引用，指向另一块内存，该内存中存储了引用变量所引用的对象（包括数组和java对象）。</p>
<p>定义一个Person类，用于定义改类型的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    public int age;</span><br><span class="line">    public double height;</span><br><span class="line"></span><br><span class="line">    public void printInfo() &#123;</span><br><span class="line">        System.out.println(&quot;年龄是：&quot; + age + &quot;, 身高是：&quot; + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义person数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Person[] students;</span><br><span class="line">students = new Person[2];</span><br><span class="line">System.out.println(&quot;students数组长度：&quot; + students.length);</span><br><span class="line">Person zhang = new Person();</span><br><span class="line">zhang.age = 12;</span><br><span class="line">zhang.height = 158;</span><br><span class="line"></span><br><span class="line">Person lee = new Person();</span><br><span class="line">lee.age = 16;</span><br><span class="line">lee.height = 161;</span><br><span class="line"></span><br><span class="line">students[0] = zhang;</span><br><span class="line">students[1] = lee;</span><br><span class="line"></span><br><span class="line">//lee和students[1]指向同一个person的实例，以下两句执行效果一样</span><br><span class="line">lee.printInfo();</span><br><span class="line">students[1].printInfo();</span><br></pre></td></tr></table></figure></p>
<p>上述数组内存分配图：</p>
<p><img src="/img/article_img/2016/数组内存分配3.png" alt=""></p>
<p>student数组的两个元素相当于两个引用，分别指向zhang和lee,lee和studentd[1]是指到同一个对象的，同一块内存，有相同的效果。</p>
<h2 id="4-数组的使用"><a href="#4-数组的使用" class="headerlink" title="4.数组的使用"></a>4.数组的使用</h2><p>当定义一个数组，初始化后就相当于定义了多个相同类型的变量。通过索引使用数组元素时，可将其作为普通变量的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Cat</span><br><span class="line">&#123;</span><br><span class="line">	double weight;</span><br><span class="line">	int age;</span><br><span class="line">	public Cat(double weight , int age)</span><br><span class="line">	&#123;</span><br><span class="line">		this.weight = weight;</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ArrayTest</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		// 定义，并动态初始化一个int[]数组</span><br><span class="line">		int[] pos = new int[5];</span><br><span class="line">		// 采用循环为每个数组元素赋值</span><br><span class="line">		for (int i = 0; i &lt; pos.length ; i++ )</span><br><span class="line">		&#123;</span><br><span class="line">			pos[i] = (i + 1) * 2;</span><br><span class="line">		&#125;</span><br><span class="line">		// 对于pos数组的元素来说，用起来完全等同于普通变量</span><br><span class="line">		// 下面即可将数组元素的值赋给int变量，</span><br><span class="line">		// 也可将int变量的值赋给数组元素</span><br><span class="line">		int a = pos[1];</span><br><span class="line">		int b = 20;</span><br><span class="line">		pos[2] = b;             </span><br><span class="line">		// 定义，并动态初始化一个Cat[]数组</span><br><span class="line">		Cat[] cats = new Cat[2];</span><br><span class="line">		cats[0] = new Cat(3.34, 2);</span><br><span class="line">		// 将cats数组的第1个元素的值赋给c1。</span><br><span class="line">		Cat c1 = cats[0];</span><br><span class="line">		Cat c2 = new Cat(4.3, 3);</span><br><span class="line">		// 将c2的值赋给cats数组的第2个元素</span><br><span class="line">		cats[1] = c2;             </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，相关的内存分配图示意图：</p>
<p><img src="/img/article_img/2016/数组内存分配4.png" alt=""></p>
<h2 id="5-多维数组"><a href="#5-多维数组" class="headerlink" title="5.多维数组"></a>5.多维数组</h2><p>对于 <code>int</code>类型，添加 <code>[]</code>后就是一个数组类型，若以<code>int[]</code>类型为已有类型，则增加一个<code>[]</code>,<code>int[][]</code>，也是一个数组类型。因此，所谓的多维数组，其数组元素依然是一个数组，即N维数组，是数组元素为N-1维数组的一维数组。<br>如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[][] a = new int[4][];</span><br><span class="line">a[0] = new int[2];</span><br><span class="line">a[0][1] = 6;</span><br></pre></td></tr></table></figure></p>
<p>内存空间分配图：</p>
<p><img src="/img/article_img/2016/数组内存分配5.png" alt=""></p>
<p>如果将其扩展成三维数组，则6所对应的数组元素指向两一个数组。</p>
<p><strong>多维数组的本质是一维数组。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[activity 生命周期及调用栈详解]]></title>
      <url>http://imtianx.cn/2016/11/08/activity%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E8%B0%83%E7%94%A8%E6%A0%88%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><code>Activity</code>作为android四大组件之首，是我们是使用最频繁的组件，只有熟练的掌握其生命周期和启动模式，才能使我们在编程中进行合理的控制，在合适的生命周期处理相关的业务，开发出高质量的应用。下面具体的介绍下他的生命周期及启动模式。(<a href="https://developer.android.com/guide/components/activities.html" target="_blank" rel="external">android 官方文档-activity</a>)<br><a id="more"></a></p>
<h3 id="一、activity-的四种状态"><a href="#一、activity-的四种状态" class="headerlink" title="一、activity 的四种状态"></a>一、activity 的四种状态</h3><ol>
<li><strong>Active/Running</strong>（活动）<br>此时，activity 处于栈顶，可见，与用户进行交互。系统会不惜一切代价保护她的活跃性的，如果需要，会取消栈中靠下的activity来保证它所需要的资源。</li>
<li><strong>Paused</strong>（暂停）<br>当activity 失去焦点，被一个新的非全屏的activity 或者透明的activity放置在栈顶时，它会进入该状态。此时，它失去了与用户交互的能力，但所有的状态信息、成员变量都还保持着，只有在系统内存极低的情况下会被回收。</li>
<li><strong>Stopped</strong>（停止）<br>当一个activity 被完全覆盖，完全不可见时会进入此状态。但在系统内存中仍然保存着所有的状态和成员信息。当需要内存时，将直接回收。</li>
<li><strong>Kill</strong>（销毁）<br>当activity 被回收或者从来没有创建过，处于此状态。改状态的activity 会从activity栈中移除。<h3 id="二、activity-的生命周期"><a href="#二、activity-的生命周期" class="headerlink" title="二、activity 的生命周期"></a>二、activity 的生命周期</h3>如下如，展示activity的整个生命周期及其切换过程。<br><img src="/img/article_img/2016/activity生命周期.png" alt=""></li>
</ol>
<blockquote>
<p>说明：</p>
<ol>
<li>当一个activity 第一次启动，回调方法如下：<strong>onCreate</strong>-&gt;<strong>onStart</strong>-&gt;<strong>onResum</strong>.</li>
<li>用户打开新的activity或者切换到桌面，回调方法如下：<strong>onPause</strong>-&gt;<strong>onStop</strong>,如果新打开的activity 主题为<strong>透明的</strong>，则不会回调<strong>onStop</strong>。</li>
<li>用户再次回到原activity，毁掉过程如下：<strong>onRestart</strong>-&gt;<strong>onStart</strong>-&gt;<strong>onResume</strong>。</li>
<li>对于整个生命周期，onCreatehe onDestroy是配对的，他们标志着activity 的创建和销毁，并且只会调用一次；对于activity 是否可见，onStart和onStop是配对的，随着用户的操作或者屏幕的电量和熄灭，会被调用多次，但是该状态下不能与用户进行交互；从activity 是否在前台来说，onResume 和onPause 是配对的，他们也会被回调多次。</li>
<li>当前activity 页面打开新的activity，先执行原activity 的 onPause 方法，然后才会启动新activity 。</li>
</ol>
</blockquote>
<h3 id="三、异常情况下的生命周期"><a href="#三、异常情况下的生命周期" class="headerlink" title="三、异常情况下的生命周期"></a>三、异常情况下的生命周期</h3><ol>
<li><p>资源相关配置改变导致activity销毁并重建<br>对于横竖屏切换导致的activity异常销毁并重建，其创建过程如下图：<br><img src="/img/article_img/2016/activity异常重建.png" alt=""></p>
</li>
<li><p>资源内存不足导致低优先级activity 被杀死<br>优先级从搞到低课分为如下三种情况：</p>
</li>
</ol>
<ul>
<li>处于前台与用户交互的activity 的优先级最高；</li>
<li>可见但非前台activity，如弹出的对话框，导致activity可见但无法与用户进行交互；</li>
<li>后台activity（已被暂停的），如执行了onStop方法，优先级最低。</li>
</ul>
<p>当系统内存不足时，按照上面的优先级杀掉activity所在的进程。</p>
<p><strong>onSaveInstanceState (Bundle outState)</strong><br>当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，具体的有如下几种场景：<br>1、当用户按下HOME键时。<br>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</p>
<p>2、长按HOME键，选择运行其他的程序时。<br>3、按下电源按键（关闭屏幕显示）时。<br>4、从activity A中启动一个新的activity时。<br>5、屏幕方向切换时，例如从竖屏切换到横屏时。（如果不指定configchange属性） 在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行</p>
<p>总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用。</p>
<blockquote>
<p><strong>注意点</strong>：<br>1.布局中的每一个View默认实现了onSaveInstanceState()方法，这样的话，这个UI的任何改变都会自动的存储和在activity重新创建的时候自动的恢复。但是这种情况只有在你为这个UI提供了唯一的ID之后才起作用，如果没有提供ID，将不会存储它的状态。</p>
<p>2.由于默认的onSaveInstanceState()方法的实现帮助UI存储它的状态，所以如果你需要覆盖这个方法去存储额外的状态信息时，你应该在执行任何代码之前都调用父类的onSaveInstanceState()方法（super.onSaveInstanceState()）。 既然有现成的可用，那么我们到底还要不要自己实现onSaveInstanceState()?这得看情况了，如果你自己的派生类中有变量影响到UI，或你程序的行为，当然就要把这个变量也保存了，那么就需要自己实现，否则就不需要。</p>
<p>3.由于onSaveInstanceState()方法调用的不确定性，你应该只使用这个方法去记录activity的瞬间状态（UI的状态）。不应该用这个方法去存储持久化数据。当用户离开这个activity的时候应该在onPause()方法中存储持久化数据（例如应该被存储到数据库中的数据）。</p>
<p>4.onSaveInstanceState()如果被调用，这个方法会在onStop()前被触发，但系统并不保证是否在onPause()之前或者之后触发。</p>
</blockquote>
<p><strong>onRestoreInstanceState (Bundle outState)</strong><br>至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的。</p>
<p>onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。</p>
<p>另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。 还有onRestoreInstanceState在onstart之后执行。 至于这两个函数的使用，给出示范代码（留意自定义代码在调用super的前或后）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onSaveInstanceState(Bundle savedInstanceState) &#123;</span><br><span class="line">        savedInstanceState.putBoolean(&quot;MyBoolean&quot;, true);</span><br><span class="line">        savedInstanceState.putDouble(&quot;myDouble&quot;, 1.9);</span><br><span class="line">        savedInstanceState.putInt(&quot;MyInt&quot;, 1);</span><br><span class="line">        savedInstanceState.putString(&quot;MyString&quot;, &quot;Welcome back to Android&quot;);</span><br><span class="line">        // etc.</span><br><span class="line">        super.onSaveInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onRestoreInstanceState(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onRestoreInstanceState(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        boolean myBoolean = savedInstanceState.getBoolean(&quot;MyBoolean&quot;);</span><br><span class="line">        double myDouble = savedInstanceState.getDouble(&quot;myDouble&quot;);</span><br><span class="line">        int myInt = savedInstanceState.getInt(&quot;MyInt&quot;);</span><br><span class="line">        String myString = savedInstanceState.getString(&quot;MyString&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>onSaveInstanceState 方法只适用于保存保存一些临时性的状态，而 onPause 方法适用于数据的持久化保存。</strong></p>
<h3 id="四、activity-启动模式"><a href="#四、activity-启动模式" class="headerlink" title="四、activity 启动模式"></a>四、activity 启动模式</h3><p><strong>任务栈</strong>是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名。</p>
<p>在AndroidManifest中可以给声明的activity通过<strong>android:launchMode=”standard|singleInstance|singleTask|singleTop”</strong>属性指定设置如下四种启动的模式：<br><strong>standard</strong><br>默认的启动方式，每次都会创建新的实例，覆盖在原来的activity之上，可以被同时添加到多个任务栈中，并且每一个任务中可以有多个实例。（只有在该模式的activity 才可以使用startActivityForResult方法）<br><strong>singleTop</strong><br>若设置为该模式，在启动activity时，系统会判断当前栈顶的activity是否是要启动的activity，如果是则直接引用这个实例不创建新的，否则创建新的实例。<br><strong>singleTask</strong><br>与singleTop 类似，它是检测整个activity栈中是否存在当前需要启动的activity。如果存在，则将该activity置于栈顶，并销毁在它之上的activity（注：这是在一个app中）。<br>如果其他程序以singleTask模式来启动这个activity，将创建一个新的任务栈，该模式有<strong>clearTop</strong>效果。<br><strong>singleInstance</strong><br>该模式的使用和浏览器的工作原理类似。在多个程序访问浏览器时，如果浏览器没有打开，则打开，否则再当前打开的浏览器中访问。声明为这种模式的activity，会出现在一个新的任务栈中，而且该任务栈只有这一个activity。</p>
<h3 id="五、Fragment和activity的生命周期关系"><a href="#五、Fragment和activity的生命周期关系" class="headerlink" title="五、Fragment和activity的生命周期关系"></a>五、Fragment和activity的生命周期关系</h3><p>如下图：<br><img src="/img/article_img/2016/fragment_and_activity_lifecycle.jpg" alt=""></p>
<p>谷歌官方 fragment 的生命周期如下图：<br><img src="/img/article_img/2016/fragment-life.png" alt=""></p>
<blockquote>
<p>参考文献：<br>《Android 开发艺术探索》<br>《Android 群英传》<br>《深入解析 Android虚拟机》</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【转】国内一线互联网公司内部面试题库(二)——android 篇]]></title>
      <url>http://imtianx.cn/2016/11/06/%E5%9B%BD%E5%86%85%E4%B8%80%E7%BA%BF%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93(%E4%BA%8C)-android/</url>
      <content type="html"><![CDATA[<p>本文转自：<a href="https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md" target="_blank" rel="external">国内一线互联网公司内部面试题库</a><br>国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库</p>
<p>熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。<br>下面是 android 部分<br><a id="more"></a></p>
<h4 id="1-数据库的操作类型有哪些，如何导入外部数据库？"><a href="#1-数据库的操作类型有哪些，如何导入外部数据库？" class="headerlink" title="1.数据库的操作类型有哪些，如何导入外部数据库？"></a><strong>1.数据库的操作类型有哪些，如何导入外部数据库？</strong></h4><p>把原数据库包括在项目源码的 res/raw </p>
<p>android系统下数据库应该存放在 /data/data/com.<em>.</em>（package name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录.</p>
<h4 id="2-是否使用过本地广播，和全局广播有什么差别？"><a href="#2-是否使用过本地广播，和全局广播有什么差别？" class="headerlink" title="2.是否使用过本地广播，和全局广播有什么差别？"></a><strong>2.是否使用过本地广播，和全局广播有什么差别？</strong></h4><p>因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。<br>不用担心别的应用伪造广播，造成安全隐患。<br>相比在系统内发送全局广播，它更高效。</p>
<h4 id="3-是否使用过intentService，作用是什么，AIDL解决了什么问题？-小米"><a href="#3-是否使用过intentService，作用是什么，AIDL解决了什么问题？-小米" class="headerlink" title="3.是否使用过intentService，作用是什么，AIDL解决了什么问题？(小米)"></a><strong>3.是否使用过intentService，作用是什么，AIDL解决了什么问题？</strong>(小米)</h4><p>生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt。</p>
<p>生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。</p>
<p>该服务提供了一个onBind()方法的默认实现，它返回null</p>
<p>提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。</p>
<p>AIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。<br>AIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。</p>
<h4 id="4-Activity、Window、View三者的差别，fragment的特点？（360）"><a href="#4-Activity、Window、View三者的差别，fragment的特点？（360）" class="headerlink" title="4.Activity、Window、View三者的差别，fragment的特点？（360）"></a><strong>4.Activity、Window、View三者的差别，fragment的特点？</strong>（360）</h4><p>Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）<br>LayoutInflater像剪刀，Xml配置像窗花图纸。</p>
<ol>
<li>在Activity中调用attach，创建了一个Window</li>
<li>创建的window是其子类PhoneWindow，在attach中创建PhoneWindow</li>
<li>在Activity中调用setContentView(R.layout.xxx)</li>
<li>其中实际上是调用的getWindow().setContentView()</li>
<li>调用PhoneWindow中的setContentView方法</li>
<li>创建ParentView：作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）</li>
<li>将指定的R.layout.xxx进行填充通过布局填充器进行填充【其中的parent指的就是DecorView】</li>
<li>调用到ViewGroup</li>
<li>调用ViewGroup的removeAllView()，先将所有的view移除掉</li>
<li>添加新的view：addView()</li>
</ol>
<p><strong>fragment 特点</strong></p>
<ul>
<li>Fragment可以作为Activity界面的一部分组成出现；</li>
<li>可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用；</li>
<li>在Activity运行过程中，可以添加、移除或者替换Fragment；</li>
<li>Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。</li>
</ul>
<h4 id="5-描述一次网络请求的流程（新浪）"><a href="#5-描述一次网络请求的流程（新浪）" class="headerlink" title="5.描述一次网络请求的流程（新浪）"></a><strong>5.描述一次网络请求的流程</strong>（新浪）</h4><p><img src="/img/article_img/2016/http.png" alt=""></p>
<h4 id="6-Handler、Thread和HandlerThread的差别（小米）"><a href="#6-Handler、Thread和HandlerThread的差别（小米）" class="headerlink" title="6.Handler、Thread和HandlerThread的差别（小米）"></a><strong>6.Handler、Thread和HandlerThread的差别</strong>（小米）</h4><p><a href="http://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p>
<p><a href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/" target="_blank" rel="external">http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/</a></p>
<p>从Android中Thread（java.lang.Thread -&gt; java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -&gt; java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。</p>
<p>android.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也是就HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。</p>
<h4 id="7-低版本SDK实现高版本api（小米）"><a href="#7-低版本SDK实现高版本api（小米）" class="headerlink" title="7.低版本SDK实现高版本api（小米）"></a><strong>7.低版本SDK实现高版本api</strong>（小米）</h4><p>自己实现或@TargetApi annotation</p>
<h4 id="8-Ubuntu编译安卓系统（百度）"><a href="#8-Ubuntu编译安卓系统（百度）" class="headerlink" title="8.Ubuntu编译安卓系统（百度）"></a><strong>8.Ubuntu编译安卓系统</strong>（百度）</h4><ol>
<li>进入源码根目录</li>
<li>. build/envsetup.sh</li>
<li>lunch</li>
<li>full(编译全部)</li>
<li>userdebug(选择编译版本)</li>
<li>make -j8(开启8个线程编译)</li>
</ol>
<h4 id="9-launch-mode应用场景（百度、小米、乐视）"><a href="#9-launch-mode应用场景（百度、小米、乐视）" class="headerlink" title="9.launch mode应用场景（百度、小米、乐视）"></a><strong>9.launch mode应用场景</strong>（百度、小米、乐视）</h4><p>standard，创建一个新的Activity。</p>
<p>singleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。</p>
<p>singleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。</p>
<p>注意:</p>
<ol>
<li>设置了”singleTask”启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在； 如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了”singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。</li>
<li>如果设置了”singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。</li>
<li>在一个任务栈中只有一个”singleTask”启动模式的Activity存在。他的上面可以有其他的Activity。这点与singleInstance是有区别的。</li>
</ol>
<p>singleInstance，回退栈中，只有这一个Activity，没有其他Activity。</p>
<p>singleTop适合接收通知启动的内容显示页面。</p>
<p>例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。</p>
<p>singleTask适合作为程序入口点。</p>
<p>例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p>
<p>singleInstance应用场景：</p>
<p>闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。</p>
<h4 id="10-touch-事件传递流程（小米）"><a href="#10-touch-事件传递流程（小米）" class="headerlink" title="10.touch 事件传递流程（小米）"></a><strong>10.touch 事件传递流程</strong>（小米）</h4><p><a href="http://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">http://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</a></p>
<h4 id="11-view绘制流程（百度）"><a href="#11-view绘制流程（百度）" class="headerlink" title="11.view绘制流程（百度）"></a><strong>11.view绘制流程</strong>（百度）</h4><p><a href="http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f" target="_blank" rel="external">http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f</a></p>
<h4 id="12-多线程（360）"><a href="#12-多线程（360）" class="headerlink" title="12.多线程（360）"></a><strong>12.多线程</strong>（360）</h4><ul>
<li>Activity.runOnUiThread(Runnable)</li>
<li>View.post(Runnable),View.postDelay(Runnable,long)</li>
<li>Handler</li>
<li>AsyncTask</li>
</ul>
<h4 id="13-线程同步（百度）"><a href="#13-线程同步（百度）" class="headerlink" title="13.线程同步（百度）"></a><strong>13.线程同步</strong>（百度）</h4><p><a href="http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more" target="_blank" rel="external">http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more</a></p>
<p><a href="http://www.juwends.com/tech/android/android-inter-thread-comm.html" target="_blank" rel="external">http://www.juwends.com/tech/android/android-inter-thread-comm.html</a></p>
<p>单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">private volatile static Singleton mSingleton;</span><br><span class="line">private Singleton()&#123;</span><br><span class="line">&#125;</span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">  if(mSingleton == null)&#123;\\A</span><br><span class="line">    synchronized(Singleton.class)&#123;\\C</span><br><span class="line">     if(mSingleton == null)</span><br><span class="line">      mSingleton = new Singleton();\\B</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mSingleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-什么情况导致内存泄漏（美团）"><a href="#14-什么情况导致内存泄漏（美团）" class="headerlink" title="14.什么情况导致内存泄漏（美团）"></a><strong>14.什么情况导致内存泄漏</strong>（美团）</h4><p>1.资源对象没关闭造成的内存泄漏</p>
<p>描述：<br>资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。<br>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。</p>
<p>2.构造Adapter时，没有使用缓存的convertView</p>
<p>描述：<br>以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：<br>public View getView(int position, ViewconvertView, ViewGroup parent)<br>来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看:<br>android.widget.AbsListView.java –&gt; voidaddScrapView(View scrap) 方法。<br>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public View getView(int position, ViewconvertView, ViewGroup parent) &#123;</span><br><span class="line">View view = new Xxx(...); </span><br><span class="line">... ... </span><br><span class="line">return view; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修正示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public View getView(int position, ViewconvertView, ViewGroup parent) &#123;</span><br><span class="line">View view = null; </span><br><span class="line">if (convertView != null) &#123; </span><br><span class="line">view = convertView; </span><br><span class="line">populate(view, getItem(position)); </span><br><span class="line">... </span><br><span class="line">&#125; else &#123; </span><br><span class="line">view = new Xxx(...); </span><br><span class="line">... </span><br><span class="line">&#125; </span><br><span class="line">return view; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.Bitmap对象不在使用时调用recycle()释放内存</p>
<p>描述：<br>有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">Free up the memory associated with thisbitmap&apos;s pixels, and mark the bitmap as &quot;dead&quot;, meaning itwill throw an exception if getPixels() or setPixels() is called, and will drawnothing. This operation cannot be reversed, so it should only be called ifyou are sure there are no further uses for the bitmap. This is anadvanced call, and normally need not be called, since the normal GCprocess will free up this memory when there are no more references to thisbitmap. </span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>4.试着使用关于application的context来替代和activity相关的context</p>
<p>这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免<br>Android内存泄漏。</p>
<p>5.注册没取消造成的内存泄漏</p>
<p>一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。<br>比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。<br>但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。<br>虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。</p>
<p>6.集合中对象没清理造成的内存泄漏</p>
<p>我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。</p>
<h4 id="15-ANR定位和修正"><a href="#15-ANR定位和修正" class="headerlink" title="15.ANR定位和修正"></a><strong>15.ANR定位和修正</strong></h4><p>如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。</p>
<ul>
<li>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。</li>
<li>主线程中存在耗时的计算</li>
<li>主线程中错误的操作，比如Thread.wait或者Thread.sleep等<br>Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框</li>
<li>应用在5秒内未响应用户的输入事件（如按键或者触摸）</li>
<li>BroadcastReceiver未在10秒内完成相关的处理</li>
<li><p>Service在特定的时间内无法处理完成 20秒</p>
</li>
<li><p>使用AsyncTask处理耗时IO操作。</p>
</li>
<li>使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。</li>
<li>使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。</li>
<li>Activity的onCreate和onResume回调中尽量避免耗时的代码</li>
<li>BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。</li>
</ul>
<h4 id="16-什么情况导致oom（乐视、美团）"><a href="#16-什么情况导致oom（乐视、美团）" class="headerlink" title="16.什么情况导致oom（乐视、美团）"></a><strong>16.什么情况导致oom</strong>（乐视、美团）</h4><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html" target="_blank" rel="external">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html</a></p>
<p>1）使用更加轻量的数据结构<br>2）Android里面使用Enum<br>3）Bitmap对象的内存占用<br>4）更大的图片<br>5）onDraw方法里面执行对象的创建<br>6）StringBuilder</p>
<h4 id="17-Android-Service与Activity之间通信的几种方式"><a href="#17-Android-Service与Activity之间通信的几种方式" class="headerlink" title="17.Android Service与Activity之间通信的几种方式"></a><strong>17.Android Service与Activity之间通信的几种方式</strong></h4><ul>
<li>通过Binder对象</li>
<li>通过broadcast(广播)的形式</li>
</ul>
<h4 id="18-Android各个版本API的区别"><a href="#18-Android各个版本API的区别" class="headerlink" title="18.Android各个版本API的区别"></a><strong>18.Android各个版本API的区别</strong></h4><p><a href="http://blog.csdn.net/lijun952048910/article/details/7980562" target="_blank" rel="external">http://blog.csdn.net/lijun952048910/article/details/7980562</a></p>
<h4 id="19-Android代码中实现WAP方式联网（360）"><a href="#19-Android代码中实现WAP方式联网（360）" class="headerlink" title="19. Android代码中实现WAP方式联网（360）"></a><strong>19. Android代码中实现WAP方式联网</strong>（360）</h4><p><a href="http://blog.csdn.net/asce1885/article/details/7844159" target="_blank" rel="external">http://blog.csdn.net/asce1885/article/details/7844159</a></p>
<h4 id="20-如何保证service在后台不被kill"><a href="#20-如何保证service在后台不被kill" class="headerlink" title="20.如何保证service在后台不被kill"></a><strong>20.如何保证service在后台不被kill</strong></h4><p>一、onStartCommand方法，返回START_STICKY</p>
<ol>
<li><p>START_STICKY<br>在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。</p>
</li>
<li><p>START_NOT_STICKY<br>在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。</p>
</li>
<li><p>START_REDELIVER_INTENT<br>在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。</p>
</li>
</ol>
<p>二、提升service优先级</p>
<p>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p>
<p>三、提升service进程优先级</p>
<p>Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是:</p>
<ol>
<li>前台进程( FOREGROUND_APP)</li>
<li>可视进程(VISIBLE_APP )</li>
<li>次要服务进程(SECONDARY_SERVER )</li>
<li>后台进程 (HIDDEN_APP)</li>
<li>内容供应节点(CONTENT_PROVIDER)</li>
<li>空进程(EMPTY_APP)</li>
</ol>
<p>当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。</p>
<p>四、onDestroy方法里重启service</p>
<p>service +broadcast  方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；</p>
<p>五、Application加上Persistent属性</p>
<p>六、监听系统广播判断Service状态</p>
<p>通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。</p>
<h4 id="21-Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）"><a href="#21-Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）" class="headerlink" title="21.Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）"></a><strong>21.Requestlayout，onlayout，onDraw，DrawChild区别与联系</strong>（猎豹）</h4><p>requestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。<br>说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制<br>任何视图包括该调用者本身。</p>
<p>onLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局)</p>
<p>调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)</p>
<p>drawChild()去重新回调每个子视图的draw()方法</p>
<h4 id="22-invalidate-和postInvalidate-的区别及使用（百度）"><a href="#22-invalidate-和postInvalidate-的区别及使用（百度）" class="headerlink" title="22.invalidate()和postInvalidate() 的区别及使用（百度）"></a><strong>22.invalidate()和postInvalidate() 的区别及使用</strong>（百度）</h4><p><a href="http://blog.csdn.net/mars2639/article/details/6650876" target="_blank" rel="external">http://blog.csdn.net/mars2639/article/details/6650876</a></p>
<h4 id="23-Android动画框架实现原理"><a href="#23-Android动画框架实现原理" class="headerlink" title="23.Android动画框架实现原理"></a><strong>23.Android动画框架实现原理</strong></h4><p>Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。</p>
<h4 id="24-Android为每个应用程序分配的内存大小是多少？（美团）"><a href="#24-Android为每个应用程序分配的内存大小是多少？（美团）" class="headerlink" title="24.Android为每个应用程序分配的内存大小是多少？（美团）"></a><strong>24.Android为每个应用程序分配的内存大小是多少？</strong>（美团）</h4><p>android程序内存一般限制在16M，也有的是24M</p>
<h4 id="25-Android-View刷新机制（百度、美团）"><a href="#25-Android-View刷新机制（百度、美团）" class="headerlink" title="25.Android View刷新机制（百度、美团）"></a><strong>25.Android View刷新机制</strong>（百度、美团）</h4><p>由ViewRoot对象的performTraversals()方法调用draw()方法发起绘制该View树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。</p>
<p>调用流程 ：</p>
<p>mView.draw()开始绘制，draw()方法实现的功能如下：</p>
<ol>
<li>绘制该View的背景</li>
<li>为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框)          </li>
<li>调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)</li>
<li>调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。</li>
</ol>
<h4 id="26-LinearLayout对比RelativeLayout（百度）"><a href="#26-LinearLayout对比RelativeLayout（百度）" class="headerlink" title="26.LinearLayout对比RelativeLayout（百度）"></a><strong>26.LinearLayout对比RelativeLayout</strong>（百度）</h4><ol>
<li>RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure</li>
<li>RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。</li>
<li>在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。</li>
</ol>
<p>最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。</p>
<h4 id="27-优化自定义view（百度、乐视、小米）"><a href="#27-优化自定义view（百度、乐视、小米）" class="headerlink" title="27.优化自定义view（百度、乐视、小米）"></a><strong>27.优化自定义view</strong>（百度、乐视、小米）</h4><p>为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。</p>
<p>你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。</p>
<p>另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。</p>
<p>如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。</p>
<h4 id="28-ContentProvider（乐视）"><a href="#28-ContentProvider（乐视）" class="headerlink" title="28.ContentProvider（乐视）"></a><strong>28.ContentProvider</strong>（乐视）</h4><p><a href="http://blog.csdn.net/coder_pig/article/details/47858489" target="_blank" rel="external">http://blog.csdn.net/coder_pig/article/details/47858489</a></p>
<h4 id="29-fragment生命周期"><a href="#29-fragment生命周期" class="headerlink" title="29.fragment生命周期"></a><strong>29.fragment生命周期</strong></h4><p><img src="/img/article_img/2016/fragment-life.png" alt=""></p>
<h4 id="30-volley解析（美团、乐视）"><a href="#30-volley解析（美团、乐视）" class="headerlink" title="30.volley解析（美团、乐视）"></a><strong>30.volley解析</strong>（美团、乐视）</h4><p><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</a></p>
<h4 id="31-Android-Glide源码解析"><a href="#31-Android-Glide源码解析" class="headerlink" title="31.Android Glide源码解析"></a><strong>31.Android Glide源码解析</strong></h4><p><a href="http://www.lightskystreet.com/2015/10/12/glide_source_analysis/" target="_blank" rel="external">http://www.lightskystreet.com/2015/10/12/glide_source_analysis/</a><br><a href="http://frodoking.github.io/2015/10/10/android-glide/" target="_blank" rel="external">http://frodoking.github.io/2015/10/10/android-glide/</a></p>
<h4 id="32-Android-设计模式"><a href="#32-Android-设计模式" class="headerlink" title="32.Android 设计模式"></a><strong>32.Android 设计模式</strong></h4><p><a href="http://blog.csdn.net/bboyfeiyu/article/details/44563871" target="_blank" rel="external">http://blog.csdn.net/bboyfeiyu/article/details/44563871</a></p>
<h4 id="33-架构设计（搜狐）"><a href="#33-架构设计（搜狐）" class="headerlink" title="33.架构设计（搜狐）"></a><strong>33.架构设计</strong>（搜狐）</h4><p><img src="/img/article_img/2016/architucture.png" alt=""></p>
<p><a href="http://www.tianmaying.com/tutorial/AndroidMVC" target="_blank" rel="external">http://www.tianmaying.com/tutorial/AndroidMVC</a></p>
<h4 id="34-Android属性动画特性（乐视、小米）"><a href="#34-Android属性动画特性（乐视、小米）" class="headerlink" title="34.Android属性动画特性（乐视、小米）"></a><strong>34.Android属性动画特性</strong>（乐视、小米）</h4><p>如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。</p>
<p>注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。</p>
<p>然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。</p>
<p>最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【转】国内一线互联网公司内部面试题库(一)——java篇]]></title>
      <url>http://imtianx.cn/2016/11/05/%E5%9B%BD%E5%86%85%E4%B8%80%E7%BA%BF%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93(%E4%B8%80)-java/</url>
      <content type="html"><![CDATA[<p>本文转自：<a href="https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md" target="_blank" rel="external">国内一线互联网公司内部面试题库</a><br>国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库</p>
<p>熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。<br>下面是java 部分<br><a id="more"></a></p>
<h4 id="1-接口的意义（百度）"><a href="#1-接口的意义（百度）" class="headerlink" title="1.接口的意义（百度）"></a><strong>1.接口的意义</strong>（百度）</h4><p>规范、扩展、回调</p>
<h4 id="2-抽象类的意义（乐视）"><a href="#2-抽象类的意义（乐视）" class="headerlink" title="2.抽象类的意义（乐视）"></a><strong>2.抽象类的意义</strong>（乐视）</h4><p>为其子类提供一个公共的类型<br>封装子类中得重复内容<br>定义抽象方法，子类虽然有不同的实现 但是定义是一致的</p>
<h4 id="3-内部类的作用-百度，乐视"><a href="#3-内部类的作用-百度，乐视" class="headerlink" title="3.内部类的作用(百度，乐视)"></a><strong>3.内部类的作用</strong>(百度，乐视)</h4><ol>
<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li>
<li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问</li>
</ol>
<h4 id="4-父类的静态方法能否被子类重写，为什么？（猎豹）"><a href="#4-父类的静态方法能否被子类重写，为什么？（猎豹）" class="headerlink" title="4.父类的静态方法能否被子类重写，为什么？（猎豹）"></a><strong>4.父类的静态方法能否被子类重写，为什么？</strong>（猎豹）</h4><p>不能</p>
<p>子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现.</p>
<h4 id="5-举1-2个排序算法，并使用java代码实现（美团）"><a href="#5-举1-2个排序算法，并使用java代码实现（美团）" class="headerlink" title="5.举1-2个排序算法，并使用java代码实现（美团）"></a><strong>5.举1-2个排序算法，并使用java代码实现</strong>（美团）</h4><p><a href="http://blog.csdn.net/qy1387/article/details/7752973" target="_blank" rel="external">http://blog.csdn.net/qy1387/article/details/7752973</a></p>
<h4 id="6-列举java的集合和继承关系（百度、美团）"><a href="#6-列举java的集合和继承关系（百度、美团）" class="headerlink" title="6.列举java的集合和继承关系（百度、美团）"></a><strong>6.列举java的集合和继承关系</strong>（百度、美团）</h4><p><img src="/img/article_img/2016/collection.png" alt=""></p>
<h4 id="7-java虚拟机的特性（百度、乐视）"><a href="#7-java虚拟机的特性（百度、乐视）" class="headerlink" title="7.java虚拟机的特性（百度、乐视）"></a><strong>7.java虚拟机的特性</strong>（百度、乐视）</h4><p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p>
<h4 id="8-哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）"><a href="#8-哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）" class="headerlink" title="8.哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）"></a><strong>8.哪些情况下的对象会被垃圾回收机制处理掉</strong>（乐视、美团、小米）</h4><p>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。</p>
<h4 id="9-进程和线程的区别（猎豹）"><a href="#9-进程和线程的区别（猎豹）" class="headerlink" title="9.进程和线程的区别（猎豹）"></a><strong>9.进程和线程的区别</strong>（猎豹）</h4><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。</p>
<p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
<p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p>
<p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p>
<p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。</p>
<h4 id="10-Java中-和equals的区别，equals和hashCode的区别（乐视）"><a href="#10-Java中-和equals的区别，equals和hashCode的区别（乐视）" class="headerlink" title="10.Java中==和equals的区别，equals和hashCode的区别（乐视）"></a><strong>10.Java中==和equals的区别，equals和hashCode的区别</strong>（乐视）</h4><p><a href="http://blog.csdn.net/tiantiandjava/article/details/46988461" target="_blank" rel="external">http://blog.csdn.net/tiantiandjava/article/details/46988461</a></p>
<h4 id="11-常见的排序算法时间复杂度（小米）"><a href="#11-常见的排序算法时间复杂度（小米）" class="headerlink" title="11.常见的排序算法时间复杂度（小米）"></a><strong>11.常见的排序算法时间复杂度</strong>（小米）</h4><p><img src="/img/article_img/2016/algorithm.png" alt=""></p>
<h4 id="12-HashMap的实现原理（美团）"><a href="#12-HashMap的实现原理（美团）" class="headerlink" title="12.HashMap的实现原理（美团）"></a><strong>12.HashMap的实现原理</strong>（美团）</h4><ol>
<li>HashMap概述：<br>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 </li>
<li>HashMap的数据结构：<br> 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</li>
</ol>
<p><img src="/img/article_img/2016/hashmap.jpg" alt=""></p>
<p>从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p>
<h4 id="13-java-状态机"><a href="#13-java-状态机" class="headerlink" title="13.java 状态机"></a><strong>13.java 状态机</strong></h4><p><a href="http://www.jdon.com/designpatterns/designpattern_State.htm" target="_blank" rel="external">http://www.jdon.com/designpatterns/designpattern_State.htm</a></p>
<h4 id="14-java中int-char-long各占多少字节数"><a href="#14-java中int-char-long各占多少字节数" class="headerlink" title="14.java中int char long各占多少字节数"></a><strong>14.java中int char long各占多少字节数</strong></h4><p>byte 位数 8 字节数 1</p>
<p>short 16 2</p>
<p>int 32 4</p>
<p>long 64 8</p>
<p>float 32 4</p>
<p>double 64 8</p>
<p>char 16 2</p>
<h4 id="15-java-int与integer的区别"><a href="#15-java-int与integer的区别" class="headerlink" title="15.java int与integer的区别"></a><strong>15.java int与integer的区别</strong></h4><p><a href="http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html" target="_blank" rel="external">http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html</a></p>
<h4 id="16-string-stringbuffer-stringbuilder-区别（小米、乐视、百度）"><a href="#16-string-stringbuffer-stringbuilder-区别（小米、乐视、百度）" class="headerlink" title="16.string stringbuffer stringbuilder 区别（小米、乐视、百度）"></a><strong>16.string stringbuffer stringbuilder 区别</strong>（小米、乐视、百度）</h4><p>String 字符串常量</p>
<p>StringBuffer 字符串变量（线程安全）</p>
<p>StringBuilder 字符串变量（非线程安全）</p>
<p>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</p>
<p>而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>
<p>String S1 = “This is only a” + “ simple” + “ test”;</p>
<p>StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);<br>你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br> String S1 = “This is only a” + “ simple” + “test”; 其实就是：<br> String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：<br> String S2 = “This is only a”;<br>String S3 = “ simple”;<br>String S4 = “ test”;<br>String S1 = S2 +S3 + S4;<br>这时候 JVM 会规规矩矩的按照原来的方式去做</p>
<p>在大部分情况下 StringBuffer &gt; String</p>
<p>StringBuffer</p>
<p>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p>
<p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。</p>
<p>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p>
<p>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。</p>
<p>在大部分情况下 StringBuilder &gt; StringBuffer</p>
<p>java.lang.StringBuilder</p>
<p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同</p>
<h4 id="17-Java多态（乐视）"><a href="#17-Java多态（乐视）" class="headerlink" title="17.Java多态（乐视）"></a><strong>17.Java多态</strong>（乐视）</h4><p>Java多态性理解</p>
<p>Java中多态性的实现</p>
<p>什么是多态</p>
<p>面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。</p>
<p>多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p>
<p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实<br>际类型，根据其实际的类型调用其相应的方法。</p>
<p>多态的作用：消除类型之间的耦合关系。</p>
<p>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。<br>下面是多态存在的三个必要条件，要求大家做梦时都能背出来！</p>
<p>多态存在的三个必要条件<br>一、要有继承；<br>二、要有重写；<br>三、父类引用指向子类对象。</p>
<p> 多态的好处：</p>
<p>1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。</p>
<p>2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。</p>
<p>3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。</p>
<p>4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。</p>
<p>5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p>
<p>Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。</p>
<h4 id="18-什么导致线程阻塞（58、美团）"><a href="#18-什么导致线程阻塞（58、美团）" class="headerlink" title="18.什么导致线程阻塞（58、美团）"></a><strong>18.什么导致线程阻塞</strong>（58、美团）</h4><p>线程的阻塞</p>
<p>为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.</p>
<p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p>
<ol>
<li>sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。<br>典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。</li>
<li>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</li>
<li>yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.</li>
<li>wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</li>
</ol>
<p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。</p>
<p>上述的核心区别导致了一系列的细节上的区别。</p>
<p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p>
<p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p>
<p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。</p>
<p>关于 wait() 和 notify() 方法最后再说明两点：</p>
<p>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p>
<p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p>
<p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p>
<p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p>
<h4 id="19-抽象类接口区别（360）"><a href="#19-抽象类接口区别（360）" class="headerlink" title="19.抽象类接口区别（360）"></a><strong>19.抽象类接口区别</strong>（360）</h4><ol>
<li><p>默认的方法实现<br>抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现</p>
</li>
<li><p>实现<br>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。<br>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</p>
</li>
<li><p>构造器<br>抽象类可以有构造器<br>接口不能有构造器</p>
</li>
<li><p>与正常Java类的区别<br>除了你不能实例化抽象类之外，它和普通Java类没有任何区<br>接口是完全不同的类型</p>
</li>
<li><p>访问修饰符<br>抽象方法可以有public、protected和default这些修饰符<br>接口方法默认修饰符是public。你不可以使用其它修饰符。</p>
</li>
<li><p>main方法<br>抽象方法可以有main方法并且我们可以运行它<br>接口没有main方法，因此我们不能运行它。</p>
</li>
<li><p>多继承<br>抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。</p>
</li>
<li><p>速度<br>它比接口速度要快<br>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</p>
</li>
<li><p>添加新方法<br>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。<br>如果你往接口中添加方法，那么你必须改变实现该接口的类。</p>
</li>
</ol>
<h4 id="20-容器类之间的区别（乐视、美团）"><a href="#20-容器类之间的区别（乐视、美团）" class="headerlink" title="20.容器类之间的区别（乐视、美团）"></a><strong>20.容器类之间的区别</strong>（乐视、美团）</h4><p><a href="http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html" target="_blank" rel="external">http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html</a><br><a href="http://alexyyek.github.io/2015/04/06/Collection/" target="_blank" rel="external">http://alexyyek.github.io/2015/04/06/Collection/</a><br><a href="http://tianmaying.com/tutorial/java_collection" target="_blank" rel="external">http://tianmaying.com/tutorial/java_collection</a></p>
<h4 id="21-java-内部类（小米）"><a href="#21-java-内部类（小米）" class="headerlink" title="21.java 内部类（小米）"></a><strong>21.java 内部类</strong>（小米）</h4><p><a href="http://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="external">http://www.cnblogs.com/chenssy/p/3388487.html</a></p>
<p><strong>22.Java中hashmap和hashtable的区别</strong>（乐视、小米）</p>
<p><a href="http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html" target="_blank" rel="external">http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html</a></p>
<p><strong>23.ArrayMap VS HashMap</strong></p>
<p><a href="http://lvable.com/?p=217" target="_blank" rel="external">http://lvable.com/?p=217</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[天盾app项目总结]]></title>
      <url>http://imtianx.cn/2016/10/23/%E5%A4%A9%E7%9B%BEapp%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>经过几个星期的努力，天盾app2.0版正式发布。再次记录下自己在开发中遇到的问题：</p>
<ol>
<li>拍照图片oom</li>
<li>listview 图片错位</li>
<li>xutils 数据库的使用与升级<a id="more"></a>
</li>
</ol>
<h3 id="1-拍照显示图片oom"><a href="#1-拍照显示图片oom" class="headerlink" title="1. 拍照显示图片oom"></a>1. 拍照显示图片oom</h3><p>由于该app中有快递单的采集，用RecyclerView 展示，并且每条可能需要拍照录入三张图片，这些图片需要显示并保存到文件便于上传。<br>目前，各个各个手机拍照后生成的图片比较大，分辨率也很高，直接显示很容易出现oom,使用BitmapFactory创建bitmap显示图片，每次使用都会分配内存，通过设置它的<strong>采样率</strong>，以避免。通过使用下面的工具类来加载图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class BitmapUtil &#123;</span><br><span class="line">private static final boolean DEBUG = false;</span><br><span class="line">private static final String TAG = BitmapUtil.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">private BitmapUtil() &#123;</span><br><span class="line">    throw new Error(&quot;Do not need instantiate!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图片压缩处理（使用Options的方法）</span><br><span class="line"> * &lt;p/&gt;</span><br><span class="line"> * @param reqWidth  目标宽度</span><br><span class="line"> * @param reqHeight 目标高度</span><br><span class="line"> */</span><br><span class="line">public static BitmapFactory.Options calculateInSampleSize(</span><br><span class="line">        final BitmapFactory.Options options, final int reqWidth,</span><br><span class="line">        final int reqHeight) &#123;</span><br><span class="line">    // 源图片的高度和宽度</span><br><span class="line">    final int height = options.outHeight;</span><br><span class="line">    final int width = options.outWidth;</span><br><span class="line">    int inSampleSize = 1;</span><br><span class="line">    if (height &gt; 400 || width &gt; 450) &#123;</span><br><span class="line">        if (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line">            // 计算出实际宽高和目标宽高的比率</span><br><span class="line">            final int heightRatio = Math.round((float) height</span><br><span class="line">                    / (float) reqHeight);</span><br><span class="line">            final int widthRatio = Math.round((float) width</span><br><span class="line">                    / (float) reqWidth);</span><br><span class="line">            // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高</span><br><span class="line">            // 一定都会大于等于目标的宽和高。</span><br><span class="line">            inSampleSize = heightRatio &lt; widthRatio ? heightRatio</span><br><span class="line">                    : widthRatio;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置压缩比例</span><br><span class="line">    options.inSampleSize = inSampleSize;</span><br><span class="line">    options.inJustDecodeBounds = false;</span><br><span class="line">    return options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取一个指定大小的bitmap</span><br><span class="line"> *</span><br><span class="line"> * @param reqWidth  目标宽度</span><br><span class="line"> * @param reqHeight 目标高度</span><br><span class="line"> */</span><br><span class="line">public static Bitmap getBitmapFromFile(String pathName, int reqWidth,</span><br><span class="line">                                       int reqHeight) &#123;</span><br><span class="line">    BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = true;</span><br><span class="line">    BitmapFactory.decodeFile(pathName, options);</span><br><span class="line">    options = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line">    return BitmapFactory.decodeFile(pathName, options);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里只列出了计算采样率和从文件中加载显示的方法，如需了解更多该工具，请<a href="https://github.com/l123456789jy/Lazy/blob/master/lazylibrary/src/main/java/com/github/lazylibrary/util/BitmapUtil.java" target="_blank" rel="external">点击此处查看</a><br>具体使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int width = mImageView.getWidth();</span><br><span class="line">int height = mImageView.getHeight();</span><br><span class="line">//picPath 为图片存储路径</span><br><span class="line">mImageView.setImageBitmap(BitmapUtil.getBitmapFromFile(picPath, width, height));</span><br></pre></td></tr></table></figure></p>
<p>进过测试，连续拍照10多张并显示，内存的消耗物明显变化，大约有2M的多动，测试手机为Nexus 6,至此，oom完美解决，性能也十分好。</p>
<h3 id="2-Listview-加载网络图片错位"><a href="#2-Listview-加载网络图片错位" class="headerlink" title="2. Listview 加载网络图片错位"></a>2. Listview 加载网络图片错位</h3><p>在app登陆前，需要选择相应的快递和分部，而快递列表的设计是显示快递图片和快递公司名称，该部分数据是由网络获取的，展示在listView中。当图片地址为空时，无图片的item就会显示其他的图片，而且随着屏幕的滚动而变化，出现错位的现象。这种情况<strong>主要是由于ListView适配器 中getView的convertView复用导致的，解决办法是为imageview设置tag标记，这里以图片的url作为标记。</strong>如下，getView的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">    ViewHolder holder;</span><br><span class="line">    if (convertView == null) &#123;</span><br><span class="line">        convertView = LayoutInflater.from(parent.getContext())</span><br><span class="line">                .inflate(R.layout.list_item_express, parent, false);</span><br><span class="line">        holder = new ViewHolder(convertView);</span><br><span class="line">        convertView.setTag(holder);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        holder = (ViewHolder) convertView.getTag();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String imgUrl = mDatas.get(position).getExpressIco();</span><br><span class="line">    holder.imgExpressIcon.setTag(imgUrl);</span><br><span class="line"></span><br><span class="line">	//这里注意图片地址的判断，被 &quot;&quot; 坑了好久</span><br><span class="line">    if (holder.imgExpressIcon.getTag() == null || holder.imgExpressIcon.getTag().equals(&quot;&quot;)) &#123;</span><br><span class="line">		//若无网络图片，显示错误图片</span><br><span class="line">        holder.imgExpressIcon.setImageResource(R.drawable.express_error);</span><br><span class="line">    &#125; else if (holder.imgExpressIcon.getTag().equals(imgUrl)) &#123;</span><br><span class="line">        x.image().bind(holder.imgExpressIcon, Constants.BASE_URL + imgUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    holder.tvExpressName.setText(mDatas.get(position).getExpressName());</span><br><span class="line"></span><br><span class="line">    return convertView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-xutils3-数据库的使用与升级"><a href="#3-xutils3-数据库的使用与升级" class="headerlink" title="3. xutils3 数据库的使用与升级"></a>3. xutils3 数据库的使用与升级</h3><p>为了节省流量，将采集的数据保存在本地，便于在wifi情况下同一上传，只有该功能需要数据库，加上项目中使用的有xutils，带有数据库模块，便没有自己写或者使用 GreenDao，Ralem等其他的数据库框架。<br>此处简单的记录下改数据库框架的使用。</p>
<ul>
<li><p>在Application中配置<br>在自己的application类（或者使用的activity）中添加配置信息，这里为了方便，在Application类中添加，并通过单利类访问使用。<br>如下部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class SNApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    private static DbManager.DaoConfig mDaoConfig = null;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取数据库配置对象</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static DbManager.DaoConfig getDaoConfig() &#123;</span><br><span class="line">        if (mDaoConfig == null) &#123;</span><br><span class="line">            mDaoConfig = new DbManager.DaoConfig()</span><br><span class="line">                    .setDbName(&quot;ygjexpress.db&quot;)</span><br><span class="line">                    .setDbVersion(2)</span><br><span class="line">                    .setDbOpenListener(new DbManager.DbOpenListener() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onDbOpened(DbManager db) &#123;</span><br><span class="line">                            // 开启WAL, 提升写入速度</span><br><span class="line">                            db.getDatabase().enableWriteAheadLogging();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setDbUpgradeListener(new DbManager.DbUpgradeListener() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onUpgrade(DbManager db, int oldVersion, int newVersion) &#123;</span><br><span class="line">                            //升级数据库</span><br><span class="line">                            try &#123;</span><br><span class="line">								//添加 user_id ，避免同一手机登陆多个账号出现数据混乱</span><br><span class="line">                                db.addColumn(PickupDbItem.class,&quot;user_id&quot;);</span><br><span class="line">                            &#125; catch (DbException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return mDaoConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据表对应的实体类<br>通过注解，来指定数据表名（Table）和字段名（Column），isId 指定是否为id,property设置是否唯一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Table(name = &quot;pickup_item&quot;)</span><br><span class="line">public class PickupDbItem &#123;</span><br><span class="line">    @Column(name = &quot;id&quot;, isId = true)</span><br><span class="line">    private int id;</span><br><span class="line">    @Column(name = &quot;sender_idcrad_id&quot;)</span><br><span class="line">    private String senderIdcradID;//身份证id</span><br><span class="line">    @Column(name = &quot;express_no&quot;)</span><br><span class="line">    private String expressNo;//快递编号</span><br><span class="line">    @Column(name = &quot;pic_bale_before&quot;)</span><br><span class="line">    private String picBaleBefore;//打包前</span><br><span class="line">    @Column(name = &quot;pic_bale_after&quot;)</span><br><span class="line">    private String picBaleAfter;//打包后图片</span><br><span class="line">    @Column(name = &quot;pic_bale_complete&quot;)</span><br><span class="line">    private String picBaleComplete;//贴快递单后图片</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;user_id&quot;)</span><br><span class="line">    private String userId; //当前登录的用户id</span><br><span class="line"></span><br><span class="line">   //此处省略构造方法和getter和setter方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//获取数据库配置</span><br><span class="line">private static DbManager mDbManager = x.getDb(SNApplication.getDaoConfig());</span><br><span class="line">//插入一条</span><br><span class="line"> mDbManager.save(pickupDbItem);</span><br><span class="line"> //查找-条</span><br><span class="line"> pickupDbItem = mDbManager.selector(PickupDbItem.class)</span><br><span class="line">                        .where(&quot;express_no&quot;, &quot;=&quot;, expressNo)</span><br><span class="line">                        .findFirst();</span><br><span class="line">//查找所有</span><br><span class="line">mDbManager.selector(PickupDbItem.class).findAll();</span><br><span class="line">//更新三个字段</span><br><span class="line"> mDbManager.update(pickupDbItem, &quot;sender_idcrad_id&quot;, &quot;pic_bale_before&quot;, &quot;pic_bale_after&quot;, &quot;pic_bale_complete&quot;);</span><br><span class="line"> //删除</span><br><span class="line"> mDbManager.delete(pickupDbItem);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用法很简单，负责的查询条件可以使用<code>WhereBuilder</code>类来构造。更多的请参见<a href="https://github.com/imtianx/xUtils3/blob/master/sample/src/main/java/org/xutils/sample/DbFragment.java" target="_blank" rel="external">此处</a>。</p>
<ul>
<li>数据库的升级</li>
</ul>
<p>在配置文件中<strong>增加版本号，在 setDbUpgradeListener 中的 onUpgrade 方法中添加或删除列，最后在实体中添加相应的字段即可</strong>。</p>
<p>项目比较小，遇到的问题也就这些，需要查看该app的，请访问<a href="https://www.pgyer.com/ygjexpress" target="_blank" rel="external">内测平台</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android studio 生成aar和jar]]></title>
      <url>http://imtianx.cn/2016/10/20/android%20studio%20%E7%94%9F%E6%88%90aar%E5%92%8Cjar/</url>
      <content type="html"><![CDATA[<h3 id="1-aar包"><a href="#1-aar包" class="headerlink" title="1. aar包"></a>1. aar包</h3><p><strong>aar</strong>包是android studio 下打包android 工程中的src、res、lib后生成的aar文件，以便导入到其他的as工程中使用。<br>在as中它的生成方式较为简单，主要步骤如下：</p>
<blockquote>
<p>1.新建model，选择 android Library；<br>2.编写好自己的代码后，将gradle中的 <strong>minifyEnabled</strong>属性 设置成<strong>true</strong><a id="more"></a>，重新build下项目（<strong>Build-&gt;Rebuild Project</strong>,或者使用gradle中的build 命令）<br>3.将as的项目调节为project,进入model下，在<strong>build/outputs/aar/</strong>文件夹下会生成相应的aar文件，如下图：</p>
</blockquote>
<p><img src="/img/article_img/2016/show_aar.png" alt=""></p>
<h3 id="2-jar包"><a href="#2-jar包" class="headerlink" title="2. jar包"></a>2. jar包</h3><p>在as中，不像ec那样可以直接导出jar,需要在gradle 中编写task,主要步骤：</p>
<blockquote>
<p>1.新建model 选择 Java Library，<br>2.先写自己的代码<br>3.在当前model 的gradle 中添写如下代码，<strong>rebuid后便会在build/libs下生成相应的jar</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Copy类型</span><br><span class="line">task makeJar(type: Copy) &#123;</span><br><span class="line">    //删除存在的</span><br><span class="line">    delete &apos;build/libs/javajarlib.jar&apos;</span><br><span class="line">    //设置拷贝的文件</span><br><span class="line">    from(&apos;build/intermediates/bundles/release/&apos;)</span><br><span class="line">    //打进jar包后的文件目录</span><br><span class="line">    into(&apos;build/libs/&apos;)</span><br><span class="line">    //include ,exclude参数来设置过滤</span><br><span class="line">    include(&apos;classes.jar&apos;)</span><br><span class="line">    //重命名</span><br><span class="line">    rename(&apos;classes.jar&apos;, &apos;javajarlib.jar&apos;)</span><br><span class="line">&#125;</span><br><span class="line">makeJar.dependsOn(build)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>但是这种方法，生成的jar是和改model 的名字一样的，即使在上面指定了名字。</p>
<h3 id="3-具体使用"><a href="#3-具体使用" class="headerlink" title="3. 具体使用"></a>3. 具体使用</h3><p>在具体的model中使用时，将生成的相应的包拷贝到libs文件夹中，对于jar可以右键 添加到library中，或者手动在 gradle 中添加。而，对于aar,则只能在gradle中手动添加，如下配置代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">    flatDir&#123;</span><br><span class="line">        dirs &apos;libs&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//在dependencies 中添加，androidlibrary-release值aar包的名字</span><br><span class="line">compile(name:&apos;androidlibrary-release&apos;, ext:&apos;aar&apos;)</span><br></pre></td></tr></table></figure>
<p>通过上面的配置就可以直接在代码中使用了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java 三大特性：封装、继承和多态]]></title>
      <url>http://imtianx.cn/2016/10/15/java%20%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/</url>
      <content type="html"><![CDATA[<p>最近项目上线，暂时稍微闲一点，来回顾下java的一些基础。回想下，也是大二上学的java，已经过去两年了，老师教的基本都是那些最基础的，如数据类型、运算符之类的，加上自己又没有好好学，基本算没学，也就后来转向android 的时候，用啥学啥，如集合、多线程和网络通信等等。下面整理下java面向对象的三大特性。</p>
<h3 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h3><p><strong>封装</strong>是把过程和数据包围起来，对数据的访问只能通过已定义的界面。<a id="more"></a><br>一般是把属性私有，对其的访问只提供<code>getter</code> 和 <code>setter</code> 方法。</p>
<h3 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h3><p><strong>继承</strong>可以理解为一个对象从另一个对象获取方法和属性的过程。常用的两个关键字为：<code>extends</code> 和 <code>implements</code>,他们决定了一个对象和另一个对象间是否是<strong>IS-A</strong>(是一个)的关系。<br>在Java中，类的继承是<strong>单一继承</strong>，也就是说，一个子类只能拥有一个父类。<br>注：java的类均是由 <code>java.lang.Object</code> 类继承而来的，上面说的一个父类并不包含Object,它并不需要显示的声明。<br><strong>extends</strong>关键字是用于 类直接的继承而<strong> implements</strong>是针对接口的。<br>类只能是单继承的，但是接口可以同时实现多个，也可以同时使用。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class A extends B implements  C,D &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：在Java中，类的多重继承是不合法，但接口允许多重继承。</p>
<h3 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h3><p><strong>多态</strong>：同一个行为具有多个不同表现形式或形态的能力。它的必要条件：继承、重写、父类引用指向子类对象。<br>多态性具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p>
<h3 id="四、重写-Override-与重载-Overload"><a href="#四、重写-Override-与重载-Overload" class="headerlink" title="四、重写(Override)与重载(Overload)"></a>四、重写(Override)与重载(Overload)</h3><p><strong>重写</strong> ：是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。他的好处在于子类可以根据需要，定义特定于自己的行为。</p>
<p><strong>方法的重写规则</strong></p>
<ol>
<li>参数列表必须完全与被重写方法的相同；</li>
<li>返回类型必须完全与被重写方法的返回类型相同；</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为final的方法不能被重写。</li>
<li>声明为static的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
</ol>
<p><strong>Super</strong>：当需要在子类中调用父类的被重写方法时，要使用super关键字。</p>
<p><strong>重载</strong>：是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<br>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<p><strong>重载的重写规则</strong></p>
<ol>
<li>被重载的方法必须改变参数列表；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
</ol>
<p><strong>重写与重载之间的区别</strong><br>| 区别点        | 方法重载   |  方法重写  |<br>| ——–   | :—–:  | :—-:  |<br>| 参数列表     |     必须修改 |   不能修改     |<br>| 返回类型        |   可以修改   |   不能修改   |<br>| 异常        |    可以修改    |  可减少或删除，不能抛出新的或者更广的异常  |<br>| 访问 | 可以修改|可以降低访问限制|</p>
<h3 id="五、接口（interface）"><a href="#五、接口（interface）" class="headerlink" title="五、接口（interface）"></a>五、接口（interface）</h3><p><strong>接口：</strong>是抽象方法的集合。它并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。<br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<p><strong>接口的特性：</strong></p>
<ol>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。</li>
<li>接口中的方法都是公有的。</li>
</ol>
<p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键，与类不同的是他可以多重继承其他接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public  interface A  extends InterfaceB,InterfaceC&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>标记接口</strong>:没有任何方法和属性。起作用如下：</p>
<ul>
<li>建立一个公共的父接口；</li>
<li>向一个类添加数据类型。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Bluetooth 通信技术深入--聊天小应用]]></title>
      <url>http://imtianx.cn/2016/09/24/Android%20Bluetooth%20%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%85%A5--%E8%81%8A%E5%A4%A9%E5%B0%8F%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>目前，市场上的大部分手机都带有蓝牙，尽管使用的不多，但作为开发者，我们还有必要了解其原理。最近的项目需要用到蓝牙技术，于是写了个 蓝牙的聊天小demo。</p>
<h3 id="1-效果示意图"><a href="#1-效果示意图" class="headerlink" title="1. 效果示意图"></a>1. 效果示意图</h3><p>这里需要两部手机进行测试。其中一部作为蓝牙服务器，另一部作为蓝牙客户端，进行通信。<a id="more"></a><br>客户端截图：<br><img src="/img/article_img/bluetooth/ble-client.gif" alt="client"><br>服务器截图：<br><img src="/img/article_img/bluetooth/ble-server.gif" alt="server"></p>
<h3 id="2-开发步骤"><a href="#2-开发步骤" class="headerlink" title="2.开发步骤"></a>2.开发步骤</h3><ol>
<li>开启蓝牙；</li>
<li>搜索蓝牙设备；</li>
<li>创建蓝牙socket，读取输出流；</li>
<li>读取和写入数据；</li>
<li>关闭连接和蓝牙。</li>
</ol>
<h3 id="3-具体的实现"><a href="#3-具体的实现" class="headerlink" title="3.具体的实现"></a>3.具体的实现</h3><h4 id="3-1-开启蓝牙"><a href="#3-1-开启蓝牙" class="headerlink" title="3.1 开启蓝牙"></a>3.1 开启蓝牙</h4><p>首先获取蓝牙适配器，若存在蓝牙未开则打开蓝牙，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();</span><br><span class="line">        if (mBluetoothAdapter == null) &#123;</span><br><span class="line">            Toast.makeText(getActivity(), &quot;无蓝牙功能&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (!mBluetoothAdapter.isEnabled()) &#123;</span><br><span class="line">                Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);</span><br><span class="line">                startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-搜索蓝牙"><a href="#3-2-搜索蓝牙" class="headerlink" title="3.2 搜索蓝牙"></a>3.2 搜索蓝牙</h4><p>首先开启蓝牙搜索功能，然后通过注册广播，搜索蓝牙设备，搜索完成后将其加入到蓝牙列表。<br>搜索蓝牙：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (mBluetoothAdapter.isDiscovering()) &#123;</span><br><span class="line">    mBluetoothAdapter.cancelDiscovery();</span><br><span class="line">    mBtnStartSearch.setText(&quot;重新搜索&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    mDatas.clear();</span><br><span class="line">    mAdapter.notifyDataSetChanged();</span><br><span class="line">    //添加设备信息到列表</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line">mBluetoothAdapter.startDiscovery();</span><br><span class="line">mBtnStartSearch.setText(&quot;ֹͣ停止搜索&quot;);</span><br></pre></td></tr></table></figure></p>
<p>注册蓝牙广播：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 搜索设备广播</span><br><span class="line">     */</span><br><span class="line">private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line"></span><br><span class="line">        if (BluetoothDevice.ACTION_FOUND.equals(action)) &#123;</span><br><span class="line">            // 获得设备信息</span><br><span class="line">            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</span><br><span class="line">            // 绑定的状态不一样则进行添加</span><br><span class="line">            if (device.getBondState() != BluetoothDevice.BOND_BONDED) &#123;</span><br><span class="line">                mDatas.add(new BtInfo(device.getName(), device.getAddress(), false));</span><br><span class="line">                mAdapter.notifyDataSetChanged();</span><br><span class="line">                mListView.setSelection(mDatas.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">            // 搜索完成</span><br><span class="line">        &#125; else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) &#123;</span><br><span class="line">            if (mListView.getCount() == 0) &#123;</span><br><span class="line">                Toast.makeText(context, &quot;没有发现设备！&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            mBtnStartSearch.setText(&quot;重新搜索&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line"> * 注册广播</span><br><span class="line"> */</span><br><span class="line">private void registerBroadcast() &#123;</span><br><span class="line">    //设备被发现广播</span><br><span class="line">    IntentFilter discoveryFilter = new IntentFilter(BluetoothDevice.ACTION_FOUND);</span><br><span class="line">    getActivity().registerReceiver(mReceiver, discoveryFilter);</span><br><span class="line"></span><br><span class="line">    // 设备发现完成</span><br><span class="line">    IntentFilter foundFilter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);</span><br><span class="line">    getActivity().registerReceiver(mReceiver, foundFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-连接蓝牙设备"><a href="#3-3-连接蓝牙设备" class="headerlink" title="3.3 连接蓝牙设备"></a>3.3 连接蓝牙设备</h4><p>这里，使用listview展示蓝牙列表信息，item 的点击事件即为连接相应的蓝牙设备，点击某一项后跳转到会话页面，并通知他刷新信息，为方便，这里使用了EventBus来订阅事件，避免使用接口，如下listview 的item 的点击事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//列表item设置监听，</span><br><span class="line">mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123;</span><br><span class="line">        BtInfo info = mDatas.get(i);</span><br><span class="line">        //好友mac地址</span><br><span class="line">        MainActivity.FRIEND_MAC_ADDRESS = info.getAddress();</span><br><span class="line">        //显示提示对话框</span><br><span class="line">        final AlertDialog.Builder dialog = new AlertDialog.Builder(getActivity());</span><br><span class="line">        dialog.setTitle(&quot;连接&quot;);</span><br><span class="line">        dialog.setMessage(&quot;名称：&quot; + info.getName() + &quot;\n&quot; + &quot;地址：&quot; + info.getAddress());</span><br><span class="line">        dialog.setPositiveButton(&quot;连接&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(DialogInterface dialogInterface, int i) &#123;</span><br><span class="line">                mBluetoothAdapter.cancelDiscovery();</span><br><span class="line">                mBtnStartSearch.setText(&quot;重新搜索&quot;);</span><br><span class="line"></span><br><span class="line">                //连接后，跳转到会话页面</span><br><span class="line">                MainActivity.mType = MainActivity.Type.CILENT;</span><br><span class="line">                //viewPager 显示第二页</span><br><span class="line">                MainActivity.mViewPager.setCurrentItem(1);</span><br><span class="line">                //通知 ChatListFragment 刷新信息</span><br><span class="line">                EventBus.getDefault().post(new EventMsg(1));</span><br><span class="line"></span><br><span class="line">                dialogInterface.dismiss();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dialog.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(DialogInterface dialogInterface, int i) &#123;</span><br><span class="line">                MainActivity.FRIEND_MAC_ADDRESS = &quot;&quot;;</span><br><span class="line">                dialogInterface.dismiss();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dialog.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="3-4-创建蓝牙socket"><a href="#3-4-创建蓝牙socket" class="headerlink" title="3.4 创建蓝牙socket"></a>3.4 创建蓝牙socket</h4><p>由于socketd的操作会阻塞线程，这里在子线程中进行创建。<br><code>BluetoothSocket</code> 客户端线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 客户端线程</span><br><span class="line">private class ClientThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mSocket = mDevice.createRfcommSocketToServiceRecord(UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));</span><br><span class="line">            Message msg = new Message();</span><br><span class="line">            msg.obj = &quot;请稍候，正在连接服务器:&quot; + MainActivity.FRIEND_MAC_ADDRESS;</span><br><span class="line">            msg.what = STATUS_CONNECT;</span><br><span class="line">            mHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">            mSocket.connect();</span><br><span class="line"></span><br><span class="line">            msg = new Message();</span><br><span class="line">            msg.obj = &quot;已经连接上服务端！可以发送信息。&quot;;</span><br><span class="line">            msg.what = STATUS_CONNECT_SUCCESS;</span><br><span class="line">            mHandler.sendMessage(msg);</span><br><span class="line">            // 启动接受数据</span><br><span class="line">            mReadThread = new ReadThread();</span><br><span class="line">            mReadThread.start();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            Message msg = new Message();</span><br><span class="line">            msg.obj = &quot;连接服务端异常！断开连接重新试一试。&quot;;</span><br><span class="line">            msg.what = STATUS_CONNECT_SUCCESS;</span><br><span class="line">            mHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建蓝牙连接时需要用到<code>UUID</code>,如需查看更多UUID，请点击<a href="http://blog.csdn.net/txadf/article/details/52235851" target="_blank" rel="external">这里</a>。<br><code>BluetoothServerSocket</code>蓝牙服务端socket线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> // 服务器端线程</span><br><span class="line">private class ServerThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建一个蓝牙服务器 参数分别：服务器名称、UUID</span><br><span class="line">            mServerSocket = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(&quot;btserver&quot;,</span><br><span class="line">                    UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));</span><br><span class="line"></span><br><span class="line">            Message msg = new Message();</span><br><span class="line">            msg.obj = &quot;请稍候，正在等待客户端的连接...&quot;;</span><br><span class="line">            msg.what = STATUS_CONNECT;</span><br><span class="line">            mHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">			/* 接受客户端的连接请求 */</span><br><span class="line">            mSocket = mServerSocket.accept();</span><br><span class="line"></span><br><span class="line">            msg = new Message();</span><br><span class="line">            msg.obj = &quot;客户端已经连接上！可以发送信息。&quot;;</span><br><span class="line">            msg.what = STATUS_CONNECT;</span><br><span class="line">            mHandler.sendMessage(msg);</span><br><span class="line">            // 启动接受数据</span><br><span class="line">            mReadThread = new ReadThread();</span><br><span class="line">            mReadThread.start();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动蓝牙客户端和服务端线程方法如下(详情参见<a href="">类</a>的<code>onEventMainThread</code>方法)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (MainActivity.mType == MainActivity.Type.CILENT) &#123;</span><br><span class="line">    String address = MainActivity.FRIEND_MAC_ADDRESS;//蓝牙地址</span><br><span class="line">    if (!TextUtils.isEmpty(address)) &#123;</span><br><span class="line">        mDevice = mBluetoothAdapter.getRemoteDevice(address);</span><br><span class="line">        mClientThread = new ClientThread();</span><br><span class="line">        mClientThread.start();</span><br><span class="line">        MainActivity.isOpen = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Toast.makeText(getActivity(), &quot;address is null !&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else if (MainActivity.mType == MainActivity.Type.SERVER) &#123;</span><br><span class="line">    mServerThread = new ServerThread();</span><br><span class="line">    mServerThread.start();</span><br><span class="line">    MainActivity.isOpen = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-5-读取和写入数据"><a href="#3-5-读取和写入数据" class="headerlink" title="3.5 读取和写入数据"></a>3.5 读取和写入数据</h4><p>这里主要是通过获取输入输出流来读取和发送数据，以读取数据为例，如下现读取数据线程代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 读取数据</span><br><span class="line">private class ReadThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        byte[] buffer = new byte[1024];</span><br><span class="line">        int bytes;</span><br><span class="line">        InputStream is = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            is = mSocket.getInputStream();</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if ((bytes = is.read(buffer)) &gt; 0) &#123;</span><br><span class="line">                    byte[] buf_data = new byte[bytes];</span><br><span class="line">                    for (int i = 0; i &lt; bytes; i++) &#123;</span><br><span class="line">                        buf_data[i] = buffer[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    String s = new String(buf_data);</span><br><span class="line">                    Message msg = new Message();</span><br><span class="line">                    msg.obj = s;</span><br><span class="line">                    msg.what = 1;</span><br><span class="line">                    mHandler.sendMessage(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; catch (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发送消息与此类似，具体请参见 会话类 <a href=""></a>。</p>
<h4 id="3-6-关闭连接"><a href="#3-6-关闭连接" class="headerlink" title="3.6 关闭连接"></a>3.6 关闭连接</h4><p>主要是关闭各个线程和关闭socket。</p>
<p>至此，整个蓝牙同信已经完成，测试时需要两个手机，一个座位服务器，一个作为客户端，实现他们间的通信。</p>
<p><a href="https://github.com/imtianx/StudyDemoForAndroid/blob/master/A05-bluetoothchatdemo" target="_blank" rel="external">示例demo下载</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Bluetooth 蓝牙技术初体验]]></title>
      <url>http://imtianx.cn/2016/09/20/Android%20Bluetooth%20%E8%93%9D%E7%89%99%E6%8A%80%E6%9C%AF%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>转自：<a href="http://www.jb51.net/article/79334.htm" target="_blank" rel="external">http://www.jb51.net/article/79334.htm</a></p>
<h3 id="1-Bluetooth包简介"><a href="#1-Bluetooth包简介" class="headerlink" title="1.Bluetooth包简介"></a>1.Bluetooth包简介</h3><p>Android平台提供了一个android.bluetooth的包，里面实现蓝牙设备之间通信的蓝牙API。总共有8个类，常用的四个类如下:<br><strong>BluetoothAdapter类</strong><br>代表了一个本地的蓝牙适配器。它是所有蓝牙交互的入口点。利用它你可以发现其他蓝牙设备，查询绑定了的设备，使用已知的MAC地址实例化一个蓝牙设备和建立一个BluetoothServerSocket（作为服务器端）来监听来自其他设备的连接。<a id="more"></a><br><strong>BluetoothDevice类</strong><br>代表了一个远端的蓝牙设备，使用它请求远端蓝牙设备连接或者获取远端蓝牙设备的名称、地址、种类和绑定状态（其信息是封装在BluetoothSocket中）。<br><strong>BluetoothSocket类</strong><br>代表了一个蓝牙套接字的接口（类似于TCP中的套接字），它是应用程序通过输入、输出流与其他蓝牙设备通信的连接点。<br><strong>BlueboothServerSocket类</strong><br>代表打开服务连接来监听可能到来的连接请求（属于server端），为了连接两个蓝牙设备必须有一个设备作为服务器打开一个服务套接字。当远端设备发起连接连接请求的时候，并且已经连接到了的时候，BlueboothServerSocket类将会返回一个BluetoothSocket。</p>
<h3 id="2-常用类的使用"><a href="#2-常用类的使用" class="headerlink" title="2.常用类的使用"></a>2.常用类的使用</h3><p><strong>BluetoothAdapter：蓝牙适配器</strong></p>
<blockquote>
<p>cancelDiscovery()取消探索，当我们正在搜索设备的时候调用这个方法将不再继续搜索<br>disable()关闭蓝牙<br>enable()打开蓝牙，这个方法打开蓝牙不会弹出提示，更多的时候我们需要问下用户是否打开，以下两行代码同样是打开蓝牙，但会提示用户：<br>Intentenabler = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);<br>startActivity(enabler);<br>getAddress()获取本地蓝牙地址<br>getDefaultAdapter()获取默认BluetoothAdapter，实际上，也只有这一种方法获取BluetoothAdapter<br>getName()获取本地蓝牙名称<br>getRemoteDevice(String address)根据蓝牙地址获取远程蓝牙设备<br>getState()获取本地蓝牙适配器当前状态<br>isDiscovering()判断当前是否正在查找设备，是则返回true<br>isEnabled()判断蓝牙是否打开，已打开返回true，否则返回false<br>listenUsingRfcommWithServiceRecord(String name,UUID uuid)根据名称，UUID创建并返回BluetoothServerSocket，这是创建BluetoothSocket服务器端的第一步<br>startDiscovery()开始搜索，这是搜索的第一步</p>
</blockquote>
<p><strong>BluetoothDevice：远程蓝牙设备</strong></p>
<blockquote>
<p>createRfcommSocketToServiceRecord(UUIDuuid)根据UUID创建并返回一个BluetoothSocket，这个方法也是我们获取BluetoothDevice<br>的目的——创建BluetoothSocket<br>这个类其他的方法，如getAddress()、getName()等，同BluetoothAdapter。</p>
</blockquote>
<p><strong>BluetoothSocket：客户端</strong></p>
<blockquote>
<p>//这个类一共有6个方法<br>close()关闭<br>connect()连接<br>isConnected()判断是否连接<br>getInptuStream()获取输入流<br>getOutputStream()获取输出流<br>getRemoteDevice()获取BluetoothSocket指定连接的远程蓝牙设备</p>
</blockquote>
<p><strong>BluetoothServerSocket：服务端</strong></p>
<blockquote>
<p>//这个类一共有4个方法<br>accept()<br>accept(int timeout)<br>close()关闭<br>getChannel()返回这个套接字绑定的通道</p>
</blockquote>
<h3 id="3-数据传输"><a href="#3-数据传输" class="headerlink" title="3.数据传输"></a>3.数据传输</h3><p><strong>蓝牙数据传输——服务器端</strong></p>
<blockquote>
<p>、获得BluetoothAdapter。<br>2、通过BluetoothAdapter.listenUsingRfcommWithServiceRecord(name,UUID uuid)方法创建BluetoothServerSocket对象。<br>3、通过luetoothServerSocket.accept()方法返回一个BluetoothSocket对象。由于该方法处于阻塞状态，需要开启线程来处理。<br>4、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。<br>5、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。</p>
</blockquote>
<p><strong>蓝牙数据传输——客户端</strong></p>
<blockquote>
<p>1、获得BluetoothAdapter。<br>2、通过BluetoothAdapter.getRemoteDevice(String address)获得指定地址的BluetoothDevice对象。<br>3、通过BluetoothDevice.createRfcommSocketToServiceRecord (UUID uuid)方法创建BluetoothSocket对象。<br>4、通过BluetoothSocket.connect（）方法来连接蓝牙设备。<br>5、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。<br>6、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。</p>
</blockquote>
<p>需要的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permissionandroid:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;</span><br><span class="line">&lt;uses-permissionandroid:name=&quot;android.permission.BLUETOOTH&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据绑定库DataBinding的使用]]></title>
      <url>http://imtianx.cn/2016/09/10/using-DataBinding/</url>
      <content type="html"><![CDATA[<p><code>Data Binding</code> 是谷歌提供的 android 数据绑定库，为了而方便开发者实现 MVVM 的架构模式，使用它可以避免我们写大量的<code>findViewByID</code>，降低代码的耦合性。<br><a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="external">官方介绍</a>(需翻墙)</p>
<h3 id="一、使用环境要求"><a href="#一、使用环境要求" class="headerlink" title="一、使用环境要求"></a>一、使用环境要求</h3><p>通过查看官方文档，改数据绑定库的使用环境要求如下：</p>
<ul>
<li>下载 SDK Manager 中的支持库： Support repository；<a id="more"></a></li>
<li>android studio 版本在1.3之后；</li>
<li>gradle 版本在1.5.0-alpha1之后；</li>
<li>android sdk在android 2.1（API level7 +）以后。</li>
</ul>
<h3 id="二、具体的使用"><a href="#二、具体的使用" class="headerlink" title="二、具体的使用"></a>二、具体的使用</h3><h4 id="2-1、配置-data-binding"><a href="#2-1、配置-data-binding" class="headerlink" title="2.1、配置 data binding."></a>2.1、配置 data binding.</h4><p>在 model 的gradle中的 <code>android</code> 节点下添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataBinding&#123;</span><br><span class="line">    enabled = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2、-建立数据对象"><a href="#2-2、-建立数据对象" class="headerlink" title="2.2、 建立数据对象"></a>2.2、 建立数据对象</h4><p>添加一个POJO类，这里定义的是 User类，添加3个变量（uname，usex，uage）及相应的get,set方法，方便接下来与布局文件惊醒绑定。</p>
<h4 id="2-3、-修改布局文件"><a href="#2-3、-修改布局文件" class="headerlink" title="2.3、 修改布局文件"></a>2.3、 修改布局文件</h4><p>使用databinding后，布局文件根节点不在是简单的LinearLayout，RelativeLayout等ViewGroup,而是 <code>Layout</code>，同时还增加了 <code>data</code> 元素，来为ui控件提供数据。基本局如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;data&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line">    &lt;!--原先的根节点--&gt;</span><br><span class="line">    &lt;LinearLayout&gt;</span><br><span class="line">    ....</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>
<p>下面简单举例说明，显示用户信息，包括用户名，性别和年龄，布局文件名为<code>activity_main</code>，使用 databinding 的布局代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;user&quot;</span><br><span class="line">            type=&quot;cn.imtianx.databindingdemo.bean.User&quot;&gt;</span><br><span class="line">        &lt;/variable&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;user.uname&#125;&quot;/&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;user.usex&#125;&quot;/&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;user.uage&#125;&quot;/&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>
<p>该布局主要是三个TextView，来显示信息，在<code>data</code>标签中添加了变量<code>variable</code>,其中<code>name</code>是变量名,<code>type</code>使我们定义的java类（注：需要写完整的包名），通过<code>@{}</code>来为 TextView设置显示的文本。<br>此外，这里的<code>data</code>也可以用<code>import</code>进行导入，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;cn.imtianx.databindingdemo.bean.User&quot;/&gt;</span><br><span class="line">    &lt;variable</span><br><span class="line">        name=&quot;user&quot;</span><br><span class="line">        type=&quot;User&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果要使用<code>String</code>等<code>java.lang.*</code>下的类，则可以直接使用。</p>
<h4 id="2-4、绑定变量数据"><a href="#2-4、绑定变量数据" class="headerlink" title="2.4、绑定变量数据"></a>2.4、绑定变量数据</h4><p>编译项目即可根据布局文件名生成相关的Binding类，生成规则是按布局文件名，去掉’_‘，按驼峰法则，并在末尾添加<code>Binding</code>。如，这里的布局文件名为<code>activity_main</code>,则生成的数据绑定类为<code>ActivityMainBinding</code>，它存放在<code>包名.databinding</code>下，然后再 <strong>activity</strong>  的<strong>onCreate</strong>方法中设置变量，代码如如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    ActivityMainBinding mainBinding = DataBindingUtil</span><br><span class="line">            .setContentView(this, R.layout.activity_main);</span><br><span class="line">    User user = new User(&quot;imtianx&quot;, &quot;男&quot;, &quot;20&quot;);</span><br><span class="line">    mainBinding.setUser(user);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 这里的 ActivityMainBinding 类会根据布局文件中的 variable 生成相应的 <code>set</code>方法。<br>至此，一个简单的数据绑定就实现了，运行程序，会依次显示user中设置的三个字段的值。</p>
<h3 id="三、设置见监听事件"><a href="#三、设置见监听事件" class="headerlink" title="三、设置见监听事件"></a>三、设置见监听事件</h3><p>这里可以通过两种方式进行绑定事件：<strong>方法引用</strong>和<strong>监听器引用</strong>。如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Presenter &#123;</span><br><span class="line"></span><br><span class="line">    public void onTextChanged(CharSequence s, int start, int before, int count) &#123;</span><br><span class="line">        mUserBean.setName(s.toString());</span><br><span class="line">        mBinding.setUser(mUserBean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        Toast.makeText(MainActivity.this, &quot;点击了名字&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onClickListenerBinding(UserBean bean) &#123;</span><br><span class="line">        Toast.makeText(MainActivity.this, bean.getSex(), Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用时首先在xml的data标签下添加变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;variable</span><br><span class="line">    name=&quot;presenter&quot;</span><br><span class="line">    type=&quot;cn.imtianx.databindingdemo.MainActivity.Presenter&quot;&gt;</span><br><span class="line">&lt;/variable&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-方法引用"><a href="#3-1-方法引用" class="headerlink" title="3.1 方法引用"></a>3.1 方法引用</h4><p>必须使用android 已有的监听的方法名及其参数，如上面的onTextChanged，onClick方法，具体的调用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=&quot;@&#123;presenter.onClick&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-监听器引用"><a href="#3-2-监听器引用" class="headerlink" title="3.2 监听器引用"></a>3.2 监听器引用</h4><p>可以方便的丛xml中向java代码中传递数据，可使用lambda表达式,如onClickListenerBinding，具体调用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=&quot;@&#123;()-&gt;presenter.onClickListenerBinding(user)&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<p>采用了lambda表达式的格式。</p>
<h3 id="四、在Fragment中的用法"><a href="#四、在Fragment中的用法" class="headerlink" title="四、在Fragment中的用法"></a>四、在Fragment中的用法</h3><p>布局文件与上一个一样，在 Fragment 的 onCreateView 中设置相关的属性，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private ActivityMainBinding mMainBinding;</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.activity_main, container, false);</span><br><span class="line">        // 方式1,直接用默认生成的Binding类绑定</span><br><span class="line">        mMainBinding = ActivityMainBinding.bind(view);</span><br><span class="line"></span><br><span class="line">        // 方式2，向上转成ViewDataBinding类型</span><br><span class="line">//        ViewDataBinding viewDataBinding = ActivityMainBinding.bind(view);</span><br><span class="line">//        mMainBinding = (ActivityMainBinding) viewDataBinding;</span><br><span class="line"></span><br><span class="line">        //方式3，使用生成的Binding的inflater，</span><br><span class="line">//        mMainBinding = ActivityMainBinding.inflate(inflater);</span><br><span class="line"></span><br><span class="line">        //方式4，使用生成的Binding的inflater,类似Inflater api</span><br><span class="line">//        mMainBinding = ActivityMainBinding.inflate(inflater, container, false);</span><br><span class="line"></span><br><span class="line">        //方式5，某种情况无法生存默认Binding的情况下，并且把对应的layout传入</span><br><span class="line">//        ViewDataBinding viewDataBinding = DataBindingUtil.inflate(inflater, R.layout.activity_main, container, false);</span><br><span class="line">//        mMainBinding = (ActivityMainBinding) viewDataBinding;</span><br><span class="line"></span><br><span class="line">        //方式6，某种情况无法生存默认Binding的情况下</span><br><span class="line">//        ViewDataBinding viewDataBinding = DataBindingUtil.bind(view);</span><br><span class="line"></span><br><span class="line">        user = new User(&quot;imtianx&quot;, &quot;男&quot;, &quot;20&quot;);</span><br><span class="line">        mMainBinding.setUser(user);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>总之，它都需要初始化Binding类，初始化model类和数据绑定。</p>
<h3 id="五-、高级用法"><a href="#五-、高级用法" class="headerlink" title="五 、高级用法"></a>五 、高级用法</h3><h4 id="5-1-使用类方法"><a href="#5-1-使用类方法" class="headerlink" title="5.1. 使用类方法"></a>5.1. 使用类方法</h4><p>首先在布局文件的<code>data</code> 使用<code>import</code>导入方法所在的类的全路径，然后再选要的地方调用，具体使用和java一样。</p>
<h4 id="5-2-类型别名"><a href="#5-2-类型别名" class="headerlink" title="5.2. 类型别名"></a>5.2. 类型别名</h4><p>在开发中可能会遇到两个用名的类，如果在<code>data</code>下同时导入他们，改如何解决？这里不用担心，可以在<code>import</code>节点下添加<code>alias</code>属性,来区别。如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;cn.imtianx.databindingdemo.bean.User&quot; alias=&quot;User1&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;cn.imtianx.databindingdemo.model.User&quot; /&gt;</span><br><span class="line">    &lt;variable</span><br><span class="line">        name=&quot;user&quot;</span><br><span class="line">        type=&quot;User1&quot;/&gt;</span><br><span class="line">    &lt;variable</span><br><span class="line">        name=&quot;user2&quot;</span><br><span class="line">        type=&quot;User&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-3-Null-Coalescing-运算符"><a href="#5-3-Null-Coalescing-运算符" class="headerlink" title="5.3. Null Coalescing 运算符"></a>5.3. Null Coalescing 运算符</h4><p>这个和java中的三木表达式一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;@&#123;user.uage ??user.uage&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>它等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;@&#123;user.uage!=null?user.uage:0&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-4-属性值"><a href="#5-4-属性值" class="headerlink" title="5.4. 属性值"></a>5.4. 属性值</h4><p>使用<code>@{}</code>在xml中使用java 中定义的一些属性值,如下给visibility 设置值，注意需要到如View类，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:visibility=&quot;@&#123;user.display? View.VISIBLE:View.GONE&#125;&quot;</span><br><span class="line">    android:text=&quot;@&#123;user.uage&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-5-使用资源数据"><a href="#5-5-使用资源数据" class="headerlink" title="5.5. 使用资源数据"></a>5.5. 使用资源数据</h4><p>设置<code>padding</code>的值，需要的dime文件中添加largePadding和smallPadding的item。对于引用 <code>String、drawable</code>等资源类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">   android:layout_width=&quot;match_parent&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">   android:padding=&quot;@&#123;user.display?(int)@dimen/largePadding : (int)@dimen/smallPadding&#125;&quot;</span><br><span class="line">   android:text=&quot;@&#123;user.uage&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-6-使用include"><a href="#5-6-使用include" class="headerlink" title="5.6. 使用include"></a>5.6. 使用include</h4><p>使用命名空间来传递variable，将当前 variable 的值传递给 include 进来 的布局中。<br>为 layout 添加命名空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br></pre></td></tr></table></figure></p>
<p>在<code>include</code>中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;include</span><br><span class="line">    layout=&quot;@layout/layout_user&quot;</span><br><span class="line">    bind:user=&quot;@&#123;user&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意在 <code>layout_user.xml</code>中也要在 variable 中 定义添加 user 变量。</p>
<h4 id="5-7-使用表达式"><a href="#5-7-使用表达式" class="headerlink" title="5.7. 使用表达式"></a>5.7. 使用表达式</h4><p>java 中的表达式，在这里也是支持的，</p>
<ul>
<li>数学 + - / * %</li>
<li>字符串连接 +</li>
<li>逻辑 &amp;&amp; ||</li>
<li>二进制 &amp; | ^</li>
<li>一元运算 + - ! ~</li>
<li>移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li>
<li>比较 == &gt; &lt; &gt;= &lt;=</li>
<li>instanceof<br>….<br>Data Binding代码生成时自动检查是否为null来避免出现<code>null pointer exceptions</code>错误,<code>String</code> 类型默认值是<code>null</code> ,<code>int</code>类型默认值是 <code>0</code>，<code>boolean</code> 类型默认值是 <code>false</code>。</li>
</ul>
<h4 id="5-8-集合"><a href="#5-8-集合" class="headerlink" title="5.8. 集合"></a>5.8. 集合</h4><p>常用的集合：arrays、lists、sparse，lists以及maps，为了简便都可以使用<code>[]</code>来访问。注意,在使用泛型时<code>&lt;</code>需要转义，用<code>&amp;lt;</code>代替，否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">  &lt;import type=&quot;android.util.SparseArray&quot;/&gt;</span><br><span class="line">  &lt;import type=&quot;java.util.Map&quot;/&gt;</span><br><span class="line">  &lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class="line">  &lt;variable name=&quot;list&quot; type=&quot;List&amp;lt;String&gt;&quot;/&gt;</span><br><span class="line">  &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&amp;lt;String&gt;&quot;/&gt;</span><br><span class="line">  &lt;variable name=&quot;map&quot; type=&quot;Map&amp;lt;String, String&gt;&quot;/&gt;</span><br><span class="line">  &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;</span><br><span class="line">  &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;list[index]&#125;&quot;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;sparse[index]&#125;&quot;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;map[key]&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-9-Data对象（数据绑定）"><a href="#5-9-Data对象（数据绑定）" class="headerlink" title="5.9.Data对象（数据绑定）"></a>5.9.Data对象（数据绑定）</h4><p>Data Binding 的强大之处主要在于双向数据绑定，当POJO对象发生变化时，通知改变Data对象，已达到更新UI的效果。有三种不同的数据变化通知机制：<code>Observable</code>对象、<code>ObservableFields</code>以及<code>observable  collections</code>。<br>这里以 Observable 为例，更改User类。使其继承<code>BaseObservable</code>,在<code>getter</code>方法前添加<code>Bindable</code>注解，在<code>setter</code>方法中调用<code>notifyPropertyChanged</code>进行更新数据。如果只更新某一字段，只需将该字段设置为<code>ObservableFields</code>类型的，如boolean,可用ObservableBoolean代替，但对其的使用需要通过get和set方法。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class User extends BaseObservable&#123;</span><br><span class="line">    private String uname;</span><br><span class="line">    private String usex;</span><br><span class="line">    private String uage;</span><br><span class="line">    private boolean isDisplay;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String uname, String usex, String uage, boolean isDisplay) &#123;</span><br><span class="line">        this.uname = uname;</span><br><span class="line">        this.usex = usex;</span><br><span class="line">        this.uage = uage;</span><br><span class="line">        this.isDisplay = isDisplay;</span><br><span class="line">    &#125;</span><br><span class="line">    @Bindable</span><br><span class="line">    public String getUname() &#123;</span><br><span class="line">        return uname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUname(String uname) &#123;</span><br><span class="line">        this.uname = uname;</span><br><span class="line">        notifyPropertyChanged(BR.uname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bindable</span><br><span class="line">    public String getUsex() &#123;</span><br><span class="line">        return usex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsex(String usex) &#123;</span><br><span class="line">        this.usex = usex;</span><br><span class="line">        notifyPropertyChanged(BR.usex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bindable</span><br><span class="line">    public String getUage() &#123;</span><br><span class="line">        return uage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUage(String uage) &#123;</span><br><span class="line">        this.uage = uage;</span><br><span class="line">        notifyPropertyChanged(BR.uage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bindable</span><br><span class="line">    public boolean isDisplay() &#123;</span><br><span class="line">        return isDisplay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDisplay(boolean display) &#123;</span><br><span class="line">        isDisplay = display;</span><br><span class="line">        notifyPropertyChanged(BR.display);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在编译期间，Bindable注解在BR(与R文件类似)类文件中生成一个Entry。BR类文件会在模块包内生成。如果用于Data类的基类不能改变，Observable接口通过方便的PropertyChangeRegistry来实现用于储存和有效地通知监听器。</p>
<p>Data Binding的基本用法已经介绍完了，但它 的使用知识点较多，暂且写到这里,对于它在ListView/RecyclerView中的用法、事件处理等稍后再做介绍。<br><br></p>
<p>文中部分资料来源于页底的参考资料。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/LyndonChin/MasteringAndroidDataBinding" target="_blank" rel="external">https://github.com/LyndonChin/MasteringAndroidDataBinding</a></li>
<li><a href="http://www.jianshu.com/p/b1df61a4df77" target="_blank" rel="external">http://www.jianshu.com/p/b1df61a4df77</a></li>
<li><a href="https://realm.io/cn/news/data-binding-android-boyar-mount/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">https://realm.io/cn/news/data-binding-android-boyar-mount/?utm_source=tuicool&amp;utm_medium=referral</a></li>
</ol>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android 异常捕获-UncaughtExceptionHandler]]></title>
      <url>http://imtianx.cn/2016/07/10/android-exception-catch-UncaughtExceptionHandler/</url>
      <content type="html"><![CDATA[<p>在android开发中，异常信息的捕获有多种方式，比如第三方的友盟、蒲公英等，这里主要使用 android 原生的 Thread.UncaughtExceptionHandler 来捕获出现的异常信息<a id="more"></a>,并给出友好的提示，避免出现停止运行，提高用户体验，下面是具体的实现过程。</p>
<p><a href="http://blog.csdn.net/zly921112/article/details/51867079" target="_blank" rel="external">转自： Android 全局异常捕获</a></p>
<h2 id="1-定义自己的异常处理类"><a href="#1-定义自己的异常处理类" class="headerlink" title="1.定义自己的异常处理类"></a>1.定义自己的异常处理类</h2><p>  新建类 <em>CrashHandler</em> 实现 <em>Thread.UncaughtExceptionHandler</em>接口，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CrashHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void uncaughtException(Thread thread, Throwable ex) &#123;</span><br><span class="line">    //回调函数，处理异常出现后的情况</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-设置该异常类为系统默认的"><a href="#2-设置该异常类为系统默认的" class="headerlink" title="2.设置该异常类为系统默认的"></a>2.设置该异常类为系统默认的</h2><p>将上面定义的异常处理类设置为系统默认的异常处理类，当出现异常时，有该类处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.setDefaultUncaughtExceptionHandler(crashHandler);</span><br></pre></td></tr></table></figure></p>
<h2 id="3-具体的实现"><a href="#3-具体的实现" class="headerlink" title="3.具体的实现"></a>3.具体的实现</h2><p>为了方便查看和修复异常，这里将出现异常的手机信息和异常信息保存在文件，以便传给服务器，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context;</span><br><span class="line">import android.content.pm.PackageInfo;</span><br><span class="line">import android.content.pm.PackageManager;</span><br><span class="line">import android.os.Build;</span><br><span class="line">import android.os.Environment;</span><br><span class="line">import android.os.Looper;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.io.StringWriter;</span><br><span class="line">import java.io.Writer;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异常管理类</span><br><span class="line"> * &lt;p/&gt;</span><br><span class="line"> * Created by imtianx on 2016-7-10.</span><br><span class="line"> */</span><br><span class="line">public class CrashHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 系统默认UncaughtExceptionHandler</span><br><span class="line">     */</span><br><span class="line">    private Thread.UncaughtExceptionHandler mDefaultHandler;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * context</span><br><span class="line">     */</span><br><span class="line">    private Context mContext;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 存储异常和参数信息</span><br><span class="line">     */</span><br><span class="line">    private Map&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 格式化时间</span><br><span class="line">     */</span><br><span class="line">    private SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd-HH-mm-ss&quot;);</span><br><span class="line"></span><br><span class="line">    private String TAG = this.getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    private static CrashHandler mInstance;</span><br><span class="line"></span><br><span class="line">    private CrashHandler() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取CrashHandler实例</span><br><span class="line">     */</span><br><span class="line">    public static synchronized CrashHandler getInstance() &#123;</span><br><span class="line">        if (null == mInstance) &#123;</span><br><span class="line">            mInstance = new CrashHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init(Context context) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        //设置该CrashHandler为系统默认的</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * uncaughtException 回调函数</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void uncaughtException(Thread thread, Throwable ex) &#123;</span><br><span class="line">        if (!handleException(ex) &amp;&amp; mDefaultHandler != null) &#123;</span><br><span class="line">            //如果自己没处理交给系统处理</span><br><span class="line">            mDefaultHandler.uncaughtException(thread, ex);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //自己处理</span><br><span class="line">            try &#123;//延迟3秒杀进程</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                Log.e(TAG, &quot;error : &quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">            //退出程序</span><br><span class="line">            AppManager.getAppManager().AppExit(mContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 收集错误信息.发送到服务器</span><br><span class="line">     *</span><br><span class="line">     * @return 处理了该异常返回true, 否则false</span><br><span class="line">     */</span><br><span class="line">    private boolean handleException(Throwable ex) &#123;</span><br><span class="line">        if (ex == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //收集设备参数信息</span><br><span class="line">        collectDeviceInfo(mContext);</span><br><span class="line">        //添加自定义信息</span><br><span class="line">        addCustomInfo();</span><br><span class="line">        //使用Toast来显示异常信息</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Looper.prepare();</span><br><span class="line">                //在此处处理出现异常的情况</span><br><span class="line">                Toast.makeText(mContext, &quot;程序开小差了呢..&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                Looper.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        //保存日志文件</span><br><span class="line">        saveCrashInfo2File(ex);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 收集设备参数信息</span><br><span class="line">     *</span><br><span class="line">     * @param ctx</span><br><span class="line">     */</span><br><span class="line">    public void collectDeviceInfo(Context ctx) &#123;</span><br><span class="line">        //获取versionName,versionCode</span><br><span class="line">        try &#123;</span><br><span class="line">            PackageManager pm = ctx.getPackageManager();</span><br><span class="line">            PackageInfo pi = pm.getPackageInfo(ctx.getPackageName(), PackageManager.GET_ACTIVITIES);</span><br><span class="line">            if (pi != null) &#123;</span><br><span class="line">                String versionName = pi.versionName == null ? &quot;null&quot; : pi.versionName;</span><br><span class="line">                String versionCode = pi.versionCode + &quot;&quot;;</span><br><span class="line">                paramsMap.put(&quot;versionName&quot;, versionName);</span><br><span class="line">                paramsMap.put(&quot;versionCode&quot;, versionCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;an error occured when collect package info&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        //获取所有系统信息</span><br><span class="line">        Field[] fields = Build.class.getDeclaredFields();</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                paramsMap.put(field.getName(), field.get(null).toString());</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Log.e(TAG, &quot;an error occured when collect crash info&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加自定义参数</span><br><span class="line">     */</span><br><span class="line">    private void addCustomInfo() &#123;</span><br><span class="line">        Log.i(TAG, &quot;addCustomInfo: 程序出错了...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 保存错误信息到文件中</span><br><span class="line">     *</span><br><span class="line">     * @param ex</span><br><span class="line">     * @return 返回文件名称, 便于将文件传送到服务器</span><br><span class="line">     */</span><br><span class="line">    private String saveCrashInfo2File(Throwable ex) &#123;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb = new StringBuffer();</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : paramsMap.entrySet()) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            sb.append(key + &quot;=&quot; + value + &quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Writer writer = new StringWriter();</span><br><span class="line">        PrintWriter printWriter = new PrintWriter(writer);</span><br><span class="line">        ex.printStackTrace(printWriter);</span><br><span class="line">        Throwable cause = ex.getCause();</span><br><span class="line">        while (cause != null) &#123;</span><br><span class="line">            cause.printStackTrace(printWriter);</span><br><span class="line">            cause = cause.getCause();</span><br><span class="line">        &#125;</span><br><span class="line">        printWriter.close();</span><br><span class="line">        String result = writer.toString();</span><br><span class="line">        sb.append(result);</span><br><span class="line">        try &#123;</span><br><span class="line">            long timestamp = System.currentTimeMillis();</span><br><span class="line">            String time = format.format(new Date());</span><br><span class="line">            String fileName = &quot;crash-&quot; + time + &quot;-&quot; + timestamp + &quot;.log&quot;;</span><br><span class="line">            if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">                String path = Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/crash/&quot;;</span><br><span class="line">                File dir = new File(path);</span><br><span class="line">                if (!dir.exists()) &#123;</span><br><span class="line">                    dir.mkdirs();</span><br><span class="line">                &#125;</span><br><span class="line">                FileOutputStream fos = new FileOutputStream(path + fileName);</span><br><span class="line">                fos.write(sb.toString().getBytes());</span><br><span class="line">                Log.i(TAG, &quot;saveCrashInfo2File: &quot;+sb.toString());</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;</span><br><span class="line">            return fileName;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;an error occured while writing file...&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：在上述代码中使用了 AppManager类，是常用的activity 管理类 <a href="https://github.com/txadf/Android_Study_Notes/tree/master/android-tools/AppManager.md" target="_blank" rel="external">点此查看</a></p>
<h2 id="4-实际使用"><a href="#4-实际使用" class="headerlink" title="4.实际使用"></a>4.实际使用</h2><p>在application中初始化，并在配置文件中添加读写权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CrashHandler.getInstance().init(this);</span><br></pre></td></tr></table></figure></p>
<p>到此，全局异常捕获已全部完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android 开源库（字体图标，MD控件等）]]></title>
      <url>http://imtianx.cn/2016/06/12/android-open-source-connected/</url>
      <content type="html"><![CDATA[<p>记录自己最近在开发中使用的开源库及部分使用方法，链接地址为个人fork后的地址，可以参见原作者仓库。本文将持续更新，大家有什么好用的可以留言，一起交流学习下。<br><a id="more"></a></p>
<h3 id="1-android-开发常用工具类"><a href="#1-android-开发常用工具类" class="headerlink" title="1. android 开发常用工具类"></a>1. android 开发常用工具类</h3><p>地址：<a href="https://github.com/txadf/Lazy" target="_blank" rel="external">https://github.com/txadf/Lazy</a></p>
<h3 id="2-字体图标"><a href="#2-字体图标" class="headerlink" title="2. 字体图标"></a>2. 字体图标</h3><p>地址：<a href="https://github.com/txadf/material-icon-lib" target="_blank" rel="external">https://github.com/txadf/material-icon-lib</a><br>用法：<br>2.1.添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;net.steamcrafted:materialiconlib:1.0.9&apos;</span><br></pre></td></tr></table></figure></p>
<p>2.2.xml中使用<br>注:需要添加命名空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;net.steamcrafted.materialiconlib.MaterialIconView</span><br><span class="line">        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">        android:id=&quot;@+id/icon&quot;</span><br><span class="line">        android:layout_width=&quot;24dp&quot;</span><br><span class="line">        android:layout_height=&quot;24dp&quot;</span><br><span class="line">        android:scaleType=&quot;center&quot;</span><br><span class="line">        app:materialIcon=&quot;account&quot;</span><br><span class="line">        app:materialIconColor=&quot;@color/mainColor&quot;</span><br><span class="line">        app:materialIconSize=&quot;24dp&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>示例效果：<br><img src="https://camo.githubusercontent.com/802f5408fb1caeae9647d6e72c5905225b24220d/687474703a2f2f692e696d6775722e636f6d2f4b584866586f382e676966" alt=""></p>
<h3 id="3-UI-Model"><a href="#3-UI-Model" class="headerlink" title="3. UI Model"></a>3. UI Model</h3><p>地址：<a href="http://genius.qiujuer.net/module/ui.html" target="_blank" rel="external">http://genius.qiujuer.net/module/ui.html</a><br>按原作者网上站上的配置。<br>具体使用，按钮的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;net.qiujuer.genius.ui.widget.Button</span><br><span class="line">            xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">            android:id=&quot;@+id/gbtn_login&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_marginTop=&quot;25dp&quot;</span><br><span class="line">            android:background=&quot;@color/mainColor&quot;</span><br><span class="line">            android:onClick=&quot;LoginClickEvent&quot;</span><br><span class="line">            android:text=&quot;@string/login_btn&quot;</span><br><span class="line">            android:textColor=&quot;@color/white&quot;</span><br><span class="line">            app:gFont=&quot;roboto.ttf&quot;</span><br><span class="line">            app:gTouchColor=&quot;@color/black_alpha_32&quot;</span><br><span class="line">            app:gTouchDurationRate=&quot;0.7&quot;</span><br><span class="line">            app:gTouchEffect=&quot;ripple&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>同样需要注意添加命名空间。</p>
<h3 id="4-xutils3"><a href="#4-xutils3" class="headerlink" title="4. xutils3"></a>4. xutils3</h3><p>地址：<a href="https://github.com/txadf/xUtils3" target="_blank" rel="external">https://github.com/txadf/xUtils3</a></p>
<h3 id="5-进度条"><a href="#5-进度条" class="headerlink" title="5.进度条"></a>5.进度条</h3><p>地址：<a href="https://github.com/txadf/spots-dialog" target="_blank" rel="external">https://github.com/txadf/spots-dialog</a><br>效果：<br><img src="https://camo.githubusercontent.com/d8108413298d70047f52cff9ac05603a5fd51988/687474703a2f2f332e62702e626c6f6773706f742e636f6d2f2d6c3155765657694d5341672f564c61355a6657346444492f41414141414141414e54632f7273576f755f71623042632f733332302f593648615453772e676966" alt=""></p>
<h3 id="6-对话框"><a href="#6-对话框" class="headerlink" title="6.对话框"></a>6.对话框</h3><p>地址:<a href="https://github.com/txadf/sweet-alert-dialog" target="_blank" rel="external">https://github.com/txadf/sweet-alert-dialog</a><br>示例效果：<br><img src="https://github.com/pedant/sweet-alert-dialog/raw/master/change_type.gif" alt=""></p>
<h3 id="7-EventBus"><a href="#7-EventBus" class="headerlink" title="7. EventBus"></a>7. EventBus</h3><p>地址：<a href="https://github.com/txadf/EventBus" target="_blank" rel="external">https://github.com/txadf/EventBus</a><br>注意：在使用，进行注册订阅时，使用下面的方式，其中“XXX”表示需要订阅的Activity或者Fragment名，避免直接使用“this”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(XXX.this);</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TabLayout+ViewPager创建tab]]></title>
      <url>http://imtianx.cn/2016/05/28/TabLayout+ViewPager%20create%20tab/</url>
      <content type="html"><![CDATA[<p>在degingn库中有TabLayout控件，可以方便的实现tab切换的效果，配合ViewPager.<br><a id="more"></a><br>如下展示效果：<br><img src="/img/article_img/TabLayout+ViewPager-create-tab.gif" alt=""></p>
<h3 id="1-添加依design赖库"><a href="#1-添加依design赖库" class="headerlink" title="1. 添加依design赖库"></a>1. 添加依design赖库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:design:23.4.0&apos;</span><br></pre></td></tr></table></figure>
<h3 id="2-编写主布局文件。"><a href="#2-编写主布局文件。" class="headerlink" title="2.编写主布局文件。"></a>2.编写主布局文件。</h3><p>使用TabLayout和ViewPager。TabLayout 有以下三个属性，方便我们设置tab的字体颜色，选中时字体的颜色及指示器的颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app:tabTextColor=&quot;@android:color/black&quot;</span><br><span class="line">app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;</span><br><span class="line">app:tabIndicatorColor=&quot;@color/colorPrimary&quot;</span><br></pre></td></tr></table></figure></p>
<p>具体的使用，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    tools:context=&quot;cn.imtianx.tablayoutdemo.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.TabLayout</span><br><span class="line">        android:id=&quot;@+id/tab&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:background=&quot;@android:color/white&quot;</span><br><span class="line">        app:tabIndicatorColor=&quot;@color/colorPrimary&quot;</span><br><span class="line">        app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;</span><br><span class="line">        app:tabTextColor=&quot;@android:color/black&quot;&gt;</span><br><span class="line">    &lt;/android.support.design.widget.TabLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v4.view.ViewPager</span><br><span class="line">        android:id=&quot;@+id/container&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/android.support.v4.view.ViewPager&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-编写每个tab的布局。"><a href="#3-编写每个tab的布局。" class="headerlink" title="3. 编写每个tab的布局。"></a>3. 编写每个tab的布局。</h3><p>为了简单，根布局仅使用一个 LinearLayout 并给其背景设置了颜色。</p>
<h3 id="4-创建适配器"><a href="#4-创建适配器" class="headerlink" title="4. 创建适配器"></a>4. 创建适配器</h3><p>创建 FragmentAdapter类，继承FragmentPagerAdapter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by imtianx on 2016-5-27.</span><br><span class="line"> */</span><br><span class="line">public class FragmentAdapter extends FragmentPagerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; mTitles; //标题</span><br><span class="line">    private List&lt;Fragment&gt; mFragments;//viewpager 显示的页面</span><br><span class="line"></span><br><span class="line">    public FragmentAdapter(FragmentManager fm, List&lt;String&gt; titles, List&lt;Fragment&gt; fragments) &#123;</span><br><span class="line">        super(fm);</span><br><span class="line">        mTitles = titles;</span><br><span class="line">        mFragments = fragments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Fragment getItem(int position) &#123;</span><br><span class="line">        return mFragments.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return mFragments.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * tab 标题</span><br><span class="line">     *</span><br><span class="line">     * @param position</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public CharSequence getPageTitle(int position) &#123;</span><br><span class="line">        return mTitles.get(position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-新建fragment页面"><a href="#5-新建fragment页面" class="headerlink" title="5. 新建fragment页面"></a>5. 新建fragment页面</h3><p>创建3个fragment，加载相应的布局。</p>
<h3 id="6-绑定控件"><a href="#6-绑定控件" class="headerlink" title="6.绑定控件"></a>6.绑定控件</h3><p>在MainActicity 中绑定控件，设置adapter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Fragment&gt; mFragmentList;</span><br><span class="line">    List&lt;String&gt; mTitles;</span><br><span class="line">    TabFragment1 mFragment1;</span><br><span class="line">    TabFragment2 mFragment2;</span><br><span class="line">    TabFragment3 mFragment3;</span><br><span class="line">    FragmentAdapter mAdapter;</span><br><span class="line"></span><br><span class="line">    private TabLayout mTabLayout;</span><br><span class="line">    private ViewPager mViewPager;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        mTabLayout = (TabLayout) findViewById(R.id.tab);</span><br><span class="line">        mViewPager = (ViewPager) findViewById(R.id.container);</span><br><span class="line"></span><br><span class="line">        //添加标题</span><br><span class="line">        mTitles = new ArrayList&lt;&gt;();</span><br><span class="line">        mTitles.add(&quot;报价中&quot;);</span><br><span class="line">        mTitles.add(&quot;运输中&quot;);</span><br><span class="line">        mTitles.add(&quot;已完成&quot;);</span><br><span class="line"></span><br><span class="line">        //添加页面</span><br><span class="line">        mFragmentList = new ArrayList&lt;&gt;();</span><br><span class="line">        mFragment1 = new TabFragment1();</span><br><span class="line">        mFragment2 = new TabFragment2();</span><br><span class="line">        mFragment3 = new TabFragment3();</span><br><span class="line">        mFragmentList.add(mFragment1);</span><br><span class="line">        mFragmentList.add(mFragment2);</span><br><span class="line">        mFragmentList.add(mFragment3);</span><br><span class="line"></span><br><span class="line">        //初始化适配器</span><br><span class="line">        mAdapter = new FragmentAdapter(getSupportFragmentManager(),</span><br><span class="line">                mTitles, mFragmentList);</span><br><span class="line">        //设置适配器</span><br><span class="line">        mViewPager.setAdapter(mAdapter);</span><br><span class="line">        //加载viewpager</span><br><span class="line">        mTabLayout.setupWithViewPager(mViewPager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-带icon的tab"><a href="#7-带icon的tab" class="headerlink" title="7. 带icon的tab"></a>7. 带icon的tab</h3><p>效果图如下：<br><img src="/img/article_img/TabLayout+ViewPager-create-tab_icon.gif" alt=""></p>
<ul>
<li><p>1.布局基本没有变，只是在上面的布局基础下，将ViewPager和TabLayout的上下位置调换下。添加如下属性将TabLayout的指示条高度设为0，不可见：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:tabIndicatorHeight=&quot;0dp&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.为每个tab添加selector。以第一个tab为例，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/home_pressed&quot; android:state_selected=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/home_normal&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.IconTabActivity中将定义的selector设置为TabLayout的icon:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mTabLayout.getTabAt(0).setIcon(getResources().getDrawable(R.drawable.tab_hall_bg));</span><br><span class="line">mTabLayout.getTabAt(1).setIcon(getResources().getDrawable(R.drawable.tab_joined_bg));</span><br><span class="line">mTabLayout.getTabAt(2).setIcon(getResources().getDrawable(R.drawable.tab_me_bg));</span><br></pre></td></tr></table></figure>
<p>到此，已经完成了，TabLayout的使用和TabHost的使用类似，但它更为方便，使用起来较为简单。<br><a href="https://github.com/imtianx/StudyDemoForAndroid/blob/master/A03-tablayoutdemo" target="_blank" rel="external">Demo下载</a><br><br>注：demo中,不带icon:的是MainActivity，带icon的是IconTabActivity。可在AndroidManifest切换运行查看</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[属性动画详解（Animator）]]></title>
      <url>http://imtianx.cn/2016/04/25/Property-animatorValueAnimator_ObjectAnimation/</url>
      <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><p>对于之前介绍的Animation，它属于<strong>视图动画</strong>（View Animation）(可参见：<a href="http://imtianx.cn/2016/04/25/view-Animation/">Animation 动画详解</a>)，包括<strong>补间动画</strong>（Tween Animation）和<strong>逐帧动画</strong>（Tween Animation）；而在android中还有另一种动画，那就是<strong>属性动画</strong>（Property Animator），它包括<strong>ValueAnimator</strong> 和 <strong>ObjectAnimator</strong>。<br><a id="more"></a><br>两者的<strong>区别</strong>：</p>
<ul>
<li>引入时间不同<br>视图动画在API Level 1 引入的，而属性动画在API Level 11（即 android 3.0）引入的； </li>
<li>所在包不同<br>视图动画在 <strong>android.view.animation.Animation</strong>包下，属性动画在：<strong>android.animation</strong>包下</li>
<li>动画类的命名不同<br>视图动画中类的名字为：<strong>XXXAnimation</strong>，而在属性动画中是：<strong>XXXAnimator</strong></li>
<li><strong>作用的对象不同</strong>（这个也是引入属性动画的原因）<br><strong>视图动画是对控件做动画，不能改变控件内部的属性，对所有的控件都可以；而属性动画是通过改变控件的属性来实现动画，但使用ObjectAnimator时要求作用的控件的属性要有get,set方法。如果控件的属性没有get/set方法，可以通过包装类间接的设置get/set方法，或者使用ValueAnimator 实现。</strong></li>
</ul>
<h1 id="2、ValueAnimator-的基本使用"><a href="#2、ValueAnimator-的基本使用" class="headerlink" title="2、ValueAnimator 的基本使用"></a>2、ValueAnimator 的基本使用</h1><p>ValueAnimator是动画的核心，但不提供任何动画效果，它更像一个数值发生器，产生具有一定规律的数字，然后让调用者来控制动画的实现过程。用法如下：</p>
<ul>
<li><strong>创建ValueAnimator实例</strong><br>例：创建0到500的动画，时间为1s:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator animator = ValueAnimator.ofInt(0,500);  </span><br><span class="line">animator.setDuration(1000);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>代码中可以看出，它不与任何控件关联，只对动画做运算。</p>
<ul>
<li><p><strong>添加它的监听事件</strong><br>下面是给它添加监听事件，实现动画的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">animator.addUpdateListener(new ValueAnimator.</span><br><span class="line">                       AnimatorUpdateListener() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">                       //具体处理动画逻辑</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               //开启动画</span><br><span class="line">               animator.start();</span><br></pre></td></tr></table></figure>
<p>具体示例：<br>点击按钮使textView从(200,200)移动到（600，,600）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  btnStartAnim = (Button) findViewById(R.id.btn);</span><br><span class="line">tv = (TextView) findViewById(R.id.tv);</span><br><span class="line">btnStartAnim.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        //设置数据</span><br><span class="line">        ValueAnimator animator = ValueAnimator.ofInt(200, 600);</span><br><span class="line">        animator.setDuration(1000);</span><br><span class="line">        //监听动画</span><br><span class="line">        animator.addUpdateListener(new ValueAnimator.</span><br><span class="line">                AnimatorUpdateListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">                //获取当前动画的值</span><br><span class="line">                int curValue = (int) animation.getAnimatedValue();</span><br><span class="line">                //设置tv的位置</span><br><span class="line">                tv.layout(curValue, curValue,</span><br><span class="line">                        curValue + tv.getWidth(),</span><br><span class="line">                        curValue + tv.getHeight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //开启动画</span><br><span class="line">        animator.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>示例效果：<br><img src="/img/article_img/ValueAnimator-simple-demo.gif" alt=""></p>
<h1 id="3、ValueAnimator-常用方法"><a href="#3、ValueAnimator-常用方法" class="headerlink" title="3、ValueAnimator 常用方法"></a>3、ValueAnimator 常用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 设置动画参数，参数类型为可变参数</span><br><span class="line">*/</span><br><span class="line">ValueAnimator ofInt(int... values);</span><br><span class="line">ValueAnimator ofFloat(int... values);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 设置动画时长，单位是毫秒</span><br><span class="line">*/</span><br><span class="line">ValueAnimator setDuration(long duration);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 获取 ValueAnimator 在运动时，当前运动点的值</span><br><span class="line">*/</span><br><span class="line">Object getAnimatedValue();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 开始动画</span><br><span class="line">*/</span><br><span class="line">void start();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 设置循环次数,设置为 INFINITE 表示无限循环</span><br><span class="line">*/</span><br><span class="line">void setRepeatCount(int value);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 设置循环模式</span><br><span class="line">* value 取值有 RESTART，REVERSE（分别为：重新开始，倒序重新开始）</span><br><span class="line">*/</span><br><span class="line">void setRepeatMode(int value);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 取消动画</span><br><span class="line">*/</span><br><span class="line">void cancel();</span><br></pre></td></tr></table></figure>
<p>通过源码，发现ofInt和ofFloat方法内部实现一样的，他们的区别在于传入的参数类型不同，需要注意的是在使用<strong>getAnimatedValue</strong>方法时，如果前面<strong>使用的是ofInt,要强转成int 类型</strong>，否则，转为float类型。<br>此外，如果不需要动画，可以调用移除动画监听方法，但需要先调用cancel方法取消动画。</p>
<h1 id="4、ObjectAnimator-的基本使用"><a href="#4、ObjectAnimator-的基本使用" class="headerlink" title="4、ObjectAnimator 的基本使用"></a>4、ObjectAnimator 的基本使用</h1><p>ObjectAnimator 类继承自ValueAnimator，使用时通过静态工厂类直接返回一个对象，参数包括对象和对象的属性名，但该属性必须要有get和set函数，这样可以真实的控制一个view的属性值，因此它基本可以实现所有的动画效果。<br>使用示例：<br>使textView的translationX从0变化到200在变化到500，持续时间为1s,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(textView,</span><br><span class="line">            &quot;translationX&quot;,new float[]&#123;200,500&#125;);</span><br><span class="line">    animator.setDuration(1000);</span><br><span class="line">    animator.start();</span><br></pre></td></tr></table></figure></p>
<p>ofFloat的参数：第一个是要操纵的View；第二个是要操纵的属性；第三个是参数，是一个可变数组。同样的，可以给它设置显示时长，插值器等。<br>在开始提到了，ObjectAnimator用于有get，set属性的控件，对于没有的可以通过一个包装类来实现，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 包装类，给width添加get，set方法</span><br><span class="line"> */</span><br><span class="line">public static class WrapperView &#123;</span><br><span class="line">    private View mTarget;</span><br><span class="line"></span><br><span class="line">    public WrapperView(View target) &#123;</span><br><span class="line">        mTarget = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getWidth() &#123;</span><br><span class="line">        return mTarget.getLayoutParams().width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWidth(int width) &#123;</span><br><span class="line">        mTarget.getLayoutParams().width = width;</span><br><span class="line">        mTarget.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用时，直接操纵包装类，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WrapperView mWrapperView = new WrapperView(btnStartAnim);</span><br><span class="line">ObjectAnimator animator = ObjectAnimator.ofInt(</span><br><span class="line">        mWrapperView,&quot;width&quot;,500).setDuration(500);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure></p>
<p>通过上面，可以知道，ObjectAnimator 实现动画主要是通过set方法来设置控件的对应的属性实现动画。</p>
<h1 id="5、ObjectAnimator-的常用方法"><a href="#5、ObjectAnimator-的常用方法" class="headerlink" title="5、ObjectAnimator 的常用方法"></a>5、ObjectAnimator 的常用方法</h1><p>除了上面的ofInt,ofFloat方法，对于要改变背景色的，可以使用<strong>ArgbEvaluator</strong>，用法如下,给textView设置背景色在三种颜色间变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator = ObjectAnimator.ofInt(textView,</span><br><span class="line">        &quot;BackgroundColor&quot;,0xffff00ff, 0xffffff00, 0xffff00ff);</span><br><span class="line">animator.setDuration(2000);</span><br><span class="line">animator.setEvaluator(new ArgbEvaluator());</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure></p>
<p>其他常用函数如下：<br>摘抄于：<a href="http://wiki.jikexueyuan.com/project/android-animation/7.html" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/android-animation/7.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 设置动画时长，单位是毫秒 </span><br><span class="line"> */  </span><br><span class="line">ValueAnimator setDuration(long duration)  </span><br><span class="line">/** </span><br><span class="line"> * 获取 ValueAnimator 在运动时，当前运动点的值 </span><br><span class="line"> */  </span><br><span class="line">Object getAnimatedValue();  </span><br><span class="line">/** </span><br><span class="line"> * 开始动画 </span><br><span class="line"> */  </span><br><span class="line">void start()  </span><br><span class="line">/** </span><br><span class="line"> * 设置循环次数,设置为 INFINITE 表示无限循环 </span><br><span class="line"> */  </span><br><span class="line">void setRepeatCount(int value)  </span><br><span class="line">/** </span><br><span class="line"> * 设置循环模式 </span><br><span class="line"> * value 取值有 RESTART，REVERSE， </span><br><span class="line"> */  </span><br><span class="line">void setRepeatMode(int value)  </span><br><span class="line">/** </span><br><span class="line"> * 取消动画 </span><br><span class="line"> */  </span><br><span class="line">void cancel()</span><br></pre></td></tr></table></figure></p>
<p>监听相关的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 监听器一：监听动画变化时的实时值 </span><br><span class="line"> */  </span><br><span class="line">public static interface AnimatorUpdateListener &#123;  </span><br><span class="line">    void onAnimationUpdate(ValueAnimator animation);  </span><br><span class="line">&#125;  </span><br><span class="line">//添加方法为：public void addUpdateListener(AnimatorUpdateListener listener)  </span><br><span class="line">/** </span><br><span class="line"> * 监听器二：监听动画变化时四个状态 </span><br><span class="line"> */  </span><br><span class="line">public static interface AnimatorListener &#123;  </span><br><span class="line">    void onAnimationStart(Animator animation);  </span><br><span class="line">    void onAnimationEnd(Animator animation);  </span><br><span class="line">    void onAnimationCancel(Animator animation);  </span><br><span class="line">    void onAnimationRepeat(Animator animation);  </span><br><span class="line">&#125;  </span><br><span class="line">//添加方法为：public void addListener(AnimatorListener listener)</span><br></pre></td></tr></table></figure></p>
<p>插值器与 Evaluator:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 设置插值器 </span><br><span class="line"> */  </span><br><span class="line">public void setInterpolator(TimeInterpolator value)  </span><br><span class="line">/** </span><br><span class="line"> * 设置 Evaluator </span><br><span class="line"> */  </span><br><span class="line">public void setEvaluator(TypeEvaluator value)</span><br></pre></td></tr></table></figure></p>
<p>更多方法可以查看api</p>
<h1 id="6、AnimatorSet的使用"><a href="#6、AnimatorSet的使用" class="headerlink" title="6、AnimatorSet的使用"></a>6、AnimatorSet的使用</h1><p>在视图动画中  AnimationSet 来处理混合动画，同样的，这里的AnimatorSet来处理多个动画的。它出了实现多种动画，还可以精确的进行顺序控制。<br>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator1 = ObjectAnimator.ofFloat(textView, &quot;translationX&quot;, 300);</span><br><span class="line">ObjectAnimator animator2 = ObjectAnimator.ofFloat(textView, &quot;scaleX&quot;, 1, 0, 1);</span><br><span class="line">ObjectAnimator animator3 = ObjectAnimator.ofFloat(textView, &quot;scaleY&quot;, 1, 0, 1);</span><br><span class="line">AnimatorSet animatorSet = new AnimatorSet();</span><br><span class="line">animatorSet.setDuration(1000);</span><br><span class="line">animatorSet.playTogether(animator1, animator2, animator3);</span><br><span class="line">animatorSet.start();</span><br></pre></td></tr></table></figure></p>
<p>示例效果：<br><img src="/img/article_img/AnimatorSet.gif" alt=""></p>
<p>以上示例设置textView在x轴方向移动300，x和y方向先缩小到一倍再还原到一倍三种动画是同时执行。<br>若需要按顺序执行，可以调用Animator的<strong>playSequentially</strong>方法。</p>
<h1 id="7、PropertyValuesHolder-的使用"><a href="#7、PropertyValuesHolder-的使用" class="headerlink" title="7、PropertyValuesHolder 的使用"></a>7、PropertyValuesHolder 的使用</h1><p>除了上面讲的AnimatorSet 实现多种动画，还可以通过PropertyValuesHolder来实现，比如上面的例子在平移的过程中实现x,y轴的缩放。如下代码;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PropertyValuesHolder valuesHolder1 = PropertyValuesHolder</span><br><span class="line">    .ofFloat(&quot;translationX&quot;, 300);</span><br><span class="line">PropertyValuesHolder valuesHolder2 = PropertyValuesHolder</span><br><span class="line">    .ofFloat(&quot;scaleX&quot;, 1, 0, 1);</span><br><span class="line">PropertyValuesHolder valuesHolder3 = PropertyValuesHolder</span><br><span class="line">    .ofFloat(&quot;scaleY&quot;, 1, 0, 1);</span><br><span class="line">ObjectAnimator.ofPropertyValuesHolder(tv, valuesHolder1,</span><br><span class="line">    valuesHolder2, valuesHolder3).setDuration(1000).start();</span><br></pre></td></tr></table></figure></p>
<p>运行效果同AnimatorSet中的示例。<br>它的实现是先分别用PropertyValuesHolder的对象来控制不同的属性，最后调用ofPropertyValuesHolder方法实现多个属性动画的共同作用。</p>
<h1 id="8、在XML文件中实现属性动画"><a href="#8、在XML文件中实现属性动画" class="headerlink" title="8、在XML文件中实现属性动画"></a>8、在XML文件中实现属性动画</h1><p>先在xml文件中定义属性，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    android:duration=1000&quot;</span><br><span class="line">    android:propertyName=&quot;scaleX&quot;</span><br><span class="line">    android:valueFrom=&quot;1.0&quot;</span><br><span class="line">    android:valueTo=&quot;2.0&quot;</span><br><span class="line">    android:valueType=&quot;floatType&quot;</span><br><span class="line">&lt;/objectAnimator&gt;</span><br></pre></td></tr></table></figure></p>
<p>在java代码代码中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animator animator = AnimatorInflater.</span><br><span class="line">        loadAnimator(MainActivity.this,</span><br><span class="line">        R.animator.scalex);</span><br><span class="line">animator.setTarget(tv);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，xml文件的定义需要放在res/animator下，而且根节点只能是：set,objectAnimator,valueAnimator三者之一。如果使用的set，可以为其指定播放的方式，属性名为：ordering=[“together”]|[“sequentially”]，<br>默认值为：“together”，对于其他具体的属性这里不再赘述了，可以参见文档。<br>在实际开发中建议使用代码实现动画，比较简单，而且很多时候某些属性的起始值无法确定。</p>
<h1 id="8、View的animate方法"><a href="#8、View的animate方法" class="headerlink" title="8、View的animate方法"></a>8、View的animate方法</h1><p>在android3.0之后，添加了animate方法来直接驱动属性动画，它其实是对属性动画的简写，如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">view.animate()</span><br><span class="line">       .alpha(0)</span><br><span class="line">       .y(300)</span><br><span class="line">       .setDuration(1000)</span><br><span class="line">       .withStartAction(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">       .withEndAction(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>上面的例子很好理解，可以通过属性来确定他的含义。<br>总之，在实现动画时，可以根据自己的实际情况选择相应的方式实现动画，必要的时候还可以自定义实现动画，往往在使用时，不只是一种动画，我们要选择合适的方式实现多种动画。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Animation 动画详解]]></title>
      <url>http://imtianx.cn/2016/04/25/view-Animation/</url>
      <content type="html"><![CDATA[<p>在android 开发中，适当的添加动画可以使界面的交互变得更加的友好，特别是在提示，引导类的场景中，合理的使用动画可以带来更好的用户体验。这里，介绍<strong>Animation</strong> 框架的用法。<a id="more"></a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Animation动画框架中提供了四中动画方式，分别为：</p>
<ul>
<li>透明    <a href="https://developer.android.com/reference/android/view/animation/AlphaAnimation.html" target="_blank" rel="external">AlphaAnimation</a></li>
<li>旋转    <a href="https://developer.android.com/reference/android/view/animation/RotateAnimation.html" target="_blank" rel="external">RotateAnimation</a></li>
<li>缩放    <a href="https://developer.android.com/reference/android/view/animation/ScaleAnimation.html" target="_blank" rel="external">ScaleAnimation</a></li>
<li>平移   <a href="https://developer.android.com/reference/android/view/animation/TranslateAnimation.html" target="_blank" rel="external">TranslateAnimation</a><br>此外，还提供了<a href="https://developer.android.com/reference/android/view/animation/AnimationSet.html" target="_blank" rel="external">AnimationSet</a>动画集合，混合使用多种动画。<br>它们对应的 <strong>xml</strong>  的标签分别为：<strong>alpha,rotate,scale,translate和set。</strong><br><strong>Animation</strong>是他们的基类，有如下的标签和对应的函数：<br><strong>android:duration setDuration(long)</strong> 动画持续时间，以毫秒为单位<br><strong>android:fillAfter setFillAfter(boolean)</strong> 如果设置为 true，控件动画结束时，将保持动画最后时的状态<br><strong>android:fillBefore setFillBefore(boolean)</strong> 如果设置为 true,控件动画结束时，还原到开始动画前的状态<br><strong>android:fillEnabled setFillEnabled(boolean)</strong> 与 android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态<br><strong>android:repeatCount setRepeatCount(int)</strong> 重复次数<br><strong>android:repeatMode setRepeatMode(int)</strong> 重复类型，有 reverse 和 restart 两个值，取值为 RESTART 或 REVERSE，必须与 repeatCount 一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。<br><strong>android:interpolator setInterpolator(Interpolator)</strong> 设定插值器，其实就是指定的动作效果，比如弹跳效果等</li>
</ul>
<h2 id="2-Interpolator-插值器"><a href="#2-Interpolator-插值器" class="headerlink" title="2. Interpolator 插值器"></a>2. Interpolator 插值器</h2><p>对于动画，它的速率变化有快又慢，谷歌给出了<strong>插值器</strong>，来方便我们控制动画的变化。在不同的插值器的作用下，其变化也不一样。官方给的插值器有（谷歌官方）：<br><img src="/img/article_img/Interpolator.jpg" alt=""><br>部分资源id为(改图来自网络)：<br><img src="/img/article_img/Interpolator-resource-id.png" alt=""></p>
<h2 id="3-xm实现动画"><a href="#3-xm实现动画" class="headerlink" title="3. xm实现动画"></a>3. xm实现动画</h2><p>以<strong>scale</strong>标签为例，其他类似。scale有以下几个属性：</p>
<ul>
<li><strong>android:fromXScale</strong> 起始的 X方向上相对自身的缩放比例，浮点值，比如 1.0 代表自身无变化，0.5 代表起始时缩小一倍，2.0 代表放大一倍；</li>
<li><strong>android:toXScale</strong> 结尾的 X 方向上相对自身的缩放比例，浮点值；</li>
<li><strong>android:fromYScale</strong> 起始的 Y方向上相对自身的缩放比例，浮点值，</li>
<li><strong>android:toYScale</strong> 结尾的 Y 方向上相对自身的缩放比例，浮点值；</li>
<li><strong>android:pivotX</strong> 缩放起点 X 轴坐标，可以是数值、百分数、百分数 p。 三种样式，比如 50、50%、50%p，当为数值时，表示在当前 View的左上角，即原点处加上 50px，做为起始缩放点；如果是 50%，表示在当前控件的左上角加上自己宽度的 50%做为起始点；如果是 50%p，那么就是表示在当前的左上角加上父控件宽度的 50%做为起始点 x 轴坐标。</li>
<li><strong>android:pivotY</strong> 缩放起点 Y 轴坐标，取值及意义跟android:pivotX 一样。</li>
<li><strong>android:interpolator</strong> 就是添加的插值器，通过不同的Resource ID引用不同的插值器类。</li>
<li><strong>android：fillAfter</strong> 保持动画结束的状态，同样的可以保存初始化状态（<strong>fileBefore</strong>）</li>
<li><strong>android:repeatMode</strong> 设定回放类型，重新开始/倒退（restart /reverse）<br>在res下新建anim 文件夹，新建scaleanim.xml文件，如下代码（宽高从0放大到1.5倍，开开始和结束速度慢，中间快，停留在结束状态，重复一次）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;scale</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span><br><span class="line">    android:fromXScale=&quot;0.0&quot;</span><br><span class="line">    android:fromYScale=&quot;0.0&quot;</span><br><span class="line">    android:pivotX=&quot;50&quot;</span><br><span class="line">    android:pivotY=&quot;50&quot;</span><br><span class="line">    android:toXScale=&quot;1.5&quot;</span><br><span class="line">    android:toYScale=&quot;1.5&quot;</span><br><span class="line">    android：fillAfter=&quot;true&quot;</span><br><span class="line">    android:repeatCount=&quot;1&quot;  </span><br><span class="line">    android:repeatMode=&quot;restart&quot;  &gt;</span><br><span class="line">&lt;/scale&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面定义好了动画，下面就是具体的使用，这里以给textView设置上面的scale动画为例，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animation mAnimation = AnimationUtils.loadAnimation(this,R.anim.scaleanim);</span><br><span class="line">    textView.startAnimation(mAnimation);</span><br></pre></td></tr></table></figure></p>
<p>注：对于其他的标签及其属性可以参见<a href="https://developer.android.com/reference/android/view/animation/Animation.html" target="_blank" rel="external">官方文档</a>,这些标签可以放在一个<strong>set标签</strong>中，来定义动画集合。</p>
<h2 id="4-java-代码实现动画"><a href="#4-java-代码实现动画" class="headerlink" title="4. java 代码实现动画"></a>4. java 代码实现动画</h2><p>这里以<strong>AlphaAnimation</strong>为例，若xml代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </span><br><span class="line">&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </span><br><span class="line">    android:interpolator=&quot;@android:anim/bounce_interpolator&quot;</span><br><span class="line">    android:fromAlpha=&quot;1.0&quot;  </span><br><span class="line">    android:toAlpha=&quot;0.1&quot;  </span><br><span class="line">    android:duration=&quot;3000&quot;  </span><br><span class="line">    android:fillBefore=&quot;true&quot;&gt;  </span><br><span class="line">&lt;/alpha&gt;</span><br></pre></td></tr></table></figure></p>
<p>与其有相同效果的java代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alphaAnim = new AlphaAnimation(1.0f,0.1f);  </span><br><span class="line">alphaAnim.setDuration(3000);  </span><br><span class="line">alphaAnim.setFillBefore(true); </span><br><span class="line">alphaAnim.setInterpolator(new BounceInterpolator());//设置插值器</span><br></pre></td></tr></table></figure></p>
<p> 最后，就是给相应的控件设置动画，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.startAnimation(alphaAnim);</span><br></pre></td></tr></table></figure></p>
<h2 id="5-动画回调监听事件"><a href="#5-动画回调监听事件" class="headerlink" title="5. 动画回调监听事件"></a>5. 动画回调监听事件</h2><p>对于上面的两中方法设置动画，可以添加相应的监听回调，获得动画的开始，结束和重复事件，并对不同的事件作出相应的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mAnimation.setAnimationListener(new Animation.AnimationListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationStart(Animation animation) &#123;</span><br><span class="line">            //动画开始前的回调处理</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationEnd(Animation animation)&#123;</span><br><span class="line">            //动画结束时的回调处理</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationRepeat(Animation animation) &#123;</span><br><span class="line">            //动画重复的回调处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>更多：<a href="http://imtianx.cn/2016/04/25/Property-animatorValueAnimator&amp;ObjectAnimation">属性动画（ValueAnimator 和 ObjectAnimation）</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SwipeRefreshLayout+RecyclerView实现下拉刷新]]></title>
      <url>http://imtianx.cn/2016/04/23/SwipeRefreshLayout-RecyclerView/</url>
      <content type="html"><![CDATA[<p>SwipeRefreshLayout+RecyclerView实现下拉刷新<br>另外还使用了CardView（一个容器类布局，它继承自FrameLayout）。<br><a id="more"></a><br>效果图如下：<br><img src="http://img.blog.csdn.net/20160411115226554" alt="这里写图片描述"></p>
<h2 id="具体的使用："><a href="#具体的使用：" class="headerlink" title="具体的使用："></a>具体的使用：</h2><h4 id="1-CardView"><a href="#1-CardView" class="headerlink" title="1.CardView"></a>1.CardView<br></h4><p>首先，引入依赖：<br><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:cardview-v7:23.3.0&apos;</span><br></pre></td></tr></table></figure></p>
<p> 接着，在布局中引用，需要添加新的名字空间<br><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:card_view=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br></pre></td></tr></table></figure></p>
<p> 通过名字空间添加两个新的属性,通过名字很容易知道，第一个是设置背景颜色，第二个是设置圆角<br><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">card_view:cardBackgroundColor=&quot;#b911e8&quot;</span><br><span class="line">card_view:cardCornerRadius=&quot;4dp&quot;</span><br></pre></td></tr></table></figure></p>
<p>这里，RecyclerView 的每一个item都是一个CardView<br><br></p>
<h4 id="2-SwipeRefreshLayout"><a href="#2-SwipeRefreshLayout" class="headerlink" title="2.SwipeRefreshLayout"></a>2.SwipeRefreshLayout</h4><p>它在V4 包下，使用代码如下：<a href="https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fres%2Flayout%2Factivity_main.xml" target="_blank" rel="external">activity_main.xml</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.v4.widget.SwipeRefreshLayout</span><br><span class="line">xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:id=&quot;@+id/swipe_container&quot;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.v7.widget.RecyclerView</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">android:id=&quot;@+id/relv&quot;&gt;</span><br><span class="line">&lt;/android.support.v7.widget.RecyclerView&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;</span><br></pre></td></tr></table></figure>
<p>在activity中设置相关的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//设置进度条颜色,最多可以有四个颜色</span><br><span class="line">setColorSchemeResources(int… colorResIds);</span><br><span class="line">//设置进度圈背景颜色</span><br><span class="line">setProgressBackgroundColorSchemeColor(int color);</span><br><span class="line">//设置监听,在OnRefresh()中处理结果</span><br><span class="line">setOnRefreshListener(SwipeRefreshLayout.OnRefreshListener);</span><br><span class="line">//设置刷新状态</span><br><span class="line">setRefreshing(Boolean refreshing);</span><br></pre></td></tr></table></figure></p>
<h4 id="3-RecyclerView"><a href="#3-RecyclerView" class="headerlink" title="3.RecyclerView"></a>3.RecyclerView</h4><p>它是谷歌对ListView的升级，效率更高，并对ViewHolder进行了封装。使用时，同样，需要依赖库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:recyclerview-v7:23.3.0&apos;</span><br></pre></td></tr></table></figure></p>
<p>编写自己的adapter，继承自 RecyclerView.Adapter ，实现三个方法：(具体内容见：<a href="https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fjava%2Fcn%2Fimtianx%2Fswrvdemo%2FRvAdapter.java" target="_blank" rel="external">RvAdapter.java</a>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将布局转换成view 并传递给RecyclerView 封装好的 ViewHolder</span><br><span class="line"> *</span><br><span class="line"> * @param parent</span><br><span class="line"> * @param viewType</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">    View view = LayoutInflater.from(parent.getContext()).inflate(</span><br><span class="line">            R.layout.rv_item_cardview, parent, false);</span><br><span class="line">    return new ViewHolder(view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 建立ViewHolder中视图与数据的关联</span><br><span class="line"> *</span><br><span class="line"> * @param holder</span><br><span class="line"> * @param position</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void onBindViewHolder(ViewHolder holder, int position) &#123;</span><br><span class="line">    holder.imageView.setImageResource(R.mipmap.img);</span><br><span class="line">    holder.textView.setText(datas.get(position));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加内部内ViewHolder继承自RecyclerView.ViewHolder, 由于android没有给RecyclerView设置点击事件，需要我们自己使用接口回调，设置监听。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class ViewHolder extends RecyclerView.ViewHolder</span><br><span class="line">&#123;</span><br><span class="line">    public ImageView imageView;</span><br><span class="line">    public TextView textView;</span><br><span class="line"></span><br><span class="line">    public ViewHolder (final View itemView)</span><br><span class="line">    &#123;</span><br><span class="line">        super (itemView);</span><br><span class="line">        imageView = (ImageView) itemView.findViewById (R.id.img_head);</span><br><span class="line">        textView = (TextView) itemView.findViewById (R.id.tv_title);</span><br><span class="line"></span><br><span class="line">        itemView.setOnClickListener (new View.OnClickListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick (View v)</span><br><span class="line">            &#123;</span><br><span class="line">                itemClickListener.onItemClick (v, getPosition() );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        textView.setOnClickListener (</span><br><span class="line">            new View.OnClickListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick (View v)</span><br><span class="line">            &#123;</span><br><span class="line">                if (itemClickListener != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    itemClickListener.onTextClick (v, getPosition() );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public OnItemClickListener itemClickListener;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置接口</span><br><span class="line"> *</span><br><span class="line"> * @param itemClickListener</span><br><span class="line"> */</span><br><span class="line">public void setItemClickListener (OnItemClickListener itemClickListener)</span><br><span class="line">&#123;</span><br><span class="line">    this.itemClickListener = itemClickListener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 点击事件接口</span><br><span class="line"> */</span><br><span class="line">public interface OnItemClickListener</span><br><span class="line">&#123;</span><br><span class="line">    //item的点击事件</span><br><span class="line">    void onItemClick (View view, int position);</span><br><span class="line">    //item中文字的点击事件</span><br><span class="line">    void onTextClick (View view, int position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后在activity中设置监听，具体见：<a href="https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo/src/main/java/cn/imtianx/swrvdemo/MainActivity.java" target="_blank" rel="external">MainActivity.java</a></p>
<p> <strong><a href="https://github.com/imtianx/StudyDemoForAndroid/tree/master/A02-swrvdemo" target="_blank" rel="external">demon地址</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Gradle发布项目到JCenter仓库]]></title>
      <url>http://imtianx.cn/2016/04/23/put-libary-to-jcenter/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://zhengxiaopeng.com/2015/02/02/%E4%BD%BF%E7%94%A8Gradle%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0JCenter%E4%BB%93%E5%BA%93/" target="_blank" rel="external">使用Gradle发布项目到JCenter仓库</a><br>这里介绍了使用gradle发布项目到jcenter的具体流程，方便项目的依赖。<br><a id="more"></a></p>
<h3 id="申请Bintray账号"><a href="#申请Bintray账号" class="headerlink" title="申请Bintray账号"></a>申请Bintray账号</h3><p>Bintray的基本功能类似于Maven Central，一样的我们需要一个账号，<a href="https://bintray.com/" target="_blank" rel="external">Bintray传送门</a>，注册完成后第一步算完成了。</p>
<h3 id="生成项目的JavaDoc和source-JARs"><a href="#生成项目的JavaDoc和source-JARs" class="headerlink" title="生成项目的JavaDoc和source JARs"></a>生成项目的JavaDoc和source JARs</h3><p>简单的说生成的这两样东西就是我们在下一步中上传到远程仓库JCenter上的文件了。这一步需要android-maven-plugin插件，所以我们需要在项目的build.gradle（Top-level build file，项目最外层的build.gradle文件）中添加这个构建依赖，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:1.0.0&apos;</span><br><span class="line">        classpath &apos;com.github.dcendents:android-maven-plugin:1.2&apos;</span><br><span class="line">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class="line">        // in the individual module build.gradle files</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：如果编译出现问题 ，可将maven 的依赖改为1.3，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath &apos;com.github.dcendents:android-maven-plugin:1.3&apos;</span><br></pre></td></tr></table></figure></p>
<p>然后在你需要发布的那个module（我这里的即是library）的build.gradle里配置如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.library&apos;</span><br><span class="line">apply plugin: &apos;com.github.dcendents.android-maven&apos;</span><br><span class="line">apply plugin: &apos;com.jfrog.bintray&apos;</span><br><span class="line">// This is the library version used when deploying the artifact</span><br><span class="line">version = &quot;1.0.0&quot;</span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 21</span><br><span class="line">    buildToolsVersion &quot;21.1.2&quot;</span><br><span class="line">    resourcePrefix &quot;bounceprogressbar__&quot;    //这个随便填</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 9</span><br><span class="line">        targetSdkVersion 21</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName version</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">    compile &apos;com.nineoldandroids:library:2.4.0+&apos;</span><br><span class="line">&#125;</span><br><span class="line">def siteUrl = &apos;https://github.com/zhengxiaopeng/BounceProgressBar&apos; // 项目的主页</span><br><span class="line">def gitUrl = &apos;https://github.com/zhengxiaopeng/BounceProgressBar.git&apos; // Git仓库的url</span><br><span class="line">group = &quot;org.rocko.bpb&quot; // Maven Group ID for the artifact，一般填你唯一的包名</span><br><span class="line">install &#123;</span><br><span class="line">    repositories.mavenInstaller &#123;</span><br><span class="line">        // This generates POM.xml with proper parameters</span><br><span class="line">        pom &#123;</span><br><span class="line">        project &#123;</span><br><span class="line">        packaging &apos;aar&apos;</span><br><span class="line">        // Add your description here</span><br><span class="line">        name &apos;Android BounceProgressBar Widget&apos; //项目描述</span><br><span class="line">        url siteUrl</span><br><span class="line">        // Set your license</span><br><span class="line">        licenses &#123;</span><br><span class="line">            license &#123;</span><br><span class="line">            name &apos;The Apache Software License, Version 2.0&apos;</span><br><span class="line">            url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        developers &#123;</span><br><span class="line">        developer &#123;</span><br><span class="line">        id &apos;zhengxiaopeng&apos;    //填写的一些基本信息</span><br><span class="line">        name &apos;Rocko&apos;</span><br><span class="line">        email &apos;zhengxiaopeng.china@gmail.com&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scm &#123;</span><br><span class="line">        connection gitUrl</span><br><span class="line">        developerConnection gitUrl</span><br><span class="line">        url siteUrl</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task sourcesJar(type: Jar) &#123;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">    classifier = &apos;sources&apos;</span><br><span class="line">&#125;</span><br><span class="line">task javadoc(type: Javadoc) &#123;</span><br><span class="line">    source = android.sourceSets.main.java.srcDirs</span><br><span class="line">    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class="line">&#125;</span><br><span class="line">task javadocJar(type: Jar, dependsOn: javadoc) &#123;</span><br><span class="line">    classifier = &apos;javadoc&apos;</span><br><span class="line">    from javadoc.destinationDir</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives javadocJar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">&#125;</span><br><span class="line">Properties properties = new Properties()</span><br><span class="line">properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())</span><br><span class="line">bintray &#123;</span><br><span class="line">    user = properties.getProperty(&quot;bintray.user&quot;)</span><br><span class="line">    key = properties.getProperty(&quot;bintray.apikey&quot;)</span><br><span class="line">    configurations = [&apos;archives&apos;]</span><br><span class="line">    pkg &#123;</span><br><span class="line">        repo = &quot;maven&quot;    </span><br><span class="line">        name = &quot;BounceProgressBar&quot;    //发布到JCenter上的项目名字</span><br><span class="line">        websiteUrl = siteUrl</span><br><span class="line">        vcsUrl = gitUrl</span><br><span class="line">        licenses = [&quot;Apache-2.0&quot;]</span><br><span class="line">        publish = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置好上述后需要在你的项目的根目录上的local.properties文件里（一般这文件需gitignore，防止泄露账户信息）配置你的bintray账号信息，your_user_name为你的用户名，your_apikey为你的账户的apikey，可以点击进入你的账户信息里再点击Edit即有查看API Key的选项，把他复制下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bintray.user=your_user_name</span><br><span class="line">bintray.apikey=your_apikey</span><br></pre></td></tr></table></figure></p>
<p>Rebuild一下项目，顺利的话，就可以在module里的build文件夹里生成相关文件了。这一步为止，就可以把你项目生成到本地的仓库中了，Android Studio中默认即在Android\sdk\extras\android\m2repository这里，所以我们可以通过如下命令(Windows中，可能还需要下载一遍Gradle，之后就不需要了)执行生成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew install</span><br></pre></td></tr></table></figure></p>
<h3 id="上传到Bintray"><a href="#上传到Bintray" class="headerlink" title="上传到Bintray"></a>上传到Bintray</h3><p>上传到Bintray需要gradle-bintray-plugin的支持，所以在最外层的build.gradle里添加构建依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:1.0.0&apos;</span><br><span class="line">        classpath &apos;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0&apos;</span><br><span class="line">        classpath &apos;com.github.dcendents:android-maven-plugin:1.2&apos;</span><br><span class="line">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class="line">        // in the individual module build.gradle files</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Rebuild一下，然后执行如下命令(Windows中)完成上传：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew bintrayUpload</span><br></pre></td></tr></table></figure></p>
<p>上传完成即可在Bintray网站上找到你的Repo，我们需要完成最后一步工作，<strong>申请你的Repo添加到JCenter</strong>。可以进入这个页面,输入你的项目名字点击匹配到的项目，然后写一写Comments再send即可，然后就等管理员批准了，我是大概等了40分钟，然后网站上会给你一条通过信息，然后就OK了，大功告成。在bintray的maven厂库中即可查看。此外，如果添加其他版本的，可以按照上述步骤操作，注意改版本号。<br>如下bintray厂库详情：<br><img src="http://img.blog.csdn.net/20160404173839075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>最后在其他项目中引用：</p>
<p>1.使用Gradle：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.rocko.bpb:library:1.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.使用maven：<br>按图中操作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android真机测试之offline或unauthorized错误]]></title>
      <url>http://imtianx.cn/2016/04/23/erroe-of-offline-or-unauthorized/</url>
      <content type="html"><![CDATA[<p>在开发中，使用真机测试较为方便，然而在ide连接手机时，adb device 提示 <strong>offline</strong> 或者 <strong>unauthorized</strong>(中文：未授权的)会令大家非常困扰。<a id="more"></a>我也同样为此而浪费了很多时间。这里，介绍一种较为方便的解决方法（亲测有效）：<br>先删除.android 文件夹下的adbkey文件夹,再连接数据线，让其重新授权。<br>对于.android 文件夹，一般在电脑c盘的用户/用户名 下，它是用于存放android虚拟机的。如果将sdk配置到了环境变量中，则.android文件夹在相应的sdk目录下。<br>此外，网上还有其他的方法，不过都没有解决：</p>
<ol>
<li>用数据线连接手机，在设备管理器中把手机的驱动卸载了，然后重启，重新连接数据线；</li>
<li>打开手机设置，进入 开发人员选项，关闭 usb调试 ，撤销usb授权，最后重新打开；</li>
<li>重启adb：①在编辑器中重启或者关掉编辑器，同时在任务管理器中结束adb.exe;<br>②使用命令行：windows下，（win+R）–&gt;cmd 进入命令行，输入一次以下命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb kill-server;</span><br><span class="line">adb start-server;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用第三方的软件，如豌豆荚（曾经用过，可用）<br>总之，不同的人有不同的方法，选择一种自己可以接受的，能够有效解决问题就行。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ListView的优化技巧]]></title>
      <url>http://imtianx.cn/2016/04/23/listview-optimize/</url>
      <content type="html"><![CDATA[<p>在实际的应用开发时，往往有很多地方需要使用listview,当然我们得了解它的一些技巧。<a id="more"></a></p>
<h3 id="1-ListView的优化技巧"><a href="#1-ListView的优化技巧" class="headerlink" title="1.ListView的优化技巧"></a>1.ListView的优化技巧</h3><p>主要使用ViewHolder来提高效率，利用它的视图缓存机制，避免每次在调用方getView()方法时通过findViewById()实例化控件。使用时，只需在自定义的adapter中定义内部类ViewHolder，将ListView的item中的控件作为其成员变量。</p>
<p>如下getView()方法：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">     ViewHolder holder = null;</span><br><span class="line">       // 判断是否缓存</span><br><span class="line">       if (convertView == null) &#123;</span><br><span class="line">           holder = new ViewHolder();</span><br><span class="line">           // 通过LayoutInflater实例化布局</span><br><span class="line">           convertView = mInflater.inflate(R.layout.notify_item, null);</span><br><span class="line">           holder.img = (ImageView) convertView.findViewById(R.id.imageView);</span><br><span class="line">           holder.title = (TextView) convertView.findViewById(R.id.textView);</span><br><span class="line">           convertView.setTag(holder);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // 通过tag找到缓存的布局</span><br><span class="line">           holder = (ViewHolder) convertView.getTag();</span><br><span class="line">       &#125;</span><br><span class="line">       // 设置布局中控件要显示的视图</span><br><span class="line">       holder.img.setBackgroundResource(R.drawable.ic_launcher);</span><br><span class="line">       holder.title.setText(mData.get(position));</span><br><span class="line">       return convertView;</span><br><span class="line">   &#125;</span><br><span class="line">//定义内部类</span><br><span class="line">   public final class ViewHolder &#123;</span><br><span class="line">       public ImageView img;</span><br><span class="line">       public TextView title;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-ListView的常用属性"><a href="#2-ListView的常用属性" class="headerlink" title="2.ListView的常用属性"></a>2.ListView的常用属性</h3><p>设置分割线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:divider=&quot;@null&quot;</span><br></pre></td></tr></table></figure></p>
<p>隐藏滚动条<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:scrollbars=&quot;none&quot;</span><br></pre></td></tr></table></figure></p>
<p>设置要显示在第N项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//瞬间完成</span><br><span class="line">listView.setSelection(N);</span><br><span class="line">//平滑完成</span><br><span class="line">listView.smoothScrollBy(distance,duration);</span><br><span class="line">listView.smoothScrollByOffset(offset);</span><br><span class="line">listView.smoothScrollToPosition(n);</span><br></pre></td></tr></table></figure></p>
<p>动态修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//改变llist后调用</span><br><span class="line">mAdapter.notifyDataSetChanged();</span><br></pre></td></tr></table></figure></p>
<h3 id="3-动态改变ListView的布局"><a href="#3-动态改变ListView的布局" class="headerlink" title="3.动态改变ListView的布局"></a>3.动态改变ListView的布局</h3><p>如：实现聊天界面，加载连个布局的。<br>主要是比普通的adapter多实现getItemViewType()和getViewType()两个方法，然后再getView()中作出相应的处理。<br>如下部分主要代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//返回第position个item是何种类型</span><br><span class="line">    @Override</span><br><span class="line">    public int getItemViewType(int position) &#123;</span><br><span class="line">        ChatItemListViewBean bean = mData.get(position);</span><br><span class="line">        return bean.getType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//返回不同布局的总数</span><br><span class="line">    @Override</span><br><span class="line">    public int getViewTypeCount() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;&lt;/span&gt;</span><br><span class="line">	</span><br><span class="line">    @Override</span><br><span class="line">    public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">        ViewHolder holder;</span><br><span class="line">        if (convertView == null) &#123;</span><br><span class="line">			//判断布局类型</span><br><span class="line">            if (getItemViewType(position) == 0) &#123;</span><br><span class="line">                holder = new ViewHolder();</span><br><span class="line">                convertView = mInflater.inflate(</span><br><span class="line">                        R.layout.chat_item_itemin, null);</span><br><span class="line">                holder.icon = (ImageView) convertView.findViewById(</span><br><span class="line">                        R.id.icon_in);</span><br><span class="line">                holder.text = (TextView) convertView.findViewById(</span><br><span class="line">                        R.id.text_in);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                holder = new ViewHolder();</span><br><span class="line">                convertView = mInflater.inflate(</span><br><span class="line">                        R.layout.chat_item_itemout, null);</span><br><span class="line">                holder.icon = (ImageView) convertView.findViewById(</span><br><span class="line">                        R.id.icon_out);</span><br><span class="line">                holder.text = (TextView) convertView.findViewById(</span><br><span class="line">                        R.id.text_out);</span><br><span class="line">            &#125;</span><br><span class="line">            convertView.setTag(holder);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            holder = (ViewHolder) convertView.getTag();</span><br><span class="line">        &#125;</span><br><span class="line">        holder.icon.setImageBitmap(mData.get(position).getIcon());</span><br><span class="line">        holder.text.setText(mData.get(position).getText());</span><br><span class="line">        return convertView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，ListView还能设置滑动监听，有OnTouchListener和OnScrollListener监听事件。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ScrollView嵌套ListView的解决方案]]></title>
      <url>http://imtianx.cn/2016/04/23/listView-in-scrollView/</url>
      <content type="html"><![CDATA[<p>在android开发中，有时会遇到ScrollView嵌套ListView的相关问题，然而直接使用ScrollView 嵌套ListView，会导致界面卡顿无法滚动，或者listview只希显示1行（设置lisview的高度为400dp课以解决）。<a id="more"></a>网上也有不同的解决方案，但主要有以下几种。</p>
<h3 id="1、不使用ScrollView"><a href="#1、不使用ScrollView" class="headerlink" title="1、不使用ScrollView"></a>1、不使用ScrollView</h3><p>这种做法是直接将scrollview中除lisview的部分单独写到一个布局文件中，将其加入到listview的头部（即：position==0 的位置）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">listView.addHeaderView(LayoutInflater.from(getApplicationContext()).</span><br><span class="line">					inflate(R.layout.list_top_view, null));</span><br><span class="line">或者在adapter的getview中加：</span><br><span class="line">if(position==0)</span><br><span class="line">&#123;</span><br><span class="line">        convertView = LayoutInflater.from(context).inflate(R.layout.list_top_view, null);</span><br><span class="line">	return convertView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：“这种方法不推荐使用，使用它就破会listview 使用ViewHolder的结构，不能达到优化的目的。</p>
<h3 id="2、动态测量ListView"><a href="#2、动态测量ListView" class="headerlink" title="2、动态测量ListView"></a>2、动态测量ListView</h3><p>在执行完listView.setAdapter(myAdapter);后调用下面的方法；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	/** 动态设置ListView的高度</span><br><span class="line">	 * @param listView</span><br><span class="line">	 */</span><br><span class="line">	public  void setListViewHeightBasedOnChildren(ListView listView) &#123;</span><br><span class="line">		if(listView == null) return;</span><br><span class="line">		ListAdapter listAdapter = listView.getAdapter();</span><br><span class="line">		if (listAdapter == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		int totalHeight = 0;</span><br><span class="line">		for (int i = 0; i &lt; listAdapter.getCount(); i++) &#123;</span><br><span class="line">			View listItem = listAdapter.getView(i, null, listView);</span><br><span class="line">			listItem.measure(0, 0);</span><br><span class="line">			totalHeight += listItem.getMeasuredHeight();</span><br><span class="line">		&#125;</span><br><span class="line">		ViewGroup.LayoutParams params = listView.getLayoutParams();</span><br><span class="line">		params.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1));</span><br><span class="line">		listView.setLayoutParams(params);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这样，界面显示的是以listview开始的，他上的内容不会显示，需手动设置ScrollView定位到顶部，或者让listview失去焦点（listView.setFocusable(false);）也可显示顶部内容。<br>scrollView定位到顶部代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollView.smoothScrollTo(0, 20);</span><br><span class="line">scrollView.fullScroll(ScrollView.FOCUS_UP);//此处无效</span><br><span class="line">scrollView.scrollTo(0, 0);//此处无效</span><br></pre></td></tr></table></figure></p>
<p>注：这种方法不用更改控件，但是它必须要求getview返回的view的布局是LinearLayout的，否则会抛出异常，而且使用时，会把所有lisview的所有item 绘制出来。</p>
<h3 id="3、自定义ListView"><a href="#3、自定义ListView" class="headerlink" title="3、自定义ListView"></a>3、自定义ListView</h3><p>自定义listview，继承自ListView，添加原有的三个构造方法，重写onMeasure() 方法，在布局文件处使用自定义的Listview，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context;</span><br><span class="line">import android.util.AttributeSet;</span><br><span class="line">import android.widget.ListView;</span><br><span class="line"></span><br><span class="line">public class MyListView extends ListView &#123;</span><br><span class="line"></span><br><span class="line">	public MyListView(Context context) &#123;</span><br><span class="line">		super(context);</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	public MyListView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">		super(context, attrs);</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line">	public MyListView(Context context, AttributeSet attrs, int defStyle) &#123;</span><br><span class="line">		super(context, attrs, defStyle);</span><br><span class="line">		// TODO Auto-generated constructor stub</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 重写原方法，使ListView适应ScrollView的效果</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">		int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2,</span><br><span class="line">				MeasureSpec.AT_MOST);</span><br><span class="line">		super.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：这种方法使用起来较为方便，它保正了lisview的所有方法，个人就是这样用的。<br>除此之外，还有使用linearLayout替代lisview，个人没有进行测试，感兴趣的的可以尝试下。对上面的各种方法，个人都经过测试，进行事件的监听也不会出先问题，可以放心使用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2015年终总结及android学习路线]]></title>
      <url>http://imtianx.cn/2016/04/23/sum-up-2015/</url>
      <content type="html"><![CDATA[<p>转眼间，一年又过去了，距离毕业也越来越近了。回想过去，感觉自己什么都还不会，顿时感到紧迫感。那么，在接下来的日子里，就要充分利用每分每秒，学习充实自己。我们搞it的就得时刻记着：活到老，学到老。<a id="more"></a><br>回想这一年，自己独自学习android，从开始安装配置开发环境，到后来的指导别人并参加实际的项目开发，经历了各种酸甜苦辣。在此，总结下学习的经历。对于android，是个开发上手入门很快的语言，但后期在其他方面需要注意和学习的事情还有很多很多。自己在android学习之路上还有伸长的路要走，但不管怎么样，还是要脚踏实地，一点点的学习，不可骄傲浮躁。下面谈谈android的学习路线(来自网络)：</p>
<h3 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h3><p>基本知识点：比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术等。<br>参考书籍：《第一行代码 Android》、《疯狂Android》</p>
<h3 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h3><p>稍微深入的知识点：AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义View、消息队列等。</p>
<ul>
<li>AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别；</li>
<li>Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用；</li>
<li>多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等；</li>
<li>事件分发：弹性滑动、滑动冲突等；</li>
<li>玩转View：View的绘制原理、各种自定义View；</li>
<li>动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理；</li>
<li>懂性能优化、熟悉mat等工具</li>
<li>懂点常见的设计模式<br>学习方法<br>阅读进阶书籍，阅读Android源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有2个点是比较困扰大家的，一个是阅读源码，另一个是自定义View以及滑动冲突。<br>学习view需要注意的地方：</li>
<li>搞懂view的滑动原理</li>
<li>搞懂如何实现弹性滑动</li>
<li>搞懂view的滑动冲突</li>
<li>搞懂view的measure、layout和draw<br>然后再学习几个已有的自定义view的例子，最后就可以搞定自定义view了，所谓万变不离其宗。<br>书籍推荐：《Android开发艺术探索》、《Android群英传》</li>
</ul>
<h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>需要懂的知识：</p>
<ul>
<li>了解系统核心机制：</li>
</ul>
<ol>
<li>了解SystemServer的启动过程</li>
<li>了解主线程的消息循环模型</li>
<li>了解AMS和PMS的工作原理</li>
<li>能够回答问题”一个应用存在多少个Window？“</li>
<li>了解四大组件的大概工作流程</li>
<li>…</li>
</ol>
<ul>
<li>基本知识点的细节</li>
</ul>
<ol>
<li>Activity的启动模式以及异常情况下不同Activity的表现</li>
<li>Service的onBind和onReBind的关联</li>
<li>onServiceDisconnected(ComponentName className)和binderDied的区别</li>
<li>AsyncTask在不同版本上的表现细节</li>
<li>线程池的细节和参数配置</li>
<li>…</li>
</ol>
<ul>
<li><p>熟悉设计模式，有架构意识</p>
<p>书籍推荐<br>《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》</p>
</li>
</ul>
<p>除此之外，还可以学习一些好的开源框架的使用（如：Eventbuss），还有第三方sdk的接入使用（如:百度地图）；总之，不管怎么说，需要我们不断地学习，接受新知识，愿在新的一年里不断提高。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Eventbus 开源库的使用]]></title>
      <url>http://imtianx.cn/2016/04/23/Eventbus-simple-use/</url>
      <content type="html"><![CDATA[<p>EventBus是一款用用于android上的事件分发/订阅的总线，包含发布者、订阅者、事件和总线。主要用于android中intent,handler等在activity，fragment等组件间传递消息。<a id="more"></a>它极好的将消息的发送者和接收者解耦，方便组件间的通信。<br>下载地址：<br>            原地址：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">https://github.com/greenrobot/EventBus</a><br>            涛哥的地址：<a href="https://github.com/kymjs/EventBus" target="_blank" rel="external">https://github.com/kymjs/EventBus</a> （包含部分中文注释）</p>
<h3 id="1、简单使用"><a href="#1、简单使用" class="headerlink" title="1、简单使用"></a>1、简单使用</h3><p>首先下载改开源库，导入项目中。接下来就是具体的使用了。如下几个方法：</p>
<ul>
<li>EventBus.getDefault().register(this);注册订阅者</li>
<li>EventBus.getDefault().post(“点击按钮，发送消息”);发送消息，传入的是自己的事件类对象</li>
<li>重写 onEventMainThread(Object object) 方法；接收处理消息，这里参数与发送消息的类型一致。</li>
<li>在 onDestroy()中注销当订阅者。</li>
</ul>
<p>这里仅仅为了说明用法，简单的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.tx.eventbusdemo;</span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.View.OnClickListener;</span><br><span class="line">import android.widget.Button;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line">import de.greenrobot.event.EventBus;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">	private Button mbtnSend;</span><br><span class="line">	private TextView mtvShowmsg;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">		super.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		//当前类注册为事件订阅者</span><br><span class="line">		EventBus.getDefault().register(this);</span><br><span class="line">		mbtnSend = (Button) findViewById(R.id.btn);</span><br><span class="line">		mtvShowmsg = (TextView) findViewById(R.id.show);</span><br><span class="line"></span><br><span class="line">		mbtnSend.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void onClick(View v) &#123;</span><br><span class="line">				//发送消息</span><br><span class="line">			EventBus.getDefault().post(&quot;点击按钮，发送消息&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	//接收处理消息</span><br><span class="line">	public void onEventMainThread(Object object) &#123;  </span><br><span class="line">		mtvShowmsg.setText(object.toString());</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	protected void onDestroy() &#123;</span><br><span class="line">		super.onDestroy();</span><br><span class="line">		//注销注册</span><br><span class="line">		EventBus.getDefault().unregister(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果图：<br><img src="http://img.blog.csdn.net/20151230182722984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="2、解析实现过程"><a href="#2、解析实现过程" class="headerlink" title="2、解析实现过程"></a>2、解析实现过程</h3><p>首先在oncreate方法中注册订阅者，它就会扫描当前类，把onEvent开头的方法记录到map中（Key为方法的参数类型，Value中包含我们的方法）；<br>当子线程执行完毕后，调用post方法，根据其参数查找对应的方法，通过反射来执行相关的方法。</p>
<p>EventBus包含4个ThreadMode：PostThread，MainThread，BackgroundThread，Async。<br>对应的方法及功能为：<br><strong>onEventPostThread</strong>   在当前发布事件的线程中执行<br><strong>onEventMainThread</strong>   在ui线程中执行<br><strong>onEventAsync</strong>   加入后台任务队列，使用线程池调用。<br><strong>onEventBackgroundThread</strong>   在非UI线程发布的事件，则直接执行；否则，加入后台任务队列，使用线程池一个接一个调用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio 快捷键]]></title>
      <url>http://imtianx.cn/2016/04/23/androidstudio-keaymap/</url>
      <content type="html"><![CDATA[<p>原官方快捷键：<a href="https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf" target="_blank" rel="external">https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf</a><br>Alt+回车 导入包,自动修正<br>Ctrl+N   查找类<br>Ctrl+Shift+N 查找文件<br>Ctrl+Alt+L  格式化代码<br>Ctrl+Alt+O 优化导入的类和包<br>Alt+Insert 生成代码(如get,set方法,构造函数等<a id="more"></a><br>Ctrl+E或者Alt+Shift+C  最近更改的代码<br>Ctrl+R 替换文本<br>Ctrl+F 查找文本<br>Ctrl+Shift+Space 自动补全代码<br>Ctrl+空格 代码提示<br>Ctrl+Alt+Space 类名或接口名提示<br>Ctrl+P 方法参数提示<br>Ctrl+Shift+Alt+N 查找类中的方法或变量<br>Alt+Shift+C 对比最近修改的代码</p>
<p>Shift+F6  重构-重命名<br>Ctrl+Shift+先上键<br>Ctrl+Y 删除行（ctrl+x不是删除行，是剪切。如果不选中，则为剪切当行。ths for 貌似掉线）<br>Ctrl+D 复制行<br>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）<br>Ctrl+J  自动代码<br>Ctrl+E 最近打开的文件<br>Ctrl+H 显示类结构图<br>Ctrl+Q 显示注释文档<br>Alt+F1 查找代码所在位置<br>Alt+1 快速打开或隐藏工程面板<br>Ctrl+Alt+ left/right 返回至上次浏览的位置<br>Alt+ left/right 切换代码视图<br>Alt+ Up/Down 在方法间快速移动定位<br>Ctrl+Shift+Up/Down 代码向上/下移动。<br>F2 或Shift+F2 高亮错误或警告快速定位</p>
<p>代码标签输入完成后，按Tab，生成代码。<br>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。<br>Ctrl+W 选中代码，连续按会有其他效果<br>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。<br>Ctrl+Up/Down 光标跳转到第一行或最后一行下<br>Ctrl+B 快速打开光标处的类或方法<br>最常用快捷键<br>1.Ctrl＋E，可以显示最近编辑的文件列表<br>2.Shift＋Click可以关闭文件<br>3.Ctrl＋[或]可以跳到大括号的开头结尾<br>4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方<br>5.Ctrl＋F12，可以显示当前文件的结构<br>6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择<br>7.Ctrl＋N，可以快速打开类<br>8.Ctrl＋Shift＋N，可以快速打开文件<br>9.Alt＋Q可以看到当前方法的声明<br>10.Ctrl＋W可以选择单词继而语句继而行继而函数<br>11.Alt＋F1可以将正在编辑的元素在各个面板中定位<br>12.Ctrl＋P，可以显示参数信息<br>13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入<br>14.Alt＋Insert可以生成构造器/Getter/Setter等<br>15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量<br>16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch<br>17.Alt＋Up and Alt＋Down可在方法间快速移动<br>下面的不是很有用<br>18.在一些地方按Alt＋Enter可以得到一些Intention Action，例如将”==”改为”equals()”<br>19.Ctrl＋Shift＋Alt＋N可以快速打开符号<br>20.Ctrl＋Shift＋Space在很多时候都能够给出Smart提示<br>21.Alt＋F3可以快速寻找<br>22.Ctrl＋/和Ctrl＋Shift＋/可以注释代码<br>23.Ctrl＋Alt＋B可以跳转到抽象方法的实现<br>24.Ctrl＋O可以选择父类的方法进行重写<br>25.Ctrl＋Q可以看JavaDoc<br>26.Ctrl＋Alt＋Space是类名自动完成<br>27.快速打开类/文件/符号时，可以使用通配符，也可以使用缩写<br>28.Live Templates! Ctrl＋J<br>29.Ctrl＋Shift＋F7可以高亮当前元素在当前文件中的使用<br>30.Ctrl＋Alt＋Up /Ctrl＋Alt＋Down可以快速跳转搜索结果<br>31.Ctrl＋Shift＋J可以整合两行<br>32.Alt＋F8是计算变量值</p>
<p>IntelliJ IDEA使用技巧一览表<br>在使用 InelliJ IDEA 的过程中，通过查找资料以及一些自己的摸索，发现这个众多 Java 程序员喜欢的 IDE 里有许多值得一提的小窍门，如果能熟练的将它们应用于实际开发过程中，相信它会大大节省你的开发时间，而且随之而来的还会有那么一点点成就感：） Try it ！ </p>
<p>1 、写代码时用 Alt-Insert （ Code|Generate… ）可以创建类里面任何字段的 getter 与 setter 方法。<br>&lt;?xml:namespace prefix = v ns = “urn:schemas-microsoft-com:vml” /&gt; </p>
<p>2 、右键点击断点标记（在文本的左边栏里）激活速查菜单，你可以快速设置 enable/disable 断点或者条件它的属性。</p>
<p>3 、 CodeCompletion （代码完成）属性里的一个特殊的变量是，激活 Ctrl-Alt-Space 可以完成在或不在当前文件里的类名。如果类没有引入则 import 标志会自动创建。</p>
<p>4 、使用 Ctrl-Shift-V 快捷键可以将最近使用的剪贴板内容选择插入到文本。使用时系统会弹出一个含有剪贴内容的对话框，从中你可以选择你要粘贴的部分。 </p>
<p>5 、利用 CodeCompletion （代码完成）属性可以快速地在代码中完成各种不同地语句，方法是先键入一个类名地前几个字母然后再用 Ctrl-Space 完成全称。如果有多个选项，它们会列在速查列表里。 </p>
<p>6 、用 Ctrl-/ 与 Ctrl-Shift-/ 来注释 / 反注释代码行与代码块。 </p>
<p>-/ 用单行注释标记（“ //… ”）来注释 / 反注释当前行或者选择地代码块。而 Ctrl-Shift-/ 则可以用块注释标记（“ /<em>…</em>/ ”）把所选块包围起来。要反注释一个代码块就在块中任何一个地方按 Ctrl-Shift-/ 即可。</p>
<p>7 、按 Alt-Q （ View|Context Info ）可以不需要移动代码就能查看当前方法地声明。连续按两次会显示当前所编辑的类名。 </p>
<p>8 、使用 Refactor|Copy Class… 可以创建一个所选择的类的“副本”。这一点很有用，比如，在你想要创建一个大部分内容都和已存在类相同的类时。 </p>
<p>9 、在编辑器里 Ctrl-D 可以复制选择的块或者没有所选块是的当前行。 </p>
<p>10 、 Ctrl-W （选择字）在编辑器里的功能是先选择脱字符处的单词，然后选择源代码的扩展区域。举例来说，先选择一个方法名，然后是调用这个方法的表达式，然后是整个语句，然后包容块，等等。</p>
<p>11 、如果你不想让指示事件细节的“亮球”图标在编辑器上显示，通过按 Alt-Enter 组合键打开所有事件列表然后用鼠标点击它就可以把这个事件文本附件的亮球置成非活动状态。 </p>
<p>这样以后就不会有指示特殊事件的亮球出现了，但是你仍然可以用 Alt-Enter 快捷键使用它。</p>
<p>12 、在使用 CodeCompletion 时，可以用逗点（ . ）字符，逗号（，）分号（；），空格和其它字符输入弹出列表里的当前高亮部分。选择的名字会随着输入的字符自动输入到编辑器里。 </p>
<p>13 、在任何工具窗口里使用 Escape 键都可以把焦点移到编辑器上。 </p>
<p>Shift-Escape 不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口。 </p>
<p>F12 键把焦点从编辑器移到最近使用的工具窗口。 </p>
<p>14 、在调试程序时查看任何表达式值的一个容易的方法就是在编辑器中选择文本（可以按几次 Ctrl-W 组合键更有效地执行这个操作）然后按 Alt-F8 。 </p>
<p>15 、要打开编辑器脱字符处使用的类或者方法 Java 文档的浏览器，就按 Shift-F1 （右键菜单的 External JavaDoc ）。 </p>
<p>要使用这个功能须要把加入浏览器的路径，在“ General ”选项中设置（ Options | IDE Settings ），另外还要把创建的 Java 文档加入到工程中（ File | Project Properties ）。 </p>
<p>16 、用 Ctrl-F12 （ View | File Structure Popup ）键你可以在当前编辑的文件中快速导航。 </p>
<p>这时它会显示当前类的成员列表。选中一个要导航的元素然后按 Enter 键或 F4 键。要轻松地定位到列表中的一个条目，只需键入它的名字即可。 </p>
<p>17 、在代码中把光标置于标记符或者它的检查点上再按 Alt-F7 （右键菜单中的 Find Usages… ）会很快地查找到在整个工程中使用地某一个类、方法或者变量的位置。</p>
<p>18 、按 Ctrl-N （ Go to | Class… ）再键入类的名字可以快速地在编辑器里打开任何一个类。从显示出来的下拉列表里选择类。<br>同样的方法你可以通过使用 Ctrl-Shift-N （ Go to | File… ）打开工程中的非 Java 文件。</p>
<p>19 、要导航代码中一些地方使用到的类、方法或者变量的声明，把光标放在查看项上再按 Ctrl-B 即可。也可以通过按 Ctrl 键的同时在查看点上单击鼠标键调转到声明处。 </p>
<p>20 、把光标放到查看点上再按 Ctrl-Alt-B 可以导航到一个抽象方法的实现代码。</p>
<p>21 、要看一个所选择的类的继承层次，按 Ctrl-H （ Browse Type Hierarchy ）即可。也可以激活编辑器中的继承关系视图查看当前编辑类的继承关系。22 、使用 Ctrl-Shift-F7 （ Search | Highlight Usages in File ）可以快速高亮显示当前文件中某一变量的使用地方。按 Escape 清除高亮显示。 </p>
<p>23 、用 Alt-F3 （ Search | Incremental Search ）在编辑器中实现快速查查找功能。 </p>
<p>在“ Search for: ”提示工具里输入字符，使用箭头键朝前和朝后搜索。按 Escape 退出。</p>
<p>24 、按 Ctrl-J 组合键来执行一些你记不起来的 Live Template 缩写。比如，键“ it ”然后按 Ctrl-J 看看有什么发生。</p>
<p>25 、 Introduce Variable 整合帮助你简化代码中复杂的声明。举个例子，在下面的代码片断里，在代码中选择一个表达式：然后按 Ctrl-Alt-V 。</p>
<p>26 、 Ctrl-Shift-J 快捷键把两行合成一行并把不必要的空格去掉以匹配你的代码格式。</p>
<p>27 、 Ctrl-Shift-Backspace （ Go to | Last Edit Location ）让你调转到代码中所做改变的最后一个地方。 </p>
<p>多按几次 Ctrl-Shift-Backspace 查看更深的修改历史。 </p>
<p>28 、用 Tools | Reformat Code… 根据你的代码样式参考（查看 Options | IDE Setting | Code Style ）格式化代码。 </p>
<p>使用 Tools | Optimize Imports… 可以根据设置（查看 Options | IDE Setting | Code Style | Imports ）自动“优化” imports （清除无用的 imports 等）。</p>
<p>29 、使用 IDEA 的 Live Templates | Live Templates 让你在眨眼间创建许多典型代码。比如，在一个方法里键入 </p>
<p>再按 Tab 键看有什么事情发生了。<br>用 Tab 键在不同的模板域内移动。查看 Options | Live Templates 获取更多的细节。</p>
<p>30 、要查看一个文件中修改的本地历史，激活右键菜单里的 Local VCS | Show History… 。也许你可以导航不同的文件版本，看看它们的不同之处再回滚到以前的任何一个版本吧。 </p>
<p>使用同样的右键菜单条目还可以看到一个目录里修改的历史。有了这个特性你就不会丢失任何代码了。</p>
<p>31 、如果要了解主菜单里每一个条目的用途，把鼠标指针移到菜单条目上再应用程序框架的底部的状态栏里就会显示它们的一些简短描述，也许会对你有帮助。 </p>
<p>32 、要在编辑器里显示方法间的分隔线，打开 Options | IDE Settings | Editor ，选中“ Show method separators ”检查盒（ checkbox ）。 </p>
<p>33 、用 Alt-Up 和 Alt-Down 键可以在编辑器里不同的方法之间快速移动。 </p>
<p>34 、用 F2/Shift-F2 键在高亮显示的语法错误间跳转。 </p>
<p>用 Ctrl-Alt-Down/Ctrl-Alt-Up 快捷键则可以在编译器错误信息或者查找操作结果间跳转。</p>
<p>35 、通过按 Ctrl-O （ Code | Override Methods… ）可以很容易地重载基本类地方法。 </p>
<p>要完成当前类 implements 的（或者抽象基本类的）接口的方法，就使用 Ctrl-I （ Code | Implement Methods… ）。 </p>
<p>36 、如果光标置于一个方法调用的括号间，按 Ctrl-P 会显示一个可用参数的列表。</p>
<p>37 、要快速查看编辑器脱字符处使用的类或方法的 Java 文档，按 Ctrl-Q （在弹出菜单的 Show Quick JavaDoc 里）即可。 </p>
<p>38 、像 Ctrl-Q （ Show Quick JavaDoc 显示简洁 Java 文档）， Ctrl-P （ Show Parameter Info 显示参数信息）， Ctrl-B （ Go to Declaration 跳转到声明）， Shift-F1 （ External JavaDoc 外部 Java 文档）以及其它一些快捷键不仅可以在编辑器里使用，也可以应用在代码完成右键列表里。 </p>
<p>39 、 Ctrl-E （ View | Recent Files ）弹出最近访问的文件右键列表。选中文件按 Enter 键打开。 </p>
<p>40 、在 IDEA 中可以很容易地对你的类，方法以及变量进行重命名并在所有使用到它们的地方自动更正。 </p>
<p>试一下，把编辑器脱字符置于任何一个变量名字上然后按 Shift-F6 （ Refactor | Rename… ）。在对话框里键入要显示地新名字再按 Enter 。你会浏览到使用这个变量地所有地方然后按“ Do Refactor ”按钮结束重命名操作。 </p>
<p>41 、要在任何视图（ Project View 工程视图， Structure View 结构视图或者其它视图）里快速 </p>
<p>选择当前编辑地部分（类，文件，方法或者字段），按 Alt-F1 （ View | Select in… ）。 </p>
<p>42 、在“ new ”字符后实例化一个已知类型对象时也许你会用到 SmartType 代码完成这个特性。比如，键入 </p>
<p>再按 Ctrl-Shift-Space ：</p>
<p>43 、通过使用 SmartType 代码完成，在 IDEA 中创建接口的整个匿名 implementation 也是非常容易的，比如，对于一些 listener （监听器），可以键入 </p>
<p>Component component; </p>
<p>component.addMouseListener( </p>
<p>  new <caret is="" here="">   </caret></p>
<p>); </p>
<p>然后再按 Ctrl-Shift-Space 看看有什么发生了。 </p>
<p>44 、在你需要设置一个已知类型的表达式的值时用 SmartType 代码完成也很有帮助。比如，键入 </p>
<p>String s = ( <caret is="" here="">   </caret></p>
<p>再按 Ctrl-Shift-Space 看看会有什么出现。 </p>
<p>45 、在所有视图里都提供了速查功能：在树里只需键入字符就可以快速定位到一个条目。 </p>
<p>46 、当你想用代码片断捕捉异常时，在编辑器里选中这个片断，按 Ctrl-Alt-T （ Code | Surround with… ）然后选择“ try/catch ”。它会自动产生代码片断中抛出的所有异常的捕捉块。在 Options | File Templates | Code tab 中你还可以自己定制产生捕捉块的模板。 </p>
<p>用列表中的其它项可以包围别的一些结构。 </p>
<p>47 、在使用代码完成时，用 Tab 键可以输入弹出列表里的高亮显示部分。 </p>
<p>不像用 Enter 键接受输入，这个选中的名字会覆盖掉脱字符右边名字的其它部分。这一点在用一个方法或者变量名替换另一个时特别有用。 </p>
<p>48 、在声明一个变量时代码完成特性会给你显示一个建议名。比如，开始键入“ private FileOutputStream ”然后按 Ctrl-Space </p>
<p>在 Options | IDE Setting | Code Style 中还可以为本地变量，参数，实例及静态字段定制名字。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初识widget桌面小组件]]></title>
      <url>http://imtianx.cn/2016/04/23/first-use-widget/</url>
      <content type="html"><![CDATA[<p>学习android widget的使用，使用高德地图的定位功能中的天气api来获取天气，做了个简单的demo。<a id="more"></a>widget的开发步骤如下：</p>
<ol>
<li>编写widget布局和配置文件；</li>
<li>编写自己的provider继承自AppWidgetProvider；</li>
<li>使用服务来更新widget；</li>
<li>修改配置文件。</li>
</ol>
<p>开发之前先导入高德定位jar包，修改配置文件添加自己的appkey和相关的权限。（详情请参照：<a href="http://lbs.amap.com/api/android-location-sdk/guide/weather/）" target="_blank" rel="external">http://lbs.amap.com/api/android-location-sdk/guide/weather/）</a></p>
<h3 id="一、编写widget布局文件和配置文件"><a href="#一、编写widget布局文件和配置文件" class="headerlink" title="一、编写widget布局文件和配置文件"></a>一、编写widget布局文件和配置文件</h3><p>这里就添加了一个TextView来显示天气信息；<br>widget配置文件： src/xml/widgetconfig<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:initialLayout=&quot;@layout/widget&quot;</span><br><span class="line">    android:minHeight=&quot;100dp&quot;</span><br><span class="line">    android:minWidth=&quot;200dp&quot;</span><br><span class="line">    android:updatePeriodMillis=&quot;860000&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;/appwidget-provider&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、AppWidgetProvider的编写，启动与停止服务。"><a href="#二、AppWidgetProvider的编写，启动与停止服务。" class="headerlink" title="二、AppWidgetProvider的编写，启动与停止服务。"></a>二、AppWidgetProvider的编写，启动与停止服务。</h3><p>在AppWidgetProvider中的主要方法有：<br>onEnabled(Context context)–第一个widget添加时调用<br>onDeleted(Context context, int[] appWidgetIds)–widget被从屏幕移除时调用<br>onDisabled(Context context) –widget 最后一个被从屏幕移除<br>onUpdate(Context context,<br>AppWidgetManager appWidgetManager,<br>int[] appWidgetIds)—刷新widget</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.tx.weatherwidget;</span><br><span class="line">import android.appwidget.AppWidgetManager;</span><br><span class="line">import android.appwidget.AppWidgetProvider;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">public class WeatherProvider extends AppWidgetProvider &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * widget第一个添加到桌面执行</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void onEnabled(Context context) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		super.onEnabled(context);</span><br><span class="line">		Intent intent = new Intent(context, WeatherService.class);</span><br><span class="line">		context.startService(intent);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 最后一个widget移除桌面执行</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void onDisabled(Context context) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		super.onDisabled(context);</span><br><span class="line">		Intent intent = new Intent(context, WeatherService.class);</span><br><span class="line">		context.stopService(intent);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 更新数据</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void onUpdate(Context context, AppWidgetManager appWidgetManager,</span><br><span class="line">			int[] appWidgetIds) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		super.onUpdate(context, appWidgetManager, appWidgetIds);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="三、service的编写，获取天气，widget更新。"><a href="#三、service的编写，获取天气，widget更新。" class="headerlink" title="三、service的编写，获取天气，widget更新。"></a>三、service的编写，获取天气，widget更新。</h3><p>主要代码在updateView中，这里使用RemoteViews，AppWidgetManager的updateAppWidget来通知widget更新。<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package com.tx.weatherwidget;</span><br><span class="line">/**</span><br><span class="line"> * 调用高德地图的天气api获取天气</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.appwidget.AppWidgetManager;</span><br><span class="line">import android.content.ComponentName;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.widget.RemoteViews;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line"></span><br><span class="line">import com.amap.api.location.AMapLocalWeatherForecast;</span><br><span class="line">import com.amap.api.location.AMapLocalWeatherListener;</span><br><span class="line">import com.amap.api.location.AMapLocalWeatherLive;</span><br><span class="line">import com.amap.api.location.LocationManagerProxy;</span><br><span class="line">import com.tx.weatherwidget.R;</span><br><span class="line"></span><br><span class="line">public class WeatherService extends Service implements</span><br><span class="line">AMapLocalWeatherListener&#123;</span><br><span class="line">	private LocationManagerProxy mLocationManagerProxy;</span><br><span class="line">	@Override</span><br><span class="line">	public IBinder onBind(Intent arg0) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void onCreate() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		super.onCreate();</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 注册天气监听</span><br><span class="line">	 */</span><br><span class="line">	private void init() &#123;</span><br><span class="line">		mLocationManagerProxy = LocationManagerProxy.getInstance(this);</span><br><span class="line">		mLocationManagerProxy.requestWeatherUpdates(</span><br><span class="line">				LocationManagerProxy.WEATHER_TYPE_LIVE, this);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void onWeatherForecaseSearched(AMapLocalWeatherForecast arg0) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void onWeatherLiveSearched(AMapLocalWeatherLive aMapLocalWeatherLive) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		if(aMapLocalWeatherLive!=null &amp;&amp; aMapLocalWeatherLive.getAMapException().getErrorCode() == 0)&#123;</span><br><span class="line">			String city = aMapLocalWeatherLive.getCity();//城市</span><br><span class="line">			String weather = aMapLocalWeatherLive.getWeather();//天气情况</span><br><span class="line">			String windDir = aMapLocalWeatherLive.getWindDir();//风向</span><br><span class="line">			String windPower = aMapLocalWeatherLive.getWindPower();//风力</span><br><span class="line">			String humidity = aMapLocalWeatherLive.getHumidity();//空气湿度</span><br><span class="line">			String reportTime = aMapLocalWeatherLive.getReportTime();//数据发布时间</span><br><span class="line">			updateView(&quot;城市： &quot;+city+&apos;\n&apos;+</span><br><span class="line">					&quot;风向： &quot;+windDir+&apos;\n&apos;+</span><br><span class="line">					&quot;风力： &quot;+windPower+&apos;\n&apos;+</span><br><span class="line">					&quot;天气情况： &quot;+weather+&apos;\n&apos;+</span><br><span class="line">					&quot;空气湿度： &quot;+humidity+&apos;\n&apos;+</span><br><span class="line">					&quot;数据发布时间： &quot;+reportTime+&apos;\n&apos;);</span><br><span class="line"></span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			// 获取天气预报失败</span><br><span class="line">			Toast.makeText(this,&quot;获取天气预报失败:&quot;+ aMapLocalWeatherLive.getAMapException().getErrorMessage(), Toast.LENGTH_SHORT).show();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	private void updateView(String info)&#123;</span><br><span class="line">		RemoteViews remoteViews = new RemoteViews(getPackageName(),</span><br><span class="line">				R.layout.widget);</span><br><span class="line">		remoteViews.setTextViewText(R.id.weather, info);</span><br><span class="line">		AppWidgetManager manager = AppWidgetManager.</span><br><span class="line">				getInstance(getApplicationContext());</span><br><span class="line">		ComponentName provider = new ComponentName(</span><br><span class="line">				getApplicationContext(), WeatherProvider.class);</span><br><span class="line">		manager.updateAppWidget(provider, remoteViews);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="四、修改配置文件，注册服务。"><a href="#四、修改配置文件，注册服务。" class="headerlink" title="四、修改配置文件，注册服务。"></a>四、修改配置文件，注册服务。</h3><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;com.tx.weatherwidget.WeatherProvider&quot; &gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">            &lt;meta-data</span><br><span class="line">                android:name=&quot;android.appwidget.provider&quot;</span><br><span class="line">                android:resource=&quot;@xml/widgetconfig&quot; /&gt;</span><br><span class="line">        &lt;/receiver&gt;</span><br><span class="line"></span><br><span class="line">        &lt;service android:name=&quot;com.tx.weatherwidget.WeatherService&quot; &gt;</span><br><span class="line">        &lt;/service&gt;</span><br></pre></td></tr></table></figure></p>
<p>源代码下载：<a href="http://download.csdn.net/detail/txadf/9267497" target="_blank" rel="external">weatherWidget</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PLSQL安装、连接服务器及字符编码更改]]></title>
      <url>http://imtianx.cn/2016/04/23/plsql-install-config/</url>
      <content type="html"><![CDATA[<p>在学习时用oracle时，使用PLSQL客户端来操作数据库，这里简单介绍了它安装相关问题。<a id="more"></a></p>
<h3 id="一、下载PLSQL并破解"><a href="#一、下载PLSQL并破解" class="headerlink" title="一、下载PLSQL并破解"></a>一、下载PLSQL并破解</h3><p>（看不惯英文的可以安装汉化文件）,下载地址：<a href="http://download.csdn.net/detail/txadf/9259051" target="_blank" rel="external">PLSQL+instantclient</a></p>
<h3 id="二、解压开始安装，"><a href="#二、解压开始安装，" class="headerlink" title="二、解压开始安装，"></a>二、解压开始安装，</h3><p>如下图介绍；并将instantclient放到自己安装的文件位置，便于之后使用。</p>
<p><img src="http://img.blog.csdn.net/20151110212717528?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="三、破解软件"><a href="#三、破解软件" class="headerlink" title="三、破解软件"></a>三、破解软件</h3><p>填写instantclient文件的位置；<br>   （1）、安装完成后运行PLSQL，在弹出的登陆界面直接点击取消，进入；<br>   （2）、帮助—&gt;注册，运行破解文件，将产品编号、序列和口令（密码）对应的填入；<br>   （3）、工具—&gt;首选项，如下图，在‘1’处填      入：D:\software_Study\oracle\instantclient_11_2\network\admin；在‘2’处填入：D:\software_Study\oracle\instantclient_11_2\oci.dll<br>注：如果连接的是服务器端的oracle，需要将‘1’文件夹下的’tnsnames.ora’,用记事本打开，更改第二行的host的值为服务器的ip地址。</p>
<h3 id="四、配置环境变量（可选操作）"><a href="#四、配置环境变量（可选操作）" class="headerlink" title="四、配置环境变量（可选操作）"></a>四、配置环境变量（可选操作）</h3><p>完成上述步骤后，退出登陆，这里使用在服务器端创建的用户名和密码，数据库选择‘XE’，连接为‘Normal’，便可登陆。<br>如果需要更改字符编码，需配置环境变量，<br>查看服务器编码：select userenv(‘language’) from dual;<br>查看PLSQL客户端编码：select * from V$NLS_PARAMETERS; 看NLS_LANGUAGE值与上一语句值是否相等；<br>我们服务器编码是utf-8，这里不匹配，添加如下环境变量：</p>
<p>变量名：NLS_LANG<br>值：AMERICAN_AMERICA.AL32UTF8</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android开发较好的blog]]></title>
      <url>http://imtianx.cn/2016/04/23/excellent-blog-author-of-android/</url>
      <content type="html"><![CDATA[<p>作为初学者，跟着大神的脚步才能成为大神，少走弯路。以下是个人收藏的一些blog。<a id="more"></a><br>CSDN博客：<br>    郭霖:<a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="external">http://blog.csdn.net/guolin_blog</a><br>    鸿洋：<a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="external">http://blog.csdn.net/lmj623565791</a><br>    IT_xiao小巫：<a href="http://blog.csdn.net/wwj_748" target="_blank" rel="external">http://blog.csdn.net/wwj_748</a><br>    Mr.Simple：<a href="http://blog.csdn.net/bboyfeiyu" target="_blank" rel="external">http://blog.csdn.net/bboyfeiyu</a><br>    爱哥：<a href="http://blog.csdn.net/aigestudio" target="_blank" rel="external">http://blog.csdn.net/aigestudio</a><br>   老罗：<a href="http://blog.csdn.net/luoshengyang" target="_blank" rel="external">http://blog.csdn.net/luoshengyang</a><br>    任玉刚：<a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna</a><br>    夏安明：<a href="http://blog.csdn.net/xiaanming" target="_blank" rel="external">http://blog.csdn.net/xiaanming</a><br>    徐医生：<a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="external">http://blog.csdn.net/eclipsexys</a><br>    郭神：<a href="http://blog.csdn.net/sinyu890807/" target="_blank" rel="external">http://blog.csdn.net/sinyu890807/</a><br>    张兴业：<a href="http://blog.csdn.net/xyz_lmn/" target="_blank" rel="external">http://blog.csdn.net/xyz_lmn/</a><br>    咪当系欧巴：<a href="http://blog.csdn.net/hellogv" target="_blank" rel="external">http://blog.csdn.net/hellogv</a><br>个人Blog<br>    张涛：<a href="http://www.kymjs.com/" target="_blank" rel="external">http://www.kymjs.com/</a><br>    码农明明桑：<a href="http://blog.isming.me/" target="_blank" rel="external">http://blog.isming.me/</a><br>     张明云：<a href="http://zmywly8866.github.io/pages/archive.html" target="_blank" rel="external">http://zmywly8866.github.io/pages/archive.html</a><br>    郝锡强：<a href="http://www.haoxiqiang.info/static/timing.html" target="_blank" rel="external">http://www.haoxiqiang.info/static/timing.html</a><br>    胡凯：<a href="http://hukai.me/blog/archives/" target="_blank" rel="external">http://hukai.me/blog/archives/</a><br>    农民伯伯：<a href="http://www.cnblogs.com/over140/" target="_blank" rel="external">http://www.cnblogs.com/over140/</a><br>    Trinea：<a href="http://www.trinea.cn/" target="_blank" rel="external">http://www.trinea.cn/</a><br>    daimajia：<a href="http://blog.daimajia.com/" target="_blank" rel="external">http://blog.daimajia.com/</a><br>    stay4it：<a href="http://www.cnblogs.com/stay/" target="_blank" rel="external">http://www.cnblogs.com/stay/</a><br>    stormzhang：<a href="http://stormzhang.com/posts.html" target="_blank" rel="external">http://stormzhang.com/posts.html</a><br>    Coder Robin：<a href="http://coderrobin.com/" target="_blank" rel="external">http://coderrobin.com/</a> </p>
<p>更多资料：<br><a href="http://blog.csdn.net/txadf/article/details/49965053" target="_blank" rel="external">Android学习资源网站大全</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PhotoView与GifView的使用]]></title>
      <url>http://imtianx.cn/2016/04/23/PhotoView_GifView/</url>
      <content type="html"><![CDATA[<p>为了解决图片的缩放和gif格式的图片显示问题，这里采用了开源库PhototView(处理图片缩放问题)和GifView(显示gif格式图片)。<a id="more"></a><br><a href="http://download.csdn.net/detail/txadf/9204419" target="_blank" rel="external">PhototView下载路径</a>，<a href="http://download.csdn.net/detail/txadf/9204413" target="_blank" rel="external">GifView下载路径</a>，<a href="http://download.csdn.net/detail/txadf/9204481" target="_blank" rel="external">Demo下载路径</a></p>
<h3 id="1、PhotoView加载本地图片"><a href="#1、PhotoView加载本地图片" class="headerlink" title="1、PhotoView加载本地图片"></a>1、PhotoView加载本地图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * PhotoView 加载本地图片</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">private ImageView mImageView;</span><br><span class="line">private PhotoViewAttacher mPhotoViewAttacher;</span><br><span class="line"></span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">	super.onCreate(savedInstanceState);</span><br><span class="line">	requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">	setContentView(R.layout.photoview_local);</span><br><span class="line">	mImageView = (ImageView) findViewById(R.id.iv_img);</span><br><span class="line">	mPhotoViewAttacher = new PhotoViewAttacher(mImageView);</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		InputStream inputStream = getAssets().open(&quot;testPhotoView.jpg&quot;);</span><br><span class="line"></span><br><span class="line">		Bitmap bitmap = BitmapFactory.decodeStream(inputStream);</span><br><span class="line">		mImageView.setImageBitmap(bitmap);&lt;/span&gt;</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、PhotoView加载网络图片："><a href="#2、PhotoView加载网络图片：" class="headerlink" title="2、PhotoView加载网络图片："></a>2、PhotoView加载网络图片：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * PhotoView 加载网络图片</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">private PhotoView mImageView;</span><br><span class="line">private PhotoViewAttacher mPhotoViewAttacher;</span><br><span class="line"></span><br><span class="line">private ImageLoader mImageLoader;</span><br><span class="line"></span><br><span class="line">private  String URL = &quot;http://pic3.nipic.com/20090525/2416945_231841034_2.jpg&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	super.onCreate(savedInstanceState);</span><br><span class="line">	requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">	setContentView(R.layout.photoview_network);</span><br><span class="line"></span><br><span class="line">	mImageView = (PhotoView) findViewById(R.id.iv_img);</span><br><span class="line"></span><br><span class="line">	mPhotoViewAttacher = new PhotoViewAttacher(mImageView);</span><br><span class="line">	mImageLoader = ImageLoader.getInstance();</span><br><span class="line">	mImageLoader.displayImage(URL, mImageView);</span><br><span class="line"></span><br><span class="line">	mImageView.setOnPhotoTapListener(new OnPhotoTapListener() &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void onPhotoTap(View arg0, float arg1, float arg2) &#123;</span><br><span class="line">			// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布局文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;uk.co.senab.photoview.PhotoView</span><br><span class="line">        android:id=&quot;@+id/iv_img&quot;</span><br><span class="line">        android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">        android:layout_height=&quot;fill_parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、GifView加载本地图片："><a href="#3、GifView加载本地图片：" class="headerlink" title="3、GifView加载本地图片："></a>3、GifView加载本地图片：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private GifView mGifView;</span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	super.onCreate(savedInstanceState);</span><br><span class="line">	requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">	setContentView(R.layout.gifview);</span><br><span class="line"></span><br><span class="line">	mGifView = (GifView) findViewById(R.id.gifview);</span><br><span class="line">	//加载本地图片</span><br><span class="line">	mGifView.setGifImage(R.drawable.gifview);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布局文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:gravity=&quot;center&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.ant.liao.GifView</span><br><span class="line">        android:id=&quot;@+id/gifview&quot;</span><br><span class="line">        android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">        android:layout_height=&quot;fill_parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android 打开其他应用]]></title>
      <url>http://imtianx.cn/2016/04/23/open-other-app/</url>
      <content type="html"><![CDATA[<p>在开发中，有时需要在自己的应用中打开其他应用，自己写了两个方法来获取手机上安装的所有应用。这里主要以打开支付宝为例。<a id="more"></a><br>（1）、获取手机上的所有应用，将其放在一个list中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;PackageInfo&gt; getAllApps() &#123;     </span><br><span class="line">	List&lt;PackageInfo&gt; apps = new ArrayList&lt;PackageInfo&gt;();     </span><br><span class="line">	PackageManager packageManager = this.getPackageManager();     </span><br><span class="line">	//获取手机内所有应用     </span><br><span class="line">	List&lt;PackageInfo&gt; paklist = packageManager.getInstalledPackages(0);     </span><br><span class="line">	for (int i = 0; i &lt; paklist.size(); i++) &#123;     </span><br><span class="line">		PackageInfo pak = (PackageInfo) paklist.get(i);     </span><br><span class="line">		//判断是否为非系统预装的应用  (大于0为系统预装应用，小于等于0为非系统应用)   </span><br><span class="line">		if ((pak.applicationInfo.flags &amp; pak.applicationInfo.FLAG_SYSTEM) &lt;= 0) &#123;     </span><br><span class="line">			apps.add(pak);     </span><br><span class="line">		&#125;     </span><br><span class="line">	&#125;     </span><br><span class="line">	return apps;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）、打开指定的app(这里打开的是支付宝)。下面的方法是在知道支付宝app的包名的情况下进行判断的，通常情况下不知道包名，可以通过appLabel可以获取应用的名称，以此来匹配。在不存在的情况下，使用手机自带浏览器打开指定的网页。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static final String PAY_PACKAGE_NAME = &quot;com.eg.android.AlipayGphone&quot;;</span><br><span class="line">private static final String PAY_WEB_URL = &quot;https://auth.alipay.com/login/index.htm&quot;;</span><br><span class="line">	</span><br><span class="line">private void launchApp() &#123;   </span><br><span class="line">	PackageManager packageManager = this.getPackageManager();   </span><br><span class="line">	List&lt;PackageInfo&gt; packages = getAllApps();   </span><br><span class="line">	PackageInfo pa = null;   </span><br><span class="line">	for(int i=0;i&lt;packages.size();i++)&#123;   </span><br><span class="line">		pa = packages.get(i);   </span><br><span class="line">		//获得应用名   </span><br><span class="line">		String appLabel = packageManager.getApplicationLabel(pa.applicationInfo).toString();   </span><br><span class="line">		//获得包名   </span><br><span class="line">		String appPackage = pa.packageName; </span><br><span class="line">		Log.e(&quot;test&quot;, &quot;&quot;+i+&quot;----&quot;+appLabel+&quot;  &quot;+appPackage);   </span><br><span class="line">		</span><br><span class="line">		//安装支付宝，打开支付宝</span><br><span class="line">		if(appPackage.equals(PAY_PACKAGE_NAME))&#123;</span><br><span class="line">			mIntent = packageManager.getLaunchIntentForPackage(PAY_PACKAGE_NAME);</span><br><span class="line">			startActivity(mIntent); </span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	//为安装支付宝，打开支付宝登陆的网页</span><br><span class="line">	mIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(PAY_WEB_URL));</span><br><span class="line">	mIntent.setClassName(&quot;com.android.browser&quot;, &quot;com.android.browser.BrowserActivity&quot;);</span><br><span class="line">	startActivity(mIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，注意添加网络访问的权限。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android自动获取短信验证码]]></title>
      <url>http://imtianx.cn/2016/04/23/auto-filin-smscode/</url>
      <content type="html"><![CDATA[<p>这里主要使用了<strong>ContentObserver</strong>类（观察者模式类）来监听短信的变化，然后通过<strong>正则表达式</strong>，提取出短信，然后在子线程中更新UI，显示验证码。<a id="more"></a><br>所谓的观察者模式，它是软件设计模式的一种，在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。观察者模式（Observer）完美的将观察者和被观察的对象分离开，在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。观察者设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。<br>ContentObserver,内容观察者，目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当 ContentObserver 所观察的Uri发生变化时，便会触发它。<br>观察特定Uri的步骤如下：</p>
<ol>
<li>、创建我们特定的 ContentObserver 派生类，必须重载父类构造方法，必须重载 onChange() 方法去处理回调后的功能实现。</li>
<li>利用 context.getContentResolover() 获得 ContentResolove 对象，接着调用 registerContentObserver() 方法去注册内容观察者。</li>
<li>由于 ContentObserver 的生命周期不同步于 Activity 和 Service 等，因此，在不需要时，需要手动的调用 unregisterContentObserver() 去取消注册。</li>
</ol>
<p><em>具体使用：</em></p>
<h3 id="1、继承ContentObserver，重写onChange方法"><a href="#1、继承ContentObserver，重写onChange方法" class="headerlink" title="1、继承ContentObserver，重写onChange方法"></a>1、继承ContentObserver，重写onChange方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package com.tx.testsms;</span><br><span class="line">/**</span><br><span class="line"> * 自动读取短信验证码</span><br><span class="line"> */</span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.database.ContentObserver;</span><br><span class="line">import android.database.Cursor;</span><br><span class="line">import android.net.Uri;</span><br><span class="line">import android.os.Handler;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">public class SmsObserver extends ContentObserver &#123;</span><br><span class="line"></span><br><span class="line">	private Context mContext;</span><br><span class="line">	private Handler mHandler;</span><br><span class="line">	private String tel_phone = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">	private String code;</span><br><span class="line"></span><br><span class="line">	public void setTel_phone(String tel_phone) &#123;</span><br><span class="line">		this.tel_phone = tel_phone;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public SmsObserver(Context mContext, Handler handler) &#123;</span><br><span class="line">		super(handler);</span><br><span class="line">		this.mContext = mContext;</span><br><span class="line">		this.mHandler = handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onChange(boolean selfChange, Uri uri) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		super.onChange(selfChange, uri);</span><br><span class="line"></span><br><span class="line">		if(uri.toString().equals(&quot;content:://sms//raw&quot;))&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Uri inboxUri = Uri.parse(&quot;content://sms//inbox&quot;);</span><br><span class="line"></span><br><span class="line">		Cursor cursor = mContext.getContentResolver().</span><br><span class="line">				query(inboxUri, null, null, null, &quot;date desc&quot;);</span><br><span class="line"></span><br><span class="line">		if(cursor!=null)&#123;</span><br><span class="line">			if(cursor.moveToFirst())&#123;</span><br><span class="line">				String address = cursor.getString(cursor.getColumnIndex(&quot;address&quot;));</span><br><span class="line">				Log.i(&quot;test&quot;, &quot;短信验证码为：--------&quot;+address);</span><br><span class="line"></span><br><span class="line">				String body = cursor.getString(cursor.getColumnIndex(&quot;body&quot;));</span><br><span class="line">				Log.i(&quot;test&quot;, &quot;uri---------&quot;+inboxUri);</span><br><span class="line"></span><br><span class="line">				if(address.equals(tel_phone))&#123;</span><br><span class="line"></span><br><span class="line">					Pattern pattern = Pattern.compile(&quot;(\\d&#123;4&#125;)&quot;);</span><br><span class="line">					Matcher matcher = pattern.matcher(body);</span><br><span class="line"></span><br><span class="line">					if(matcher.find())&#123;</span><br><span class="line">						code = matcher.group(0);</span><br><span class="line">						Log.i(&quot;test&quot;, &quot;短信验证码为：--------&quot;+code);</span><br><span class="line">						mHandler.obtainMessage(</span><br><span class="line">								MainActivity.MSG_RECEIVED_CODE,code).sendToTarget();</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			cursor.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册"><a href="#2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册" class="headerlink" title="2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册"></a>2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">package com.tx.testsms;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.net.Uri;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.Handler;</span><br><span class="line">import android.os.Message;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.View.OnClickListener;</span><br><span class="line">import android.view.Window;</span><br><span class="line">import android.widget.Button;</span><br><span class="line">import android.widget.EditText;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">	public static final int MSG_RECEIVED_CODE = 1;</span><br><span class="line"></span><br><span class="line">	private SmsObserver mSmsObserver;</span><br><span class="line">	private Handler mHandler;</span><br><span class="line"></span><br><span class="line">	private EditText metPhone;</span><br><span class="line">	private TextView mtvCode;</span><br><span class="line">	private Button mbtnButton;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">		super.onCreate(savedInstanceState);</span><br><span class="line">		requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">		metPhone = (EditText) findViewById(R.id.phone);</span><br><span class="line">		mbtnButton = (Button) findViewById(R.id.btn);</span><br><span class="line">		mtvCode = (TextView) findViewById(R.id.code);</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 设置手机号，拦截固定的手机号</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		mbtnButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void onClick(View arg0) &#123;</span><br><span class="line">				// TODO Auto-generated method stub</span><br><span class="line">				mSmsObserver.setTel_phone(metPhone.getText().toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 在子线程中更新UI</span><br><span class="line">		 */</span><br><span class="line">		mHandler = new Handler()&#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void handleMessage(Message msg) &#123;</span><br><span class="line">				// TODO Auto-generated method stub</span><br><span class="line">				super.handleMessage(msg);</span><br><span class="line">				if(msg.what == MSG_RECEIVED_CODE)&#123;</span><br><span class="line">					mtvCode.setText(&quot;四位短信验证码为：&quot;+msg.obj.toString());</span><br><span class="line">					Toast.makeText(getApplicationContext(), msg.obj.toString(), Toast.LENGTH_SHORT).show();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		&lt;span style=&quot;color:#ff0000;&quot;&gt;/**</span><br><span class="line">		 * 实例化ContentObserver,注册短信监听</span><br><span class="line">		 */</span><br><span class="line">		mSmsObserver = new SmsObserver(getApplicationContext(), mHandler);</span><br><span class="line">		Uri  uri = Uri.parse(&quot;content://sms&quot;);</span><br><span class="line">		getContentResolver().registerContentObserver(uri, true, mSmsObserver);&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 由于 ContentObserver 的生命周期不同步于 Activity 和 Service ，</span><br><span class="line">	 * 因此需要手动取消注册</span><br><span class="line">	 * </span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void onDestroy() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		super.onDestroy();</span><br><span class="line">		&lt;span style=&quot;color:#ff0000;&quot;&gt;getContentResolver().unregisterContentObserver(mSmsObserver);&lt;/span&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、注意在配置文件中添加读取短信的权限："><a href="#3、注意在配置文件中添加读取短信的权限：" class="headerlink" title="3、注意在配置文件中添加读取短信的权限："></a>3、注意在配置文件中添加读取短信的权限：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意：最小sdk为16.</strong></p>
<h3 id="4、如下运行截图："><a href="#4、如下运行截图：" class="headerlink" title="4、如下运行截图："></a>4、如下运行截图：</h3><p><img src="http://img.blog.csdn.net/20151017130345615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>控制台打印出的Log：<br><img src="http://img.blog.csdn.net/20151017130527628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>例子源代码：<a href="http://download.csdn.net/detail/txadf/9188791" target="_blank" rel="external">http://download.csdn.net/detail/txadf/9188791</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android SQLite学习手册]]></title>
      <url>http://imtianx.cn/2016/04/23/android-sqlite-notebook/</url>
      <content type="html"><![CDATA[<p> 在实际的应用中，SQLite作为目前最为流行的开源嵌入式关系型数据库，在系统的架构设计中正在扮演着越来越为重要的角色。和很多其它嵌入式NoSQL数据库不同的是，SQLite支持很多关系型数据库的基本特征，这在数据移植、程序演示等应用中有着不可替代的优势。<a id="more"></a>从官方文档中我们可以获悉到，SQLite支持的数据量和运行效率都是非常骄人的，因此在海量数据的解决方案中，SQLite可以作为数据预计算的桥头堡，从而显著减少存储在关系型数据库服务器中的数据数量，最终提高系统的查询效率和运行期效率，同时也可以显著的降低数据备份的磁盘开销</p>
<h4 id="SQLite学习手册-开篇"><a href="#SQLite学习手册-开篇" class="headerlink" title="SQLite学习手册(开篇)"></a>SQLite学习手册(开篇)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/09/2317603.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/09/2317603.html</a><br>一、简介<br>二、SQLite的主要优点<br>三、和RDBMS相比SQLite的一些劣势<br>四、个性化特征</p>
<h4 id="SQLite学习手册-C-C-接口简介"><a href="#SQLite学习手册-C-C-接口简介" class="headerlink" title="SQLite学习手册(C/C++接口简介)"></a>SQLite学习手册(C/C++接口简介)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321386.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321386.html</a><br>一、概述<br>二、核心对象和接口<br>三、参数绑定</p>
<h4 id="SQLite学习手册-数据表和视图"><a href="#SQLite学习手册-数据表和视图" class="headerlink" title="SQLite学习手册(数据表和视图)"></a>SQLite学习手册(数据表和视图)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321668.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321668.html</a><br>一、创建数据表<br>二、表的修改<br>三、表的删除<br>四、创建视图<br>五、删除视图</p>
<h4 id="SQLite学习手册-内置函数"><a href="#SQLite学习手册-内置函数" class="headerlink" title="SQLite学习手册(内置函数)"></a>SQLite学习手册(内置函数)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2322027.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2322027.html</a><br>一、聚合函数<br>二、核心函数<br>三、日期和时间函数</p>
<h4 id="SQLite学习手册-索引和数据分析-清理"><a href="#SQLite学习手册-索引和数据分析-清理" class="headerlink" title="SQLite学习手册(索引和数据分析/清理)"></a>SQLite学习手册(索引和数据分析/清理)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322335.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322335.html</a><br>一、创建索引<br>二、删除索引<br>三、重建索引<br>四、数据分析<br>五、数据清理</p>
<h4 id="SQLite学习手册-数据库和事物"><a href="#SQLite学习手册-数据库和事物" class="headerlink" title="SQLite学习手册(数据库和事物)"></a>SQLite学习手册(数据库和事物)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322575.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322575.html</a><br>一、Attach数据库<br>二、Detach数据库<br>三、事物</p>
<h4 id="SQLite学习手册-表达式"><a href="#SQLite学习手册-表达式" class="headerlink" title="SQLite学习手册(表达式)"></a>SQLite学习手册(表达式)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/16/2323907.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/16/2323907.html</a><br>一、常用表达式<br>二、条件表达式<br>三、转换表达式</p>
<h4 id="SQLite学习手册-数据类型"><a href="#SQLite学习手册-数据类型" class="headerlink" title="SQLite学习手册(数据类型)"></a>SQLite学习手册(数据类型)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325258.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325258.html</a><br>一、存储种类和数据类型<br>二、类型亲缘性<br>三、比较表达式<br>四、操作符</p>
<h4 id="SQLite学习手册-命令行工具"><a href="#SQLite学习手册-命令行工具" class="headerlink" title="SQLite学习手册(命令行工具)"></a>SQLite学习手册(命令行工具)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325981.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325981.html</a></p>
<h4 id="SQLite学习手册-在线备份"><a href="#SQLite学习手册-在线备份" class="headerlink" title="SQLite学习手册(在线备份)"></a>SQLite学习手册(在线备份)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/19/2326309.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/19/2326309.html</a><br>一、常用备份<br>二、在线备份APIs简介<br>三、高级应用技巧</p>
<h4 id="SQLite学习手册-内存数据库"><a href="#SQLite学习手册-内存数据库" class="headerlink" title="SQLite学习手册(内存数据库)"></a>SQLite学习手册(内存数据库)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/20/2328348.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/20/2328348.html</a><br>一、内存数据库<br>二、临时数据库</p>
<h4 id="SQLite学习手册-临时文件"><a href="#SQLite学习手册-临时文件" class="headerlink" title="SQLite学习手册(临时文件)"></a>SQLite学习手册(临时文件)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/21/2328483.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/21/2328483.html</a><br>一、简介<br>二、具体说明<br>三、相关的编译时参数和指令<br>四、其它优化策略</p>
<h4 id="SQLite学习手册-锁和并发控制"><a href="#SQLite学习手册-锁和并发控制" class="headerlink" title="SQLite学习手册(锁和并发控制)"></a>SQLite学习手册(锁和并发控制)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/01/22/2328753.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/01/22/2328753.html</a><br>一、概述<br>二、文件锁<br>三、回滚日志<br>四、数据写入<br>五、SQL级别的事物控制</p>
<h4 id="SQLite学习手册-实例代码-lt-一-gt"><a href="#SQLite学习手册-实例代码-lt-一-gt" class="headerlink" title="SQLite学习手册(实例代码&lt;一&gt;)"></a>SQLite学习手册(实例代码&lt;一&gt;)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2340780.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2340780.html</a><br>一、获取表的Schema信息<br>二、常规数据插入</p>
<h4 id="SQLite学习手册-实例代码-lt-二-gt"><a href="#SQLite学习手册-实例代码-lt-二-gt" class="headerlink" title="SQLite学习手册(实例代码&lt;二&gt;)"></a>SQLite学习手册(实例代码&lt;二&gt;)</h4><p><a href="http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2341480.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2341480.html</a><br>三、高效的批量数据插入<br>四、数据查询</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQLit相关类的介绍及使用]]></title>
      <url>http://imtianx.cn/2016/04/23/android-sqlite-use/</url>
      <content type="html"><![CDATA[<p>本文主要介绍了SQLit中相关的几个类（SQLiteDatabase、ContentValues、SQLiteOpenHelper）中的常用的方法及其作用。<br><a id="more"></a></p>
<h2 id="1-SQLiteDatabase类"><a href="#1-SQLiteDatabase类" class="headerlink" title="1. SQLiteDatabase类"></a><strong>1. SQLiteDatabase类</strong></h2><p>（对 SQLite数据库增、删、改、查的操作）<br> 常用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execSQL(String  sql);</span><br><span class="line">execSQL(String sql, String[] args);</span><br></pre></td></tr></table></figure></p>
<p>示例：删除 person表中personId＝1的记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db=this.getWritableDatabase();</span><br><span class="line">db.execSQL(“delete from  person where personId=?”,new</span><br><span class="line">String[]&#123;“1”&#125;);</span><br><span class="line">db.execSQL(“delete from  person where personId=1”);</span><br></pre></td></tr></table></figure></p>
<p>提示：this是 SQLiteOpenHelper类的实例，该类稍后介绍。</p>
<h4 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Context.openOrCreateDatabase(Stringdbname,int mode);</span><br></pre></td></tr></table></figure>
<p>作用：打开数据库，若数据库未创建则创建数据库。<br>参数－dbname：数据库文件名。<br>参数－mode：访问权限，有以下常量选择：<br>1、MODE_PRIVATE：不允许其它应用程序访问本数据库。<br>2、MODE_WORLD_READABLE：允许其它应用程序读本数据库。<br>3、MODE_WORLD_WRITEABLE：允许其它应用程序写本数据库。<br>4、MODE_APPEND：若数据库已存在，则允向数据库中许添加数据。</p>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long insert(TABLE_NAME, String nullColumnHack, ContentValues   contentValues);</span><br></pre></td></tr></table></figure>
<p>作用：添加记录。<br>参数－TABLE_NAME：表名。<br>参数－nullColumnHack：若插入的数据是空行，则本参数必须设置为 null。<br>参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int delete(TABLE_NAME, String  where, String[]  whereValue);</span><br></pre></td></tr></table></figure>
<p>作用：删除记录。<br>参数－TABLE_NAME：表名。<br>参数－where：删除的条件，相当于 SQL语句中的where部分的 SQL命令。<br>参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。<br>示例：删除当前数据库中表peson中，字段 personId值为1的行，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(“person”,”personId=?”,newString[]&#123;“1”&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int update(TABLE_NAME, contentValues,String  where, String[] whereValue) ;</span><br></pre></td></tr></table></figure>
<p>作用：更新记录。<br>参数－TABLE_NAME：表名。<br>参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据。可<br>存放多个键－值对数据，代表需要更新的数据。<br>参数－where：更新的条件，相当于 SQL语句中的where部分的 SQL命令。<br>参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。<br>示例：更新当前数据库的person表中,personId＝1的记录，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ContentValues  values=new ContentValues();//创建可存操作的键－值对的对象</span><br><span class="line">values.put(“name”,”李四”);//存放姓名数据</span><br><span class="line">values.put(“phone”,”13315577889”);//存放电话数据</span><br><span class="line">//实例化SQLiteDatabase对象</span><br><span class="line">SQLiteDatabase db=this.getWritableDatabase();</span><br><span class="line">db.update(“person” ,values,”personId=?”，new String[]&#123;“1”);//更新数据</span><br></pre></td></tr></table></figure></p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cursor rawQuery(String sql,String[]selectionArgs);</span><br></pre></td></tr></table></figure>
<p>作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。<br>参数－sql：查询的 SQL命令。<br>参数－selectionArgs：查询的条件数据。<br>提示：<br>(1)Cursor类稍后介绍。<br>(2)若 sql中没有占位符，则第二个参数设置为 null。<br>(3)对数据表进行变更操作时，使用execSQL，对数据表进行查询时，使用rawQuery<br>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cursorquery(table,projection,selection,selectionArgs,groupby,having,orderby);</span><br></pre></td></tr></table></figure></p>
<p>作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。<br>cursor :返回值类型，返回查询结果游标对象。<br>  table : String ,要查询的表名。<br>  projection : String[]，要查询的列名，如果为 null，则查询所有列。<br>  selection : String,查询条件。<br>  selectionArgs:String[]为selection中的？补值的数组。<br>  groupby : String,分组列的列名。<br>  having:String,分组在查询的条件。<br>  orderby:String排序列的列名。</p>
<h2 id="2、ContentValues类"><a href="#2、ContentValues类" class="headerlink" title="2、ContentValues类"></a>2、ContentValues类</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ContentValues类包装了HashMap类，该类用于存取键－值对的数据，每个键－值对数<br>据表示一列的列名和该列的数据。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContentValues();</span><br></pre></td></tr></table></figure>
<p>作用：无参构造方法，创建一个内部成员变量为 HashMap<string,object>的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void put(String key,Object value);</span><br></pre></td></tr></table></figure></string,object></p>
<p>作用：向成员变量 mValues中存放一个键－值对数据。<br>提示：value可以是 Java的所有基本数据类型、数组、对象的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object** get(String key);</span><br></pre></td></tr></table></figure></p>
<p>作用：获取键名 key对应的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXX getAsXXX(String key);</span><br></pre></td></tr></table></figure></p>
<p>作用：返回 XXX类型的值。<br>提示：XXX可以是所有基本类型的包装类，如 Integer，还有AsByteArray（字节数组类型）。</p>
<h2 id="3-、SQLiteOpenHelper类"><a href="#3-、SQLiteOpenHelper类" class="headerlink" title="3 、SQLiteOpenHelper类"></a>3 、SQLiteOpenHelper类</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>SQLiteOpenHelper类是Android提供的用于操作 SQLite数据库的工具类，该工具类能<br>方便地创建数据库、表，以及管理数据库版本。</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized SQLiteDatabasegetReadableDatabase();</span><br></pre></td></tr></table></figure>
<p>作用：以读写的方式打开数据库对应的 SQLiteDatabase类的对象。<br>提示：synchronized关键字定义该方法为线程同步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized SQLiteDatabasegetWriteableDatabase();</span><br></pre></td></tr></table></figure></p>
<p>作用：以写的方式创建或打开数据库对应的 SQLiteDatabase类的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract onCreate(SQLiteDatabase db);</span><br></pre></td></tr></table></figure></p>
<p>作用：首次创建数据库时，回调本方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 开源项目分类汇总]]></title>
      <url>http://imtianx.cn/2016/04/23/open-source/</url>
      <content type="html"><![CDATA[<p>在github上看见的开源android 代码，十分全面，内容如下：</p>
<p>目前包括：<br>Android 开源项目第一篇——个性化控件(View)篇<br>  包括ListView、ActionBar、Menu、ViewPager、Gallery、GridView、ImageView<a id="more"></a>、ProgressBar、TextView、ScrollView、TimeView、TipView、FlipView、ColorPickView、GraphView、UI Style、其他<br>Android 开源项目第二篇——工具库篇<br>  包括依赖注入、图片缓存、网络请求、数据库 ORM 工具包、Android 公共库、高版本向低版本兼容库、多媒体、事件总线、传感器、安全、插件化、文件、其他<br>Android 开源项目第三篇——优秀项目篇<br>  比较有意思的完整的 Android 项目<br>Android 开源项目第四篇——开发及测试工具篇<br>  包括开发效率工具、开发自测相关、测试工具、开发及编译环境、其他<br>Android 开源项目第五篇——优秀个人和团体篇<br>  乐于分享并且有一些很不错的开源项目的个人和组织，包括 JakeWharton、Chris Banes、Koushik Dutta 等大牛<br>github地址：<a href="https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6view" target="_blank" rel="external">https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6view</a><br>希望对大家有帮助。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[收集的Android开源框架及其地址]]></title>
      <url>http://imtianx.cn/2016/04/23/open-source-frame/</url>
      <content type="html"><![CDATA[<h3 id="1、volley"><a href="#1、volley" class="headerlink" title="1、volley"></a>1、volley</h3><p>项目地址 <a href="https://github.com/smanikandan14/Volley-demo" target="_blank" rel="external">https://github.com/smanikandan14/Volley-demo</a><br>JSON，图像等的异步下载；<br>网络请求的排序（scheduling）<br>网络请求的优先级处理<br>缓存<br>多级别取消请求和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）<br><a id="more"></a></p>
<h3 id="2、android-async-http"><a href="#2、android-async-http" class="headerlink" title="2、android-async-http"></a>2、android-async-http</h3><p>项目地址：<a href="https://github.com/loopj/android-async-http，文档介绍：http://loopj.com/android-async-http/" target="_blank" rel="external">https://github.com/loopj/android-async-http，文档介绍：http://loopj.com/android-async-http/</a> </p>
<p>在匿名回调中处理请求结果<br>在UI线程外进行http请求<br>文件断点上传<br>智能重试<br>默认gzip压缩<br>支持解析成Json格式<br>可将Cookies持久化到SharedPreferences</p>
<h3 id="3、Afinal框架"><a href="#3、Afinal框架" class="headerlink" title="3、Afinal框架"></a>3、Afinal框架</h3><p>项目地址：<a href="https://github.com/yangfuhai/afinal" target="_blank" rel="external">https://github.com/yangfuhai/afinal</a></p>
<p>主要有四大模块：</p>
<p>数据库模块：Android中的orm框架，使用了线程池对sqlite进行操作。<br>注解模块：Android中的ioc框架，完全注解方式就可以进行UI绑定和事件绑定。无需findViewById和setClickListener等。<br>网络模块：通过httpclient进行封装http数据请求，支持Ajax方式加载，支持下载、上传文件功能。<br>图片缓存模块：通过FinalBitmap，imageview加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。<br>　　FinalBitmap可以配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。FinalBitmap的内存管理使用lru算法，没有使用弱引用（Android2.3以后Google已经不建议使用弱引用，Android2.3后强行回收软引用和弱引用，详情查看Android官方文档），更好的管理bitmap内存。FinalBitmap可以自定义下载器，用来扩展其他协议显示网络图片，比如ftp等。同时可以自定义bitmap显示器，</p>
<p>　　在imageview显示图片的时候播放动画等（默认是渐变动画显示）。</p>
<h3 id="4、xUtils框架"><a href="#4、xUtils框架" class="headerlink" title="4、xUtils框架"></a>4、xUtils框架</h3><p>项目地址：<a href="https://github.com/wyouflf/xUtils，主要有四大模块：" target="_blank" rel="external">https://github.com/wyouflf/xUtils，主要有四大模块：</a><br><strong>数据库模块：</strong><br>Android 中的 orm 框架，一行代码就可以进行增删改查；<br>支持事务，默认关闭；<br>可通过注解自定义表名，列名，外键，唯一性约束，NOT NULL约束，CHECK约束等（需要混淆的时候请注解表名和列名）；<br>支持绑定外键，保存实体时外键关联实体自动保存或更新；<br>自动加载外键关联实体，支持延时加载；<br>支持链式表达查询，更直观的查询语义，参考下面的介绍或sample中的例子。<br><strong>注解模块：</strong></p>
<p>Android中的 ioc 框架，完全注解方式就可以进行 UI，资源和事件绑定；<br>新的事件绑定方式，使用混淆工具混淆后仍可正常工作；<br>目前支持常用的20种事件绑定，参见 View Common Event Listener 类和包com.lidroid.xutils.view.annotation.event。<br><strong>网络模块：</strong></p>
<p>支持同步，异步方式的请求；<br>支持大文件上传，上传大文件不会oom；<br>支持GET，POST，PUT，MOVE，COPY，DELETE，HEAD，OPTIONS，TRACE，CONNECT请求；<br>下载支持301/302重定向，支持设置是否根据Content-Disposition重命名下载的文件；<br>返回文本内容的请求（默认只启用了GET请求）支持缓存，可设置默认过期时间和针对当前请求的过期时间。<br><strong>图片缓存模块：</strong></p>
<p>加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象；<br>支持加载网络图片和本地图片；<br>内存管理使用lru算法，更好的管理bitmap内存；<br>可配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。</p>
<h3 id="5、ThinkAndroid"><a href="#5、ThinkAndroid" class="headerlink" title="5、ThinkAndroid"></a>5、ThinkAndroid</h3><p>项目地址：<a href="https://github.com/white-cat/ThinkAndroid" target="_blank" rel="external">https://github.com/white-cat/ThinkAndroid</a></p>
<p>主要有以下模块：</p>
<p><strong>MVC模块：</strong>实现视图与模型的分离。<br><strong>ioc模块：</strong> Android中的ioc模块，完全注解方式就可以进行UI绑定、res中的资源的读取、以及对象的初始化。<br><strong>数据库模块：</strong> Android中的orm框架，使用了线程池对sqlite进行操作。<br><strong>http模块：</strong> 通过httpclient进行封装http数据请求，支持异步及同步方式加载。<br><strong>缓存模块：</strong> 通过简单的配置及设计可以很好的实现缓存，对缓存可以随意的配置<br><strong>图片缓存模块：</strong> i mageview加载图片的时候无需考虑图片加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。<br><strong>配置器模块：</strong> 可以对简易的实现配对配置的操作，目前配置文件可以支持Preference、Properties对配置进行存取。<br><strong>日志打印模块</strong>：可以较快的轻易的是实现日志打印，支持日志打印的扩展，目前支持对sdcard写入本地打印、以及控制台打印<br><strong>下载器模块</strong>：可以简单的实现多线程下载、后台下载、断点续传、对下载进行控制、如开始、暂停、删除等等。<br><strong>网络状态检测模块</strong>：当网络状态改变时，对其进行检。</p>
<h3 id="6、LoonAndroid"><a href="#6、LoonAndroid" class="headerlink" title="6、LoonAndroid"></a>6、LoonAndroid</h3><p>项目地址：<a href="https://github.com/gdpancheng/LoonAndroid" target="_blank" rel="external">https://github.com/gdpancheng/LoonAndroid</a></p>
<p>主要有以下模块：<br>自动注入框架（只需要继承框架内的APP既可）<br>图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性）<br>网络请求模块（继承了基本上现在所有的http请求）<br>eventbus（集成一个开源的框架）<br>验证框架（集成开源框架）<br>Json解析（支持解析成集合或者对象）<br>数据库（不知道是哪位写的 忘记了）<br>多线程断点下载（自动判断是否支持多线程，判断是否是重定向）<br>自动更新模块<br>一系列工具类</p>
<h3 id="7、图片加载："><a href="#7、图片加载：" class="headerlink" title="7、图片加载："></a>7、图片加载：</h3><p> Universal Image Loader - <a href="https://github.com/onlyTan/Android-Universal-Image-Loader" target="_blank" rel="external">https://github.com/onlyTan/Android-Universal-Image-Loader</a></p>
<p>用法参考 -<a href="http://blog.csdn.net/xiaanming/article/details/26810303" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/26810303</a></p>
<h3 id="8、动画框架："><a href="#8、动画框架：" class="headerlink" title="8、动画框架："></a>8、动画框架：</h3><p>  nineoldandroids -  <a href="https://github.com/JakeWharton/NineOldAndroids" target="_blank" rel="external">https://github.com/JakeWharton/NineOldAndroids</a><br>用法参考 -<a href="http://blog.csdn.net/lmj623565791/article/details/38067475" target="_blank" rel="external">http://blog.csdn.net/lmj623565791/article/details/38067475</a></p>
<h3 id="9、进程间通信框架："><a href="#9、进程间通信框架：" class="headerlink" title="9、进程间通信框架："></a>9、进程间通信框架：</h3><p>   eventBus -  <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">https://github.com/greenrobot/EventBus</a><br>用法参考 - <a href="http://blog.csdn.net/lmj623565791/article/details/40794879" target="_blank" rel="external">http://blog.csdn.net/lmj623565791/article/details/40794879</a></p>
<h3 id="10、SQLite数据库："><a href="#10、SQLite数据库：" class="headerlink" title="10、SQLite数据库："></a>10、SQLite数据库：</h3><p>LitePal - </p>
<p><a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="external">https://github.com/LitePalFramework/LitePal</a></p>
<h3 id="11、百分比布局："><a href="#11、百分比布局：" class="headerlink" title="11、百分比布局："></a>11、百分比布局：</h3><p>android-percent-support-extend  -  </p>
<p><a href="https://github.com/hongyangAndroid/android-percent-support-extend" target="_blank" rel="external">https://github.com/hongyangAndroid/android-percent-support-extend</a></p>
<p>百分比布局：<br>android-percent-support-extend  -  </p>
<p><a href="https://github.com/hongyangAndroid/android-percent-support-extend" target="_blank" rel="external">https://github.com/hongyangAndroid/android-percent-support-extend</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 屏幕适配dp,sp]]></title>
      <url>http://imtianx.cn/2016/04/23/screen-adaptation-dp_sp/</url>
      <content type="html"><![CDATA[<p>相关的概念：</p>
<h4 id="dp"><a href="#dp" class="headerlink" title="dp"></a><strong>dp</strong></h4><p>即dip，设备独立像素，device independent pixels的缩写，密度无关像素，Android特有的单位，在屏幕密度dpi= 160屏幕上，1dp = 1px。1dp 在屏幕上总是1/160 英寸。<br>它常用在设置镖局，内边距或任何不打算按照像素值指定尺寸的情况下。<br><a id="more"></a></p>
<h4 id="sp"><a href="#sp" class="headerlink" title="sp"></a><strong>sp</strong></h4><p>和dp很类似，英文为：scale-independent pixel ，缩放无关像素，与密度无关。一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。</p>
<h4 id="px"><a href="#px" class="headerlink" title="px"></a><strong>px</strong></h4><p>是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素。<br> 在设计领域中，像素是用来计算数码影像的最小单位。计算机中显示的图像并非连续的线条组成，而是由许多肉眼看不见的小点组成。如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小点所组成，这些小点就是构成影像的最小单位“像素”。由于是最小的独立显示单位，px均为整数，不会出现0.5px的情况。</p>
<h4 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a><strong>dpi</strong></h4><p>dpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。比如320X480分辨率的手机，宽2英寸，高3英寸, 每英寸包含的像素点的数量为320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi，横向和纵向的这个值都是相同的，原因是大部分手机屏幕使用正方形的像素点。</p>
<h4 id="Android-Drawable"><a href="#Android-Drawable" class="headerlink" title="Android Drawable"></a><strong>Android Drawable</strong></h4><p>我们新建一个Android项目后应该可以看到很多drawable文件夹，分别对应不同的dpi</p>
<pre><code>drawable-ldpi (dpi=120, density=0.75)

drawable-mdpi (dpi=160, density=1)

drawable-hdpi (dpi=240, density=1.5)

drawable-xhdpi (dpi=320, density=2)

drawable-xxhdpi (dpi=480, density=3)
</code></pre><p>首先必须清楚一个自动渲染的概念，Android SDK会自动屏幕尺寸选择对应的资源文件进行渲染，如SDK检测到你手机dpi是160的话会优先到drawable-mdpi文件夹下找对应的图片资源，注意只是优先，假设你手机dpi是160，但是你只在xhpdi文件夹下有对应的图片资源文件，程序一样可以正常运行。所以理论上来说只需要提供一种规格的图片资源就ok了，如果只提供ldpi规格的图片，对于大分辨率的手机如果把图片放大就会不清晰，所以需要提供一套你需要支持的最大dpi的图片，这样即使用户的手机分辨率很小，这样图片缩小依然很清晰。</p>
<p><strong>xhdpi成为首选</strong><br>上面说了只需要提供一套大的dpi的图片就ok了，现在市面手机分辨率最大可达到1080X1920的分辨率，如Nexus5，dpi属于xxhdpi，但是毕竟还没普及，目前市面上最普遍的高端机的分辨率还多集中在720X1080范围，也就是多集中在xhdpi，所以目前来看xhpdi规则的图片成为了首选。当然随着技术规格的提高以后发展，以后可能市场上xxdpi的手机会越来越普遍，但这是后话。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android 中webview的屏幕适配问题]]></title>
      <url>http://imtianx.cn/2016/04/23/webview-Screen-adaptation/</url>
      <content type="html"><![CDATA[<p>两行代码解决WebView的屏幕适配问题<br><a id="more"></a><br>一个简单的方法，让网页快速适应手机屏幕，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebSettings webSettings= webView.getSettings();</span><br><span class="line">webSettings.setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN);</span><br></pre></td></tr></table></figure></p>
<p>说明：<br><em>LayoutAlgorithm</em>  是一个枚举，用来控制html的布局，总共有三种类型：<br> <strong>NORMAL</strong>：正常显示，没有渲染变化。<br> <strong>SINGLE_COLUMN</strong>：把所有内容放到WebView组件等宽的一列中。<br> <strong>NARROW_COLUMNS</strong>：可能的话，使所有列的宽度不超过屏幕宽度。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo 编写发布博客]]></title>
      <url>http://imtianx.cn/2016/04/23/hexo-%20write-blog/</url>
      <content type="html"><![CDATA[<p>上一篇 :<a href="http://imtianx.cn/2016/04/20/Hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">Hexo+github搭建个人博客</a><br>我们介绍了博客的搭建过程，这里说明如何编写博客及发布.<br><a id="more"></a></p>
<h2 id="1、编写博客"><a href="#1、编写博客" class="headerlink" title="1、编写博客"></a>1、编写博客</h2><ul>
<li><h5 id="a、使用hexo-命令"><a href="#a、使用hexo-命令" class="headerlink" title="a、使用hexo 命令"></a>a、使用hexo 命令</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] blogName</span><br></pre></td></tr></table></figure>
<p>  这里layout默认的是 <strong>post</strong>,可以为文章指定标题，日期，分类，标签等，方便博客的管理。其中分类和标签若有多个，可放在“<strong>[ ]</strong>”中，用“<strong>，</strong>”。隔开具体如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">	title: &#123;&#123; title &#125;&#125;</span><br><span class="line">	date: &#123;&#123; date &#125;&#125;</span><br><span class="line">	categories: [分类1,子分类]</span><br><span class="line">	tags: [标签1,标签2,]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>需要注意的是是：“<strong>title：</strong>”标签<strong>冒号</strong>后有<strong>空格</strong>，其他的同样。<br>此外，为了界面美观，可以添加 显示”<strong>read more</strong>“,如：只显示第一段，则在第一段后添加：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="b、直接用编辑器编写"><a href="#b、直接用编辑器编写" class="headerlink" title="b、直接用编辑器编写"></a>b、直接用编辑器编写</h5><p>  博客的编写支持markdown 语法，个人使用的是<strong>作业部落</strong>的Cmd Markdown 编辑器，非常好用，语法简单，方便，具体用法参见<a href="https://www.zybuluo.com/mdeditor#345522" target="_blank" rel="external">这里</a>。<br>  这种方式需要在写好的文件开头添加<strong>post</strong>文件，方法同上。然后吧写好的文件放到“<strong>_posts</strong>” 文件夹下，如果没有准备发布，作为草稿可以放在“<strong>_data</strong>”文件夹下。</p>
</li>
</ul>
<h2 id="2、发布博客"><a href="#2、发布博客" class="headerlink" title="2、发布博客"></a>2、发布博客</h2><p>打开gitshell 进入博客根目录，生成静态页面：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></p>
<p>然后起动服务就可以在网页上预览了。</p>
<p>最后就是将页面提交github。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo+github 搭建个人博客]]></title>
      <url>http://imtianx.cn/2016/04/20/hexo+github%20-build-my-blog/</url>
      <content type="html"><![CDATA[<p>最近，看见很多人在使用hexo+github搭建自己的博客，为了方便记录平时的学习内容。在此，我也学习搭建一个个人博客，记下自己的搭建过程，方便自己，也方便他人。<br><a id="more"></a></p>
<h2 id="1、安装前准备"><a href="#1、安装前准备" class="headerlink" title="1、安装前准备"></a>1、安装前准备</h2><blockquote>
<ul>
<li>安装 <strong>Node.js</strong> ，(可以去 <a href="https://nodejs.org/en/" target="_blank" rel="external">官网</a> 下载相应的版本，并安装。</li>
<li>安装Git (或者安装github客户端)</li>
</ul>
</blockquote>
<hr>
<h2 id="2、安装hexo"><a href="#2、安装hexo" class="headerlink" title="2、安装hexo"></a>2、安装hexo</h2><p>windows下进入命令行，执行如下命令：</p>
<pre><code>npm install-g hexo
</code></pre><p>然后启动 git shell 初始化hexo。这里，我打算把hexo放在自己新建的 “myblog” 文件夹下，则需要先进入该文件夹下，然后进行初始化，如下命令：</p>
<pre><code>E:\GitHub&gt; cd myblog            //进入目录
E:\GitHub\myblog&gt; hexo init    //进行初始化
</code></pre><p>注：我的git shell 的根目录为 E:\Github ,myblog 文件夹在它下面。<br>然后就是静静的等待它下载完成，可能需要几分钟。<br>最后就可以生成静态界面：</p>
<pre><code>hexo g
</code></pre><p>启动服务：</p>
<pre><code>hexo s
</code></pre><p>打开浏览器，输入 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 即可成功打开。<br>到此，你已经成功的弄好博客页面了。</p>
<hr>
<h2 id="3、配置到github"><a href="#3、配置到github" class="headerlink" title="3、配置到github"></a>3、配置到github</h2><p>上面生成的 博客页面仅限本机使用，别人无法访问。有服务器的可以把它配置到服务器上。但这里采用的是提交到github，由它托管，就可以方便的访问了。<br>在github 上建立  <strong><em>用户名.github.io</em></strong> 的仓库。如我的github用户名为：txadf,仓库为：<strong>txadf.github.io</strong>  地址为 ：<a href="https://github.com/txadf/txadf.github.io.git" target="_blank" rel="external">https://github.com/txadf/txadf.github.io.git</a><br>然后打开blog 文件夹下的 _config.yml 文件，在最后修改为如下代码：</p>
<pre><code>deploy:
  type: git
  repo: https://github.com/txadf/txadf.github.io.git
  branch: master
</code></pre><p>最后，提交博客文件到gtihub,执行如下命令：</p>
<pre><code>hexo d
</code></pre><p>如果不出错，那么就可以在浏览器用 txadf.github.进行访问了。</p>
<hr>
<h2 id="4、hexo-相关命令"><a href="#4、hexo-相关命令" class="headerlink" title="4、hexo 相关命令"></a>4、hexo 相关命令</h2><pre><code>cls             清屏
hexo clean      清理项目
hexo g          生成静态界面
hexo s          启动服务器
hexo d          提交到github
hexo help       全部的命令
</code></pre><p>新建文章：</p>
<pre><code>hexo new &quot;blogname&quot;
</code></pre><p>博客支持markdown语法，可以用相关的编辑器写好后放在<strong>_posts</strong>文件下。对于markdown语法，如有不懂课自行百度。</p>
<hr>
<h2 id="5、主题推荐"><a href="#5、主题推荐" class="headerlink" title="5、主题推荐"></a>5、主题推荐</h2><p>对于主题的修改，只需要修改 blog 文件夹下的 <strong>_config.yml</strong> 中的<strong>theme</strong>属性为指定的主题名，并将主题放到theme文件夹下。<br>然后 进行部署（hexo g） 和提交 （hexo d）<br>注：对于其他的属性，修改 方法类似，如网站标题，作者等。</p>
<p>这里推荐几个个人比较喜欢的主题：</p>
<ol>
<li><a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism" target="_blank" rel="external">我的博客主题</a>  </li>
<li><a href="https://github.com/txadf/hexo-theme-spfk" target="_blank" rel="external">hexo-theme-spfk</a></li>
</ol>
<p>更多主题，请访问<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">这里</a></p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>http://imtianx.cn/about/index.html</url>
      <content type="html"><![CDATA[<p>大家好，我是imtianx。欢迎来到我的个人技术博客。</p>
<p>作为一个搞技术的，不断地学习是必不可少的。然而，不管什么技术，如果学习完不使用，很快就会忘记，所以，及时的做笔记十分重要。在此，搭建自己的个人博客，记录自己的成长过程。虽然我还是一个刚入门的技术小白，但我相信，总有一天会成长为一个技术大牛的，加油！<br><strong>联系方式</strong>：<br>QQ： 764275613<br>email： imtianx@163.com</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[读书]]></title>
      <url>http://imtianx.cn/reading/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
