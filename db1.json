{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/settings/CNAME","path":"settings/CNAME","modified":1,"renderable":0},{"_id":"themes/raytaylorism/source/favicon-0.png","path":"favicon-0.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/weixin_favicon.png","path":"weixin_favicon.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/diyihangdaima.jpg","path":"img/diyihangdaima.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/qunyingzhuan.jpg","path":"img/qunyingzhuan.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/yisutansuo.jpg","path":"img/yisutansuo.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/yuanmashejimoshi.jpg","path":"img/yuanmashejimoshi.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/js/prettify.js","path":"js/prettify.js","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/quanweizhilan.jpg","path":"img/quanweizhilan.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/weixin.jpg","path":"img/weixin.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/wudangshan.jpg","path":"img/wudangshan.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/yafalu.jpg","path":"img/yafalu.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/zhifubao.jpg","path":"img/zhifubao.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/images/side-user-cover.jpg","path":"css/images/side-user-cover.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/lib/font-awesome.min.css","path":"css/lib/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/lib/prettify-tomorrow-night-eighties.css","path":"css/lib/prettify-tomorrow-night-eighties.css","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/AnimatorSet.gif","path":"img/article_img/AnimatorSet.gif","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/Interpolator-resource-id.png","path":"img/article_img/Interpolator-resource-id.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/Interpolator.jpg","path":"img/article_img/Interpolator.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/TabLayout+ViewPager-create-tab.gif","path":"img/article_img/TabLayout+ViewPager-create-tab.gif","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/ValueAnimator-simple-demo.gif","path":"img/article_img/ValueAnimator-simple-demo.gif","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/fengkuangjiangyi.jpg","path":"img/fengkuangjiangyi.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/js/materialize.min.js","path":"js/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/lib/materialize.min.css","path":"css/lib/materialize.min.css","modified":1,"renderable":1},{"_id":"source/settings/android-engineer-resume-imtianx.pdf","path":"settings/android-engineer-resume-imtianx.pdf","modified":1,"renderable":0},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Bold.eot","path":"css/font/roboto/Roboto-Bold.eot","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Bold.woff2","path":"css/font/roboto/Roboto-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Bold.woff","path":"css/font/roboto/Roboto-Bold.woff","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Light.eot","path":"css/font/roboto/Roboto-Light.eot","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Light.woff","path":"css/font/roboto/Roboto-Light.woff","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Light.woff2","path":"css/font/roboto/Roboto-Light.woff2","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Medium.eot","path":"css/font/roboto/Roboto-Medium.eot","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Medium.woff","path":"css/font/roboto/Roboto-Medium.woff","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Regular.eot","path":"css/font/roboto/Roboto-Regular.eot","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Medium.woff2","path":"css/font/roboto/Roboto-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Regular.woff","path":"css/font/roboto/Roboto-Regular.woff","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Regular.woff2","path":"css/font/roboto/Roboto-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/Binder 工作机制.png","path":"img/article_img/2016/Binder 工作机制.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/Handler 消息机制.png","path":"img/article_img/2016/Handler 消息机制.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/Handler消息处理流程.png","path":"img/article_img/2016/Handler消息处理流程.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/Scroller滑动机制.png","path":"img/article_img/2016/Scroller滑动机制.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/View 中的scrollTo和scrollBy.png","path":"img/article_img/2016/View 中的scrollTo和scrollBy.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/activity异常重建.png","path":"img/article_img/2016/activity异常重建.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/collection_diagram.png","path":"img/article_img/2016/collection_diagram.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/fragment_and_activity_lifecycle.jpg","path":"img/article_img/2016/fragment_and_activity_lifecycle.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/hashmap.jpg","path":"img/article_img/2016/hashmap.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/map_diagram.png","path":"img/article_img/2016/map_diagram.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/object_state.png","path":"img/article_img/2016/object_state.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/view.png","path":"img/article_img/2016/view.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/view_zuobiao.png","path":"img/article_img/2016/view_zuobiao.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/weakreference.png","path":"img/article_img/2016/weakreference.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/对象内存分配1.png","path":"img/article_img/2016/对象内存分配1.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/数组内存分配5.png","path":"img/article_img/2016/数组内存分配5.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/TabLayout+ViewPager-create-tab_icon.gif","path":"img/article_img/TabLayout+ViewPager-create-tab_icon.gif","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/font-awesome/FontAwesome.otf","path":"css/font/font-awesome/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/font-awesome/fontawesome-webfont.eot","path":"css/font/font-awesome/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/font-awesome/fontawesome-webfont.woff","path":"css/font/font-awesome/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/font-awesome/fontawesome-webfont.woff2","path":"css/font/font-awesome/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Bold.ttf","path":"css/font/roboto/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Light.ttf","path":"css/font/roboto/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Medium.ttf","path":"css/font/roboto/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Regular.ttf","path":"css/font/roboto/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/activity生命周期.png","path":"img/article_img/2016/activity生命周期.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/architucture.png","path":"img/article_img/2016/architucture.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/fragment-life.png","path":"img/article_img/2016/fragment-life.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/show_aar.png","path":"img/article_img/2016/show_aar.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/对象内存分配2.png","path":"img/article_img/2016/对象内存分配2.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/数组内存分配1.png","path":"img/article_img/2016/数组内存分配1.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/数组内存分配2.png","path":"img/article_img/2016/数组内存分配2.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/数组内存分配3.png","path":"img/article_img/2016/数组内存分配3.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/数组内存分配4.png","path":"img/article_img/2016/数组内存分配4.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/font-awesome/fontawesome-webfont.ttf","path":"css/font/font-awesome/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/algorithm.png","path":"img/article_img/2016/algorithm.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/collection.png","path":"img/article_img/2016/collection.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/setvmintegerMax.png","path":"img/article_img/2016/setvmintegerMax.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/danjiangkoushi.jpg","path":"img/danjiangkoushi.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/huatlib-2.jpg","path":"img/huatlib-2.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/ide_show_class_diagram.png","path":"img/article_img/2016/ide_show_class_diagram.png","modified":1,"renderable":1},{"_id":"source/settings/search.xml","path":"settings/search.xml","modified":1,"renderable":0},{"_id":"themes/raytaylorism/source/img/huatlib.jpg","path":"img/huatlib.jpg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/css/font/font-awesome/fontawesome-webfont.svg","path":"css/font/font-awesome/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/bluetooth/ble-client.gif","path":"img/article_img/bluetooth/ble-client.gif","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/bluetooth/ble-server.gif","path":"img/article_img/bluetooth/ble-server.gif","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/http.png","path":"img/article_img/2016/http.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/article_img/2016/对象内存分配-debug.png","path":"img/article_img/2016/对象内存分配-debug.png","modified":1,"renderable":1},{"_id":"themes/raytaylorism/source/img/head.jpg","path":"img/head.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/raytaylorism/.gitignore","hash":"cda50c55bb8864e0d96101140b62f880f690da5e","modified":1459780065390},{"_id":"themes/raytaylorism/Gruntfile.js","hash":"f0c204fc7b3343417cc1a0fdca12ab089394b654","modified":1472565716000},{"_id":"themes/raytaylorism/LICENSE","hash":"115cd028ae511ac9e3d30eb4933da38136a68513","modified":1459780065393},{"_id":"themes/raytaylorism/README.md","hash":"44ab92c9ff080a692bc7ba4876267fcdd0c287a1","modified":1483155496254},{"_id":"themes/raytaylorism/_config.yml","hash":"39272db1cb7c3712c5540756b8544032d367faab","modified":1486482441288},{"_id":"source/_data/111slider.json","hash":"86e7a28a49e0984dd5880cea006a8f2692238d94","modified":1464409557677},{"_id":"source/_data/about.json","hash":"2ff279654646ae1f0ebd0a2c879bafc8771e4773","modified":1483155215649},{"_id":"source/_data/hint.json","hash":"3f457c33e73b5ebc637ca9cffe52169922fd9e99","modified":1468149938508},{"_id":"source/_data/link.json","hash":"37b453eb76b8794ae84d1af3982768de183ba8de","modified":1490410743075},{"_id":"source/_data/reading.json","hash":"406c00dcecc82d28e9e3d2cac16abd946ed62e6e","modified":1479990841801},{"_id":"source/about/index.md","hash":"88879fb72c7b345610eb0575911cb2580d9fca1c","modified":1486482363521},{"_id":"source/_posts/Android Bluetooth 蓝牙技术初体验.md","hash":"c998141368ed539f2e67259777fe68575bfcfb54","modified":1475849822376},{"_id":"source/_posts/Android Bluetooth 通信技术深入--聊天小应用.md","hash":"55e565bd5e681c055ac6a132a4fd369543af6c30","modified":1475934473412},{"_id":"source/_posts/Android View 的事件体系.md","hash":"afa7cfab966e47056e39fe3aa7dee7552893d30a","modified":1483149619452},{"_id":"source/_posts/AsyncTask 工作原理及线程池.md","hash":"baec1e14aeeac5527e1cae9def7310581ce77f84","modified":1483776920815},{"_id":"source/_posts/Eventbus-simple-use.md","hash":"18baa20708e53bb8f4c58940e1c60a50de8278c7","modified":1461406069175},{"_id":"source/_posts/PhotoView_GifView.md","hash":"bef5a9bd55c037bbdc8c941ef2ee3e5e051ca8ab","modified":1461403747408},{"_id":"source/_posts/Property-animatorValueAnimator_ObjectAnimation.md","hash":"26a0f2eafaa512f40fd58f87cc4709043b8f3948","modified":1461587121152},{"_id":"source/_posts/SwipeRefreshLayout-RecyclerView.md","hash":"7e715518d9eade7fbf9111bacb0ca16d30f12911","modified":1475849402411},{"_id":"source/_posts/TabLayout+ViewPager create tab.md","hash":"eacdf20823db8d385114768d73ee12ee2de96b91","modified":1477124904623},{"_id":"source/_posts/Tomcat中配置单IP多二级域名方法.md","hash":"bd0a12bb57ac975c9b9eaf4060c63d8a5187c87b","modified":1486822742231},{"_id":"source/_posts/activity 生命周期及调用栈详解.md","hash":"b423f9c80ad0c6f1bba2df027a4cd0ea8d6c407c","modified":1478943885989},{"_id":"source/_posts/android  多渠道打包.md","hash":"e5e9749fdb1e5e5ce32d356f3cd2b7a7bacdf71f","modified":1481879995345},{"_id":"source/_posts/android 7.0-take-photo.md","hash":"7f6eba495f1bd3418f06f8660556a118e10e421c","modified":1490364450567},{"_id":"source/_posts/android IPC 机制及进程通信.md","hash":"9ad12bc307fa60535a699e6ec8f9d2cd162ffc83","modified":1481949393694},{"_id":"source/_posts/android studio 生成aar和jar.md","hash":"cdec03e1cd0d4afa8c41ceeac69089e341a577d4","modified":1478010972434},{"_id":"source/_posts/android 消息机制及其原理.md","hash":"c07e695a93354f6e0321323adfc55c3f72891d01","modified":1483706486622},{"_id":"source/_posts/android 自定义View 详解.md","hash":"e5bc6a2c446b477842e37156c42048604ee78c85","modified":1482128477679},{"_id":"source/_posts/android-exception-catch-UncaughtExceptionHandler.md","hash":"a947dd34771981a1ab82d91a941a696c9256330d","modified":1468149780735},{"_id":"source/_posts/android-open-source-connected.md","hash":"2bf5ad971125cebd5df5f1ed2012dac4be1ec1e0","modified":1468551356308},{"_id":"source/_posts/android-sqlite-notebook.md","hash":"3179a293853685961efc319d4bd15997169f8370","modified":1461400963622},{"_id":"source/_posts/android-sqlite-use.md","hash":"dccf28b05ffbe69a5095282ec3b716d0d4dd661a","modified":1461400843941},{"_id":"source/_posts/androidstudio-keaymap.md","hash":"7404247bc6f226c024017274c0b04dc744e9aea2","modified":1461405566254},{"_id":"source/_posts/auto-filin-smscode.md","hash":"0ddb36177f0da13cbb238c8323679959ef1b5217","modified":1461402734919},{"_id":"source/_posts/excellent-blog-author-of-android.md","hash":"2208a77edb130a03d5d46678bb3047dfd15a86c7","modified":1461405211432},{"_id":"source/_posts/erroe-of-offline-or-unauthorized.md","hash":"af551e041c877f956d2ca175c95f554cde8aaf44","modified":1461407224053},{"_id":"source/_posts/first-use-widget.md","hash":"0fbe7598deac952884f5a2056e6d7426e3034be4","modified":1461404921202},{"_id":"source/_posts/hexo+github -build-my-blog.md","hash":"f2d9acab22e419917462a4af3e13525d11878baf","modified":1461332607376},{"_id":"source/_posts/hexo- write-blog.md","hash":"ad65fbbdec8e2d6e900faf83d7c6d7a659c223d2","modified":1461379903906},{"_id":"source/_posts/java 三大特性：封装、继承和多态.md","hash":"b21d35f39f35bf74f014e4c3242811b5a8e4dc84","modified":1479531038780},{"_id":"source/_posts/java 知识 之 内存管理.md","hash":"a72687b5af17f9d97d4199f2dd12b368efc13e53","modified":1479969069267},{"_id":"source/_posts/java 知识 之 常见java集合的实现细节.md","hash":"cb23285750907afdb176d0bad4f17f5127f14795","modified":1479810033363},{"_id":"source/_posts/java 知识之 对象及其内存管理.md","hash":"2fb53cd6fc31a3836d8e3cac4c30a5744bf714f2","modified":1479969183136},{"_id":"source/_posts/java 知识之 反射的使用.md","hash":"1d6bc34f0070dbe82372cd97d249c494c278f5c5","modified":1480131232935},{"_id":"source/_posts/java 知识之 数组及其内存管理.md","hash":"d3877bfb18e19695f567811a44a47fff2649dfde","modified":1479532175966},{"_id":"source/_posts/java 知识之 注解的使用和解析.md","hash":"e9fc1a79cbe6f1d7f0fd22fc31cce0931b8e5695","modified":1480128434082},{"_id":"source/_posts/java知识 之 Integer自动拆装箱与缓存.md","hash":"9265c8e1d42b22fdb265fe35044de01726c1fe72","modified":1480226249929},{"_id":"source/_posts/listView-in-scrollView.md","hash":"491f8a296bc81df0f135c575798ff9145c3b5b8d","modified":1461406689020},{"_id":"source/_posts/listview-optimize.md","hash":"0c8adbda6474cc6171234eb0660eaa79bf203bb0","modified":1461407595994},{"_id":"source/_posts/open-other-app.md","hash":"03571d27c1e19038ee03931581f3ef1928a01204","modified":1461403034832},{"_id":"source/_posts/open-source-frame.md","hash":"ff3112f7909d9727d62c6726cfe94dc6b38d2ad3","modified":1461398533891},{"_id":"source/_posts/open-source.md","hash":"35a484bae6518a99bea983b61775778dec1b0530","modified":1461401641896},{"_id":"source/_posts/plsql-install-config.md","hash":"f2a69f6285e280ac63d20e5109f9c17960fc0e7f","modified":1461404259868},{"_id":"source/_posts/put-libary-to-jcenter.md","hash":"db7349356a18689634e26494772bfb64f2852bb0","modified":1461554095240},{"_id":"source/_posts/screen-adaptation-dp_sp.md","hash":"a22b4f9555c274b77bd2e384ad1f4a9be8f3b779","modified":1461397161713},{"_id":"source/_posts/sum-up-2015.md","hash":"d14d2e2539673cfdc73a95107a35b2d1e0e6595a","modified":1461406270801},{"_id":"source/_posts/using-DataBinding.md","hash":"fa03e92504c9f1bd81a0c94b270e51c09f749377","modified":1474333417613},{"_id":"source/_posts/view-Animation.md","hash":"e5b994099bb428ae7b7c4c6aacd43c3fac00a110","modified":1482631863789},{"_id":"source/_posts/webview-Screen-adaptation.md","hash":"26fab7a306f14fc023636f2649778217d392ef48","modified":1461396409452},{"_id":"source/_posts/国内一线互联网公司内部面试题库(一)-java.md","hash":"b25e4fd2a9ca8f1316bf305d4163ded2a942719f","modified":1478520120275},{"_id":"source/_posts/国内一线互联网公司内部面试题库(二)-android.md","hash":"56d8b40606891f7e4bc32811f3a7c4fd01cfe011","modified":1478520176810},{"_id":"source/_posts/天盾app项目总结.md","hash":"19ad48116ca285dc16c46ad3706888ada48ef944","modified":1477230984658},{"_id":"source/reading/index.md","hash":"ab4ae4fad36f371f60b49973797a115423a784d4","modified":1459780065400},{"_id":"source/settings/CNAME","hash":"1264284dae49c8fe88b8b85350ad8847b0857671","modified":1490371521762},{"_id":"source/settings/README.md","hash":"05a8744593283abf9aa44fff6e201da3db1d38fc","modified":1490371521768},{"_id":"source/settings/baidu_verify_MSHxCKJSJ1.html","hash":"a93d5f00c2207434cccb29478294563b3f563cca","modified":1490371522661},{"_id":"themes/raytaylorism/_data/about.json","hash":"ad37c7a373e24ba9fb26630b0e761cabb3431b90","modified":1459780065395},{"_id":"themes/raytaylorism/_data/hint.json","hash":"178fe345ea95511364ed70da86186cb834947993","modified":1459780065396},{"_id":"themes/raytaylorism/_data/link.json","hash":"b865125d0440e6717ee3d88d1b518a4ebdb32d61","modified":1459780065396},{"_id":"themes/raytaylorism/_data/reading.json","hash":"e8045e22b2d499a5d813320a8c2b1bccdbedd46d","modified":1459780065397},{"_id":"themes/raytaylorism/_data/slider.json","hash":"361373b57cfb5371027af42000bbaec4e03333a3","modified":1459780065398},{"_id":"themes/raytaylorism/languages/default.yml","hash":"c776295eb1a97a8b938624c329f3e4b7288114b5","modified":1482274322000},{"_id":"themes/raytaylorism/languages/zh-CN.yml","hash":"ea0b8f560bd8315ebe794358a7c8ab379ec3ab3b","modified":1482274322000},{"_id":"themes/raytaylorism/languages/zh-TW.yml","hash":"b514bfb6832c1f33269836fbceb6356ac846386c","modified":1482274322000},{"_id":"themes/raytaylorism/layout/about.ejs","hash":"54e74d61dba41f173f111e32deeb58447260f0e3","modified":1482274322000},{"_id":"themes/raytaylorism/layout/archive.ejs","hash":"0a21af8903e95c6d8bb7554b089ac219e8708ad7","modified":1482274322000},{"_id":"themes/raytaylorism/layout/index.ejs","hash":"34cbcb6c75e2eef622fea6fecebfe15fb7522a95","modified":1482274322000},{"_id":"themes/raytaylorism/layout/layout.ejs","hash":"0fbced6bf0129f550ad66d57735d269b70728b49","modified":1482274322000},{"_id":"themes/raytaylorism/layout/page.ejs","hash":"90441f114859ce63ef7c7d93d668dbe5939995c2","modified":1482274322000},{"_id":"themes/raytaylorism/layout/post.ejs","hash":"8e550fd95ef761909294ed3a4aa428ff0509fbf0","modified":1482274322000},{"_id":"themes/raytaylorism/layout/reading.ejs","hash":"8ff2e67f23d265dbbf07db26bce6277ba72d8511","modified":1482274322000},{"_id":"themes/raytaylorism/layout/tag.ejs","hash":"42ecab14917abd40c0a38e6ab629f089352a24b1","modified":1482274322000},{"_id":"themes/raytaylorism/source/favicon-0.png","hash":"5962feb23035fd72f8bcebd02f11fa3fd3431612","modified":1457126904000},{"_id":"themes/raytaylorism/source/favicon.png","hash":"67227b713abcedb34172ad15fbe1b8c76e337ac2","modified":1478848297674},{"_id":"themes/raytaylorism/source/weixin_favicon.png","hash":"4a8466bd7d8cf4753cab8fb68647b40b91a246ad","modified":1482274322000},{"_id":"themes/raytaylorism/_md/reading/index.md","hash":"ab4ae4fad36f371f60b49973797a115423a784d4","modified":1459780065400},{"_id":"themes/raytaylorism/_md/about/index.md","hash":"cf37b9536668e276655568ad5b3ef20f78c1ad8f","modified":1459780065399},{"_id":"themes/raytaylorism/layout/_partial/archive_title.ejs","hash":"37c38ef6972ddd92668ea08983f4b34230b39d52","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/archive.ejs","hash":"6fc4dc05d153dbf1dd955df4ff19c380692f87e9","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/article.ejs","hash":"068cd4f944f8f0810d06bc79d11042da406c7067","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/construction.ejs","hash":"21190b5a0d567ed4ea5d5289459690b72c1452f0","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/feature_guide.ejs","hash":"752d5c0a4a6f2f2228ae99bb6bede195080a15d8","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/float.ejs","hash":"a561efd4b391988f4ab71562b62e58fb744dc61a","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/footer.ejs","hash":"6d7835aba5201c2666677ddf06275062a742779d","modified":1483154435168},{"_id":"themes/raytaylorism/layout/_partial/after_footer.ejs","hash":"e233fb794a365e0e3ee6d6dcd4eaae221d5b03ec","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/head.ejs","hash":"406c0bdb3ef224bb5ec375123426a0babae2724a","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/header.ejs","hash":"426eeb374b409a6ab6eb8e21a7213b6a6147d6f9","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/menu_drawer.ejs","hash":"28a46dd851b971216c788ace1ca5609d961c2446","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/pagenav.ejs","hash":"e7ada8faaee878ea4dde267d1b420bb45421670d","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/pagination.ejs","hash":"247c1507971b3e41ed539dd7f8d15af8e21c0d58","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/search.ejs","hash":"1285a8ecb670f6460b31c0fbca9af13b202f5838","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/side_nav.ejs","hash":"b12e72453fb981924d17fa48904af6951f07450f","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/simple_article.ejs","hash":"fdcbb516a3745d0a70c94e565d53510d9f47693c","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/slider.ejs","hash":"bb7b53f6ca9c852808d955fb074f88112e51ea59","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_widget/about.ejs","hash":"54e74d61dba41f173f111e32deeb58447260f0e3","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/archive.ejs","hash":"0a21af8903e95c6d8bb7554b089ac219e8708ad7","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/blogroll.ejs","hash":"cf42209342e51e1729dcc9b01b1e5497f152844f","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_widget/category.ejs","hash":"fb2d42083c97dfaba2717fb2e63e744259ec4530","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_widget/index.ejs","hash":"34cbcb6c75e2eef622fea6fecebfe15fb7522a95","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/layout.ejs","hash":"0fbced6bf0129f550ad66d57735d269b70728b49","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/page.ejs","hash":"90441f114859ce63ef7c7d93d668dbe5939995c2","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/post.ejs","hash":"8e550fd95ef761909294ed3a4aa428ff0509fbf0","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/reading.ejs","hash":"8ff2e67f23d265dbbf07db26bce6277ba72d8511","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/recent_posts.ejs","hash":"0025878eb4cbf17ddc909f82497e9c73e4091c20","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_widget/tag.ejs","hash":"31b93c078a03af98de504eeb0153f9c0dbc74ed9","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_widget/tagcloud.ejs","hash":"1da338304f94f042606b73e235e9c725628c34ad","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/style.styl","hash":"2c7ef7179e29084efe77c653d537b56889734a22","modified":1482274322000},{"_id":"themes/raytaylorism/source/img/diyihangdaima.jpg","hash":"1e1b2fc1148f41515bad16744895282c856d5593","modified":1461325660157},{"_id":"themes/raytaylorism/source/img/qunyingzhuan.jpg","hash":"a8d0ab7568b8b27c2ace38dcb4cf70213c675288","modified":1460034499572},{"_id":"themes/raytaylorism/source/img/yisutansuo.jpg","hash":"5cca726aa52594bac5da3e7c6f072190acb14b42","modified":1461325407614},{"_id":"themes/raytaylorism/source/img/yuanmashejimoshi.jpg","hash":"99b1e8948b8ce48904615e405f4f7d38595bc828","modified":1461325451714},{"_id":"themes/raytaylorism/source/js/prettify.js","hash":"d24b1da342b5c2d0582f0922118aaf0b2a6840d5","modified":1482274322000},{"_id":"themes/raytaylorism/source/img/quanweizhilan.jpg","hash":"2f0de334e2ab72084afc7a89ce8ead319b2fa2a1","modified":1460034785329},{"_id":"themes/raytaylorism/source/img/weixin.jpg","hash":"0d08966c80e76cb886a57fd87b2ffd26aa3e7d99","modified":1460036924808},{"_id":"themes/raytaylorism/source/img/wudangshan.jpg","hash":"29a7bc40de361d8a0ed3d3be1ece41e962ff2c27","modified":1461324238830},{"_id":"themes/raytaylorism/source/img/yafalu.jpg","hash":"1e0fc9e198fbfefe9cedffa24fb262f972291515","modified":1460034935116},{"_id":"themes/raytaylorism/source/img/zhifubao.jpg","hash":"c725317ba494b8efcc23329482e90234ca6289e0","modified":1460037167678},{"_id":"themes/raytaylorism/source/js/jquery.min.js","hash":"69bb69e25ca7d5ef0935317584e6153f3fd9a88c","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/plugin/analytics.ejs","hash":"b88303620558f833c6d7505af762d12e21f90f90","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/plugin/google_code_prettify.ejs","hash":"3aecf1e3e706417131918e3f489557e2d5f438af","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/plugin/comment.ejs","hash":"a095ef55ca52e6db052a4e3c93ced2eb6cedf589","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/plugin/main_javascript.ejs","hash":"cc246117386c6cbde13e3b4316ba5e85af659df6","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/plugin/noscript.ejs","hash":"182650c8be93b093997ac4d5fe14af2f835b98d9","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/plugin/mathjax.ejs","hash":"f0e5e249d2bd6dc2a72baf0f71d2d67463c7b3ad","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/plugin/reward.ejs","hash":"fde8d42347f72f3b3594c36b1f3c94c6d90a31b6","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/post/category.ejs","hash":"f48f487dc952f5703d9bc7737fc6eb2e6b439608","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/post/gallery.ejs","hash":"0adb673358b42b9ac52b2c1f72b92368cdcf5f2e","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/post/prevnext.ejs","hash":"dbb790cf454fda546c82a411a3b50ebb0129a1e8","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/post/readtimes.ejs","hash":"c829d0598f9906f663a8ace1c86f2aa6024d642c","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/post/tablecontents.ejs","hash":"a851061909d4e27321d1792a262f55385529fb2d","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/post/tag.ejs","hash":"36cbf8f85f93be441d47d1a4a0584afd85480d4f","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/post/time.ejs","hash":"e11498240ece670129a2fbfb2fed16ff315344d4","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_partial/post/title.ejs","hash":"c6c44ea53bbfd3838c7bf7cc236c6db1a4b9460e","modified":1482274322000},{"_id":"themes/raytaylorism/layout/_widget/_partial/after_footer.ejs","hash":"77476565bc85987d7656751cbc27b473223b0186","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/archive.ejs","hash":"a2c9a472b554561a3a6f3ef7ec0ece9b1c93ebab","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/archive_title.ejs","hash":"3dc915d0ce299510a985d40b9bc8a3e173439b43","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/article.ejs","hash":"9dc23a8faceca79855ec571c25e399edb1a740a2","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/construction.ejs","hash":"21190b5a0d567ed4ea5d5289459690b72c1452f0","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/feature_guide.ejs","hash":"752d5c0a4a6f2f2228ae99bb6bede195080a15d8","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/float.ejs","hash":"a561efd4b391988f4ab71562b62e58fb744dc61a","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/footer.ejs","hash":"42796d6fca3a62bb25816b35aa40390b16939f23","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/head.ejs","hash":"406c0bdb3ef224bb5ec375123426a0babae2724a","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/header.ejs","hash":"426eeb374b409a6ab6eb8e21a7213b6a6147d6f9","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/menu_drawer.ejs","hash":"28a46dd851b971216c788ace1ca5609d961c2446","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/pagenav.ejs","hash":"e7ada8faaee878ea4dde267d1b420bb45421670d","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/pagination.ejs","hash":"247c1507971b3e41ed539dd7f8d15af8e21c0d58","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/search.ejs","hash":"1285a8ecb670f6460b31c0fbca9af13b202f5838","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/side_nav.ejs","hash":"b12e72453fb981924d17fa48904af6951f07450f","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/simple_article.ejs","hash":"86c62b38b1664244c45587b02f7c99e28fa3abee","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/slider.ejs","hash":"bb7b53f6ca9c852808d955fb074f88112e51ea59","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_widget/blogroll.ejs","hash":"cf42209342e51e1729dcc9b01b1e5497f152844f","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_widget/category.ejs","hash":"fb2d42083c97dfaba2717fb2e63e744259ec4530","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_widget/recent_posts.ejs","hash":"0025878eb4cbf17ddc909f82497e9c73e4091c20","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_widget/tag.ejs","hash":"bc8e48d8afbe7e882cea13b07b634b5ce63e7b61","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_widget/tagcloud.ejs","hash":"1da338304f94f042606b73e235e9c725628c34ad","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_base/icons.css","hash":"ab167f1694ffe10c3c51d18a633efd41be121555","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_base/layout.styl","hash":"14a747f9fce53f586d11ed67a597a8e71a802d17","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_base/lib_customize.styl","hash":"e4946dec16d0e96e6f2067a09c275ea84c0b3146","modified":1483155159530},{"_id":"themes/raytaylorism/source/css/_base/variable.styl","hash":"6812c6940c7c59b9fab5b41e6b832e89416d11c5","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/about.styl","hash":"b0f80e89e7518d49190b79985c10c8a7b24bfa19","modified":1486303743028},{"_id":"themes/raytaylorism/source/css/_partial/archive.styl","hash":"d912cf297c10e78bd90f3210d596ec87a16f74ad","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/article.styl","hash":"94bdf4d6da4ec154124ac66008c8dff66882c7e4","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/comment.styl","hash":"bfa4d7caedffffab18b29f70db9cbf2a15a5f24b","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/footer.styl","hash":"c0d422ce12e0565915148079aa1a134773588568","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/header.styl","hash":"534686e8e9de54e8dd99eb1b064f5ad3a0199a4e","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/index.styl","hash":"27918d50e5a69899f184280d9e0048576ac3c85d","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/link_context.styl","hash":"cd403f732319354781c552d26d37bad7c4450ad5","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/other.styl","hash":"710eea97e5c98a1426d1a3c0fc8f648279c7a82d","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/reading.styl","hash":"7abecdfc7fd21f7d11f1568d430418296b34945a","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/search.styl","hash":"caef055a95598415656c417e662264397363704b","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/side_nav.styl","hash":"b239b6b55e87e86d038d6aa821beeb66a9cbaf39","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/slider.styl","hash":"8933a67e92680dbdfd6af7c2ecaa8d86346df907","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/style.styl","hash":"2c7ef7179e29084efe77c653d537b56889734a22","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/syntax.styl","hash":"20df0f8a54729980094514fc726b51591ada1ad7","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/tablecontents.styl","hash":"e04fa0e7664065077750a7223ae3390cc84a4c56","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/images/side-user-cover.jpg","hash":"d8d73a64d6d5af83a27e6af1d4fedef808955ba0","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/lib/font-awesome.min.css","hash":"683d12731b7429d32ec7de00a6706602e403013f","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/lib/prettify-tomorrow-night-eighties.css","hash":"35e07bd7a4585363060edd558a0e9939e7e68323","modified":1482274322000},{"_id":"themes/raytaylorism/source/img/article_img/AnimatorSet.gif","hash":"403975d8a5438c240efb1696af822609eb78ff95","modified":1461582952609},{"_id":"themes/raytaylorism/source/img/article_img/Interpolator-resource-id.png","hash":"fdc07317bc9e32f50b1ded4f8b193abbd108c2fe","modified":1461550375577},{"_id":"themes/raytaylorism/source/img/article_img/Interpolator.jpg","hash":"a16df621389f83c4f4c5ae8d4513c812bb2e4a37","modified":1461503633077},{"_id":"themes/raytaylorism/source/img/article_img/TabLayout+ViewPager-create-tab.gif","hash":"8d26b2c4d6d9f3b43d22e1d149e23d0a7fe8befe","modified":1464403449140},{"_id":"themes/raytaylorism/source/img/article_img/ValueAnimator-simple-demo.gif","hash":"0218020756f8740cbbf5e26dff87963a1cc71e1a","modified":1461565604402},{"_id":"themes/raytaylorism/source/img/fengkuangjiangyi.jpg","hash":"22a6f6be5bc03c52e25cf91cb5cd6396ca4efe95","modified":1460034586793},{"_id":"themes/raytaylorism/source/js/materialize.min.js","hash":"c9308fbe808a149aa11061af40a4be5f391cccee","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/lib/materialize.min.css","hash":"41d1676b73eec020eaeb9b507dcbcd30069ae8cb","modified":1482274322000},{"_id":"source/settings/android-engineer-resume-imtianx.pdf","hash":"ab473974671cb37204c339af5cc3b829ef8b5722","modified":1490371521867},{"_id":"themes/raytaylorism/layout/_widget/_partial/plugin/analytics.ejs","hash":"b88303620558f833c6d7505af762d12e21f90f90","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/plugin/google_code_prettify.ejs","hash":"3aecf1e3e706417131918e3f489557e2d5f438af","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/plugin/comment.ejs","hash":"a095ef55ca52e6db052a4e3c93ced2eb6cedf589","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/plugin/main_javascript.ejs","hash":"7cb7addc89cf636e5862f928dbeaa867525ab799","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/plugin/mathjax.ejs","hash":"f0e5e249d2bd6dc2a72baf0f71d2d67463c7b3ad","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/plugin/noscript.ejs","hash":"182650c8be93b093997ac4d5fe14af2f835b98d9","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/plugin/reward.ejs","hash":"fde8d42347f72f3b3594c36b1f3c94c6d90a31b6","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/post/category.ejs","hash":"f48f487dc952f5703d9bc7737fc6eb2e6b439608","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/post/tablecontents.ejs","hash":"a851061909d4e27321d1792a262f55385529fb2d","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/post/gallery.ejs","hash":"0adb673358b42b9ac52b2c1f72b92368cdcf5f2e","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/post/tag.ejs","hash":"36cbf8f85f93be441d47d1a4a0584afd85480d4f","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/post/time.ejs","hash":"166534f9231b5c77c76d9d4fb40f66e2e918837d","modified":1472565716000},{"_id":"themes/raytaylorism/layout/_widget/_partial/post/title.ejs","hash":"7e48dc0d240ab4bbea27dcb383fb56fb9656c6a9","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/_base/icons.css","hash":"ab167f1694ffe10c3c51d18a633efd41be121555","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_base/layout.styl","hash":"14a747f9fce53f586d11ed67a597a8e71a802d17","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_base/lib_customize.styl","hash":"2e9f3c668f79b0dd11b3babf828d376c6c91e0b2","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_base/variable.styl","hash":"6812c6940c7c59b9fab5b41e6b832e89416d11c5","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/about.styl","hash":"b0f80e89e7518d49190b79985c10c8a7b24bfa19","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/archive.styl","hash":"d912cf297c10e78bd90f3210d596ec87a16f74ad","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/article.styl","hash":"94bdf4d6da4ec154124ac66008c8dff66882c7e4","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/comment.styl","hash":"bfa4d7caedffffab18b29f70db9cbf2a15a5f24b","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/footer.styl","hash":"c0d422ce12e0565915148079aa1a134773588568","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/header.styl","hash":"534686e8e9de54e8dd99eb1b064f5ad3a0199a4e","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/index.styl","hash":"27918d50e5a69899f184280d9e0048576ac3c85d","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/link_context.styl","hash":"cd403f732319354781c552d26d37bad7c4450ad5","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/other.styl","hash":"8be9dcf7b70f8e4693a2590bb38997273e01bca7","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/reading.styl","hash":"7abecdfc7fd21f7d11f1568d430418296b34945a","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/search.styl","hash":"caef055a95598415656c417e662264397363704b","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/side_nav.styl","hash":"b239b6b55e87e86d038d6aa821beeb66a9cbaf39","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/syntax.styl","hash":"20df0f8a54729980094514fc726b51591ada1ad7","modified":1475281398000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/slider.styl","hash":"8933a67e92680dbdfd6af7c2ecaa8d86346df907","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/_partial/tablecontents.styl","hash":"7bbd7f34aae24b6af38fdd79ea3c85546d12eca4","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/images/side-user-cover.jpg","hash":"d8d73a64d6d5af83a27e6af1d4fedef808955ba0","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/lib/font-awesome.min.css","hash":"683d12731b7429d32ec7de00a6706602e403013f","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/lib/prettify-tomorrow-night-eighties.css","hash":"35e07bd7a4585363060edd558a0e9939e7e68323","modified":1472565716000},{"_id":"themes/raytaylorism/source/img/article_img/2016/Binder 工作机制.png","hash":"d147e10c24dc7e1f93292a742f32f634b3c952b8","modified":1481949073922},{"_id":"themes/raytaylorism/source/img/article_img/2016/Handler 消息机制.png","hash":"517d00041f1118d996e560a716a7c0083fd1dca8","modified":1483692824568},{"_id":"themes/raytaylorism/source/img/article_img/2016/Handler消息处理流程.png","hash":"15c9f3b74c4f02c21731adb6a619c969b8f3ac32","modified":1483700538985},{"_id":"themes/raytaylorism/source/img/article_img/2016/Scroller滑动机制.png","hash":"581ac5ff4ca88b69cf8aeaee3a22ce50e4a86156","modified":1481949052589},{"_id":"themes/raytaylorism/source/img/article_img/2016/View 中的scrollTo和scrollBy.png","hash":"566299fbf43a98a8b4c09fbe5bc7257418919896","modified":1481949065450},{"_id":"themes/raytaylorism/source/img/article_img/2016/activity异常重建.png","hash":"0ae3ce8c11c8bf681ce5d55bdcd308bb316c3942","modified":1478770615614},{"_id":"themes/raytaylorism/source/img/article_img/2016/collection_diagram.png","hash":"a1d272d57bdf600206cd7a20f7b27e74ab011d2a","modified":1479625150360},{"_id":"themes/raytaylorism/source/img/article_img/2016/fragment_and_activity_lifecycle.jpg","hash":"00c9cd5383f131a65bc1403b5fb7e76dc00a7a9a","modified":1478940389140},{"_id":"themes/raytaylorism/source/img/article_img/2016/hashmap.jpg","hash":"05538fa7587558e64f7d24271eda573f2f3f0070","modified":1469827988000},{"_id":"themes/raytaylorism/source/img/article_img/2016/map_diagram.png","hash":"75c21014f5c974bc7a0aa823a88401c8752390fb","modified":1479626687338},{"_id":"themes/raytaylorism/source/img/article_img/2016/object_state.png","hash":"15f0680d858a6d610619c3c4d7bb5c30b96371ff","modified":1479959397525},{"_id":"themes/raytaylorism/source/img/article_img/2016/view.png","hash":"7a6afb81ddcd0616107dc4730d732f380a29f589","modified":1479005849186},{"_id":"themes/raytaylorism/source/img/article_img/2016/view_zuobiao.png","hash":"75e8be4f28df4c580ceb82cfa11c531edfb56373","modified":1481948688327},{"_id":"themes/raytaylorism/source/img/article_img/2016/weakreference.png","hash":"0ace8486c78140b1fe1c69928968e505a3595253","modified":1479961014847},{"_id":"themes/raytaylorism/source/img/article_img/2016/对象内存分配1.png","hash":"61aaa13782cd86db39302fda2883dd8d3d964f01","modified":1479379109738},{"_id":"themes/raytaylorism/source/img/article_img/2016/数组内存分配5.png","hash":"c80d75d65023dd2fd00cb3cdea3d9933d3eb69a5","modified":1479372867451},{"_id":"themes/raytaylorism/source/img/article_img/TabLayout+ViewPager-create-tab_icon.gif","hash":"bdf2485ff5d03b126e828a80e613b521bd3b1b14","modified":1477123140729},{"_id":"themes/raytaylorism/source/css/font/font-awesome/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/font-awesome/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/font-awesome/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/font-awesome/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/lib/materialize.min.css","hash":"41d1676b73eec020eaeb9b507dcbcd30069ae8cb","modified":1472565716000},{"_id":"themes/raytaylorism/source/img/article_img/2016/activity生命周期.png","hash":"254cdf96faf2a0367bc4e8f87b4b85d2895dca8b","modified":1478665448144},{"_id":"themes/raytaylorism/source/img/article_img/2016/architucture.png","hash":"513ac60d19820eed8f30382ea862e936d21d996c","modified":1469827988000},{"_id":"themes/raytaylorism/source/img/article_img/2016/fragment-life.png","hash":"5fb1c2f6b58f13e9a45cf3e6d493883cd170c907","modified":1469827988000},{"_id":"themes/raytaylorism/source/img/article_img/2016/show_aar.png","hash":"f56d01f1006624264d638653061fc252a90650fa","modified":1478008489240},{"_id":"themes/raytaylorism/source/img/article_img/2016/对象内存分配2.png","hash":"2380a9c2f7fb67fbf0cae41cce5d9c039b6b05ee","modified":1479525571075},{"_id":"themes/raytaylorism/source/img/article_img/2016/数组内存分配1.png","hash":"f2dd91477ac54fbd2b31ca482fb35e9c66f15b7b","modified":1479371587688},{"_id":"themes/raytaylorism/source/img/article_img/2016/数组内存分配2.png","hash":"2de5f20e74395fb6f3a0da5e13187dc575d4af44","modified":1479371675206},{"_id":"themes/raytaylorism/source/img/article_img/2016/数组内存分配3.png","hash":"5e9d809fe2840bc49391d19587a0b364a066704c","modified":1479371631420},{"_id":"themes/raytaylorism/source/img/article_img/2016/数组内存分配4.png","hash":"5ff6a9989258e5369926a49ed6ed0f2262de6100","modified":1479371349286},{"_id":"themes/raytaylorism/source/css/font/font-awesome/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1482274322000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1472565716000},{"_id":"themes/raytaylorism/source/img/article_img/2016/algorithm.png","hash":"8040ddda187f9b96999d75f3fda3b46c25dbd7b8","modified":1469827988000},{"_id":"themes/raytaylorism/source/img/article_img/2016/collection.png","hash":"5cc8c2dd3c1e10316cca5bd26a1669862e0151e1","modified":1469827988000},{"_id":"themes/raytaylorism/source/img/article_img/2016/setvmintegerMax.png","hash":"fee0f168f9ee3befc76a982d5f5b0b87d198c047","modified":1480222952047},{"_id":"themes/raytaylorism/source/img/danjiangkoushi.jpg","hash":"2ad4ee26c239eb3756a8d64efccbf031da1379a9","modified":1461324134960},{"_id":"themes/raytaylorism/source/img/huatlib-2.jpg","hash":"570a6d6ae10da2da56222dc522e58236cc78bdcb","modified":1468551597753},{"_id":"themes/raytaylorism/source/css/_partial/font/font-awesome/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/font-awesome/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/font-awesome/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/font-awesome/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1472565716000},{"_id":"themes/raytaylorism/source/css/_partial/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1472565716000},{"_id":"themes/raytaylorism/source/img/article_img/2016/ide_show_class_diagram.png","hash":"c801d226a351085b4d285564973fd71421f74cfb","modified":1479628166677},{"_id":"source/settings/search.xml","hash":"edadae02245b6043d422be2fbaa91f7cf8023872","modified":1490371524559},{"_id":"themes/raytaylorism/source/css/_partial/font/font-awesome/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1472565716000},{"_id":"themes/raytaylorism/source/img/huatlib.jpg","hash":"08536b8191d597c887826be399074aae3b1389b5","modified":1461410882004},{"_id":"themes/raytaylorism/source/css/font/font-awesome/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1482274322000},{"_id":"themes/raytaylorism/source/img/article_img/bluetooth/ble-client.gif","hash":"9eb9fbfc0578a24510036d3baca58e8f551c54c1","modified":1471445410826},{"_id":"themes/raytaylorism/source/img/article_img/bluetooth/ble-server.gif","hash":"db9c019884313f66cfec80490310c3b2fd6537b6","modified":1471445793965},{"_id":"themes/raytaylorism/source/img/article_img/2016/http.png","hash":"e45f81f0f0af81e2ad7113e584ac8a2894818d28","modified":1469827988000},{"_id":"themes/raytaylorism/source/css/_partial/font/font-awesome/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1472565716000},{"_id":"themes/raytaylorism/source/img/article_img/2016/对象内存分配-debug.png","hash":"4870c51a2d5f89927641b3943546705d5337ae47","modified":1479462595883},{"_id":"themes/raytaylorism/source/img/head.jpg","hash":"ab4885679f50ae1b1611f6b369bd08fbd87520b3","modified":1486480725243},{"_id":"public/search.xml","hash":"f76963997929a459b5f6d4ad4356aa276269e5ef","modified":1490413716707},{"_id":"public/about/index.html","hash":"1cc67bedbc1b2c2a07bc9144623172f1a65b6c64","modified":1490413717180},{"_id":"public/reading/index.html","hash":"174ff9beabe8bc0443d4f91a63ba45413d44da0b","modified":1490413717180},{"_id":"public/settings/README.html","hash":"3915f09d1f0b5d3c43a8967b71f613e565089de1","modified":1490413717180},{"_id":"public/settings/baidu_verify_MSHxCKJSJ1.html","hash":"c0fd755d1a2e67c2e3082857d075b2813ea9ae9b","modified":1490413717180},{"_id":"public/2017/03/05/android 7.0-take-photo/index.html","hash":"edeaa789d5c957d8a48da9894aa041f8812340e8","modified":1490413717180},{"_id":"public/2017/01/11/Tomcat中配置单IP多二级域名方法/index.html","hash":"7e6d21932205706f1cbf70f8772f2c4ca83d48f9","modified":1490413717180},{"_id":"public/2017/01/06/AsyncTask 工作原理及线程池/index.html","hash":"969a08bafe01806398b0b5a2f4f8d1c1774a5e50","modified":1490413717180},{"_id":"public/2016/12/27/android 消息机制及其原理/index.html","hash":"4e6f33f1a2eff76ce99318924035a1fe7858b529","modified":1490413717180},{"_id":"public/2016/12/19/android 自定义View 详解/index.html","hash":"79d481a31c3d4f4cc040acaedd829e1d7559e469","modified":1490413717180},{"_id":"public/2016/12/17/Android View 的事件体系/index.html","hash":"941c693a85eee2c70c7cf1754f97736531e259df","modified":1490413717180},{"_id":"public/2016/12/14/android IPC 机制及进程通信/index.html","hash":"87a152d41d9d0ecfba11b00ab2933873183e7396","modified":1490413717180},{"_id":"public/2016/12/12/android  多渠道打包/index.html","hash":"7db3b2fbe614ddc6f07cd44ae666e09d75cc738a","modified":1490413717180},{"_id":"public/2016/11/27/java知识 之 Integer自动拆装箱与缓存/index.html","hash":"7f2b2b0fc583151f040663d8d383eac4ac8e9c3a","modified":1490413717180},{"_id":"public/2016/11/26/java 知识之 注解的使用和解析/index.html","hash":"34183d1639e32e805f3b3ccc9c3cd7217701ed03","modified":1490413717180},{"_id":"public/2016/11/25/java 知识之 反射的使用/index.html","hash":"a74eb52e66206b8c6884a3e02d79f3b188c15999","modified":1490413717180},{"_id":"public/2016/11/24/java 知识 之 内存管理/index.html","hash":"cc22c8bcefb8534d1dbf230587032ee15255f042","modified":1490413717180},{"_id":"public/2016/11/22/java 知识 之 常见java集合的实现细节/index.html","hash":"09689c9a30e6df5acde059d1b450aa78bff888c2","modified":1490413717180},{"_id":"public/2016/11/19/java 知识之 对象及其内存管理/index.html","hash":"cc9015401d76893e67b85a51f2513be09f6cb1d4","modified":1490413717180},{"_id":"public/2016/11/17/java 知识之 数组及其内存管理/index.html","hash":"7bea944df8019c4f5207eb76696744c0b8afa8be","modified":1490413717180},{"_id":"public/2016/11/08/activity 生命周期及调用栈详解/index.html","hash":"079b72d7dd0062f5254361d529c072b09fde8aa9","modified":1490413717180},{"_id":"public/2016/11/06/国内一线互联网公司内部面试题库(二)-android/index.html","hash":"7abbf94e97e712541c51be2de02fe326989a0c91","modified":1490413717180},{"_id":"public/2016/11/05/国内一线互联网公司内部面试题库(一)-java/index.html","hash":"d8d84189011f965a9f8260adcb65244cb007afec","modified":1490413717180},{"_id":"public/2016/10/23/天盾app项目总结/index.html","hash":"e6338dc41d979ba9bf45c84ad96550b7bae33b49","modified":1490413717180},{"_id":"public/2016/10/20/android studio 生成aar和jar/index.html","hash":"6d96857094d56a724526dec80f57073f1bb81b02","modified":1490413717180},{"_id":"public/2016/10/15/java 三大特性：封装、继承和多态/index.html","hash":"6333a3cc15fda74d8c5ce9aedd7526ad163dd1cf","modified":1490413717180},{"_id":"public/2016/09/24/Android Bluetooth 通信技术深入--聊天小应用/index.html","hash":"b0353bdfc40b4cb7cc22836f841389f466ea516e","modified":1490413717180},{"_id":"public/2016/09/20/Android Bluetooth 蓝牙技术初体验/index.html","hash":"877eddb8f337039dd51e87bb80c3aa8ad23a7f6b","modified":1490413717180},{"_id":"public/2016/09/10/using-DataBinding/index.html","hash":"066632ca97ea888a5ee65fb9afcea6ea5cbc185e","modified":1490413717180},{"_id":"public/2016/07/10/android-exception-catch-UncaughtExceptionHandler/index.html","hash":"0ff8136e9e4d53a5aa2a123aa512bd7a68ab7deb","modified":1490413717180},{"_id":"public/2016/06/12/android-open-source-connected/index.html","hash":"e5d05c32c6c87a3f4cfacf45e5544121aa435b8c","modified":1490413717180},{"_id":"public/2016/05/28/TabLayout+ViewPager create tab/index.html","hash":"a7c81c3cfc5e06b23fc7047abfb46db297bb99b4","modified":1490413717180},{"_id":"public/2016/04/25/Property-animatorValueAnimator_ObjectAnimation/index.html","hash":"5216fdad826305bb3105acd5e9c065f5a720edff","modified":1490413717180},{"_id":"public/2016/04/25/view-Animation/index.html","hash":"2c87cf61803248af5f1cafa5eb0ca28129f488d9","modified":1490413717180},{"_id":"public/2016/04/23/SwipeRefreshLayout-RecyclerView/index.html","hash":"17fb8ffe2e1a9365ed867ed14a4656424224f0a3","modified":1490413717180},{"_id":"public/2016/04/23/put-libary-to-jcenter/index.html","hash":"9f0c8ee36afac89d1fd40407d3a26951b592561a","modified":1490413717180},{"_id":"public/2016/04/23/listview-optimize/index.html","hash":"c015bb281382b7ab385882918d505a01aa7a77c2","modified":1490413717180},{"_id":"public/2016/04/23/erroe-of-offline-or-unauthorized/index.html","hash":"e1d641f054006e91d0046f3ac68087dc04254361","modified":1490413717180},{"_id":"public/2016/04/23/listView-in-scrollView/index.html","hash":"e6f7ad3ddd375596e6d5774b7a7639268c26963a","modified":1490413717180},{"_id":"public/2016/04/23/sum-up-2015/index.html","hash":"d7c7ea7f217b821be223ab26fe096e421c495d89","modified":1490413717180},{"_id":"public/2016/04/23/Eventbus-simple-use/index.html","hash":"9f74a7aea03338bfa9923b69c3d5fb03b8e69c3c","modified":1490413717180},{"_id":"public/2016/04/23/androidstudio-keaymap/index.html","hash":"d0211fe54bd13531bface46316aff7881d2bf37e","modified":1490413717180},{"_id":"public/2016/04/23/first-use-widget/index.html","hash":"cbe85a53e83cd0fc04bfeddc20fad6d6233b11f5","modified":1490413717180},{"_id":"public/2016/04/23/plsql-install-config/index.html","hash":"5c09934ffdda03fdb6c679785e889ead6b1bbede","modified":1490413717180},{"_id":"public/2016/04/23/excellent-blog-author-of-android/index.html","hash":"f470727f695c3b289fd480afb337980cc906ea94","modified":1490413717180},{"_id":"public/2016/04/23/PhotoView_GifView/index.html","hash":"ebfb8c4593a305cb526b347c5de6bacb63cc9a14","modified":1490413717180},{"_id":"public/2016/04/23/open-other-app/index.html","hash":"15cb68d8fcd13431381c7fa27dd9f5d246d9353f","modified":1490413717180},{"_id":"public/2016/04/23/auto-filin-smscode/index.html","hash":"422442fa9eb15dbbb97457f577c4c46c46036fe4","modified":1490413717180},{"_id":"public/2016/04/23/android-sqlite-notebook/index.html","hash":"8b6961b5be90f2731dd278ae87830cd7b03ea4cb","modified":1490413717180},{"_id":"public/2016/04/23/android-sqlite-use/index.html","hash":"d4279661723e96cba1913b823c767d1d212427c1","modified":1490413717180},{"_id":"public/2016/04/23/open-source/index.html","hash":"e84d6318fa145463641f24ec1c91b238bf999d44","modified":1490413717180},{"_id":"public/2016/04/23/open-source-frame/index.html","hash":"ff67b5803132ccdcdef16a8b8e978d800fda96d9","modified":1490413717180},{"_id":"public/2016/04/23/screen-adaptation-dp_sp/index.html","hash":"01423a9811227aad611683457dd5c34b12547eac","modified":1490413717180},{"_id":"public/2016/04/23/webview-Screen-adaptation/index.html","hash":"bbdbc0d115bb13fcff03a184083a8ea9f6a041c7","modified":1490413717180},{"_id":"public/2016/04/23/hexo- write-blog/index.html","hash":"6c48e1763376dcf1fc67e7b353646e77f4c57f95","modified":1490413717180},{"_id":"public/2016/04/20/hexo+github -build-my-blog/index.html","hash":"e9c494e898f893c8a58dd2283f4fd0e745127a32","modified":1490413717180},{"_id":"public/archives/index.html","hash":"0f0f15aadf5110376a6b24b1f7a3ee3fbdf2d7a0","modified":1490413717180},{"_id":"public/archives/2016/index.html","hash":"34ebcee43cb12c85512906252c8edc70c17a6850","modified":1490413717180},{"_id":"public/archives/2016/04/index.html","hash":"6edc6ddf8a0b5bf42045c737d3b9375d5f4ac759","modified":1490413717180},{"_id":"public/archives/2016/05/index.html","hash":"cc1d2bee7250412b086907508e5d23bc27523e29","modified":1490413717180},{"_id":"public/archives/2016/06/index.html","hash":"001d6e541fba68a64a341c283ef809e238493c3d","modified":1490413717180},{"_id":"public/archives/2016/07/index.html","hash":"9085dfb8391bdc119ac3b33c4f38e927245a5f6b","modified":1490413717180},{"_id":"public/archives/2016/09/index.html","hash":"7b3bf0f944eb6c39a0118e7300f87e64537c35a0","modified":1490413717180},{"_id":"public/archives/2016/10/index.html","hash":"47fd6550d7d000d31e2de582cc5c9abc43b57af7","modified":1490413717180},{"_id":"public/archives/2016/11/index.html","hash":"d542523d8455ace94db6448935c46311a3ba5605","modified":1490413717180},{"_id":"public/archives/2016/12/index.html","hash":"a8ab1f3d062fdd325b80b8b68a14456b631733c7","modified":1490413717180},{"_id":"public/archives/2017/index.html","hash":"bc8a73c525ba46b5d8c33b74d10a8f3efba026fb","modified":1490413717180},{"_id":"public/archives/2017/01/index.html","hash":"60a26d6089aeb646da46990357648beb70d648a0","modified":1490413717180},{"_id":"public/archives/2017/03/index.html","hash":"d5e66c6ad2894eb966f8dc59968533925180e20e","modified":1490413717180},{"_id":"public/categories/android/index.html","hash":"05ba1158e34a6d245b5121a166a2d341640a9991","modified":1490413717180},{"_id":"public/categories/android/学习笔记/index.html","hash":"bf8a9d44449303ded07b350f1876001babbc2927","modified":1490413717180},{"_id":"public/categories/后端/index.html","hash":"30aa23934ac51f90977bee26e283af7b319aeb66","modified":1490413717180},{"_id":"public/categories/android/开源库/index.html","hash":"38bc32c6fe827f0f645b87c272968879dbc90103","modified":1490413717180},{"_id":"public/categories/android/SQLit/index.html","hash":"1f9f2484dca180e6040078644b4d7afebfea88b3","modified":1490413717180},{"_id":"public/categories/工具软件/index.html","hash":"9cae340f4d44902eae218da0e684122d48ce99f8","modified":1490413717180},{"_id":"public/categories/后端/域名配置/index.html","hash":"78862938613650f3d511db502c4182a226ec3901","modified":1490413717180},{"_id":"public/categories/java/index.html","hash":"041cc2633d315d0e7f258d7933c4db48e639b111","modified":1490413717180},{"_id":"public/categories/工具软件/hexo/index.html","hash":"732b7f73a7a57159e19fa8fefee4af40d743cab4","modified":1490413717180},{"_id":"public/categories/工具软件/PL-SQL/index.html","hash":"455350f7562a866e15325cb472554195cc3bf9a9","modified":1490413717180},{"_id":"public/categories/java/基础知识/index.html","hash":"506ae8bf896c2450124eef7ce5298f9e79b081bf","modified":1490413717180},{"_id":"public/categories/java/高级知识/index.html","hash":"507d0dbddc433f21a10449cf4ae9713ec47e996b","modified":1490413717180},{"_id":"public/categories/面试/index.html","hash":"3b9b70dfcddf5eb09968ea75601e28562cc8e429","modified":1490413717180},{"_id":"public/categories/android/项目总结/index.html","hash":"a103ac7ca436124b59ecd5ad8391c7edd0ff8afa","modified":1490413717180},{"_id":"public/index.html","hash":"1c52de193f5dd27cffcd3db673c723a5cf24a364","modified":1490413717180},{"_id":"public/page/2/index.html","hash":"c426549ab43a82b258fbc29440f9386eeca29030","modified":1490413717180},{"_id":"public/page/3/index.html","hash":"5977f4e3821fd5f88777a3aa10f38606a4372727","modified":1490413717180},{"_id":"public/page/4/index.html","hash":"1ded11a59198308a54035615cd49659bc01acb20","modified":1490413717180},{"_id":"public/page/5/index.html","hash":"527ded8c1a74f2ff062e8c6e2411b5acb981293f","modified":1490413717180},{"_id":"public/page/6/index.html","hash":"2db8f7b74d309eb2bd7a97010146b01fdf99aafc","modified":1490413717180},{"_id":"public/tags/android/index.html","hash":"83e85bbf7738f73ff4177b28212daf9924a76523","modified":1490413717180},{"_id":"public/tags/蓝牙/index.html","hash":"aac4f8feacb71526ee9ef1c4bfd0567eaea20402","modified":1490413717180},{"_id":"public/tags/通信/index.html","hash":"977aba09de1a3461f1192156bd3ee4138b3029b1","modified":1490413717180},{"_id":"public/tags/聊天/index.html","hash":"0ec9bfd5ce8126fcb50db8e2d0a92bd07129442d","modified":1490413717180},{"_id":"public/tags/View/index.html","hash":"efb8ab8a146365998bb06228ba13724a5433217c","modified":1490413717180},{"_id":"public/tags/事件分发/index.html","hash":"b62ff725304cefc3f7d798890b1adaecb8fca719","modified":1490413717180},{"_id":"public/tags/滑动冲突/index.html","hash":"f59b5e949a4012505955ab71b52b367aed18c59f","modified":1490413717180},{"_id":"public/tags/AsyncTask/index.html","hash":"78d1553ddda49a3e8d3f977630422336591761cc","modified":1490413717180},{"_id":"public/tags/线程池/index.html","hash":"d6df4110ec1d1911765e9c4526668bd53decde84","modified":1490413717180},{"_id":"public/tags/Eventbus/index.html","hash":"b11512c2bd2849fb4c9be2edf5c09bc37800b87f","modified":1490413717180},{"_id":"public/tags/开源框架/index.html","hash":"67015f97d24b3a24581aa006784b70fb0bdd2e50","modified":1490413717180},{"_id":"public/tags/图片缩放/index.html","hash":"87b3ab258feb4d2a3918c85bd6d2d843b4fb36b1","modified":1490413717180},{"_id":"public/tags/gif/index.html","hash":"3f4ad5e080b1589c08aada92b83bca0985db67b6","modified":1490413717180},{"_id":"public/tags/Animator/index.html","hash":"edd2d7cf10afa125d06bd73a4cafdaead5d05fd0","modified":1490413717180},{"_id":"public/tags/属性动画/index.html","hash":"9fd4991aef5541034019cc18052a37c01c975730","modified":1490413717180},{"_id":"public/tags/5-X新特新/index.html","hash":"12ce098e0530100cbbd6fe343de746a5cd2d60c9","modified":1490413717180},{"_id":"public/tags/RecyclerView/index.html","hash":"cedb6b338ed6143345694f8da089299a70f0ada2","modified":1490413717180},{"_id":"public/tags/CardView/index.html","hash":"657d372ee59206871d63d2b169627dac8783e4b8","modified":1490413717180},{"_id":"public/tags/5-X新特性/index.html","hash":"5af27b0270dec0c40bdd77643db13726f7d7f4c5","modified":1490413717180},{"_id":"public/tags/TabLayout/index.html","hash":"a510b959f0eb3c5b0074666c4cdb67efcba549d7","modified":1490413717180},{"_id":"public/tags/tomcat/index.html","hash":"fa6ca4fd069f0a9db954fa6302a9cda0024a4a8e","modified":1490413717180},{"_id":"public/tags/域名解析/index.html","hash":"6069f0c48d92619f07edef6c68c001ad2a5736a0","modified":1490413717180},{"_id":"public/tags/二级域名/index.html","hash":"fbe3b0d50b964d5b9fc4846eec2a1a87c89a0608","modified":1490413717180},{"_id":"public/tags/Activity/index.html","hash":"30145ff6f009756c4310fadd70f7a1de14bf8ef7","modified":1490413717180},{"_id":"public/tags/生命周期/index.html","hash":"1351827994dbc9f298bfc901922f52e467182c75","modified":1490413717180},{"_id":"public/tags/多渠道打包/index.html","hash":"611ee60540b9861f07cbaf563afa838ef558db11","modified":1490413717180},{"_id":"public/tags/android7-0/index.html","hash":"84be09e133baf971f513b8e6cd040c3f1f784e05","modified":1490413717180},{"_id":"public/tags/拍照适配/index.html","hash":"556294aeb7e13f51fe7455591485a01769c49671","modified":1490413717180},{"_id":"public/tags/相册/index.html","hash":"ccaaf9c233f4711efe460c7fecdd8ea4822b1e37","modified":1490413717180},{"_id":"public/tags/IPC/index.html","hash":"a49eb9017e2a760fa2093ef0f5be70a4276ba297","modified":1490413717180},{"_id":"public/tags/AIDL/index.html","hash":"0711085545d5fa50fb72ebe3c4316d2415903720","modified":1490413717180},{"_id":"public/tags/进程通信/index.html","hash":"d8c10880524b3279b88324257dc439d23f34f85c","modified":1490413717180},{"_id":"public/tags/aar/index.html","hash":"31c0eb26de17e37136461f4eee83044f7880bce5","modified":1490413717180},{"_id":"public/tags/jar/index.html","hash":"32ff45dce76425e738ad20a86337e3790e80c51a","modified":1490413717180},{"_id":"public/tags/消息机制/index.html","hash":"c5e27f40577bbae88390b65ea2e7d0c5fa90de31","modified":1490413717180},{"_id":"public/tags/Handler/index.html","hash":"55a594be337f360a50acb643d20c50bbaef37766","modified":1490413717180},{"_id":"public/tags/自定义/index.html","hash":"f914a4e2b6e60435cf0fd5333f1c7d59d90152a6","modified":1490413717180},{"_id":"public/tags/原理/index.html","hash":"41349dadd6c3bc8793109a5592596ba24daad286","modified":1490413717180},{"_id":"public/tags/异常捕获/index.html","hash":"008511b8cf0e61d0caf5c501b2779909d14cca5e","modified":1490413717180},{"_id":"public/tags/SQLit/index.html","hash":"69e71717ea489d2903bd0c63eceae3b65d0be766","modified":1490413717180},{"_id":"public/tags/androidstudio/index.html","hash":"834ec055e0015b3a2365d4958be0d11c662a54ba","modified":1490413717180},{"_id":"public/tags/快捷键/index.html","hash":"340a4c1440a08d4b6db264c3fd74a2eaeed3ad39","modified":1490413717180},{"_id":"public/tags/验证码/index.html","hash":"84a1b5b6f3a892d533da3f47f9aa24a2ca299ce1","modified":1490413717180},{"_id":"public/tags/blog/index.html","hash":"68a7ac0331fd6c23565bf601ba5e23839b54d188","modified":1490413717180},{"_id":"public/tags/真机调试/index.html","hash":"34181c1003fe867d2b65c1047eae6e93a1666423","modified":1490413717195},{"_id":"public/tags/offline/index.html","hash":"434ec8c3b49243ee448d83195574914c5bc7318c","modified":1490413717195},{"_id":"public/tags/widget/index.html","hash":"cf611bb8df130ff392859128d02366cd7dd85d7c","modified":1490413717195},{"_id":"public/tags/软件/index.html","hash":"069b0c5dccb24945b341eaba53e6470d62dbfd04","modified":1490413717195},{"_id":"public/tags/gihub/index.html","hash":"33e35e54503ad21cdb4fd3a06fff3d0efe82dee1","modified":1490413717195},{"_id":"public/tags/hexo/index.html","hash":"c21a51bf4beec9260503f5f7b61f6077d68ac937","modified":1490413717195},{"_id":"public/tags/写博客/index.html","hash":"a5da8c0c84acfad9203a28410c58a12edee093a4","modified":1490413717195},{"_id":"public/tags/java/index.html","hash":"e9ea4d956bfa773fce83b21893a624a3675f3cf2","modified":1490413717195},{"_id":"public/tags/继承/index.html","hash":"d5afef3b85d49fd5ee7d70115342a1aed2539cd5","modified":1490413717195},{"_id":"public/tags/多态/index.html","hash":"dc4f478cba094c073c3f0506ce3639f6b3bcf810","modified":1490413717195},{"_id":"public/tags/内存回收/index.html","hash":"61bf720bfc64e6da16c4e98c300ea52766ef3127","modified":1490413717195},{"_id":"public/tags/集合/index.html","hash":"2af90100031f8a7bc626e1c01020f9881c285105","modified":1490413717195},{"_id":"public/tags/内存管理/index.html","hash":"c5531fc0e6548b2145adb94fee93e818ab3cda57","modified":1490413717195},{"_id":"public/tags/反射/index.html","hash":"0507dfbce44b87afe6dbcf2665f9a00a24b3480f","modified":1490413717195},{"_id":"public/tags/对象/index.html","hash":"6932dc5fb502506e964a10e824c4a5497851f806","modified":1490413717195},{"_id":"public/tags/数组/index.html","hash":"d15e0ee79db6ba79b64c5a112084f50b6175848a","modified":1490413717195},{"_id":"public/tags/注解/index.html","hash":"2eb0e027ed877cc94f3da0ec5951487ff29f3377","modified":1490413717195},{"_id":"public/tags/自定义注解/index.html","hash":"4e32c6a4b7ae75501bae25c99bb1a13e60d0cd6f","modified":1490413717195},{"_id":"public/tags/拆装箱/index.html","hash":"044fc434a56dde59bffe92d0f7ce36d3aaed50ed","modified":1490413717195},{"_id":"public/tags/Integer缓存/index.html","hash":"2b1d75378318217e2d9b95b529761362ae30b6c8","modified":1490413717195},{"_id":"public/tags/ScrollView/index.html","hash":"e0166dac0a4d41914729019af2ab510e15105e93","modified":1490413717195},{"_id":"public/tags/ListView/index.html","hash":"07f2d90506da1ec6449a43d487708f40eabf447a","modified":1490413717195},{"_id":"public/tags/Listview/index.html","hash":"ebd08de7cbcbce1572232eec3c839410e9d0998f","modified":1490413717195},{"_id":"public/tags/性能优化/index.html","hash":"c8d2f925bec4cc3860dbd2b0572eab35d7e4c188","modified":1490413717195},{"_id":"public/tags/打开应用/index.html","hash":"5de3033cc2c791a944c27ab5967ceeea03ddbacc","modified":1490413717195},{"_id":"public/tags/oracle/index.html","hash":"831300769197d8b3f9f7aba8b859e56b009b5dcc","modified":1490413717195},{"_id":"public/tags/PL-SQL/index.html","hash":"df460e58764218085d3865212c5acc1baa50e888","modified":1490413717195},{"_id":"public/tags/gradle/index.html","hash":"a3e727a87f4a877fa8bf557c351e580ba58c8a30","modified":1490413717195},{"_id":"public/tags/jcenter/index.html","hash":"0f0624f41cec66159bfd6358db059108e36d71a7","modified":1490413717195},{"_id":"public/tags/屏幕适配/index.html","hash":"df5666228e1102ed38c4310550c24dcbb7d02960","modified":1490413717195},{"_id":"public/tags/学习路线/index.html","hash":"b679a2abf7723c75342f54310f98b18392361786","modified":1490413717195},{"_id":"public/tags/总结/index.html","hash":"bb98e14405a007286cae83de479661b7d46eba35","modified":1490413717195},{"_id":"public/tags/DataBinding/index.html","hash":"92227c9ca1c9fdcdfb7139ea870bc50228715df2","modified":1490413717195},{"_id":"public/tags/数据绑定/index.html","hash":"3dcc85c932cf392184ae2446d9e284cfeaf5a6d5","modified":1490413717195},{"_id":"public/tags/Animation/index.html","hash":"de6101b6b713195dc0519d0cb1ac5a9d3632c1b4","modified":1490413717195},{"_id":"public/tags/动画/index.html","hash":"f54090914226b043fdb5484c8acf5529947a29bd","modified":1490413717195},{"_id":"public/tags/webview/index.html","hash":"262313ebe2e54b8d3fcbff0e5cee7ef3f760366f","modified":1490413717195},{"_id":"public/tags/面试/index.html","hash":"141df030662ba90bd16481d580998e6d464b0a64","modified":1490413717195},{"_id":"public/tags/拍照oom/index.html","hash":"f6e2b04133b62976ee97c60af59afa9908391751","modified":1490413717195},{"_id":"public/tags/图片错位/index.html","hash":"3eb5cee399b84c3fb4b4777cff1b19fac92658e6","modified":1490413717195},{"_id":"public/tags/xutils3/index.html","hash":"d0d8b3ebbc43557443c6c4cbe15259229858e0cb","modified":1490413717195},{"_id":"public/settings/CNAME","hash":"1264284dae49c8fe88b8b85350ad8847b0857671","modified":1490413717445},{"_id":"public/favicon.png","hash":"67227b713abcedb34172ad15fbe1b8c76e337ac2","modified":1490413717445},{"_id":"public/favicon-0.png","hash":"5962feb23035fd72f8bcebd02f11fa3fd3431612","modified":1490413717445},{"_id":"public/weixin_favicon.png","hash":"4a8466bd7d8cf4753cab8fb68647b40b91a246ad","modified":1490413717445},{"_id":"public/img/diyihangdaima.jpg","hash":"1e1b2fc1148f41515bad16744895282c856d5593","modified":1490413717445},{"_id":"public/img/qunyingzhuan.jpg","hash":"a8d0ab7568b8b27c2ace38dcb4cf70213c675288","modified":1490413717445},{"_id":"public/img/yisutansuo.jpg","hash":"5cca726aa52594bac5da3e7c6f072190acb14b42","modified":1490413717445},{"_id":"public/img/yuanmashejimoshi.jpg","hash":"99b1e8948b8ce48904615e405f4f7d38595bc828","modified":1490413717445},{"_id":"public/css/images/side-user-cover.jpg","hash":"d8d73a64d6d5af83a27e6af1d4fedef808955ba0","modified":1490413717445},{"_id":"public/img/article_img/AnimatorSet.gif","hash":"403975d8a5438c240efb1696af822609eb78ff95","modified":1490413717445},{"_id":"public/img/article_img/Interpolator-resource-id.png","hash":"fdc07317bc9e32f50b1ded4f8b193abbd108c2fe","modified":1490413717445},{"_id":"public/img/article_img/Interpolator.jpg","hash":"a16df621389f83c4f4c5ae8d4513c812bb2e4a37","modified":1490413717445},{"_id":"public/img/article_img/TabLayout+ViewPager-create-tab.gif","hash":"8d26b2c4d6d9f3b43d22e1d149e23d0a7fe8befe","modified":1490413717445},{"_id":"public/img/article_img/ValueAnimator-simple-demo.gif","hash":"0218020756f8740cbbf5e26dff87963a1cc71e1a","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1490413717445},{"_id":"public/css/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1490413717445},{"_id":"public/img/article_img/2016/Binder 工作机制.png","hash":"d147e10c24dc7e1f93292a742f32f634b3c952b8","modified":1490413717445},{"_id":"public/img/article_img/2016/Handler 消息机制.png","hash":"517d00041f1118d996e560a716a7c0083fd1dca8","modified":1490413717445},{"_id":"public/img/article_img/2016/Handler消息处理流程.png","hash":"15c9f3b74c4f02c21731adb6a619c969b8f3ac32","modified":1490413717445},{"_id":"public/img/article_img/2016/Scroller滑动机制.png","hash":"581ac5ff4ca88b69cf8aeaee3a22ce50e4a86156","modified":1490413717445},{"_id":"public/img/article_img/2016/View 中的scrollTo和scrollBy.png","hash":"566299fbf43a98a8b4c09fbe5bc7257418919896","modified":1490413717445},{"_id":"public/img/article_img/2016/activity异常重建.png","hash":"0ae3ce8c11c8bf681ce5d55bdcd308bb316c3942","modified":1490413717445},{"_id":"public/img/article_img/2016/collection_diagram.png","hash":"a1d272d57bdf600206cd7a20f7b27e74ab011d2a","modified":1490413717445},{"_id":"public/img/article_img/2016/hashmap.jpg","hash":"05538fa7587558e64f7d24271eda573f2f3f0070","modified":1490413717445},{"_id":"public/img/article_img/2016/fragment_and_activity_lifecycle.jpg","hash":"00c9cd5383f131a65bc1403b5fb7e76dc00a7a9a","modified":1490413717445},{"_id":"public/img/article_img/2016/object_state.png","hash":"15f0680d858a6d610619c3c4d7bb5c30b96371ff","modified":1490413717445},{"_id":"public/img/article_img/2016/view.png","hash":"7a6afb81ddcd0616107dc4730d732f380a29f589","modified":1490413717445},{"_id":"public/img/article_img/2016/map_diagram.png","hash":"75c21014f5c974bc7a0aa823a88401c8752390fb","modified":1490413717445},{"_id":"public/img/article_img/2016/view_zuobiao.png","hash":"75e8be4f28df4c580ceb82cfa11c531edfb56373","modified":1490413717445},{"_id":"public/img/article_img/2016/weakreference.png","hash":"0ace8486c78140b1fe1c69928968e505a3595253","modified":1490413717445},{"_id":"public/img/article_img/2016/对象内存分配1.png","hash":"61aaa13782cd86db39302fda2883dd8d3d964f01","modified":1490413717445},{"_id":"public/img/article_img/2016/数组内存分配5.png","hash":"c80d75d65023dd2fd00cb3cdea3d9933d3eb69a5","modified":1490413717445},{"_id":"public/img/quanweizhilan.jpg","hash":"2f0de334e2ab72084afc7a89ce8ead319b2fa2a1","modified":1490413718466},{"_id":"public/img/weixin.jpg","hash":"0d08966c80e76cb886a57fd87b2ffd26aa3e7d99","modified":1490413718482},{"_id":"public/img/wudangshan.jpg","hash":"29a7bc40de361d8a0ed3d3be1ece41e962ff2c27","modified":1490413718482},{"_id":"public/img/yafalu.jpg","hash":"1e0fc9e198fbfefe9cedffa24fb262f972291515","modified":1490413718482},{"_id":"public/img/zhifubao.jpg","hash":"c725317ba494b8efcc23329482e90234ca6289e0","modified":1490413718482},{"_id":"public/css/font/font-awesome/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1490413718482},{"_id":"public/css/font/font-awesome/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1490413718482},{"_id":"public/css/font/font-awesome/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1490413718482},{"_id":"public/css/font/font-awesome/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1490413718482},{"_id":"public/css/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1490413718482},{"_id":"public/css/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1490413718482},{"_id":"public/css/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1490413718482},{"_id":"public/css/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1490413718482},{"_id":"public/img/article_img/2016/activity生命周期.png","hash":"254cdf96faf2a0367bc4e8f87b4b85d2895dca8b","modified":1490413718482},{"_id":"public/img/article_img/2016/architucture.png","hash":"513ac60d19820eed8f30382ea862e936d21d996c","modified":1490413718482},{"_id":"public/img/article_img/2016/fragment-life.png","hash":"5fb1c2f6b58f13e9a45cf3e6d493883cd170c907","modified":1490413718497},{"_id":"public/img/article_img/2016/show_aar.png","hash":"f56d01f1006624264d638653061fc252a90650fa","modified":1490413718497},{"_id":"public/img/article_img/2016/对象内存分配2.png","hash":"2380a9c2f7fb67fbf0cae41cce5d9c039b6b05ee","modified":1490413718497},{"_id":"public/img/article_img/2016/数组内存分配1.png","hash":"f2dd91477ac54fbd2b31ca482fb35e9c66f15b7b","modified":1490413718497},{"_id":"public/img/article_img/2016/数组内存分配2.png","hash":"2de5f20e74395fb6f3a0da5e13187dc575d4af44","modified":1490413718497},{"_id":"public/img/article_img/2016/数组内存分配3.png","hash":"5e9d809fe2840bc49391d19587a0b364a066704c","modified":1490413718497},{"_id":"public/img/article_img/2016/数组内存分配4.png","hash":"5ff6a9989258e5369926a49ed6ed0f2262de6100","modified":1490413718497},{"_id":"public/js/prettify.js","hash":"d24b1da342b5c2d0582f0922118aaf0b2a6840d5","modified":1490413718513},{"_id":"public/css/lib/prettify-tomorrow-night-eighties.css","hash":"35e07bd7a4585363060edd558a0e9939e7e68323","modified":1490413718513},{"_id":"public/css/style.css","hash":"73f363c91a93324f298aa8d2184600d06e27a1d5","modified":1490413718513},{"_id":"public/css/lib/font-awesome.min.css","hash":"683d12731b7429d32ec7de00a6706602e403013f","modified":1490413718513},{"_id":"public/js/jquery.min.js","hash":"69bb69e25ca7d5ef0935317584e6153f3fd9a88c","modified":1490413718513},{"_id":"public/js/materialize.min.js","hash":"c9308fbe808a149aa11061af40a4be5f391cccee","modified":1490413718513},{"_id":"public/css/lib/materialize.min.css","hash":"41d1676b73eec020eaeb9b507dcbcd30069ae8cb","modified":1490413718513},{"_id":"public/img/fengkuangjiangyi.jpg","hash":"22a6f6be5bc03c52e25cf91cb5cd6396ca4efe95","modified":1490413718513},{"_id":"public/img/article_img/TabLayout+ViewPager-create-tab_icon.gif","hash":"bdf2485ff5d03b126e828a80e613b521bd3b1b14","modified":1490413718513},{"_id":"public/css/font/font-awesome/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1490413718513},{"_id":"public/img/article_img/2016/algorithm.png","hash":"8040ddda187f9b96999d75f3fda3b46c25dbd7b8","modified":1490413718513},{"_id":"public/img/article_img/2016/collection.png","hash":"5cc8c2dd3c1e10316cca5bd26a1669862e0151e1","modified":1490413718513},{"_id":"public/img/article_img/2016/setvmintegerMax.png","hash":"fee0f168f9ee3befc76a982d5f5b0b87d198c047","modified":1490413718513},{"_id":"public/img/article_img/2016/ide_show_class_diagram.png","hash":"c801d226a351085b4d285564973fd71421f74cfb","modified":1490413718529},{"_id":"public/css/font/font-awesome/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1490413718669},{"_id":"public/img/article_img/bluetooth/ble-client.gif","hash":"9eb9fbfc0578a24510036d3baca58e8f551c54c1","modified":1490413718669},{"_id":"public/img/article_img/bluetooth/ble-server.gif","hash":"db9c019884313f66cfec80490310c3b2fd6537b6","modified":1490413718669},{"_id":"public/img/danjiangkoushi.jpg","hash":"2ad4ee26c239eb3756a8d64efccbf031da1379a9","modified":1490413718919},{"_id":"public/img/huatlib-2.jpg","hash":"570a6d6ae10da2da56222dc522e58236cc78bdcb","modified":1490413718919},{"_id":"public/settings/android-engineer-resume-imtianx.pdf","hash":"ab473974671cb37204c339af5cc3b829ef8b5722","modified":1490413718919},{"_id":"public/img/article_img/2016/http.png","hash":"e45f81f0f0af81e2ad7113e584ac8a2894818d28","modified":1490413721208},{"_id":"public/img/huatlib.jpg","hash":"08536b8191d597c887826be399074aae3b1389b5","modified":1490413721474},{"_id":"public/settings/search.xml","hash":"edadae02245b6043d422be2fbaa91f7cf8023872","modified":1490413721833},{"_id":"public/img/article_img/2016/对象内存分配-debug.png","hash":"4870c51a2d5f89927641b3943546705d5337ae47","modified":1490413722980},{"_id":"public/img/head.jpg","hash":"ab4885679f50ae1b1611f6b369bd08fbd87520b3","modified":1490413723089}],"Category":[{"name":"android","_id":"cj0opucef0005g0g5j0xbgnni"},{"name":"学习笔记","parent":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucfa000jg0g53m971q29"},{"name":"后端","_id":"cj0opuchw0027g0g5d9d9iall"},{"name":"开源库","parent":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucib002fg0g5y207so8l"},{"name":"SQLit","parent":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucib002lg0g5ysge362j"},{"name":"工具软件","_id":"cj0opucir0030g0g5p6g1kgmc"},{"name":"域名配置","parent":"cj0opuchw0027g0g5d9d9iall","_id":"cj0opucj7003fg0g5tyc3ldz6"},{"name":"java","_id":"cj0opucjm003ng0g5371zqwog"},{"name":"hexo","parent":"cj0opucir0030g0g5p6g1kgmc","_id":"cj0opuckh0052g0g556s0hga9"},{"name":"PL/SQL","parent":"cj0opucir0030g0g5p6g1kgmc","_id":"cj0opuckx005dg0g545mnom1u"},{"name":"基础知识","parent":"cj0opucjm003ng0g5371zqwog","_id":"cj0opuckx005kg0g52dl8gca1"},{"name":"高级知识","parent":"cj0opucjm003ng0g5371zqwog","_id":"cj0opuckx005qg0g5m9ibkixz"},{"name":"面试","_id":"cj0opuckx005yg0g5fhk34np8"},{"name":"项目总结","parent":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckx006dg0g5yukldigr"}],"Data":[{"_id":"111slider","data":[{"image":"/img/huatlib.jpg","align":"center","title":"湖北汽车工业学院--逸夫图书馆","subtitle":"全国唯一一所以汽车命名的全日制普通本科高等院校","link":null},{"image":"/img/wudangshan.jpg","align":"left","title":"道教圣地，武当山","subtitle":"世界文化遗产地之一，国家重点风景名胜区，5A级景区。","link":null},{"image":"/img/danjiangkoushi.jpg","align":"right","title":"中国水都，丹江口","subtitle":"南水北调中线工程核心水源地，被誉为‘亚洲天池’","link":null}]},{"_id":"about","data":{"avatar":"/img/head.jpg","name":"imtianx","tag":"java/android/移动开发","desc":"java，android，移动开发，技术宅","skills":{"android":7,"java":7,"C/C++":5,"Kotlin":4,"":-1,"Python":3,"oracle/mysql":4,"html/css":5,"PHP":3,"Git":4},"projects":[{"name":"完成的项目1","image":"https://o1wh05aeh.qnssl.com/image/view/app_icons/ff8557e5ab297f94eb2760a18a2f3c4e/120","tags":["2016年5月","车辆监管"],"description":"为武汉南斗六星系统集成有限公司开发的一款app,主要是车辆信息查询、不在线车辆查询，在途和在库车辆信息的查询等","link_text":"内测平台","link":"https://www.pgyer.com/P0go"},{"name":"完成的项目2","image":"https://o1wh05aeh.qnssl.com/image/view/app_icons/abe95244d7711b01c4e37c3592bf7e13/120","description":"十堰韵达物流公司同城配送app,司机端为app。主要功能：司机端对货主发布的货物进行竞标，选中的标书进行配送及相关状态的报告等，此外还可以参与客运等。","tags":["2016年7月","八匹马新版"],"link_text":"内测平台","link":"https://www.pgyer.com/nT2B"},{"name":"完成的项目3","image":"https://o1wh05aeh.qnssl.com/image/view/app_icons/e00bf29ff55e131785dd8c1dab5b8cf5/120","description":"为市邮管局开发的快递实名app,该版本为快递员版，主要功能：省份证识别，快递单识别，拍照存储及数据上传。","tags":["2016年9月","天盾（快递实名）"],"link_text":"内测平台","link":"https://www.pgyer.com/ygjexpress"}],"reward":["/img/weixin.jpg","/img/zhifubao.jpg"]}},{"_id":"link","data":{"social":{"github":"https://github.com/imtianx","weibo":"http://weibo.com/imtianx"},"extern":{"android开发技术周报":"http://androidweekly.cn/","android官网":"http://developer.android.com/index.html","掘金":"http://gold.xitu.io/","androidcat":"http://androidcat.com/","简书":"http://www.jianshu.com/","CSDN":"http://www.csdn.net/","泡在网上的日子":"http://www.jcodecraeer.com/","翻墙SSBetter":"http://t.cn/Rij9p4Y","Kictto":"http://blog.kictto.tech/"}}},{"_id":"hint","data":{"new":{"selector":[]}}},{"_id":"reading","data":{"define":{"readed":"已读","reading":"在读","wanted":"想读"},"contents":{"readed":[{"title":"疯狂 android讲义 ","cover":"/img/fengkuangjiangyi.jpg","review":"书很厚，但内容很丰富，3.0版的是基于sdk5.0的，很适合初学者。","doubanLink":"/"},{"title":"第一行代码","cover":"/img/diyihangdaima.jpg","review":"内容很实用，讲的很详细，作者的博客也讲的很好","doubanLink":"/"},{"title":"android编程权威指南","cover":"/img/quanweizhilan.jpg","review":"一本翻译国外的书，内容丰富，正本书围绕几个小项目展开，便于学习。","doubanLink":"/"},{"title":"android 群英传","cover":"/img/qunyingzhuan.jpg","review":"进阶类的书籍，需要一定的基础，","doubanLink":"/"},{"title":"大话重构","cover":"https://img1.doubanio.com/lpic/s27246379.jpg","review":"软件开发中重构的技巧","doubanLink":"https://book.douban.com/subject/25853677/"}],"reading":[{"title":"android 开发艺术探索","cover":"/img/yisutansuo.jpg","review":"进阶类书籍，就个人而言，很难懂，大都从源码角度讲解，很详细","doubanLink":"/"},{"title":"疯狂Java程序员的基本修养","cover":"https://img3.doubanio.com/lpic/s24960574.jpg","review":"java进阶类书籍","doubanLink":"https://book.douban.com/subject/20471013/"},{"title":"App研发录","cover":"/img/yafalu.jpg","review":"","doubanLink":"/"}],"wanted":[{"title":"android 源码设计模式","cover":"/img/yuanmashejimoshi.jpg","review":"讲解设计模式在android源码中的应用","doubanLink":"/"},{"title":"第二行代码","cover":"https://img3.doubanio.com/lpic/s29152261.jpg","review":"android开发书籍","doubanLink":"https://book.douban.com/subject/26915433/"}]}}}],"Page":[{"title":"关于","layout":"about","_content":"大家好，我是imtianx。欢迎来到我的个人技术博客。\n\n作为一个搞技术的，不断地学习是必不可少的。然而，不管什么技术，如果学习完不使用，很快就会忘记，所以，及时的做笔记十分重要。在此，搭建自己的个人博客，记录自己的成长过程。欢迎与我交流哦！\n**联系方式**：\nQQ : <a target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3&uin=764275613&site=qq&menu=yes\" alt=\"点击这里给我发消息\">764275613</a>\nemail ：<a href=\"Mailto:imtianx@163.com\">imtianx@163.com</a> \n","source":"about/index.md","raw":"title: 关于\nlayout: about\n---\n大家好，我是imtianx。欢迎来到我的个人技术博客。\n\n作为一个搞技术的，不断地学习是必不可少的。然而，不管什么技术，如果学习完不使用，很快就会忘记，所以，及时的做笔记十分重要。在此，搭建自己的个人博客，记录自己的成长过程。欢迎与我交流哦！\n**联系方式**：\nQQ : <a target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3&uin=764275613&site=qq&menu=yes\" alt=\"点击这里给我发消息\">764275613</a>\nemail ：<a href=\"Mailto:imtianx@163.com\">imtianx@163.com</a> \n","date":"2017-02-07T15:46:03.521Z","updated":"2017-02-07T15:46:03.521Z","path":"about/index.html","comments":1,"_id":"cj0opucdz0000g0g52tov85t1","content":"<p>大家好，我是imtianx。欢迎来到我的个人技术博客。</p>\n<p>作为一个搞技术的，不断地学习是必不可少的。然而，不管什么技术，如果学习完不使用，很快就会忘记，所以，及时的做笔记十分重要。在此，搭建自己的个人博客，记录自己的成长过程。欢迎与我交流哦！<br><strong>联系方式</strong>：<br>QQ : <a target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3&uin=764275613&site=qq&menu=yes\" alt=\"点击这里给我发消息\">764275613</a><br>email ：<a href=\"Mailto:imtianx@163.com\" target=\"_blank\" rel=\"external\">imtianx@163.com</a> </p>\n","excerpt":"","more":"<p>大家好，我是imtianx。欢迎来到我的个人技术博客。</p>\n<p>作为一个搞技术的，不断地学习是必不可少的。然而，不管什么技术，如果学习完不使用，很快就会忘记，所以，及时的做笔记十分重要。在此，搭建自己的个人博客，记录自己的成长过程。欢迎与我交流哦！<br><strong>联系方式</strong>：<br>QQ : <a target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3&uin=764275613&site=qq&menu=yes\" alt=\"点击这里给我发消息\">764275613</a><br>email ：<a href=\"Mailto:imtianx@163.com\">imtianx@163.com</a> </p>\n"},{"title":"读书","layout":"reading","_content":"","source":"reading/index.md","raw":"title: 读书\nlayout: reading\n---\n","date":"2016-04-04T14:27:45.400Z","updated":"2016-04-04T14:27:45.400Z","path":"reading/index.html","comments":1,"_id":"cj0opucdz0002g0g50e5864j6","content":"","excerpt":"","more":""},{"_content":"[个人博客主页](http://imtianx.cn/)\n<br><br>绑定域名:<br>\n    新建CNAME 文件，在里面写上自己的域名;<br>\n    登陆到自己的域名解析控制台，添加解析类型 “CNAME” ，“记录值”为“your_githubname.github.io”<br>\n    例如：我的github用户名为：imtianx,则记录值为：imtianx.github.io\n\t对于配置二级域名，也是同样的。\n","source":"settings/README.md","raw":"[个人博客主页](http://imtianx.cn/)\n<br><br>绑定域名:<br>\n    新建CNAME 文件，在里面写上自己的域名;<br>\n    登陆到自己的域名解析控制台，添加解析类型 “CNAME” ，“记录值”为“your_githubname.github.io”<br>\n    例如：我的github用户名为：imtianx,则记录值为：imtianx.github.io\n\t对于配置二级域名，也是同样的。\n","date":"2017-03-24T16:05:21.768Z","updated":"2017-03-24T16:05:21.768Z","path":"settings/README.html","title":"","comments":1,"layout":"page","_id":"cj0opucef0006g0g54zaozaj6","content":"<p><a href=\"http://imtianx.cn/\">个人博客主页</a><br><br><br>绑定域名:<br><br>    新建CNAME 文件，在里面写上自己的域名;<br><br>    登陆到自己的域名解析控制台，添加解析类型 “CNAME” ，“记录值”为“your_githubname.github.io”<br><br>    例如：我的github用户名为：imtianx,则记录值为：imtianx.github.io<br>    对于配置二级域名，也是同样的。</p>\n","excerpt":"","more":"<p><a href=\"http://imtianx.cn/\">个人博客主页</a><br><br><br>绑定域名:<br><br>    新建CNAME 文件，在里面写上自己的域名;<br><br>    登陆到自己的域名解析控制台，添加解析类型 “CNAME” ，“记录值”为“your_githubname.github.io”<br><br>    例如：我的github用户名为：imtianx,则记录值为：imtianx.github.io<br>    对于配置二级域名，也是同样的。</p>\n"},{"_content":"MSHxCKJSJ1","source":"settings/baidu_verify_MSHxCKJSJ1.html","raw":"MSHxCKJSJ1","date":"2017-03-24T16:05:22.661Z","updated":"2017-03-24T16:05:22.661Z","path":"settings/baidu_verify_MSHxCKJSJ1.html","title":"","comments":1,"layout":"page","_id":"cj0opucef0008g0g5sfbqph70","content":"MSHxCKJSJ1","excerpt":"","more":"MSHxCKJSJ1"}],"Post":[{"title":"Android Bluetooth 蓝牙技术初体验","date":"2016-09-20T08:06:25.000Z","_content":"\n\n转自：[http://www.jb51.net/article/79334.htm](http://www.jb51.net/article/79334.htm)\n\n### 1.Bluetooth包简介\nAndroid平台提供了一个android.bluetooth的包，里面实现蓝牙设备之间通信的蓝牙API。总共有8个类，常用的四个类如下:\n**BluetoothAdapter类**\n代表了一个本地的蓝牙适配器。它是所有蓝牙交互的入口点。利用它你可以发现其他蓝牙设备，查询绑定了的设备，使用已知的MAC地址实例化一个蓝牙设备和建立一个BluetoothServerSocket（作为服务器端）来监听来自其他设备的连接。<!--more-->\n**BluetoothDevice类**\n代表了一个远端的蓝牙设备，使用它请求远端蓝牙设备连接或者获取远端蓝牙设备的名称、地址、种类和绑定状态（其信息是封装在BluetoothSocket中）。\n**BluetoothSocket类**\n代表了一个蓝牙套接字的接口（类似于TCP中的套接字），它是应用程序通过输入、输出流与其他蓝牙设备通信的连接点。\n**BlueboothServerSocket类**\n代表打开服务连接来监听可能到来的连接请求（属于server端），为了连接两个蓝牙设备必须有一个设备作为服务器打开一个服务套接字。当远端设备发起连接连接请求的时候，并且已经连接到了的时候，BlueboothServerSocket类将会返回一个BluetoothSocket。\n\n### 2.常用类的使用\n**BluetoothAdapter：蓝牙适配器**\n> cancelDiscovery()取消探索，当我们正在搜索设备的时候调用这个方法将不再继续搜索\ndisable()关闭蓝牙\nenable()打开蓝牙，这个方法打开蓝牙不会弹出提示，更多的时候我们需要问下用户是否打开，以下两行代码同样是打开蓝牙，但会提示用户：\nIntentenabler = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);\nstartActivity(enabler);\ngetAddress()获取本地蓝牙地址\ngetDefaultAdapter()获取默认BluetoothAdapter，实际上，也只有这一种方法获取BluetoothAdapter\ngetName()获取本地蓝牙名称\ngetRemoteDevice(String address)根据蓝牙地址获取远程蓝牙设备\ngetState()获取本地蓝牙适配器当前状态\nisDiscovering()判断当前是否正在查找设备，是则返回true\nisEnabled()判断蓝牙是否打开，已打开返回true，否则返回false\nlistenUsingRfcommWithServiceRecord(String name,UUID uuid)根据名称，UUID创建并返回BluetoothServerSocket，这是创建BluetoothSocket服务器端的第一步\nstartDiscovery()开始搜索，这是搜索的第一步\n\n**BluetoothDevice：远程蓝牙设备**\n> createRfcommSocketToServiceRecord(UUIDuuid)根据UUID创建并返回一个BluetoothSocket，这个方法也是我们获取BluetoothDevice\n的目的——创建BluetoothSocket\n这个类其他的方法，如getAddress()、getName()等，同BluetoothAdapter。\n\n**BluetoothSocket：客户端**\n> //这个类一共有6个方法\nclose()关闭\nconnect()连接\nisConnected()判断是否连接\ngetInptuStream()获取输入流\ngetOutputStream()获取输出流\ngetRemoteDevice()获取BluetoothSocket指定连接的远程蓝牙设备\n\n**BluetoothServerSocket：服务端**\n> //这个类一共有4个方法\naccept()\naccept(int timeout)\nclose()关闭\ngetChannel()返回这个套接字绑定的通道\n\n### 3.数据传输\n**蓝牙数据传输——服务器端**\n> 、获得BluetoothAdapter。 \n2、通过BluetoothAdapter.listenUsingRfcommWithServiceRecord(name,UUID uuid)方法创建BluetoothServerSocket对象。 \n3、通过luetoothServerSocket.accept()方法返回一个BluetoothSocket对象。由于该方法处于阻塞状态，需要开启线程来处理。 \n4、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。 \n5、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。\n\n**蓝牙数据传输——客户端**\n> 1、获得BluetoothAdapter。 \n2、通过BluetoothAdapter.getRemoteDevice(String address)获得指定地址的BluetoothDevice对象。 \n3、通过BluetoothDevice.createRfcommSocketToServiceRecord (UUID uuid)方法创建BluetoothSocket对象。 \n4、通过BluetoothSocket.connect（）方法来连接蓝牙设备。 \n5、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。 \n6、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。\n\n需要的权限：\n```\n<uses-permissionandroid:name=\"android.permission.BLUETOOTH_ADMIN\" />\n<uses-permissionandroid:name=\"android.permission.BLUETOOTH\" />\n```\n\n\n\n\n","source":"_posts/Android Bluetooth 蓝牙技术初体验.md","raw":"\n---\ntitle: Android Bluetooth 蓝牙技术初体验\ndate: 2016-09-20 16:06:25\ncategories: [android,学习笔记]\ntags: [android,蓝牙,通信]\n---\n\n\n转自：[http://www.jb51.net/article/79334.htm](http://www.jb51.net/article/79334.htm)\n\n### 1.Bluetooth包简介\nAndroid平台提供了一个android.bluetooth的包，里面实现蓝牙设备之间通信的蓝牙API。总共有8个类，常用的四个类如下:\n**BluetoothAdapter类**\n代表了一个本地的蓝牙适配器。它是所有蓝牙交互的入口点。利用它你可以发现其他蓝牙设备，查询绑定了的设备，使用已知的MAC地址实例化一个蓝牙设备和建立一个BluetoothServerSocket（作为服务器端）来监听来自其他设备的连接。<!--more-->\n**BluetoothDevice类**\n代表了一个远端的蓝牙设备，使用它请求远端蓝牙设备连接或者获取远端蓝牙设备的名称、地址、种类和绑定状态（其信息是封装在BluetoothSocket中）。\n**BluetoothSocket类**\n代表了一个蓝牙套接字的接口（类似于TCP中的套接字），它是应用程序通过输入、输出流与其他蓝牙设备通信的连接点。\n**BlueboothServerSocket类**\n代表打开服务连接来监听可能到来的连接请求（属于server端），为了连接两个蓝牙设备必须有一个设备作为服务器打开一个服务套接字。当远端设备发起连接连接请求的时候，并且已经连接到了的时候，BlueboothServerSocket类将会返回一个BluetoothSocket。\n\n### 2.常用类的使用\n**BluetoothAdapter：蓝牙适配器**\n> cancelDiscovery()取消探索，当我们正在搜索设备的时候调用这个方法将不再继续搜索\ndisable()关闭蓝牙\nenable()打开蓝牙，这个方法打开蓝牙不会弹出提示，更多的时候我们需要问下用户是否打开，以下两行代码同样是打开蓝牙，但会提示用户：\nIntentenabler = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);\nstartActivity(enabler);\ngetAddress()获取本地蓝牙地址\ngetDefaultAdapter()获取默认BluetoothAdapter，实际上，也只有这一种方法获取BluetoothAdapter\ngetName()获取本地蓝牙名称\ngetRemoteDevice(String address)根据蓝牙地址获取远程蓝牙设备\ngetState()获取本地蓝牙适配器当前状态\nisDiscovering()判断当前是否正在查找设备，是则返回true\nisEnabled()判断蓝牙是否打开，已打开返回true，否则返回false\nlistenUsingRfcommWithServiceRecord(String name,UUID uuid)根据名称，UUID创建并返回BluetoothServerSocket，这是创建BluetoothSocket服务器端的第一步\nstartDiscovery()开始搜索，这是搜索的第一步\n\n**BluetoothDevice：远程蓝牙设备**\n> createRfcommSocketToServiceRecord(UUIDuuid)根据UUID创建并返回一个BluetoothSocket，这个方法也是我们获取BluetoothDevice\n的目的——创建BluetoothSocket\n这个类其他的方法，如getAddress()、getName()等，同BluetoothAdapter。\n\n**BluetoothSocket：客户端**\n> //这个类一共有6个方法\nclose()关闭\nconnect()连接\nisConnected()判断是否连接\ngetInptuStream()获取输入流\ngetOutputStream()获取输出流\ngetRemoteDevice()获取BluetoothSocket指定连接的远程蓝牙设备\n\n**BluetoothServerSocket：服务端**\n> //这个类一共有4个方法\naccept()\naccept(int timeout)\nclose()关闭\ngetChannel()返回这个套接字绑定的通道\n\n### 3.数据传输\n**蓝牙数据传输——服务器端**\n> 、获得BluetoothAdapter。 \n2、通过BluetoothAdapter.listenUsingRfcommWithServiceRecord(name,UUID uuid)方法创建BluetoothServerSocket对象。 \n3、通过luetoothServerSocket.accept()方法返回一个BluetoothSocket对象。由于该方法处于阻塞状态，需要开启线程来处理。 \n4、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。 \n5、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。\n\n**蓝牙数据传输——客户端**\n> 1、获得BluetoothAdapter。 \n2、通过BluetoothAdapter.getRemoteDevice(String address)获得指定地址的BluetoothDevice对象。 \n3、通过BluetoothDevice.createRfcommSocketToServiceRecord (UUID uuid)方法创建BluetoothSocket对象。 \n4、通过BluetoothSocket.connect（）方法来连接蓝牙设备。 \n5、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。 \n6、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。\n\n需要的权限：\n```\n<uses-permissionandroid:name=\"android.permission.BLUETOOTH_ADMIN\" />\n<uses-permissionandroid:name=\"android.permission.BLUETOOTH\" />\n```\n\n\n\n\n","slug":"Android Bluetooth 蓝牙技术初体验","published":1,"updated":"2016-10-07T14:17:02.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucdz0001g0g51a3vla5g","content":"<p>转自：<a href=\"http://www.jb51.net/article/79334.htm\" target=\"_blank\" rel=\"external\">http://www.jb51.net/article/79334.htm</a></p>\n<h3 id=\"1-Bluetooth包简介\"><a href=\"#1-Bluetooth包简介\" class=\"headerlink\" title=\"1.Bluetooth包简介\"></a>1.Bluetooth包简介</h3><p>Android平台提供了一个android.bluetooth的包，里面实现蓝牙设备之间通信的蓝牙API。总共有8个类，常用的四个类如下:<br><strong>BluetoothAdapter类</strong><br>代表了一个本地的蓝牙适配器。它是所有蓝牙交互的入口点。利用它你可以发现其他蓝牙设备，查询绑定了的设备，使用已知的MAC地址实例化一个蓝牙设备和建立一个BluetoothServerSocket（作为服务器端）来监听来自其他设备的连接。<a id=\"more\"></a><br><strong>BluetoothDevice类</strong><br>代表了一个远端的蓝牙设备，使用它请求远端蓝牙设备连接或者获取远端蓝牙设备的名称、地址、种类和绑定状态（其信息是封装在BluetoothSocket中）。<br><strong>BluetoothSocket类</strong><br>代表了一个蓝牙套接字的接口（类似于TCP中的套接字），它是应用程序通过输入、输出流与其他蓝牙设备通信的连接点。<br><strong>BlueboothServerSocket类</strong><br>代表打开服务连接来监听可能到来的连接请求（属于server端），为了连接两个蓝牙设备必须有一个设备作为服务器打开一个服务套接字。当远端设备发起连接连接请求的时候，并且已经连接到了的时候，BlueboothServerSocket类将会返回一个BluetoothSocket。</p>\n<h3 id=\"2-常用类的使用\"><a href=\"#2-常用类的使用\" class=\"headerlink\" title=\"2.常用类的使用\"></a>2.常用类的使用</h3><p><strong>BluetoothAdapter：蓝牙适配器</strong></p>\n<blockquote>\n<p>cancelDiscovery()取消探索，当我们正在搜索设备的时候调用这个方法将不再继续搜索<br>disable()关闭蓝牙<br>enable()打开蓝牙，这个方法打开蓝牙不会弹出提示，更多的时候我们需要问下用户是否打开，以下两行代码同样是打开蓝牙，但会提示用户：<br>Intentenabler = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);<br>startActivity(enabler);<br>getAddress()获取本地蓝牙地址<br>getDefaultAdapter()获取默认BluetoothAdapter，实际上，也只有这一种方法获取BluetoothAdapter<br>getName()获取本地蓝牙名称<br>getRemoteDevice(String address)根据蓝牙地址获取远程蓝牙设备<br>getState()获取本地蓝牙适配器当前状态<br>isDiscovering()判断当前是否正在查找设备，是则返回true<br>isEnabled()判断蓝牙是否打开，已打开返回true，否则返回false<br>listenUsingRfcommWithServiceRecord(String name,UUID uuid)根据名称，UUID创建并返回BluetoothServerSocket，这是创建BluetoothSocket服务器端的第一步<br>startDiscovery()开始搜索，这是搜索的第一步</p>\n</blockquote>\n<p><strong>BluetoothDevice：远程蓝牙设备</strong></p>\n<blockquote>\n<p>createRfcommSocketToServiceRecord(UUIDuuid)根据UUID创建并返回一个BluetoothSocket，这个方法也是我们获取BluetoothDevice<br>的目的——创建BluetoothSocket<br>这个类其他的方法，如getAddress()、getName()等，同BluetoothAdapter。</p>\n</blockquote>\n<p><strong>BluetoothSocket：客户端</strong></p>\n<blockquote>\n<p>//这个类一共有6个方法<br>close()关闭<br>connect()连接<br>isConnected()判断是否连接<br>getInptuStream()获取输入流<br>getOutputStream()获取输出流<br>getRemoteDevice()获取BluetoothSocket指定连接的远程蓝牙设备</p>\n</blockquote>\n<p><strong>BluetoothServerSocket：服务端</strong></p>\n<blockquote>\n<p>//这个类一共有4个方法<br>accept()<br>accept(int timeout)<br>close()关闭<br>getChannel()返回这个套接字绑定的通道</p>\n</blockquote>\n<h3 id=\"3-数据传输\"><a href=\"#3-数据传输\" class=\"headerlink\" title=\"3.数据传输\"></a>3.数据传输</h3><p><strong>蓝牙数据传输——服务器端</strong></p>\n<blockquote>\n<p>、获得BluetoothAdapter。<br>2、通过BluetoothAdapter.listenUsingRfcommWithServiceRecord(name,UUID uuid)方法创建BluetoothServerSocket对象。<br>3、通过luetoothServerSocket.accept()方法返回一个BluetoothSocket对象。由于该方法处于阻塞状态，需要开启线程来处理。<br>4、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。<br>5、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。</p>\n</blockquote>\n<p><strong>蓝牙数据传输——客户端</strong></p>\n<blockquote>\n<p>1、获得BluetoothAdapter。<br>2、通过BluetoothAdapter.getRemoteDevice(String address)获得指定地址的BluetoothDevice对象。<br>3、通过BluetoothDevice.createRfcommSocketToServiceRecord (UUID uuid)方法创建BluetoothSocket对象。<br>4、通过BluetoothSocket.connect（）方法来连接蓝牙设备。<br>5、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。<br>6、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。</p>\n</blockquote>\n<p>需要的权限：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permissionandroid:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;</span><br><span class=\"line\">&lt;uses-permissionandroid:name=&quot;android.permission.BLUETOOTH&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<p>转自：<a href=\"http://www.jb51.net/article/79334.htm\">http://www.jb51.net/article/79334.htm</a></p>\n<h3 id=\"1-Bluetooth包简介\"><a href=\"#1-Bluetooth包简介\" class=\"headerlink\" title=\"1.Bluetooth包简介\"></a>1.Bluetooth包简介</h3><p>Android平台提供了一个android.bluetooth的包，里面实现蓝牙设备之间通信的蓝牙API。总共有8个类，常用的四个类如下:<br><strong>BluetoothAdapter类</strong><br>代表了一个本地的蓝牙适配器。它是所有蓝牙交互的入口点。利用它你可以发现其他蓝牙设备，查询绑定了的设备，使用已知的MAC地址实例化一个蓝牙设备和建立一个BluetoothServerSocket（作为服务器端）来监听来自其他设备的连接。","more":"<br><strong>BluetoothDevice类</strong><br>代表了一个远端的蓝牙设备，使用它请求远端蓝牙设备连接或者获取远端蓝牙设备的名称、地址、种类和绑定状态（其信息是封装在BluetoothSocket中）。<br><strong>BluetoothSocket类</strong><br>代表了一个蓝牙套接字的接口（类似于TCP中的套接字），它是应用程序通过输入、输出流与其他蓝牙设备通信的连接点。<br><strong>BlueboothServerSocket类</strong><br>代表打开服务连接来监听可能到来的连接请求（属于server端），为了连接两个蓝牙设备必须有一个设备作为服务器打开一个服务套接字。当远端设备发起连接连接请求的时候，并且已经连接到了的时候，BlueboothServerSocket类将会返回一个BluetoothSocket。</p>\n<h3 id=\"2-常用类的使用\"><a href=\"#2-常用类的使用\" class=\"headerlink\" title=\"2.常用类的使用\"></a>2.常用类的使用</h3><p><strong>BluetoothAdapter：蓝牙适配器</strong></p>\n<blockquote>\n<p>cancelDiscovery()取消探索，当我们正在搜索设备的时候调用这个方法将不再继续搜索<br>disable()关闭蓝牙<br>enable()打开蓝牙，这个方法打开蓝牙不会弹出提示，更多的时候我们需要问下用户是否打开，以下两行代码同样是打开蓝牙，但会提示用户：<br>Intentenabler = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);<br>startActivity(enabler);<br>getAddress()获取本地蓝牙地址<br>getDefaultAdapter()获取默认BluetoothAdapter，实际上，也只有这一种方法获取BluetoothAdapter<br>getName()获取本地蓝牙名称<br>getRemoteDevice(String address)根据蓝牙地址获取远程蓝牙设备<br>getState()获取本地蓝牙适配器当前状态<br>isDiscovering()判断当前是否正在查找设备，是则返回true<br>isEnabled()判断蓝牙是否打开，已打开返回true，否则返回false<br>listenUsingRfcommWithServiceRecord(String name,UUID uuid)根据名称，UUID创建并返回BluetoothServerSocket，这是创建BluetoothSocket服务器端的第一步<br>startDiscovery()开始搜索，这是搜索的第一步</p>\n</blockquote>\n<p><strong>BluetoothDevice：远程蓝牙设备</strong></p>\n<blockquote>\n<p>createRfcommSocketToServiceRecord(UUIDuuid)根据UUID创建并返回一个BluetoothSocket，这个方法也是我们获取BluetoothDevice<br>的目的——创建BluetoothSocket<br>这个类其他的方法，如getAddress()、getName()等，同BluetoothAdapter。</p>\n</blockquote>\n<p><strong>BluetoothSocket：客户端</strong></p>\n<blockquote>\n<p>//这个类一共有6个方法<br>close()关闭<br>connect()连接<br>isConnected()判断是否连接<br>getInptuStream()获取输入流<br>getOutputStream()获取输出流<br>getRemoteDevice()获取BluetoothSocket指定连接的远程蓝牙设备</p>\n</blockquote>\n<p><strong>BluetoothServerSocket：服务端</strong></p>\n<blockquote>\n<p>//这个类一共有4个方法<br>accept()<br>accept(int timeout)<br>close()关闭<br>getChannel()返回这个套接字绑定的通道</p>\n</blockquote>\n<h3 id=\"3-数据传输\"><a href=\"#3-数据传输\" class=\"headerlink\" title=\"3.数据传输\"></a>3.数据传输</h3><p><strong>蓝牙数据传输——服务器端</strong></p>\n<blockquote>\n<p>、获得BluetoothAdapter。<br>2、通过BluetoothAdapter.listenUsingRfcommWithServiceRecord(name,UUID uuid)方法创建BluetoothServerSocket对象。<br>3、通过luetoothServerSocket.accept()方法返回一个BluetoothSocket对象。由于该方法处于阻塞状态，需要开启线程来处理。<br>4、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。<br>5、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。</p>\n</blockquote>\n<p><strong>蓝牙数据传输——客户端</strong></p>\n<blockquote>\n<p>1、获得BluetoothAdapter。<br>2、通过BluetoothAdapter.getRemoteDevice(String address)获得指定地址的BluetoothDevice对象。<br>3、通过BluetoothDevice.createRfcommSocketToServiceRecord (UUID uuid)方法创建BluetoothSocket对象。<br>4、通过BluetoothSocket.connect（）方法来连接蓝牙设备。<br>5、通过BluetoothSocket.getInputStream（）和BluetoothSocket.getOutputStream（）方法获得读写数据的InputStream和OutputStream对象。<br>6、通过InputStream.read()方法来读数据。通过OutputStream.write（）方法来写数据。</p>\n</blockquote>\n<p>需要的权限：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permissionandroid:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;</span><br><span class=\"line\">&lt;uses-permissionandroid:name=&quot;android.permission.BLUETOOTH&quot; /&gt;</span><br></pre></td></tr></table></figure></p>"},{"title":"Android Bluetooth 通信技术深入--聊天小应用","date":"2016-09-24T08:06:25.000Z","_content":"目前，市场上的大部分手机都带有蓝牙，尽管使用的不多，但作为开发者，我们还有必要了解其原理。最近的项目需要用到蓝牙技术，于是写了个 蓝牙的聊天小demo。\n### 1. 效果示意图\n这里需要两部手机进行测试。其中一部作为蓝牙服务器，另一部作为蓝牙客户端，进行通信。<!--more-->\n客户端截图：\n![client](/img/article_img/bluetooth/ble-client.gif)\n服务器截图：\n![server](/img/article_img/bluetooth/ble-server.gif)\n\n### 2.开发步骤\n 1. 开启蓝牙；\n 2. 搜索蓝牙设备；\n 3. 创建蓝牙socket，读取输出流；\n 4. 读取和写入数据；\n 5. 关闭连接和蓝牙。\n\n### 3.具体的实现\n\n#### 3.1 开启蓝牙\n首先获取蓝牙适配器，若存在蓝牙未开则打开蓝牙，如下代码：\n```\nBluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\n        if (mBluetoothAdapter == null) {\n            Toast.makeText(getActivity(), \"无蓝牙功能\", Toast.LENGTH_SHORT).show();\n        } else {\n            if (!mBluetoothAdapter.isEnabled()) {\n                Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);\n                startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);\n            }\n        }\n```\n\n#### 3.2 搜索蓝牙\n首先开启蓝牙搜索功能，然后通过注册广播，搜索蓝牙设备，搜索完成后将其加入到蓝牙列表。\n搜索蓝牙：\n```\nif (mBluetoothAdapter.isDiscovering()) {\n    mBluetoothAdapter.cancelDiscovery();\n    mBtnStartSearch.setText(\"重新搜索\");\n} else {\n    mDatas.clear();\n    mAdapter.notifyDataSetChanged();\n    //添加设备信息到列表\n    init();\n}\nmBluetoothAdapter.startDiscovery();\nmBtnStartSearch.setText(\"ֹͣ停止搜索\");\n```\n注册蓝牙广播：\n\n```\n/**\n     * 搜索设备广播\n     */\nprivate final BroadcastReceiver mReceiver = new BroadcastReceiver() {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n\n        if (BluetoothDevice.ACTION_FOUND.equals(action)) {\n            // 获得设备信息\n            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);\n            // 绑定的状态不一样则进行添加\n            if (device.getBondState() != BluetoothDevice.BOND_BONDED) {\n                mDatas.add(new BtInfo(device.getName(), device.getAddress(), false));\n                mAdapter.notifyDataSetChanged();\n                mListView.setSelection(mDatas.size() - 1);\n            }\n            // 搜索完成\n        } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) {\n            if (mListView.getCount() == 0) {\n                Toast.makeText(context, \"没有发现设备！\", Toast.LENGTH_SHORT).show();\n            }\n            mBtnStartSearch.setText(\"重新搜索\");\n        }\n\n    }\n};\n\n /**\n * 注册广播\n */\nprivate void registerBroadcast() {\n    //设备被发现广播\n    IntentFilter discoveryFilter = new IntentFilter(BluetoothDevice.ACTION_FOUND);\n    getActivity().registerReceiver(mReceiver, discoveryFilter);\n\n    // 设备发现完成\n    IntentFilter foundFilter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);\n    getActivity().registerReceiver(mReceiver, foundFilter);\n}\n```\n\n#### 3.3 连接蓝牙设备\n这里，使用listview展示蓝牙列表信息，item 的点击事件即为连接相应的蓝牙设备，点击某一项后跳转到会话页面，并通知他刷新信息，为方便，这里使用了EventBus来订阅事件，避免使用接口，如下listview 的item 的点击事件：\n```\n//列表item设置监听，\nmListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n    @Override\n    public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {\n        BtInfo info = mDatas.get(i);\n        //好友mac地址\n        MainActivity.FRIEND_MAC_ADDRESS = info.getAddress();\n        //显示提示对话框\n        final AlertDialog.Builder dialog = new AlertDialog.Builder(getActivity());\n        dialog.setTitle(\"连接\");\n        dialog.setMessage(\"名称：\" + info.getName() + \"\\n\" + \"地址：\" + info.getAddress());\n        dialog.setPositiveButton(\"连接\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                mBluetoothAdapter.cancelDiscovery();\n                mBtnStartSearch.setText(\"重新搜索\");\n\n                //连接后，跳转到会话页面\n                MainActivity.mType = MainActivity.Type.CILENT;\n                //viewPager 显示第二页\n                MainActivity.mViewPager.setCurrentItem(1);\n                //通知 ChatListFragment 刷新信息\n                EventBus.getDefault().post(new EventMsg(1));\n\n                dialogInterface.dismiss();\n\n            }\n        });\n        dialog.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                MainActivity.FRIEND_MAC_ADDRESS = \"\";\n                dialogInterface.dismiss();\n\n            }\n        });\n        dialog.show();\n    }\n});\n```\n#### 3.4 创建蓝牙socket\n由于socketd的操作会阻塞线程，这里在子线程中进行创建。\n`BluetoothSocket` 客户端线程：\n```\n// 客户端线程\nprivate class ClientThread extends Thread {\n    public void run() {\n        try {\n            mSocket = mDevice.createRfcommSocketToServiceRecord(UUID.fromString(\"00001101-0000-1000-8000-00805F9B34FB\"));\n            Message msg = new Message();\n            msg.obj = \"请稍候，正在连接服务器:\" + MainActivity.FRIEND_MAC_ADDRESS;\n            msg.what = STATUS_CONNECT;\n            mHandler.sendMessage(msg);\n\n            mSocket.connect();\n\n            msg = new Message();\n            msg.obj = \"已经连接上服务端！可以发送信息。\";\n            msg.what = STATUS_CONNECT_SUCCESS;\n            mHandler.sendMessage(msg);\n            // 启动接受数据\n            mReadThread = new ReadThread();\n            mReadThread.start();\n        } catch (IOException e) {\n            Message msg = new Message();\n            msg.obj = \"连接服务端异常！断开连接重新试一试。\";\n            msg.what = STATUS_CONNECT_SUCCESS;\n            mHandler.sendMessage(msg);\n        }\n    }\n}\n```\n创建蓝牙连接时需要用到`UUID`,如需查看更多UUID，请点击[这里](http://blog.csdn.net/txadf/article/details/52235851)。\n`BluetoothServerSocket`蓝牙服务端socket线程：\n```\n // 服务器端线程\nprivate class ServerThread extends Thread {\n    public void run() {\n        try {\n            // 创建一个蓝牙服务器 参数分别：服务器名称、UUID\n            mServerSocket = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(\"btserver\",\n                    UUID.fromString(\"00001101-0000-1000-8000-00805F9B34FB\"));\n\n            Message msg = new Message();\n            msg.obj = \"请稍候，正在等待客户端的连接...\";\n            msg.what = STATUS_CONNECT;\n            mHandler.sendMessage(msg);\n\n\t\t\t/* 接受客户端的连接请求 */\n            mSocket = mServerSocket.accept();\n\n            msg = new Message();\n            msg.obj = \"客户端已经连接上！可以发送信息。\";\n            msg.what = STATUS_CONNECT;\n            mHandler.sendMessage(msg);\n            // 启动接受数据\n            mReadThread = new ReadThread();\n            mReadThread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n启动蓝牙客户端和服务端线程方法如下(详情参见[类]()的`onEventMainThread`方法)：\n```\nif (MainActivity.mType == MainActivity.Type.CILENT) {\n    String address = MainActivity.FRIEND_MAC_ADDRESS;//蓝牙地址\n    if (!TextUtils.isEmpty(address)) {\n        mDevice = mBluetoothAdapter.getRemoteDevice(address);\n        mClientThread = new ClientThread();\n        mClientThread.start();\n        MainActivity.isOpen = true;\n    } else {\n        Toast.makeText(getActivity(), \"address is null !\", Toast.LENGTH_SHORT).show();\n    }\n} else if (MainActivity.mType == MainActivity.Type.SERVER) {\n    mServerThread = new ServerThread();\n    mServerThread.start();\n    MainActivity.isOpen = true;\n}\n```\n#### 3.5 读取和写入数据\n这里主要是通过获取输入输出流来读取和发送数据，以读取数据为例，如下现读取数据线程代码：\n```\n// 读取数据\nprivate class ReadThread extends Thread {\n    public void run() {\n        byte[] buffer = new byte[1024];\n        int bytes;\n        InputStream is = null;\n        try {\n            is = mSocket.getInputStream();\n            while (true) {\n                if ((bytes = is.read(buffer)) > 0) {\n                    byte[] buf_data = new byte[bytes];\n                    for (int i = 0; i < bytes; i++) {\n                        buf_data[i] = buffer[i];\n                    }\n                    String s = new String(buf_data);\n                    Message msg = new Message();\n                    msg.obj = s;\n                    msg.what = 1;\n                    mHandler.sendMessage(msg);\n                }\n            }\n        } catch (IOException e1) {\n            e1.printStackTrace();\n        } finally {\n            try {\n                is.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n        }\n    }\n}\n```\n发送消息与此类似，具体请参见 会话类 []()。\n#### 3.6 关闭连接\n主要是关闭各个线程和关闭socket。\n\n\n至此，整个蓝牙同信已经完成，测试时需要两个手机，一个座位服务器，一个作为客户端，实现他们间的通信。\n\n[示例demo下载](https://github.com/imtianx/StudyDemoForAndroid/blob/master/A05-bluetoothchatdemo)\n\n\n\n\n\n\n","source":"_posts/Android Bluetooth 通信技术深入--聊天小应用.md","raw":"---\ntitle: Android Bluetooth 通信技术深入--聊天小应用\ndate: 2016-09-24 16:06:25\ncategories: [android,学习笔记]\ntags: [android,蓝牙,聊天]\n---\n目前，市场上的大部分手机都带有蓝牙，尽管使用的不多，但作为开发者，我们还有必要了解其原理。最近的项目需要用到蓝牙技术，于是写了个 蓝牙的聊天小demo。\n### 1. 效果示意图\n这里需要两部手机进行测试。其中一部作为蓝牙服务器，另一部作为蓝牙客户端，进行通信。<!--more-->\n客户端截图：\n![client](/img/article_img/bluetooth/ble-client.gif)\n服务器截图：\n![server](/img/article_img/bluetooth/ble-server.gif)\n\n### 2.开发步骤\n 1. 开启蓝牙；\n 2. 搜索蓝牙设备；\n 3. 创建蓝牙socket，读取输出流；\n 4. 读取和写入数据；\n 5. 关闭连接和蓝牙。\n\n### 3.具体的实现\n\n#### 3.1 开启蓝牙\n首先获取蓝牙适配器，若存在蓝牙未开则打开蓝牙，如下代码：\n```\nBluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\n        if (mBluetoothAdapter == null) {\n            Toast.makeText(getActivity(), \"无蓝牙功能\", Toast.LENGTH_SHORT).show();\n        } else {\n            if (!mBluetoothAdapter.isEnabled()) {\n                Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);\n                startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);\n            }\n        }\n```\n\n#### 3.2 搜索蓝牙\n首先开启蓝牙搜索功能，然后通过注册广播，搜索蓝牙设备，搜索完成后将其加入到蓝牙列表。\n搜索蓝牙：\n```\nif (mBluetoothAdapter.isDiscovering()) {\n    mBluetoothAdapter.cancelDiscovery();\n    mBtnStartSearch.setText(\"重新搜索\");\n} else {\n    mDatas.clear();\n    mAdapter.notifyDataSetChanged();\n    //添加设备信息到列表\n    init();\n}\nmBluetoothAdapter.startDiscovery();\nmBtnStartSearch.setText(\"ֹͣ停止搜索\");\n```\n注册蓝牙广播：\n\n```\n/**\n     * 搜索设备广播\n     */\nprivate final BroadcastReceiver mReceiver = new BroadcastReceiver() {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n\n        if (BluetoothDevice.ACTION_FOUND.equals(action)) {\n            // 获得设备信息\n            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);\n            // 绑定的状态不一样则进行添加\n            if (device.getBondState() != BluetoothDevice.BOND_BONDED) {\n                mDatas.add(new BtInfo(device.getName(), device.getAddress(), false));\n                mAdapter.notifyDataSetChanged();\n                mListView.setSelection(mDatas.size() - 1);\n            }\n            // 搜索完成\n        } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) {\n            if (mListView.getCount() == 0) {\n                Toast.makeText(context, \"没有发现设备！\", Toast.LENGTH_SHORT).show();\n            }\n            mBtnStartSearch.setText(\"重新搜索\");\n        }\n\n    }\n};\n\n /**\n * 注册广播\n */\nprivate void registerBroadcast() {\n    //设备被发现广播\n    IntentFilter discoveryFilter = new IntentFilter(BluetoothDevice.ACTION_FOUND);\n    getActivity().registerReceiver(mReceiver, discoveryFilter);\n\n    // 设备发现完成\n    IntentFilter foundFilter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);\n    getActivity().registerReceiver(mReceiver, foundFilter);\n}\n```\n\n#### 3.3 连接蓝牙设备\n这里，使用listview展示蓝牙列表信息，item 的点击事件即为连接相应的蓝牙设备，点击某一项后跳转到会话页面，并通知他刷新信息，为方便，这里使用了EventBus来订阅事件，避免使用接口，如下listview 的item 的点击事件：\n```\n//列表item设置监听，\nmListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n    @Override\n    public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {\n        BtInfo info = mDatas.get(i);\n        //好友mac地址\n        MainActivity.FRIEND_MAC_ADDRESS = info.getAddress();\n        //显示提示对话框\n        final AlertDialog.Builder dialog = new AlertDialog.Builder(getActivity());\n        dialog.setTitle(\"连接\");\n        dialog.setMessage(\"名称：\" + info.getName() + \"\\n\" + \"地址：\" + info.getAddress());\n        dialog.setPositiveButton(\"连接\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                mBluetoothAdapter.cancelDiscovery();\n                mBtnStartSearch.setText(\"重新搜索\");\n\n                //连接后，跳转到会话页面\n                MainActivity.mType = MainActivity.Type.CILENT;\n                //viewPager 显示第二页\n                MainActivity.mViewPager.setCurrentItem(1);\n                //通知 ChatListFragment 刷新信息\n                EventBus.getDefault().post(new EventMsg(1));\n\n                dialogInterface.dismiss();\n\n            }\n        });\n        dialog.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialogInterface, int i) {\n                MainActivity.FRIEND_MAC_ADDRESS = \"\";\n                dialogInterface.dismiss();\n\n            }\n        });\n        dialog.show();\n    }\n});\n```\n#### 3.4 创建蓝牙socket\n由于socketd的操作会阻塞线程，这里在子线程中进行创建。\n`BluetoothSocket` 客户端线程：\n```\n// 客户端线程\nprivate class ClientThread extends Thread {\n    public void run() {\n        try {\n            mSocket = mDevice.createRfcommSocketToServiceRecord(UUID.fromString(\"00001101-0000-1000-8000-00805F9B34FB\"));\n            Message msg = new Message();\n            msg.obj = \"请稍候，正在连接服务器:\" + MainActivity.FRIEND_MAC_ADDRESS;\n            msg.what = STATUS_CONNECT;\n            mHandler.sendMessage(msg);\n\n            mSocket.connect();\n\n            msg = new Message();\n            msg.obj = \"已经连接上服务端！可以发送信息。\";\n            msg.what = STATUS_CONNECT_SUCCESS;\n            mHandler.sendMessage(msg);\n            // 启动接受数据\n            mReadThread = new ReadThread();\n            mReadThread.start();\n        } catch (IOException e) {\n            Message msg = new Message();\n            msg.obj = \"连接服务端异常！断开连接重新试一试。\";\n            msg.what = STATUS_CONNECT_SUCCESS;\n            mHandler.sendMessage(msg);\n        }\n    }\n}\n```\n创建蓝牙连接时需要用到`UUID`,如需查看更多UUID，请点击[这里](http://blog.csdn.net/txadf/article/details/52235851)。\n`BluetoothServerSocket`蓝牙服务端socket线程：\n```\n // 服务器端线程\nprivate class ServerThread extends Thread {\n    public void run() {\n        try {\n            // 创建一个蓝牙服务器 参数分别：服务器名称、UUID\n            mServerSocket = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(\"btserver\",\n                    UUID.fromString(\"00001101-0000-1000-8000-00805F9B34FB\"));\n\n            Message msg = new Message();\n            msg.obj = \"请稍候，正在等待客户端的连接...\";\n            msg.what = STATUS_CONNECT;\n            mHandler.sendMessage(msg);\n\n\t\t\t/* 接受客户端的连接请求 */\n            mSocket = mServerSocket.accept();\n\n            msg = new Message();\n            msg.obj = \"客户端已经连接上！可以发送信息。\";\n            msg.what = STATUS_CONNECT;\n            mHandler.sendMessage(msg);\n            // 启动接受数据\n            mReadThread = new ReadThread();\n            mReadThread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n启动蓝牙客户端和服务端线程方法如下(详情参见[类]()的`onEventMainThread`方法)：\n```\nif (MainActivity.mType == MainActivity.Type.CILENT) {\n    String address = MainActivity.FRIEND_MAC_ADDRESS;//蓝牙地址\n    if (!TextUtils.isEmpty(address)) {\n        mDevice = mBluetoothAdapter.getRemoteDevice(address);\n        mClientThread = new ClientThread();\n        mClientThread.start();\n        MainActivity.isOpen = true;\n    } else {\n        Toast.makeText(getActivity(), \"address is null !\", Toast.LENGTH_SHORT).show();\n    }\n} else if (MainActivity.mType == MainActivity.Type.SERVER) {\n    mServerThread = new ServerThread();\n    mServerThread.start();\n    MainActivity.isOpen = true;\n}\n```\n#### 3.5 读取和写入数据\n这里主要是通过获取输入输出流来读取和发送数据，以读取数据为例，如下现读取数据线程代码：\n```\n// 读取数据\nprivate class ReadThread extends Thread {\n    public void run() {\n        byte[] buffer = new byte[1024];\n        int bytes;\n        InputStream is = null;\n        try {\n            is = mSocket.getInputStream();\n            while (true) {\n                if ((bytes = is.read(buffer)) > 0) {\n                    byte[] buf_data = new byte[bytes];\n                    for (int i = 0; i < bytes; i++) {\n                        buf_data[i] = buffer[i];\n                    }\n                    String s = new String(buf_data);\n                    Message msg = new Message();\n                    msg.obj = s;\n                    msg.what = 1;\n                    mHandler.sendMessage(msg);\n                }\n            }\n        } catch (IOException e1) {\n            e1.printStackTrace();\n        } finally {\n            try {\n                is.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n        }\n    }\n}\n```\n发送消息与此类似，具体请参见 会话类 []()。\n#### 3.6 关闭连接\n主要是关闭各个线程和关闭socket。\n\n\n至此，整个蓝牙同信已经完成，测试时需要两个手机，一个座位服务器，一个作为客户端，实现他们间的通信。\n\n[示例demo下载](https://github.com/imtianx/StudyDemoForAndroid/blob/master/A05-bluetoothchatdemo)\n\n\n\n\n\n\n","slug":"Android Bluetooth 通信技术深入--聊天小应用","published":1,"updated":"2016-10-08T13:47:53.412Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucdz0003g0g57bvkihsd","content":"<p>目前，市场上的大部分手机都带有蓝牙，尽管使用的不多，但作为开发者，我们还有必要了解其原理。最近的项目需要用到蓝牙技术，于是写了个 蓝牙的聊天小demo。</p>\n<h3 id=\"1-效果示意图\"><a href=\"#1-效果示意图\" class=\"headerlink\" title=\"1. 效果示意图\"></a>1. 效果示意图</h3><p>这里需要两部手机进行测试。其中一部作为蓝牙服务器，另一部作为蓝牙客户端，进行通信。<a id=\"more\"></a><br>客户端截图：<br><img src=\"/img/article_img/bluetooth/ble-client.gif\" alt=\"client\"><br>服务器截图：<br><img src=\"/img/article_img/bluetooth/ble-server.gif\" alt=\"server\"></p>\n<h3 id=\"2-开发步骤\"><a href=\"#2-开发步骤\" class=\"headerlink\" title=\"2.开发步骤\"></a>2.开发步骤</h3><ol>\n<li>开启蓝牙；</li>\n<li>搜索蓝牙设备；</li>\n<li>创建蓝牙socket，读取输出流；</li>\n<li>读取和写入数据；</li>\n<li>关闭连接和蓝牙。</li>\n</ol>\n<h3 id=\"3-具体的实现\"><a href=\"#3-具体的实现\" class=\"headerlink\" title=\"3.具体的实现\"></a>3.具体的实现</h3><h4 id=\"3-1-开启蓝牙\"><a href=\"#3-1-开启蓝牙\" class=\"headerlink\" title=\"3.1 开启蓝牙\"></a>3.1 开启蓝牙</h4><p>首先获取蓝牙适配器，若存在蓝牙未开则打开蓝牙，如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();</span><br><span class=\"line\">        if (mBluetoothAdapter == null) &#123;</span><br><span class=\"line\">            Toast.makeText(getActivity(), &quot;无蓝牙功能&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (!mBluetoothAdapter.isEnabled()) &#123;</span><br><span class=\"line\">                Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);</span><br><span class=\"line\">                startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-2-搜索蓝牙\"><a href=\"#3-2-搜索蓝牙\" class=\"headerlink\" title=\"3.2 搜索蓝牙\"></a>3.2 搜索蓝牙</h4><p>首先开启蓝牙搜索功能，然后通过注册广播，搜索蓝牙设备，搜索完成后将其加入到蓝牙列表。<br>搜索蓝牙：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (mBluetoothAdapter.isDiscovering()) &#123;</span><br><span class=\"line\">    mBluetoothAdapter.cancelDiscovery();</span><br><span class=\"line\">    mBtnStartSearch.setText(&quot;重新搜索&quot;);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    mDatas.clear();</span><br><span class=\"line\">    mAdapter.notifyDataSetChanged();</span><br><span class=\"line\">    //添加设备信息到列表</span><br><span class=\"line\">    init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mBluetoothAdapter.startDiscovery();</span><br><span class=\"line\">mBtnStartSearch.setText(&quot;ֹͣ停止搜索&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>注册蓝牙广播：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * 搜索设备广播</span><br><span class=\"line\">     */</span><br><span class=\"line\">private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class=\"line\">        String action = intent.getAction();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (BluetoothDevice.ACTION_FOUND.equals(action)) &#123;</span><br><span class=\"line\">            // 获得设备信息</span><br><span class=\"line\">            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</span><br><span class=\"line\">            // 绑定的状态不一样则进行添加</span><br><span class=\"line\">            if (device.getBondState() != BluetoothDevice.BOND_BONDED) &#123;</span><br><span class=\"line\">                mDatas.add(new BtInfo(device.getName(), device.getAddress(), false));</span><br><span class=\"line\">                mAdapter.notifyDataSetChanged();</span><br><span class=\"line\">                mListView.setSelection(mDatas.size() - 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 搜索完成</span><br><span class=\"line\">        &#125; else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) &#123;</span><br><span class=\"line\">            if (mListView.getCount() == 0) &#123;</span><br><span class=\"line\">                Toast.makeText(context, &quot;没有发现设备！&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mBtnStartSearch.setText(&quot;重新搜索&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> /**</span><br><span class=\"line\"> * 注册广播</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void registerBroadcast() &#123;</span><br><span class=\"line\">    //设备被发现广播</span><br><span class=\"line\">    IntentFilter discoveryFilter = new IntentFilter(BluetoothDevice.ACTION_FOUND);</span><br><span class=\"line\">    getActivity().registerReceiver(mReceiver, discoveryFilter);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设备发现完成</span><br><span class=\"line\">    IntentFilter foundFilter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);</span><br><span class=\"line\">    getActivity().registerReceiver(mReceiver, foundFilter);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-连接蓝牙设备\"><a href=\"#3-3-连接蓝牙设备\" class=\"headerlink\" title=\"3.3 连接蓝牙设备\"></a>3.3 连接蓝牙设备</h4><p>这里，使用listview展示蓝牙列表信息，item 的点击事件即为连接相应的蓝牙设备，点击某一项后跳转到会话页面，并通知他刷新信息，为方便，这里使用了EventBus来订阅事件，避免使用接口，如下listview 的item 的点击事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//列表item设置监听，</span><br><span class=\"line\">mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123;</span><br><span class=\"line\">        BtInfo info = mDatas.get(i);</span><br><span class=\"line\">        //好友mac地址</span><br><span class=\"line\">        MainActivity.FRIEND_MAC_ADDRESS = info.getAddress();</span><br><span class=\"line\">        //显示提示对话框</span><br><span class=\"line\">        final AlertDialog.Builder dialog = new AlertDialog.Builder(getActivity());</span><br><span class=\"line\">        dialog.setTitle(&quot;连接&quot;);</span><br><span class=\"line\">        dialog.setMessage(&quot;名称：&quot; + info.getName() + &quot;\\n&quot; + &quot;地址：&quot; + info.getAddress());</span><br><span class=\"line\">        dialog.setPositiveButton(&quot;连接&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(DialogInterface dialogInterface, int i) &#123;</span><br><span class=\"line\">                mBluetoothAdapter.cancelDiscovery();</span><br><span class=\"line\">                mBtnStartSearch.setText(&quot;重新搜索&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">                //连接后，跳转到会话页面</span><br><span class=\"line\">                MainActivity.mType = MainActivity.Type.CILENT;</span><br><span class=\"line\">                //viewPager 显示第二页</span><br><span class=\"line\">                MainActivity.mViewPager.setCurrentItem(1);</span><br><span class=\"line\">                //通知 ChatListFragment 刷新信息</span><br><span class=\"line\">                EventBus.getDefault().post(new EventMsg(1));</span><br><span class=\"line\"></span><br><span class=\"line\">                dialogInterface.dismiss();</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        dialog.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(DialogInterface dialogInterface, int i) &#123;</span><br><span class=\"line\">                MainActivity.FRIEND_MAC_ADDRESS = &quot;&quot;;</span><br><span class=\"line\">                dialogInterface.dismiss();</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        dialog.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-4-创建蓝牙socket\"><a href=\"#3-4-创建蓝牙socket\" class=\"headerlink\" title=\"3.4 创建蓝牙socket\"></a>3.4 创建蓝牙socket</h4><p>由于socketd的操作会阻塞线程，这里在子线程中进行创建。<br><code>BluetoothSocket</code> 客户端线程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 客户端线程</span><br><span class=\"line\">private class ClientThread extends Thread &#123;</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mSocket = mDevice.createRfcommSocketToServiceRecord(UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));</span><br><span class=\"line\">            Message msg = new Message();</span><br><span class=\"line\">            msg.obj = &quot;请稍候，正在连接服务器:&quot; + MainActivity.FRIEND_MAC_ADDRESS;</span><br><span class=\"line\">            msg.what = STATUS_CONNECT;</span><br><span class=\"line\">            mHandler.sendMessage(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">            mSocket.connect();</span><br><span class=\"line\"></span><br><span class=\"line\">            msg = new Message();</span><br><span class=\"line\">            msg.obj = &quot;已经连接上服务端！可以发送信息。&quot;;</span><br><span class=\"line\">            msg.what = STATUS_CONNECT_SUCCESS;</span><br><span class=\"line\">            mHandler.sendMessage(msg);</span><br><span class=\"line\">            // 启动接受数据</span><br><span class=\"line\">            mReadThread = new ReadThread();</span><br><span class=\"line\">            mReadThread.start();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            Message msg = new Message();</span><br><span class=\"line\">            msg.obj = &quot;连接服务端异常！断开连接重新试一试。&quot;;</span><br><span class=\"line\">            msg.what = STATUS_CONNECT_SUCCESS;</span><br><span class=\"line\">            mHandler.sendMessage(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建蓝牙连接时需要用到<code>UUID</code>,如需查看更多UUID，请点击<a href=\"http://blog.csdn.net/txadf/article/details/52235851\" target=\"_blank\" rel=\"external\">这里</a>。<br><code>BluetoothServerSocket</code>蓝牙服务端socket线程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // 服务器端线程</span><br><span class=\"line\">private class ServerThread extends Thread &#123;</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 创建一个蓝牙服务器 参数分别：服务器名称、UUID</span><br><span class=\"line\">            mServerSocket = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(&quot;btserver&quot;,</span><br><span class=\"line\">                    UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">            Message msg = new Message();</span><br><span class=\"line\">            msg.obj = &quot;请稍候，正在等待客户端的连接...&quot;;</span><br><span class=\"line\">            msg.what = STATUS_CONNECT;</span><br><span class=\"line\">            mHandler.sendMessage(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t/* 接受客户端的连接请求 */</span><br><span class=\"line\">            mSocket = mServerSocket.accept();</span><br><span class=\"line\"></span><br><span class=\"line\">            msg = new Message();</span><br><span class=\"line\">            msg.obj = &quot;客户端已经连接上！可以发送信息。&quot;;</span><br><span class=\"line\">            msg.what = STATUS_CONNECT;</span><br><span class=\"line\">            mHandler.sendMessage(msg);</span><br><span class=\"line\">            // 启动接受数据</span><br><span class=\"line\">            mReadThread = new ReadThread();</span><br><span class=\"line\">            mReadThread.start();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>启动蓝牙客户端和服务端线程方法如下(详情参见<a href=\"\">类</a>的<code>onEventMainThread</code>方法)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (MainActivity.mType == MainActivity.Type.CILENT) &#123;</span><br><span class=\"line\">    String address = MainActivity.FRIEND_MAC_ADDRESS;//蓝牙地址</span><br><span class=\"line\">    if (!TextUtils.isEmpty(address)) &#123;</span><br><span class=\"line\">        mDevice = mBluetoothAdapter.getRemoteDevice(address);</span><br><span class=\"line\">        mClientThread = new ClientThread();</span><br><span class=\"line\">        mClientThread.start();</span><br><span class=\"line\">        MainActivity.isOpen = true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        Toast.makeText(getActivity(), &quot;address is null !&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; else if (MainActivity.mType == MainActivity.Type.SERVER) &#123;</span><br><span class=\"line\">    mServerThread = new ServerThread();</span><br><span class=\"line\">    mServerThread.start();</span><br><span class=\"line\">    MainActivity.isOpen = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-5-读取和写入数据\"><a href=\"#3-5-读取和写入数据\" class=\"headerlink\" title=\"3.5 读取和写入数据\"></a>3.5 读取和写入数据</h4><p>这里主要是通过获取输入输出流来读取和发送数据，以读取数据为例，如下现读取数据线程代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 读取数据</span><br><span class=\"line\">private class ReadThread extends Thread &#123;</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        byte[] buffer = new byte[1024];</span><br><span class=\"line\">        int bytes;</span><br><span class=\"line\">        InputStream is = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            is = mSocket.getInputStream();</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                if ((bytes = is.read(buffer)) &gt; 0) &#123;</span><br><span class=\"line\">                    byte[] buf_data = new byte[bytes];</span><br><span class=\"line\">                    for (int i = 0; i &lt; bytes; i++) &#123;</span><br><span class=\"line\">                        buf_data[i] = buffer[i];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    String s = new String(buf_data);</span><br><span class=\"line\">                    Message msg = new Message();</span><br><span class=\"line\">                    msg.obj = s;</span><br><span class=\"line\">                    msg.what = 1;</span><br><span class=\"line\">                    mHandler.sendMessage(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">            e1.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                is.close();</span><br><span class=\"line\">            &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                e1.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>发送消息与此类似，具体请参见 会话类 <a href=\"\"></a>。</p>\n<h4 id=\"3-6-关闭连接\"><a href=\"#3-6-关闭连接\" class=\"headerlink\" title=\"3.6 关闭连接\"></a>3.6 关闭连接</h4><p>主要是关闭各个线程和关闭socket。</p>\n<p>至此，整个蓝牙同信已经完成，测试时需要两个手机，一个座位服务器，一个作为客户端，实现他们间的通信。</p>\n<p><a href=\"https://github.com/imtianx/StudyDemoForAndroid/blob/master/A05-bluetoothchatdemo\" target=\"_blank\" rel=\"external\">示例demo下载</a></p>\n","excerpt":"<p>目前，市场上的大部分手机都带有蓝牙，尽管使用的不多，但作为开发者，我们还有必要了解其原理。最近的项目需要用到蓝牙技术，于是写了个 蓝牙的聊天小demo。</p>\n<h3 id=\"1-效果示意图\"><a href=\"#1-效果示意图\" class=\"headerlink\" title=\"1. 效果示意图\"></a>1. 效果示意图</h3><p>这里需要两部手机进行测试。其中一部作为蓝牙服务器，另一部作为蓝牙客户端，进行通信。","more":"<br>客户端截图：<br><img src=\"/img/article_img/bluetooth/ble-client.gif\" alt=\"client\"><br>服务器截图：<br><img src=\"/img/article_img/bluetooth/ble-server.gif\" alt=\"server\"></p>\n<h3 id=\"2-开发步骤\"><a href=\"#2-开发步骤\" class=\"headerlink\" title=\"2.开发步骤\"></a>2.开发步骤</h3><ol>\n<li>开启蓝牙；</li>\n<li>搜索蓝牙设备；</li>\n<li>创建蓝牙socket，读取输出流；</li>\n<li>读取和写入数据；</li>\n<li>关闭连接和蓝牙。</li>\n</ol>\n<h3 id=\"3-具体的实现\"><a href=\"#3-具体的实现\" class=\"headerlink\" title=\"3.具体的实现\"></a>3.具体的实现</h3><h4 id=\"3-1-开启蓝牙\"><a href=\"#3-1-开启蓝牙\" class=\"headerlink\" title=\"3.1 开启蓝牙\"></a>3.1 开启蓝牙</h4><p>首先获取蓝牙适配器，若存在蓝牙未开则打开蓝牙，如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();</span><br><span class=\"line\">        if (mBluetoothAdapter == null) &#123;</span><br><span class=\"line\">            Toast.makeText(getActivity(), &quot;无蓝牙功能&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (!mBluetoothAdapter.isEnabled()) &#123;</span><br><span class=\"line\">                Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);</span><br><span class=\"line\">                startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-2-搜索蓝牙\"><a href=\"#3-2-搜索蓝牙\" class=\"headerlink\" title=\"3.2 搜索蓝牙\"></a>3.2 搜索蓝牙</h4><p>首先开启蓝牙搜索功能，然后通过注册广播，搜索蓝牙设备，搜索完成后将其加入到蓝牙列表。<br>搜索蓝牙：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (mBluetoothAdapter.isDiscovering()) &#123;</span><br><span class=\"line\">    mBluetoothAdapter.cancelDiscovery();</span><br><span class=\"line\">    mBtnStartSearch.setText(&quot;重新搜索&quot;);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    mDatas.clear();</span><br><span class=\"line\">    mAdapter.notifyDataSetChanged();</span><br><span class=\"line\">    //添加设备信息到列表</span><br><span class=\"line\">    init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mBluetoothAdapter.startDiscovery();</span><br><span class=\"line\">mBtnStartSearch.setText(&quot;ֹͣ停止搜索&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>注册蓝牙广播：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * 搜索设备广播</span><br><span class=\"line\">     */</span><br><span class=\"line\">private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class=\"line\">        String action = intent.getAction();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (BluetoothDevice.ACTION_FOUND.equals(action)) &#123;</span><br><span class=\"line\">            // 获得设备信息</span><br><span class=\"line\">            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</span><br><span class=\"line\">            // 绑定的状态不一样则进行添加</span><br><span class=\"line\">            if (device.getBondState() != BluetoothDevice.BOND_BONDED) &#123;</span><br><span class=\"line\">                mDatas.add(new BtInfo(device.getName(), device.getAddress(), false));</span><br><span class=\"line\">                mAdapter.notifyDataSetChanged();</span><br><span class=\"line\">                mListView.setSelection(mDatas.size() - 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 搜索完成</span><br><span class=\"line\">        &#125; else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) &#123;</span><br><span class=\"line\">            if (mListView.getCount() == 0) &#123;</span><br><span class=\"line\">                Toast.makeText(context, &quot;没有发现设备！&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mBtnStartSearch.setText(&quot;重新搜索&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> /**</span><br><span class=\"line\"> * 注册广播</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void registerBroadcast() &#123;</span><br><span class=\"line\">    //设备被发现广播</span><br><span class=\"line\">    IntentFilter discoveryFilter = new IntentFilter(BluetoothDevice.ACTION_FOUND);</span><br><span class=\"line\">    getActivity().registerReceiver(mReceiver, discoveryFilter);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设备发现完成</span><br><span class=\"line\">    IntentFilter foundFilter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);</span><br><span class=\"line\">    getActivity().registerReceiver(mReceiver, foundFilter);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-连接蓝牙设备\"><a href=\"#3-3-连接蓝牙设备\" class=\"headerlink\" title=\"3.3 连接蓝牙设备\"></a>3.3 连接蓝牙设备</h4><p>这里，使用listview展示蓝牙列表信息，item 的点击事件即为连接相应的蓝牙设备，点击某一项后跳转到会话页面，并通知他刷新信息，为方便，这里使用了EventBus来订阅事件，避免使用接口，如下listview 的item 的点击事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//列表item设置监听，</span><br><span class=\"line\">mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123;</span><br><span class=\"line\">        BtInfo info = mDatas.get(i);</span><br><span class=\"line\">        //好友mac地址</span><br><span class=\"line\">        MainActivity.FRIEND_MAC_ADDRESS = info.getAddress();</span><br><span class=\"line\">        //显示提示对话框</span><br><span class=\"line\">        final AlertDialog.Builder dialog = new AlertDialog.Builder(getActivity());</span><br><span class=\"line\">        dialog.setTitle(&quot;连接&quot;);</span><br><span class=\"line\">        dialog.setMessage(&quot;名称：&quot; + info.getName() + &quot;\\n&quot; + &quot;地址：&quot; + info.getAddress());</span><br><span class=\"line\">        dialog.setPositiveButton(&quot;连接&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(DialogInterface dialogInterface, int i) &#123;</span><br><span class=\"line\">                mBluetoothAdapter.cancelDiscovery();</span><br><span class=\"line\">                mBtnStartSearch.setText(&quot;重新搜索&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">                //连接后，跳转到会话页面</span><br><span class=\"line\">                MainActivity.mType = MainActivity.Type.CILENT;</span><br><span class=\"line\">                //viewPager 显示第二页</span><br><span class=\"line\">                MainActivity.mViewPager.setCurrentItem(1);</span><br><span class=\"line\">                //通知 ChatListFragment 刷新信息</span><br><span class=\"line\">                EventBus.getDefault().post(new EventMsg(1));</span><br><span class=\"line\"></span><br><span class=\"line\">                dialogInterface.dismiss();</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        dialog.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(DialogInterface dialogInterface, int i) &#123;</span><br><span class=\"line\">                MainActivity.FRIEND_MAC_ADDRESS = &quot;&quot;;</span><br><span class=\"line\">                dialogInterface.dismiss();</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        dialog.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-4-创建蓝牙socket\"><a href=\"#3-4-创建蓝牙socket\" class=\"headerlink\" title=\"3.4 创建蓝牙socket\"></a>3.4 创建蓝牙socket</h4><p>由于socketd的操作会阻塞线程，这里在子线程中进行创建。<br><code>BluetoothSocket</code> 客户端线程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 客户端线程</span><br><span class=\"line\">private class ClientThread extends Thread &#123;</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mSocket = mDevice.createRfcommSocketToServiceRecord(UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));</span><br><span class=\"line\">            Message msg = new Message();</span><br><span class=\"line\">            msg.obj = &quot;请稍候，正在连接服务器:&quot; + MainActivity.FRIEND_MAC_ADDRESS;</span><br><span class=\"line\">            msg.what = STATUS_CONNECT;</span><br><span class=\"line\">            mHandler.sendMessage(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">            mSocket.connect();</span><br><span class=\"line\"></span><br><span class=\"line\">            msg = new Message();</span><br><span class=\"line\">            msg.obj = &quot;已经连接上服务端！可以发送信息。&quot;;</span><br><span class=\"line\">            msg.what = STATUS_CONNECT_SUCCESS;</span><br><span class=\"line\">            mHandler.sendMessage(msg);</span><br><span class=\"line\">            // 启动接受数据</span><br><span class=\"line\">            mReadThread = new ReadThread();</span><br><span class=\"line\">            mReadThread.start();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            Message msg = new Message();</span><br><span class=\"line\">            msg.obj = &quot;连接服务端异常！断开连接重新试一试。&quot;;</span><br><span class=\"line\">            msg.what = STATUS_CONNECT_SUCCESS;</span><br><span class=\"line\">            mHandler.sendMessage(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建蓝牙连接时需要用到<code>UUID</code>,如需查看更多UUID，请点击<a href=\"http://blog.csdn.net/txadf/article/details/52235851\">这里</a>。<br><code>BluetoothServerSocket</code>蓝牙服务端socket线程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> // 服务器端线程</span><br><span class=\"line\">private class ServerThread extends Thread &#123;</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 创建一个蓝牙服务器 参数分别：服务器名称、UUID</span><br><span class=\"line\">            mServerSocket = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(&quot;btserver&quot;,</span><br><span class=\"line\">                    UUID.fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">            Message msg = new Message();</span><br><span class=\"line\">            msg.obj = &quot;请稍候，正在等待客户端的连接...&quot;;</span><br><span class=\"line\">            msg.what = STATUS_CONNECT;</span><br><span class=\"line\">            mHandler.sendMessage(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t/* 接受客户端的连接请求 */</span><br><span class=\"line\">            mSocket = mServerSocket.accept();</span><br><span class=\"line\"></span><br><span class=\"line\">            msg = new Message();</span><br><span class=\"line\">            msg.obj = &quot;客户端已经连接上！可以发送信息。&quot;;</span><br><span class=\"line\">            msg.what = STATUS_CONNECT;</span><br><span class=\"line\">            mHandler.sendMessage(msg);</span><br><span class=\"line\">            // 启动接受数据</span><br><span class=\"line\">            mReadThread = new ReadThread();</span><br><span class=\"line\">            mReadThread.start();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>启动蓝牙客户端和服务端线程方法如下(详情参见<a href=\"\">类</a>的<code>onEventMainThread</code>方法)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (MainActivity.mType == MainActivity.Type.CILENT) &#123;</span><br><span class=\"line\">    String address = MainActivity.FRIEND_MAC_ADDRESS;//蓝牙地址</span><br><span class=\"line\">    if (!TextUtils.isEmpty(address)) &#123;</span><br><span class=\"line\">        mDevice = mBluetoothAdapter.getRemoteDevice(address);</span><br><span class=\"line\">        mClientThread = new ClientThread();</span><br><span class=\"line\">        mClientThread.start();</span><br><span class=\"line\">        MainActivity.isOpen = true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        Toast.makeText(getActivity(), &quot;address is null !&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; else if (MainActivity.mType == MainActivity.Type.SERVER) &#123;</span><br><span class=\"line\">    mServerThread = new ServerThread();</span><br><span class=\"line\">    mServerThread.start();</span><br><span class=\"line\">    MainActivity.isOpen = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-5-读取和写入数据\"><a href=\"#3-5-读取和写入数据\" class=\"headerlink\" title=\"3.5 读取和写入数据\"></a>3.5 读取和写入数据</h4><p>这里主要是通过获取输入输出流来读取和发送数据，以读取数据为例，如下现读取数据线程代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 读取数据</span><br><span class=\"line\">private class ReadThread extends Thread &#123;</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        byte[] buffer = new byte[1024];</span><br><span class=\"line\">        int bytes;</span><br><span class=\"line\">        InputStream is = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            is = mSocket.getInputStream();</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                if ((bytes = is.read(buffer)) &gt; 0) &#123;</span><br><span class=\"line\">                    byte[] buf_data = new byte[bytes];</span><br><span class=\"line\">                    for (int i = 0; i &lt; bytes; i++) &#123;</span><br><span class=\"line\">                        buf_data[i] = buffer[i];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    String s = new String(buf_data);</span><br><span class=\"line\">                    Message msg = new Message();</span><br><span class=\"line\">                    msg.obj = s;</span><br><span class=\"line\">                    msg.what = 1;</span><br><span class=\"line\">                    mHandler.sendMessage(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">            e1.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                is.close();</span><br><span class=\"line\">            &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                e1.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>发送消息与此类似，具体请参见 会话类 <a href=\"\"></a>。</p>\n<h4 id=\"3-6-关闭连接\"><a href=\"#3-6-关闭连接\" class=\"headerlink\" title=\"3.6 关闭连接\"></a>3.6 关闭连接</h4><p>主要是关闭各个线程和关闭socket。</p>\n<p>至此，整个蓝牙同信已经完成，测试时需要两个手机，一个座位服务器，一个作为客户端，实现他们间的通信。</p>\n<p><a href=\"https://github.com/imtianx/StudyDemoForAndroid/blob/master/A05-bluetoothchatdemo\">示例demo下载</a></p>"},{"title":"Android View 的事件体系","date":"2016-12-17T08:06:25.000Z","_content":"\n\n>本文为读书笔记： 《Android 开发艺术探索 》——第三章 View 的事件体系     \n\nandroid 系统虽然提供了很多基本的控件，如Button、TextView等，但是很多时候系统提供的view不能满足我们的需求，此时就需要我们根据自己的需求进行自定义控件。这些控件都是继承自View的。\n<!-- more -->\n## 一、android 控件架构\nandroid 中的控件在界面上都会占一块巨型区域，主要分为两类：ViewGroup和View控件。ViewGroup作为父控件可以包含多个View控件，并管理他们，但其也是继承自View。通过Viewgroup，整个控件界面形成了View的控件树，如图1所示。\n\n上层控件负责字控件的测量与绘制，并传递交互事件。在Activity 中 通过`findViewById()`方法，就是以树的 *深度优先遍历*  查找对应的控件。控件树的顶部都有一个ViewParent 对象，对整个视图进行控制。\n![](/img/article_img/2016/view.png)\n\n\n如上面图2 所示，是android 界面的架构图，在activity 中 通过 `setContentView()` 方法设置为根布局。在每一个Activity 中 都包含一个Window 对象，它由 PhoneWindow来实现，PhoneWindow 讲一个 DecorView 设置为整个应用窗口的根View。DecorView 作为窗口界面的顶层视图，封装了一些窗口操作的通用方法，所有View 的监听事件，都通过`WindowManagerService` 进行接收，并通过Activity 对象来回调相应的onClickListener。对于DecorView，他由TitleView 和ContentView 组成，\n前者承载的是一个`Actionbar`，后者承载的是一个`FrameLayout`。\n\n## 二、View 的基本知识\n### 2.1、View 的位置参数\nview 的位置由两个顶点坐标来决定，主要是左上（left,top）和右下(right,bottom)坐标。他们是相对于View 的父容器来说的，是相对坐标。如下图他们的关系：\n![](/img/article_img/2016/view_zuobiao.png)\n\n```\nwidth = right - left;\nheight = bottom - top;\n\n```\n在View 中都有相应的方法来获取他们的值。从android 3.0开始，View增加了几个参数：x,y,translationX和translationY，其中x、y表示View 左上角的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。同样的，他们也有相应的get/set方法，translationX和translationY的默认值均为0。\n```\nx = left + translationX;\ny = right + translationY;\n```\n在View 的移动过程中top和left 表示原始左上角坐标，并不会改变。\n\n### 2.2、MotionEvent和TouchSlop\n**（1）、MotionEvent**\n在手指触摸屏幕后，会有一系列的事件，主要事件类型有：\n\n```\nACTION_DOWN // 收支接触\nACTION_MOVE // 手指在屏幕上移动\nACTION_UP //手指从屏幕松开\nACTION_CANCEL //取消\n...\n```\n使用 `MotionEvent` 对象获取的 点击的 x 和 y ,使用 `getX / getY` 获取的是相对于当前View左上角的x和y,而 `getRawX / getRawY` 获取的是相对于手机屏幕左上角的坐标。\n\n**（2）、TouchSlop**\nTouchSlop 是系统所能识别的最小滑动距离，小于它则视未发生滑动，他和设备相关，在不同的设备上获取的值不同。通过 ` ViewConfiguration.get(getContext()).getScaledTouchSlop();` 获取。\n\n\n### 2.3、VelocityTracker、GestureDetector和Scroller\n**（1）、VelocityTracker**\n速度追踪，用于追踪滑动过程中的速度，包括水平和竖直速度。如下具体使用步骤：\n\n```\n//1.在 onTouchEvent 方法中追踪当前事件的速度\nVelocityTracker  tracker = VelocityTracker.obtain();\ntracker.addMovement(event);\n//2.获取当前速度\ntracker.computeCurrentVelocity(1000);//计算速度\nint xVelocity = (int) tracker.getXVelocity();\nint yVelocity = (int) tracker.getYVelocity();\n//3.在不需要的时候重置回收内存\ntracker.recycle();\n```\n\n**（2）、GestureDetector**\n手势检测，用于检测单击、滑动、长按、双击等手势。\n在使用时，首先要实现 `GestureDetector.OnGestureListener`接口，如果需要双击，则需实现 `GestureDetector.OnDoubleTapListener` 接口；\n\n```\n//设置监听\nmGestureDetector = new GestureDetector(this);\n//避免长按后无法拖动，自己测试时发现不设置，长按后也可以拖动\nmGestureDetector.setIsLongpressEnabled(false);\n```\n然后在 onTouchEvent 添加如下代码：\n\n```\nboolean consume = mGestureDetector.onTouchEvent(event);\nreturn consume;\n```\n\nGestureDetector 类中的 OnGestureListener 接口和 OnDoubleTapListener 接口相关实现方法说明：\n\n|方法名|描述|所属接口|\n|------|:----:|:------:|\n|onDown|手指轻触，一个ACTION_DOWN 触发|OnGestureListener|\n|onShowPress|手指轻触，尚未松开或者拖动|OnGestureListener|\n|onSingleTapUp|单击：手指（轻触后）松开，伴随一个ACTION_UP触发|OnGestureListener|\n|onScroll|拖动：手指按下并拖动，一个ACTION_DOWN，多个ACTION_MOVE|OnGestureListener|\n|onLongPress|长按|OnGestureListener|\n|onFling|快速滑动：按下快速滑动并松开|OnGestureListener|\n||||\n|onSingleTapConfirmed|严格单击：这个只可能是单击，不会是双击中的一次单击|OnDoubleTapListener|\n|onDoubleTap|双击 :与onSingleTapConfirmed 不共存|OnDoubleTapListener|\n|onDoubleTapEvent|表示发生了双击行为|OnDoubleTapListener|\n\n\n**（3）、Scroller**\n弹性滑动，可是实现有过度效果的滑动，View 的 ScrollTo/ScrollBy 都是瞬间滑动完成的。\n\n## 三、View 的滑动\n实现View的滑动主要有如下三种方式:\n\n1. **scrollTo /scrollBy** :适合对view 的内容改变；\n2. **动画**： 主要用于没有交互的View 和实现复杂的动画效果；\n3. **改变布局参数**：操作稍微复杂，适合有交互的View 。\n\n\n\n### 3.1. 通过View 的 ScrollTo/ScrollBy 方法\n\nView 源码中的相关实现：\n\n```\n  /**\n     * Set the scrolled position of your view. This will cause a call to\n     * {@link #onScrollChanged(int, int, int, int)} and the view will be\n     * invalidated.\n     * @param x the x position to scroll to\n     * @param y the y position to scroll to\n     */\n    public void scrollTo(int x, int y) {\n        if (mScrollX != x || mScrollY != y) {\n            int oldX = mScrollX;\n            int oldY = mScrollY;\n            mScrollX = x;\n            mScrollY = y;\n            invalidateParentCaches();\n            onScrollChanged(mScrollX, mScrollY, oldX, oldY);\n            if (!awakenScrollBars()) {\n                postInvalidateOnAnimation();\n            }\n        }\n    }\n    \n      /**\n     * Move the scrolled position of your view. This will cause a call to\n     * {@link #onScrollChanged(int, int, int, int)} and the view will be\n     * invalidated.\n     * @param x the amount of pixels to scroll by horizontally\n     * @param y the amount of pixels to scroll by vertically\n     */\n    public void scrollBy(int x, int y) {\n        scrollTo(mScrollX + x, mScrollY + y);\n    }\n\n```\n\n其中 `scrollBy` 调用的是 `scrollTo`，它实现了使用当前位置的相对滑动，而 `scrollTo` 是基于所传参数的绝对滑动。**在滑动过程中，mScrollX 的值等于 View 左边缘 和 View 内容左边缘在水平方向的距离，而 mScrollY 则是View 上边缘和 View 内容上边缘在竖直方向的距离。他们都是以像素单位。如果从 左往右/从上往下 滑动，mScrollX/mScrollY 为正。**\n\nscrollBy 和 scrollTo 只能改变 View 内容的位置而不能改变View 在布局中的位置。\n\n如下滑动过程中，mScrollX/mScrollY 取值情况：\n\n![](/img/article_img/2016/View 中的scrollTo和scrollBy.png)\n\n\n### 3.2. 使用动画\n\n通过动画为View 添加平移效果，View 的 tanslationX 和 tanslationY 属性，可以采用传统的动画和属性动画。\n动画不能真正的改变 View 的位置，只是移动的是他的影像，如果在新位置有点击事件，则无效。但是在android 3.0以后属性动画解决了该问题。\n\n### 3.3. 改变布局参数\n通过改变View 的LayoutParams 使得 View 重新布局实现滑动。\n这里以 把 Button 水平移动 100px 为例。可以改变 Button 的 `marginLeft` ,或者在其左边放一个宽度为0 的view,当要平移时改变他的宽度，使其被挤到右边（加入Button的父布局为LinearLayout），实现滑动。\n\n如下是改变 `LayoutParams`的方式：\n\n```\n ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams)\n                mButton.getLayoutParams();\nparams.width += 100;\nparams.leftMargin += 100;\nmButton.setLayoutParams(params);  // 或者  mButton.requestLayout();\n```\n\n## 四、弹性滑动\n为了避免 滑动的生硬，可以采用弹性滑动，提高用户体验。这里主要有 ：Scroller、动画、延时三种方式。\n\n如下是 `Scroller` 的典型使用，主要是 **invalidate**方法起的作用。\n\n```\nScroller mScroller = new Scroller(context);\n\n/**\n * 滑动到指定位置\n *\n * @param destX  X 滑动距离\n * @param destY  Y 滑动距离\n */\nprivate void smoothScrollTo(int destX, int destY) {\n    //滑动起点X\n    int scrollX = getScrollX();\n    //滑动起点Y\n    int scrollY = getScrollY();\n    //1000 ms内慢慢滑向 （destX，destY）\n    mScroller.startScroll(scrollX, scrollY, destX, destY, 1000);\n    //重绘\n    invalidate();\n}\n /**\n * 使View 不断重绘\n */\n@Override\npublic void computeScroll() {\n    /**\n     *  computeScrollOffset 方法通过时间流逝百分比计算 scrollX和scrollY \n     *  返回true 表示滑动未结束\n     */\n    if (mScroller.computeScrollOffset()) {\n        //滑动到当前位置，通过小幅度滑动实现弹性滑动\n        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n        //再次重绘\n        postInvalidate();\n    }\n}\n```\n如下 **Scroller 的滑动原理（相关方法的调用过程）**：\n\n![](/img/article_img/2016/Scroller滑动机制.png)\n\n\n对于延时达到弹性滑动，主要是利用 了Handler 或者 View 的 postDelayed 方法，或者线程的 sleep方法。\n\n\n## 五、View 的事件分发机制\n\n在 view 中事件分发十分重要，了解他的原理，对我们理解View 和解决滑动冲突都十分重要。\n>  1. 所有的Touch事件都封装到 `MotionEvent` 里面；\n 2. 事件处理包括三种情况，分别为：**传递—-dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费—-onTouchEvent()函数和OnTouchListener**；\n 3. 事件类型分为 ACTION_DOWN, ACTION_UP, ACTION_MOVE , ACTION_POINTER_DOWN, ACTION_POINTER_UP , ACTION_CANCEL 等，每个事件都是以 ACTION_DOWN 开始 ACTION_UP 结束。\n\n\n用下面伪代码表示事件分发过程及其关系：\n\n```\n//事件分发\npublic boolean dispatchTouchEvent(MotionEvent event) {\n    boolean consume = false;\n    //是否被拦截\n    if (onInterceptTouchEvent(event))\n    {\n        //被拦截，处理事件\n        consume = onTouchEvent(event);\n    } else {\n        //未被拦截，向下分发\n        consume = childView.dispatchTouchEvent(event);\n    }\n    return consume;\n}\n```\n\n**事件传递的基本流程**：\n\n-  事件都是从Activity.dispatchTouchEvent()开始传递；\n-  事件由父View传递给子View，ViewGroup可以通过onInterceptTouchEvent()方法对事件拦截，停止其向子view传递；\n- 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数；\n- 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来，也就是说ACTION_DOWN必须返回true，之后的事件才会传递进来；\n- OnTouchListener优先于onTouchEvent()对事件进行消费。\n\n## 六、View 的滑动冲突\n\n滑动冲突的出现是由于内外两个view都是可以滑动的，如 ScrollView 中嵌套 ListView 。常见的滑动冲突场景有：\n\n- 场景一：内外滑动方向不一致；\n- 场景二：内外滑动方向一致；\n- 场景三：上述两种场景的嵌套。\n\n对于场景一，可以根据水平竖直方向的滑动距离差判断是哪种滑动，进行相应的拦截；场景二，可以通过自己的业务制定相应的处理规则，然后进行处理；场景三则结合前两种进行。\n\n有些滑动冲突是采用了不合理的布局导致，可以更换布局，而有些则必须通过自定义控件重写拦截和分发事件处理。\n\n\n\n\n","source":"_posts/Android View 的事件体系.md","raw":"---\ntitle: Android View 的事件体系\ndate: 2016-12-17 16:06:25\ncategories: [android,学习笔记]\ntags: [View,事件分发,滑动冲突]\n---\n\n\n>本文为读书笔记： 《Android 开发艺术探索 》——第三章 View 的事件体系     \n\nandroid 系统虽然提供了很多基本的控件，如Button、TextView等，但是很多时候系统提供的view不能满足我们的需求，此时就需要我们根据自己的需求进行自定义控件。这些控件都是继承自View的。\n<!-- more -->\n## 一、android 控件架构\nandroid 中的控件在界面上都会占一块巨型区域，主要分为两类：ViewGroup和View控件。ViewGroup作为父控件可以包含多个View控件，并管理他们，但其也是继承自View。通过Viewgroup，整个控件界面形成了View的控件树，如图1所示。\n\n上层控件负责字控件的测量与绘制，并传递交互事件。在Activity 中 通过`findViewById()`方法，就是以树的 *深度优先遍历*  查找对应的控件。控件树的顶部都有一个ViewParent 对象，对整个视图进行控制。\n![](/img/article_img/2016/view.png)\n\n\n如上面图2 所示，是android 界面的架构图，在activity 中 通过 `setContentView()` 方法设置为根布局。在每一个Activity 中 都包含一个Window 对象，它由 PhoneWindow来实现，PhoneWindow 讲一个 DecorView 设置为整个应用窗口的根View。DecorView 作为窗口界面的顶层视图，封装了一些窗口操作的通用方法，所有View 的监听事件，都通过`WindowManagerService` 进行接收，并通过Activity 对象来回调相应的onClickListener。对于DecorView，他由TitleView 和ContentView 组成，\n前者承载的是一个`Actionbar`，后者承载的是一个`FrameLayout`。\n\n## 二、View 的基本知识\n### 2.1、View 的位置参数\nview 的位置由两个顶点坐标来决定，主要是左上（left,top）和右下(right,bottom)坐标。他们是相对于View 的父容器来说的，是相对坐标。如下图他们的关系：\n![](/img/article_img/2016/view_zuobiao.png)\n\n```\nwidth = right - left;\nheight = bottom - top;\n\n```\n在View 中都有相应的方法来获取他们的值。从android 3.0开始，View增加了几个参数：x,y,translationX和translationY，其中x、y表示View 左上角的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。同样的，他们也有相应的get/set方法，translationX和translationY的默认值均为0。\n```\nx = left + translationX;\ny = right + translationY;\n```\n在View 的移动过程中top和left 表示原始左上角坐标，并不会改变。\n\n### 2.2、MotionEvent和TouchSlop\n**（1）、MotionEvent**\n在手指触摸屏幕后，会有一系列的事件，主要事件类型有：\n\n```\nACTION_DOWN // 收支接触\nACTION_MOVE // 手指在屏幕上移动\nACTION_UP //手指从屏幕松开\nACTION_CANCEL //取消\n...\n```\n使用 `MotionEvent` 对象获取的 点击的 x 和 y ,使用 `getX / getY` 获取的是相对于当前View左上角的x和y,而 `getRawX / getRawY` 获取的是相对于手机屏幕左上角的坐标。\n\n**（2）、TouchSlop**\nTouchSlop 是系统所能识别的最小滑动距离，小于它则视未发生滑动，他和设备相关，在不同的设备上获取的值不同。通过 ` ViewConfiguration.get(getContext()).getScaledTouchSlop();` 获取。\n\n\n### 2.3、VelocityTracker、GestureDetector和Scroller\n**（1）、VelocityTracker**\n速度追踪，用于追踪滑动过程中的速度，包括水平和竖直速度。如下具体使用步骤：\n\n```\n//1.在 onTouchEvent 方法中追踪当前事件的速度\nVelocityTracker  tracker = VelocityTracker.obtain();\ntracker.addMovement(event);\n//2.获取当前速度\ntracker.computeCurrentVelocity(1000);//计算速度\nint xVelocity = (int) tracker.getXVelocity();\nint yVelocity = (int) tracker.getYVelocity();\n//3.在不需要的时候重置回收内存\ntracker.recycle();\n```\n\n**（2）、GestureDetector**\n手势检测，用于检测单击、滑动、长按、双击等手势。\n在使用时，首先要实现 `GestureDetector.OnGestureListener`接口，如果需要双击，则需实现 `GestureDetector.OnDoubleTapListener` 接口；\n\n```\n//设置监听\nmGestureDetector = new GestureDetector(this);\n//避免长按后无法拖动，自己测试时发现不设置，长按后也可以拖动\nmGestureDetector.setIsLongpressEnabled(false);\n```\n然后在 onTouchEvent 添加如下代码：\n\n```\nboolean consume = mGestureDetector.onTouchEvent(event);\nreturn consume;\n```\n\nGestureDetector 类中的 OnGestureListener 接口和 OnDoubleTapListener 接口相关实现方法说明：\n\n|方法名|描述|所属接口|\n|------|:----:|:------:|\n|onDown|手指轻触，一个ACTION_DOWN 触发|OnGestureListener|\n|onShowPress|手指轻触，尚未松开或者拖动|OnGestureListener|\n|onSingleTapUp|单击：手指（轻触后）松开，伴随一个ACTION_UP触发|OnGestureListener|\n|onScroll|拖动：手指按下并拖动，一个ACTION_DOWN，多个ACTION_MOVE|OnGestureListener|\n|onLongPress|长按|OnGestureListener|\n|onFling|快速滑动：按下快速滑动并松开|OnGestureListener|\n||||\n|onSingleTapConfirmed|严格单击：这个只可能是单击，不会是双击中的一次单击|OnDoubleTapListener|\n|onDoubleTap|双击 :与onSingleTapConfirmed 不共存|OnDoubleTapListener|\n|onDoubleTapEvent|表示发生了双击行为|OnDoubleTapListener|\n\n\n**（3）、Scroller**\n弹性滑动，可是实现有过度效果的滑动，View 的 ScrollTo/ScrollBy 都是瞬间滑动完成的。\n\n## 三、View 的滑动\n实现View的滑动主要有如下三种方式:\n\n1. **scrollTo /scrollBy** :适合对view 的内容改变；\n2. **动画**： 主要用于没有交互的View 和实现复杂的动画效果；\n3. **改变布局参数**：操作稍微复杂，适合有交互的View 。\n\n\n\n### 3.1. 通过View 的 ScrollTo/ScrollBy 方法\n\nView 源码中的相关实现：\n\n```\n  /**\n     * Set the scrolled position of your view. This will cause a call to\n     * {@link #onScrollChanged(int, int, int, int)} and the view will be\n     * invalidated.\n     * @param x the x position to scroll to\n     * @param y the y position to scroll to\n     */\n    public void scrollTo(int x, int y) {\n        if (mScrollX != x || mScrollY != y) {\n            int oldX = mScrollX;\n            int oldY = mScrollY;\n            mScrollX = x;\n            mScrollY = y;\n            invalidateParentCaches();\n            onScrollChanged(mScrollX, mScrollY, oldX, oldY);\n            if (!awakenScrollBars()) {\n                postInvalidateOnAnimation();\n            }\n        }\n    }\n    \n      /**\n     * Move the scrolled position of your view. This will cause a call to\n     * {@link #onScrollChanged(int, int, int, int)} and the view will be\n     * invalidated.\n     * @param x the amount of pixels to scroll by horizontally\n     * @param y the amount of pixels to scroll by vertically\n     */\n    public void scrollBy(int x, int y) {\n        scrollTo(mScrollX + x, mScrollY + y);\n    }\n\n```\n\n其中 `scrollBy` 调用的是 `scrollTo`，它实现了使用当前位置的相对滑动，而 `scrollTo` 是基于所传参数的绝对滑动。**在滑动过程中，mScrollX 的值等于 View 左边缘 和 View 内容左边缘在水平方向的距离，而 mScrollY 则是View 上边缘和 View 内容上边缘在竖直方向的距离。他们都是以像素单位。如果从 左往右/从上往下 滑动，mScrollX/mScrollY 为正。**\n\nscrollBy 和 scrollTo 只能改变 View 内容的位置而不能改变View 在布局中的位置。\n\n如下滑动过程中，mScrollX/mScrollY 取值情况：\n\n![](/img/article_img/2016/View 中的scrollTo和scrollBy.png)\n\n\n### 3.2. 使用动画\n\n通过动画为View 添加平移效果，View 的 tanslationX 和 tanslationY 属性，可以采用传统的动画和属性动画。\n动画不能真正的改变 View 的位置，只是移动的是他的影像，如果在新位置有点击事件，则无效。但是在android 3.0以后属性动画解决了该问题。\n\n### 3.3. 改变布局参数\n通过改变View 的LayoutParams 使得 View 重新布局实现滑动。\n这里以 把 Button 水平移动 100px 为例。可以改变 Button 的 `marginLeft` ,或者在其左边放一个宽度为0 的view,当要平移时改变他的宽度，使其被挤到右边（加入Button的父布局为LinearLayout），实现滑动。\n\n如下是改变 `LayoutParams`的方式：\n\n```\n ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams)\n                mButton.getLayoutParams();\nparams.width += 100;\nparams.leftMargin += 100;\nmButton.setLayoutParams(params);  // 或者  mButton.requestLayout();\n```\n\n## 四、弹性滑动\n为了避免 滑动的生硬，可以采用弹性滑动，提高用户体验。这里主要有 ：Scroller、动画、延时三种方式。\n\n如下是 `Scroller` 的典型使用，主要是 **invalidate**方法起的作用。\n\n```\nScroller mScroller = new Scroller(context);\n\n/**\n * 滑动到指定位置\n *\n * @param destX  X 滑动距离\n * @param destY  Y 滑动距离\n */\nprivate void smoothScrollTo(int destX, int destY) {\n    //滑动起点X\n    int scrollX = getScrollX();\n    //滑动起点Y\n    int scrollY = getScrollY();\n    //1000 ms内慢慢滑向 （destX，destY）\n    mScroller.startScroll(scrollX, scrollY, destX, destY, 1000);\n    //重绘\n    invalidate();\n}\n /**\n * 使View 不断重绘\n */\n@Override\npublic void computeScroll() {\n    /**\n     *  computeScrollOffset 方法通过时间流逝百分比计算 scrollX和scrollY \n     *  返回true 表示滑动未结束\n     */\n    if (mScroller.computeScrollOffset()) {\n        //滑动到当前位置，通过小幅度滑动实现弹性滑动\n        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n        //再次重绘\n        postInvalidate();\n    }\n}\n```\n如下 **Scroller 的滑动原理（相关方法的调用过程）**：\n\n![](/img/article_img/2016/Scroller滑动机制.png)\n\n\n对于延时达到弹性滑动，主要是利用 了Handler 或者 View 的 postDelayed 方法，或者线程的 sleep方法。\n\n\n## 五、View 的事件分发机制\n\n在 view 中事件分发十分重要，了解他的原理，对我们理解View 和解决滑动冲突都十分重要。\n>  1. 所有的Touch事件都封装到 `MotionEvent` 里面；\n 2. 事件处理包括三种情况，分别为：**传递—-dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费—-onTouchEvent()函数和OnTouchListener**；\n 3. 事件类型分为 ACTION_DOWN, ACTION_UP, ACTION_MOVE , ACTION_POINTER_DOWN, ACTION_POINTER_UP , ACTION_CANCEL 等，每个事件都是以 ACTION_DOWN 开始 ACTION_UP 结束。\n\n\n用下面伪代码表示事件分发过程及其关系：\n\n```\n//事件分发\npublic boolean dispatchTouchEvent(MotionEvent event) {\n    boolean consume = false;\n    //是否被拦截\n    if (onInterceptTouchEvent(event))\n    {\n        //被拦截，处理事件\n        consume = onTouchEvent(event);\n    } else {\n        //未被拦截，向下分发\n        consume = childView.dispatchTouchEvent(event);\n    }\n    return consume;\n}\n```\n\n**事件传递的基本流程**：\n\n-  事件都是从Activity.dispatchTouchEvent()开始传递；\n-  事件由父View传递给子View，ViewGroup可以通过onInterceptTouchEvent()方法对事件拦截，停止其向子view传递；\n- 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数；\n- 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来，也就是说ACTION_DOWN必须返回true，之后的事件才会传递进来；\n- OnTouchListener优先于onTouchEvent()对事件进行消费。\n\n## 六、View 的滑动冲突\n\n滑动冲突的出现是由于内外两个view都是可以滑动的，如 ScrollView 中嵌套 ListView 。常见的滑动冲突场景有：\n\n- 场景一：内外滑动方向不一致；\n- 场景二：内外滑动方向一致；\n- 场景三：上述两种场景的嵌套。\n\n对于场景一，可以根据水平竖直方向的滑动距离差判断是哪种滑动，进行相应的拦截；场景二，可以通过自己的业务制定相应的处理规则，然后进行处理；场景三则结合前两种进行。\n\n有些滑动冲突是采用了不合理的布局导致，可以更换布局，而有些则必须通过自定义控件重写拦截和分发事件处理。\n\n\n\n\n","slug":"Android View 的事件体系","published":1,"updated":"2016-12-31T02:00:19.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucef0007g0g5tliq2emk","content":"<blockquote>\n<p>本文为读书笔记： 《Android 开发艺术探索 》——第三章 View 的事件体系     </p>\n</blockquote>\n<p>android 系统虽然提供了很多基本的控件，如Button、TextView等，但是很多时候系统提供的view不能满足我们的需求，此时就需要我们根据自己的需求进行自定义控件。这些控件都是继承自View的。<br><a id=\"more\"></a></p>\n<h2 id=\"一、android-控件架构\"><a href=\"#一、android-控件架构\" class=\"headerlink\" title=\"一、android 控件架构\"></a>一、android 控件架构</h2><p>android 中的控件在界面上都会占一块巨型区域，主要分为两类：ViewGroup和View控件。ViewGroup作为父控件可以包含多个View控件，并管理他们，但其也是继承自View。通过Viewgroup，整个控件界面形成了View的控件树，如图1所示。</p>\n<p>上层控件负责字控件的测量与绘制，并传递交互事件。在Activity 中 通过<code>findViewById()</code>方法，就是以树的 <em>深度优先遍历</em>  查找对应的控件。控件树的顶部都有一个ViewParent 对象，对整个视图进行控制。<br><img src=\"/img/article_img/2016/view.png\" alt=\"\"></p>\n<p>如上面图2 所示，是android 界面的架构图，在activity 中 通过 <code>setContentView()</code> 方法设置为根布局。在每一个Activity 中 都包含一个Window 对象，它由 PhoneWindow来实现，PhoneWindow 讲一个 DecorView 设置为整个应用窗口的根View。DecorView 作为窗口界面的顶层视图，封装了一些窗口操作的通用方法，所有View 的监听事件，都通过<code>WindowManagerService</code> 进行接收，并通过Activity 对象来回调相应的onClickListener。对于DecorView，他由TitleView 和ContentView 组成，<br>前者承载的是一个<code>Actionbar</code>，后者承载的是一个<code>FrameLayout</code>。</p>\n<h2 id=\"二、View-的基本知识\"><a href=\"#二、View-的基本知识\" class=\"headerlink\" title=\"二、View 的基本知识\"></a>二、View 的基本知识</h2><h3 id=\"2-1、View-的位置参数\"><a href=\"#2-1、View-的位置参数\" class=\"headerlink\" title=\"2.1、View 的位置参数\"></a>2.1、View 的位置参数</h3><p>view 的位置由两个顶点坐标来决定，主要是左上（left,top）和右下(right,bottom)坐标。他们是相对于View 的父容器来说的，是相对坐标。如下图他们的关系：<br><img src=\"/img/article_img/2016/view_zuobiao.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width = right - left;</span><br><span class=\"line\">height = bottom - top;</span><br></pre></td></tr></table></figure>\n<p>在View 中都有相应的方法来获取他们的值。从android 3.0开始，View增加了几个参数：x,y,translationX和translationY，其中x、y表示View 左上角的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。同样的，他们也有相应的get/set方法，translationX和translationY的默认值均为0。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = left + translationX;</span><br><span class=\"line\">y = right + translationY;</span><br></pre></td></tr></table></figure></p>\n<p>在View 的移动过程中top和left 表示原始左上角坐标，并不会改变。</p>\n<h3 id=\"2-2、MotionEvent和TouchSlop\"><a href=\"#2-2、MotionEvent和TouchSlop\" class=\"headerlink\" title=\"2.2、MotionEvent和TouchSlop\"></a>2.2、MotionEvent和TouchSlop</h3><p><strong>（1）、MotionEvent</strong><br>在手指触摸屏幕后，会有一系列的事件，主要事件类型有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACTION_DOWN // 收支接触</span><br><span class=\"line\">ACTION_MOVE // 手指在屏幕上移动</span><br><span class=\"line\">ACTION_UP //手指从屏幕松开</span><br><span class=\"line\">ACTION_CANCEL //取消</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>使用 <code>MotionEvent</code> 对象获取的 点击的 x 和 y ,使用 <code>getX / getY</code> 获取的是相对于当前View左上角的x和y,而 <code>getRawX / getRawY</code> 获取的是相对于手机屏幕左上角的坐标。</p>\n<p><strong>（2）、TouchSlop</strong><br>TouchSlop 是系统所能识别的最小滑动距离，小于它则视未发生滑动，他和设备相关，在不同的设备上获取的值不同。通过 <code>ViewConfiguration.get(getContext()).getScaledTouchSlop();</code> 获取。</p>\n<h3 id=\"2-3、VelocityTracker、GestureDetector和Scroller\"><a href=\"#2-3、VelocityTracker、GestureDetector和Scroller\" class=\"headerlink\" title=\"2.3、VelocityTracker、GestureDetector和Scroller\"></a>2.3、VelocityTracker、GestureDetector和Scroller</h3><p><strong>（1）、VelocityTracker</strong><br>速度追踪，用于追踪滑动过程中的速度，包括水平和竖直速度。如下具体使用步骤：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.在 onTouchEvent 方法中追踪当前事件的速度</span><br><span class=\"line\">VelocityTracker  tracker = VelocityTracker.obtain();</span><br><span class=\"line\">tracker.addMovement(event);</span><br><span class=\"line\">//2.获取当前速度</span><br><span class=\"line\">tracker.computeCurrentVelocity(1000);//计算速度</span><br><span class=\"line\">int xVelocity = (int) tracker.getXVelocity();</span><br><span class=\"line\">int yVelocity = (int) tracker.getYVelocity();</span><br><span class=\"line\">//3.在不需要的时候重置回收内存</span><br><span class=\"line\">tracker.recycle();</span><br></pre></td></tr></table></figure>\n<p><strong>（2）、GestureDetector</strong><br>手势检测，用于检测单击、滑动、长按、双击等手势。<br>在使用时，首先要实现 <code>GestureDetector.OnGestureListener</code>接口，如果需要双击，则需实现 <code>GestureDetector.OnDoubleTapListener</code> 接口；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//设置监听</span><br><span class=\"line\">mGestureDetector = new GestureDetector(this);</span><br><span class=\"line\">//避免长按后无法拖动，自己测试时发现不设置，长按后也可以拖动</span><br><span class=\"line\">mGestureDetector.setIsLongpressEnabled(false);</span><br></pre></td></tr></table></figure>\n<p>然后在 onTouchEvent 添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean consume = mGestureDetector.onTouchEvent(event);</span><br><span class=\"line\">return consume;</span><br></pre></td></tr></table></figure>\n<p>GestureDetector 类中的 OnGestureListener 接口和 OnDoubleTapListener 接口相关实现方法说明：</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">所属接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onDown</td>\n<td style=\"text-align:center\">手指轻触，一个ACTION_DOWN 触发</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td>onShowPress</td>\n<td style=\"text-align:center\">手指轻触，尚未松开或者拖动</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td>onSingleTapUp</td>\n<td style=\"text-align:center\">单击：手指（轻触后）松开，伴随一个ACTION_UP触发</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td>onScroll</td>\n<td style=\"text-align:center\">拖动：手指按下并拖动，一个ACTION_DOWN，多个ACTION_MOVE</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td>onLongPress</td>\n<td style=\"text-align:center\">长按</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td>onFling</td>\n<td style=\"text-align:center\">快速滑动：按下快速滑动并松开</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>onSingleTapConfirmed</td>\n<td style=\"text-align:center\">严格单击：这个只可能是单击，不会是双击中的一次单击</td>\n<td style=\"text-align:center\">OnDoubleTapListener</td>\n</tr>\n<tr>\n<td>onDoubleTap</td>\n<td style=\"text-align:center\">双击 :与onSingleTapConfirmed 不共存</td>\n<td style=\"text-align:center\">OnDoubleTapListener</td>\n</tr>\n<tr>\n<td>onDoubleTapEvent</td>\n<td style=\"text-align:center\">表示发生了双击行为</td>\n<td style=\"text-align:center\">OnDoubleTapListener</td>\n</tr>\n</tbody>\n</table>\n<p><strong>（3）、Scroller</strong><br>弹性滑动，可是实现有过度效果的滑动，View 的 ScrollTo/ScrollBy 都是瞬间滑动完成的。</p>\n<h2 id=\"三、View-的滑动\"><a href=\"#三、View-的滑动\" class=\"headerlink\" title=\"三、View 的滑动\"></a>三、View 的滑动</h2><p>实现View的滑动主要有如下三种方式:</p>\n<ol>\n<li><strong>scrollTo /scrollBy</strong> :适合对view 的内容改变；</li>\n<li><strong>动画</strong>： 主要用于没有交互的View 和实现复杂的动画效果；</li>\n<li><strong>改变布局参数</strong>：操作稍微复杂，适合有交互的View 。</li>\n</ol>\n<h3 id=\"3-1-通过View-的-ScrollTo-ScrollBy-方法\"><a href=\"#3-1-通过View-的-ScrollTo-ScrollBy-方法\" class=\"headerlink\" title=\"3.1. 通过View 的 ScrollTo/ScrollBy 方法\"></a>3.1. 通过View 的 ScrollTo/ScrollBy 方法</h3><p>View 源码中的相关实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">   * Set the scrolled position of your view. This will cause a call to</span><br><span class=\"line\">   * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be</span><br><span class=\"line\">   * invalidated.</span><br><span class=\"line\">   * @param x the x position to scroll to</span><br><span class=\"line\">   * @param y the y position to scroll to</span><br><span class=\"line\">   */</span><br><span class=\"line\">  public void scrollTo(int x, int y) &#123;</span><br><span class=\"line\">      if (mScrollX != x || mScrollY != y) &#123;</span><br><span class=\"line\">          int oldX = mScrollX;</span><br><span class=\"line\">          int oldY = mScrollY;</span><br><span class=\"line\">          mScrollX = x;</span><br><span class=\"line\">          mScrollY = y;</span><br><span class=\"line\">          invalidateParentCaches();</span><br><span class=\"line\">          onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class=\"line\">          if (!awakenScrollBars()) &#123;</span><br><span class=\"line\">              postInvalidateOnAnimation();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    /**</span><br><span class=\"line\">   * Move the scrolled position of your view. This will cause a call to</span><br><span class=\"line\">   * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be</span><br><span class=\"line\">   * invalidated.</span><br><span class=\"line\">   * @param x the amount of pixels to scroll by horizontally</span><br><span class=\"line\">   * @param y the amount of pixels to scroll by vertically</span><br><span class=\"line\">   */</span><br><span class=\"line\">  public void scrollBy(int x, int y) &#123;</span><br><span class=\"line\">      scrollTo(mScrollX + x, mScrollY + y);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>scrollBy</code> 调用的是 <code>scrollTo</code>，它实现了使用当前位置的相对滑动，而 <code>scrollTo</code> 是基于所传参数的绝对滑动。<strong>在滑动过程中，mScrollX 的值等于 View 左边缘 和 View 内容左边缘在水平方向的距离，而 mScrollY 则是View 上边缘和 View 内容上边缘在竖直方向的距离。他们都是以像素单位。如果从 左往右/从上往下 滑动，mScrollX/mScrollY 为正。</strong></p>\n<p>scrollBy 和 scrollTo 只能改变 View 内容的位置而不能改变View 在布局中的位置。</p>\n<p>如下滑动过程中，mScrollX/mScrollY 取值情况：</p>\n<p><img src=\"/img/article_img/2016/View 中的scrollTo和scrollBy.png\" alt=\"\"></p>\n<h3 id=\"3-2-使用动画\"><a href=\"#3-2-使用动画\" class=\"headerlink\" title=\"3.2. 使用动画\"></a>3.2. 使用动画</h3><p>通过动画为View 添加平移效果，View 的 tanslationX 和 tanslationY 属性，可以采用传统的动画和属性动画。<br>动画不能真正的改变 View 的位置，只是移动的是他的影像，如果在新位置有点击事件，则无效。但是在android 3.0以后属性动画解决了该问题。</p>\n<h3 id=\"3-3-改变布局参数\"><a href=\"#3-3-改变布局参数\" class=\"headerlink\" title=\"3.3. 改变布局参数\"></a>3.3. 改变布局参数</h3><p>通过改变View 的LayoutParams 使得 View 重新布局实现滑动。<br>这里以 把 Button 水平移动 100px 为例。可以改变 Button 的 <code>marginLeft</code> ,或者在其左边放一个宽度为0 的view,当要平移时改变他的宽度，使其被挤到右边（加入Button的父布局为LinearLayout），实现滑动。</p>\n<p>如下是改变 <code>LayoutParams</code>的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams)</span><br><span class=\"line\">                mButton.getLayoutParams();</span><br><span class=\"line\">params.width += 100;</span><br><span class=\"line\">params.leftMargin += 100;</span><br><span class=\"line\">mButton.setLayoutParams(params);  // 或者  mButton.requestLayout();</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、弹性滑动\"><a href=\"#四、弹性滑动\" class=\"headerlink\" title=\"四、弹性滑动\"></a>四、弹性滑动</h2><p>为了避免 滑动的生硬，可以采用弹性滑动，提高用户体验。这里主要有 ：Scroller、动画、延时三种方式。</p>\n<p>如下是 <code>Scroller</code> 的典型使用，主要是 <strong>invalidate</strong>方法起的作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scroller mScroller = new Scroller(context);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 滑动到指定位置</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param destX  X 滑动距离</span><br><span class=\"line\"> * @param destY  Y 滑动距离</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void smoothScrollTo(int destX, int destY) &#123;</span><br><span class=\"line\">    //滑动起点X</span><br><span class=\"line\">    int scrollX = getScrollX();</span><br><span class=\"line\">    //滑动起点Y</span><br><span class=\"line\">    int scrollY = getScrollY();</span><br><span class=\"line\">    //1000 ms内慢慢滑向 （destX，destY）</span><br><span class=\"line\">    mScroller.startScroll(scrollX, scrollY, destX, destY, 1000);</span><br><span class=\"line\">    //重绘</span><br><span class=\"line\">    invalidate();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> /**</span><br><span class=\"line\"> * 使View 不断重绘</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void computeScroll() &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  computeScrollOffset 方法通过时间流逝百分比计算 scrollX和scrollY </span><br><span class=\"line\">     *  返回true 表示滑动未结束</span><br><span class=\"line\">     */</span><br><span class=\"line\">    if (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">        //滑动到当前位置，通过小幅度滑动实现弹性滑动</span><br><span class=\"line\">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class=\"line\">        //再次重绘</span><br><span class=\"line\">        postInvalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如下 <strong>Scroller 的滑动原理（相关方法的调用过程）</strong>：</p>\n<p><img src=\"/img/article_img/2016/Scroller滑动机制.png\" alt=\"\"></p>\n<p>对于延时达到弹性滑动，主要是利用 了Handler 或者 View 的 postDelayed 方法，或者线程的 sleep方法。</p>\n<h2 id=\"五、View-的事件分发机制\"><a href=\"#五、View-的事件分发机制\" class=\"headerlink\" title=\"五、View 的事件分发机制\"></a>五、View 的事件分发机制</h2><p>在 view 中事件分发十分重要，了解他的原理，对我们理解View 和解决滑动冲突都十分重要。</p>\n<blockquote>\n<ol>\n<li>所有的Touch事件都封装到 <code>MotionEvent</code> 里面；</li>\n<li>事件处理包括三种情况，分别为：<strong>传递—-dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费—-onTouchEvent()函数和OnTouchListener</strong>；</li>\n<li>事件类型分为 ACTION_DOWN, ACTION_UP, ACTION_MOVE , ACTION_POINTER_DOWN, ACTION_POINTER_UP , ACTION_CANCEL 等，每个事件都是以 ACTION_DOWN 开始 ACTION_UP 结束。</li>\n</ol>\n</blockquote>\n<p>用下面伪代码表示事件分发过程及其关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//事件分发</span><br><span class=\"line\">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">    boolean consume = false;</span><br><span class=\"line\">    //是否被拦截</span><br><span class=\"line\">    if (onInterceptTouchEvent(event))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //被拦截，处理事件</span><br><span class=\"line\">        consume = onTouchEvent(event);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        //未被拦截，向下分发</span><br><span class=\"line\">        consume = childView.dispatchTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return consume;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>事件传递的基本流程</strong>：</p>\n<ul>\n<li>事件都是从Activity.dispatchTouchEvent()开始传递；</li>\n<li>事件由父View传递给子View，ViewGroup可以通过onInterceptTouchEvent()方法对事件拦截，停止其向子view传递；</li>\n<li>如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数；</li>\n<li>如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来，也就是说ACTION_DOWN必须返回true，之后的事件才会传递进来；</li>\n<li>OnTouchListener优先于onTouchEvent()对事件进行消费。</li>\n</ul>\n<h2 id=\"六、View-的滑动冲突\"><a href=\"#六、View-的滑动冲突\" class=\"headerlink\" title=\"六、View 的滑动冲突\"></a>六、View 的滑动冲突</h2><p>滑动冲突的出现是由于内外两个view都是可以滑动的，如 ScrollView 中嵌套 ListView 。常见的滑动冲突场景有：</p>\n<ul>\n<li>场景一：内外滑动方向不一致；</li>\n<li>场景二：内外滑动方向一致；</li>\n<li>场景三：上述两种场景的嵌套。</li>\n</ul>\n<p>对于场景一，可以根据水平竖直方向的滑动距离差判断是哪种滑动，进行相应的拦截；场景二，可以通过自己的业务制定相应的处理规则，然后进行处理；场景三则结合前两种进行。</p>\n<p>有些滑动冲突是采用了不合理的布局导致，可以更换布局，而有些则必须通过自定义控件重写拦截和分发事件处理。</p>\n","excerpt":"<blockquote>\n<p>本文为读书笔记： 《Android 开发艺术探索 》——第三章 View 的事件体系     </p>\n</blockquote>\n<p>android 系统虽然提供了很多基本的控件，如Button、TextView等，但是很多时候系统提供的view不能满足我们的需求，此时就需要我们根据自己的需求进行自定义控件。这些控件都是继承自View的。<br>","more":"</p>\n<h2 id=\"一、android-控件架构\"><a href=\"#一、android-控件架构\" class=\"headerlink\" title=\"一、android 控件架构\"></a>一、android 控件架构</h2><p>android 中的控件在界面上都会占一块巨型区域，主要分为两类：ViewGroup和View控件。ViewGroup作为父控件可以包含多个View控件，并管理他们，但其也是继承自View。通过Viewgroup，整个控件界面形成了View的控件树，如图1所示。</p>\n<p>上层控件负责字控件的测量与绘制，并传递交互事件。在Activity 中 通过<code>findViewById()</code>方法，就是以树的 <em>深度优先遍历</em>  查找对应的控件。控件树的顶部都有一个ViewParent 对象，对整个视图进行控制。<br><img src=\"/img/article_img/2016/view.png\" alt=\"\"></p>\n<p>如上面图2 所示，是android 界面的架构图，在activity 中 通过 <code>setContentView()</code> 方法设置为根布局。在每一个Activity 中 都包含一个Window 对象，它由 PhoneWindow来实现，PhoneWindow 讲一个 DecorView 设置为整个应用窗口的根View。DecorView 作为窗口界面的顶层视图，封装了一些窗口操作的通用方法，所有View 的监听事件，都通过<code>WindowManagerService</code> 进行接收，并通过Activity 对象来回调相应的onClickListener。对于DecorView，他由TitleView 和ContentView 组成，<br>前者承载的是一个<code>Actionbar</code>，后者承载的是一个<code>FrameLayout</code>。</p>\n<h2 id=\"二、View-的基本知识\"><a href=\"#二、View-的基本知识\" class=\"headerlink\" title=\"二、View 的基本知识\"></a>二、View 的基本知识</h2><h3 id=\"2-1、View-的位置参数\"><a href=\"#2-1、View-的位置参数\" class=\"headerlink\" title=\"2.1、View 的位置参数\"></a>2.1、View 的位置参数</h3><p>view 的位置由两个顶点坐标来决定，主要是左上（left,top）和右下(right,bottom)坐标。他们是相对于View 的父容器来说的，是相对坐标。如下图他们的关系：<br><img src=\"/img/article_img/2016/view_zuobiao.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width = right - left;</span><br><span class=\"line\">height = bottom - top;</span><br></pre></td></tr></table></figure>\n<p>在View 中都有相应的方法来获取他们的值。从android 3.0开始，View增加了几个参数：x,y,translationX和translationY，其中x、y表示View 左上角的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。同样的，他们也有相应的get/set方法，translationX和translationY的默认值均为0。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = left + translationX;</span><br><span class=\"line\">y = right + translationY;</span><br></pre></td></tr></table></figure></p>\n<p>在View 的移动过程中top和left 表示原始左上角坐标，并不会改变。</p>\n<h3 id=\"2-2、MotionEvent和TouchSlop\"><a href=\"#2-2、MotionEvent和TouchSlop\" class=\"headerlink\" title=\"2.2、MotionEvent和TouchSlop\"></a>2.2、MotionEvent和TouchSlop</h3><p><strong>（1）、MotionEvent</strong><br>在手指触摸屏幕后，会有一系列的事件，主要事件类型有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACTION_DOWN // 收支接触</span><br><span class=\"line\">ACTION_MOVE // 手指在屏幕上移动</span><br><span class=\"line\">ACTION_UP //手指从屏幕松开</span><br><span class=\"line\">ACTION_CANCEL //取消</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>使用 <code>MotionEvent</code> 对象获取的 点击的 x 和 y ,使用 <code>getX / getY</code> 获取的是相对于当前View左上角的x和y,而 <code>getRawX / getRawY</code> 获取的是相对于手机屏幕左上角的坐标。</p>\n<p><strong>（2）、TouchSlop</strong><br>TouchSlop 是系统所能识别的最小滑动距离，小于它则视未发生滑动，他和设备相关，在不同的设备上获取的值不同。通过 <code>ViewConfiguration.get(getContext()).getScaledTouchSlop();</code> 获取。</p>\n<h3 id=\"2-3、VelocityTracker、GestureDetector和Scroller\"><a href=\"#2-3、VelocityTracker、GestureDetector和Scroller\" class=\"headerlink\" title=\"2.3、VelocityTracker、GestureDetector和Scroller\"></a>2.3、VelocityTracker、GestureDetector和Scroller</h3><p><strong>（1）、VelocityTracker</strong><br>速度追踪，用于追踪滑动过程中的速度，包括水平和竖直速度。如下具体使用步骤：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.在 onTouchEvent 方法中追踪当前事件的速度</span><br><span class=\"line\">VelocityTracker  tracker = VelocityTracker.obtain();</span><br><span class=\"line\">tracker.addMovement(event);</span><br><span class=\"line\">//2.获取当前速度</span><br><span class=\"line\">tracker.computeCurrentVelocity(1000);//计算速度</span><br><span class=\"line\">int xVelocity = (int) tracker.getXVelocity();</span><br><span class=\"line\">int yVelocity = (int) tracker.getYVelocity();</span><br><span class=\"line\">//3.在不需要的时候重置回收内存</span><br><span class=\"line\">tracker.recycle();</span><br></pre></td></tr></table></figure>\n<p><strong>（2）、GestureDetector</strong><br>手势检测，用于检测单击、滑动、长按、双击等手势。<br>在使用时，首先要实现 <code>GestureDetector.OnGestureListener</code>接口，如果需要双击，则需实现 <code>GestureDetector.OnDoubleTapListener</code> 接口；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//设置监听</span><br><span class=\"line\">mGestureDetector = new GestureDetector(this);</span><br><span class=\"line\">//避免长按后无法拖动，自己测试时发现不设置，长按后也可以拖动</span><br><span class=\"line\">mGestureDetector.setIsLongpressEnabled(false);</span><br></pre></td></tr></table></figure>\n<p>然后在 onTouchEvent 添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean consume = mGestureDetector.onTouchEvent(event);</span><br><span class=\"line\">return consume;</span><br></pre></td></tr></table></figure>\n<p>GestureDetector 类中的 OnGestureListener 接口和 OnDoubleTapListener 接口相关实现方法说明：</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">所属接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onDown</td>\n<td style=\"text-align:center\">手指轻触，一个ACTION_DOWN 触发</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td>onShowPress</td>\n<td style=\"text-align:center\">手指轻触，尚未松开或者拖动</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td>onSingleTapUp</td>\n<td style=\"text-align:center\">单击：手指（轻触后）松开，伴随一个ACTION_UP触发</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td>onScroll</td>\n<td style=\"text-align:center\">拖动：手指按下并拖动，一个ACTION_DOWN，多个ACTION_MOVE</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td>onLongPress</td>\n<td style=\"text-align:center\">长按</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td>onFling</td>\n<td style=\"text-align:center\">快速滑动：按下快速滑动并松开</td>\n<td style=\"text-align:center\">OnGestureListener</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>onSingleTapConfirmed</td>\n<td style=\"text-align:center\">严格单击：这个只可能是单击，不会是双击中的一次单击</td>\n<td style=\"text-align:center\">OnDoubleTapListener</td>\n</tr>\n<tr>\n<td>onDoubleTap</td>\n<td style=\"text-align:center\">双击 :与onSingleTapConfirmed 不共存</td>\n<td style=\"text-align:center\">OnDoubleTapListener</td>\n</tr>\n<tr>\n<td>onDoubleTapEvent</td>\n<td style=\"text-align:center\">表示发生了双击行为</td>\n<td style=\"text-align:center\">OnDoubleTapListener</td>\n</tr>\n</tbody>\n</table>\n<p><strong>（3）、Scroller</strong><br>弹性滑动，可是实现有过度效果的滑动，View 的 ScrollTo/ScrollBy 都是瞬间滑动完成的。</p>\n<h2 id=\"三、View-的滑动\"><a href=\"#三、View-的滑动\" class=\"headerlink\" title=\"三、View 的滑动\"></a>三、View 的滑动</h2><p>实现View的滑动主要有如下三种方式:</p>\n<ol>\n<li><strong>scrollTo /scrollBy</strong> :适合对view 的内容改变；</li>\n<li><strong>动画</strong>： 主要用于没有交互的View 和实现复杂的动画效果；</li>\n<li><strong>改变布局参数</strong>：操作稍微复杂，适合有交互的View 。</li>\n</ol>\n<h3 id=\"3-1-通过View-的-ScrollTo-ScrollBy-方法\"><a href=\"#3-1-通过View-的-ScrollTo-ScrollBy-方法\" class=\"headerlink\" title=\"3.1. 通过View 的 ScrollTo/ScrollBy 方法\"></a>3.1. 通过View 的 ScrollTo/ScrollBy 方法</h3><p>View 源码中的相关实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">   * Set the scrolled position of your view. This will cause a call to</span><br><span class=\"line\">   * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be</span><br><span class=\"line\">   * invalidated.</span><br><span class=\"line\">   * @param x the x position to scroll to</span><br><span class=\"line\">   * @param y the y position to scroll to</span><br><span class=\"line\">   */</span><br><span class=\"line\">  public void scrollTo(int x, int y) &#123;</span><br><span class=\"line\">      if (mScrollX != x || mScrollY != y) &#123;</span><br><span class=\"line\">          int oldX = mScrollX;</span><br><span class=\"line\">          int oldY = mScrollY;</span><br><span class=\"line\">          mScrollX = x;</span><br><span class=\"line\">          mScrollY = y;</span><br><span class=\"line\">          invalidateParentCaches();</span><br><span class=\"line\">          onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class=\"line\">          if (!awakenScrollBars()) &#123;</span><br><span class=\"line\">              postInvalidateOnAnimation();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    /**</span><br><span class=\"line\">   * Move the scrolled position of your view. This will cause a call to</span><br><span class=\"line\">   * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be</span><br><span class=\"line\">   * invalidated.</span><br><span class=\"line\">   * @param x the amount of pixels to scroll by horizontally</span><br><span class=\"line\">   * @param y the amount of pixels to scroll by vertically</span><br><span class=\"line\">   */</span><br><span class=\"line\">  public void scrollBy(int x, int y) &#123;</span><br><span class=\"line\">      scrollTo(mScrollX + x, mScrollY + y);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>scrollBy</code> 调用的是 <code>scrollTo</code>，它实现了使用当前位置的相对滑动，而 <code>scrollTo</code> 是基于所传参数的绝对滑动。<strong>在滑动过程中，mScrollX 的值等于 View 左边缘 和 View 内容左边缘在水平方向的距离，而 mScrollY 则是View 上边缘和 View 内容上边缘在竖直方向的距离。他们都是以像素单位。如果从 左往右/从上往下 滑动，mScrollX/mScrollY 为正。</strong></p>\n<p>scrollBy 和 scrollTo 只能改变 View 内容的位置而不能改变View 在布局中的位置。</p>\n<p>如下滑动过程中，mScrollX/mScrollY 取值情况：</p>\n<p><img src=\"/img/article_img/2016/View 中的scrollTo和scrollBy.png\" alt=\"\"></p>\n<h3 id=\"3-2-使用动画\"><a href=\"#3-2-使用动画\" class=\"headerlink\" title=\"3.2. 使用动画\"></a>3.2. 使用动画</h3><p>通过动画为View 添加平移效果，View 的 tanslationX 和 tanslationY 属性，可以采用传统的动画和属性动画。<br>动画不能真正的改变 View 的位置，只是移动的是他的影像，如果在新位置有点击事件，则无效。但是在android 3.0以后属性动画解决了该问题。</p>\n<h3 id=\"3-3-改变布局参数\"><a href=\"#3-3-改变布局参数\" class=\"headerlink\" title=\"3.3. 改变布局参数\"></a>3.3. 改变布局参数</h3><p>通过改变View 的LayoutParams 使得 View 重新布局实现滑动。<br>这里以 把 Button 水平移动 100px 为例。可以改变 Button 的 <code>marginLeft</code> ,或者在其左边放一个宽度为0 的view,当要平移时改变他的宽度，使其被挤到右边（加入Button的父布局为LinearLayout），实现滑动。</p>\n<p>如下是改变 <code>LayoutParams</code>的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams)</span><br><span class=\"line\">                mButton.getLayoutParams();</span><br><span class=\"line\">params.width += 100;</span><br><span class=\"line\">params.leftMargin += 100;</span><br><span class=\"line\">mButton.setLayoutParams(params);  // 或者  mButton.requestLayout();</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、弹性滑动\"><a href=\"#四、弹性滑动\" class=\"headerlink\" title=\"四、弹性滑动\"></a>四、弹性滑动</h2><p>为了避免 滑动的生硬，可以采用弹性滑动，提高用户体验。这里主要有 ：Scroller、动画、延时三种方式。</p>\n<p>如下是 <code>Scroller</code> 的典型使用，主要是 <strong>invalidate</strong>方法起的作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scroller mScroller = new Scroller(context);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 滑动到指定位置</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param destX  X 滑动距离</span><br><span class=\"line\"> * @param destY  Y 滑动距离</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void smoothScrollTo(int destX, int destY) &#123;</span><br><span class=\"line\">    //滑动起点X</span><br><span class=\"line\">    int scrollX = getScrollX();</span><br><span class=\"line\">    //滑动起点Y</span><br><span class=\"line\">    int scrollY = getScrollY();</span><br><span class=\"line\">    //1000 ms内慢慢滑向 （destX，destY）</span><br><span class=\"line\">    mScroller.startScroll(scrollX, scrollY, destX, destY, 1000);</span><br><span class=\"line\">    //重绘</span><br><span class=\"line\">    invalidate();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> /**</span><br><span class=\"line\"> * 使View 不断重绘</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void computeScroll() &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  computeScrollOffset 方法通过时间流逝百分比计算 scrollX和scrollY </span><br><span class=\"line\">     *  返回true 表示滑动未结束</span><br><span class=\"line\">     */</span><br><span class=\"line\">    if (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">        //滑动到当前位置，通过小幅度滑动实现弹性滑动</span><br><span class=\"line\">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class=\"line\">        //再次重绘</span><br><span class=\"line\">        postInvalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如下 <strong>Scroller 的滑动原理（相关方法的调用过程）</strong>：</p>\n<p><img src=\"/img/article_img/2016/Scroller滑动机制.png\" alt=\"\"></p>\n<p>对于延时达到弹性滑动，主要是利用 了Handler 或者 View 的 postDelayed 方法，或者线程的 sleep方法。</p>\n<h2 id=\"五、View-的事件分发机制\"><a href=\"#五、View-的事件分发机制\" class=\"headerlink\" title=\"五、View 的事件分发机制\"></a>五、View 的事件分发机制</h2><p>在 view 中事件分发十分重要，了解他的原理，对我们理解View 和解决滑动冲突都十分重要。</p>\n<blockquote>\n<ol>\n<li>所有的Touch事件都封装到 <code>MotionEvent</code> 里面；</li>\n<li>事件处理包括三种情况，分别为：<strong>传递—-dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费—-onTouchEvent()函数和OnTouchListener</strong>；</li>\n<li>事件类型分为 ACTION_DOWN, ACTION_UP, ACTION_MOVE , ACTION_POINTER_DOWN, ACTION_POINTER_UP , ACTION_CANCEL 等，每个事件都是以 ACTION_DOWN 开始 ACTION_UP 结束。</li>\n</ol>\n</blockquote>\n<p>用下面伪代码表示事件分发过程及其关系：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//事件分发</span><br><span class=\"line\">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">    boolean consume = false;</span><br><span class=\"line\">    //是否被拦截</span><br><span class=\"line\">    if (onInterceptTouchEvent(event))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //被拦截，处理事件</span><br><span class=\"line\">        consume = onTouchEvent(event);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        //未被拦截，向下分发</span><br><span class=\"line\">        consume = childView.dispatchTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return consume;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>事件传递的基本流程</strong>：</p>\n<ul>\n<li>事件都是从Activity.dispatchTouchEvent()开始传递；</li>\n<li>事件由父View传递给子View，ViewGroup可以通过onInterceptTouchEvent()方法对事件拦截，停止其向子view传递；</li>\n<li>如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数；</li>\n<li>如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来，也就是说ACTION_DOWN必须返回true，之后的事件才会传递进来；</li>\n<li>OnTouchListener优先于onTouchEvent()对事件进行消费。</li>\n</ul>\n<h2 id=\"六、View-的滑动冲突\"><a href=\"#六、View-的滑动冲突\" class=\"headerlink\" title=\"六、View 的滑动冲突\"></a>六、View 的滑动冲突</h2><p>滑动冲突的出现是由于内外两个view都是可以滑动的，如 ScrollView 中嵌套 ListView 。常见的滑动冲突场景有：</p>\n<ul>\n<li>场景一：内外滑动方向不一致；</li>\n<li>场景二：内外滑动方向一致；</li>\n<li>场景三：上述两种场景的嵌套。</li>\n</ul>\n<p>对于场景一，可以根据水平竖直方向的滑动距离差判断是哪种滑动，进行相应的拦截；场景二，可以通过自己的业务制定相应的处理规则，然后进行处理；场景三则结合前两种进行。</p>\n<p>有些滑动冲突是采用了不合理的布局导致，可以更换布局，而有些则必须通过自定义控件重写拦截和分发事件处理。</p>"},{"title":"AsyncTask 工作原理及线程池","date":"2017-01-06T08:06:25.000Z","_content":"\n> 读书笔记： 《Android 开发艺术探索》 ——第十一章：android 线程及线程池\n\n在 android 中，线程通常为主线程和子线程，前者主要处理和界面相关的事情，而后者主要用于耗时操作。\nandroid 中的线程主要有 `Thread`、`AsyncTask`、`IntentService` 和 `HandlerThread` 。\n<!--more-->\n## 一、android 中的线程形态\n\nAsyncTask、IntentService 和 HandlerThread 的底层实现都是线程，但都有特殊的表现形式，各有优缺点。 \n**AsyncTask** 封装了 线程池 和 Handler ，主要用于子线程更新UI；**HandlerThread** 是一种具有消息循环的线程，内部可以使用 Handler ； **IntentService** 是一个服务，内部采用 HandlerThread 执行任务，它类似一个后台线程，但是一个服务，不容易被杀死。\n\n### 1.1 AsyncTask\n\nAsyncTask 是一个轻量级的异步线程任务类，它在线程池中执行后台任务，然后把进度和最终结果传递给主线程并在主线程中更新UI，它封装了 Thread 和 Handler，但不适合特别耗时的后台任务，对于特别耗时的任务可以用线程池。\n\n\nAsyncTask 是一个**抽象的泛型类**，有 Params, Progress, Result 三个泛型参数，分别表示参数类型、后台任务执行进度类型、后台任务返回结果类型。如果不需要具体的参数，可用 Void 代替。\n```\npublic abstract class AsyncTask<Params, Progress, Result> {}\n```\n\n核心方法如下：\n\n- **onPreExecute()**\n在主线程中执行，异步任务之前调用，一般用于做准备工作。\n- **doInBackground(Params... params)**\n在线程池中执行异步任务，可以通过 publishProgress （最终会调用onProgressUpdate）方法更新任务进度，次啊外该方法需要计算返回结果给onPostExecute。\n- **onProgressUpdate((Progress... values)**\n在主线程中当任务进度改变后被调用\n- **onPostExecute(Result result)**\n在主线程中执行，异步任务执行完后，result 是 doInBackground 返回的值。\n\n使用时注意事项：\n\n-  AsyncTask 必须在主线程中加载\n- AsyncTask 的对象必须在主线程中创建\n- execute 方法必须在UI线程中调用\n- 不要在程序中直接调用 上述和新方法\n- 一个 AsyncTask 对象只能调用一次 execute 方法\n- AsyncTask 在 android3.0后 ，用一个线程串行执行任务。\n\n\n在使用 AsyncTask 时调用了 execute方法，而该方法调用了 executeOnExecutor ，如下源码：\n\n```\n @MainThread\npublic final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n}\n@MainThread\npublic final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,\n        Params... params) {\n    if (mStatus != Status.PENDING) {\n        switch (mStatus) {\n            case RUNNING:\n                throw new IllegalStateException(\"Cannot execute task:\"\n                        + \" the task is already running.\");\n            case FINISHED:\n                throw new IllegalStateException(\"Cannot execute task:\"\n                        + \" the task has already been executed \"\n                        + \"(a task can be executed only once)\");\n        }\n    }\n\n    mStatus = Status.RUNNING;\n\n    onPreExecute();\n\n    mWorker.mParams = params;\n    exec.execute(mFuture);\n\n    return this;\n}\n```\nsDefaultExecutor 是一个串行的线程池，所有的任务都在该线程池中排队执行。这里也可以发现 AsyncTask 的 onPreExecute 方法是先执行的。mFuture 是一个 FutureTask（一个并发类） 对象，在AsyncTask的构造函数中通过 mWorker 进行实例化，而 mWorker 中 保存的有AsyncTask的参数。\n如下 AsyncTask 的构造方法：\n```\npublic AsyncTask() {\n    mWorker = new WorkerRunnable<Params, Result>() {\n        public Result call() throws Exception {\n            mTaskInvoked.set(true);\n            Result result = null;\n            try {\n                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                //noinspection unchecked\n                result = doInBackground(mParams);\n                Binder.flushPendingCommands();\n            } catch (Throwable tr) {\n                mCancelled.set(true);\n                throw tr;\n            } finally {\n                postResult(result);\n            }\n            return result;\n        }\n    };\n\n    mFuture = new FutureTask<Result>(mWorker) {\n        @Override\n        protected void done() {\n            try {\n                postResultIfNotInvoked(get());\n            } catch (InterruptedException e) {\n                android.util.Log.w(LOG_TAG, e);\n            } catch (ExecutionException e) {\n                throw new RuntimeException(\"An error occurred while executing doInBackground()\",\n                        e.getCause());\n            } catch (CancellationException e) {\n                postResultIfNotInvoked(null);\n            }\n        }\n    };\n}\n```\n\n下面是线程池的执行过程：\n\n```\npublic static final Executor SERIAL_EXECUTOR = new SerialExecutor();\nprivate static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;\n//...\nprivate static class SerialExecutor implements Executor {\n    final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n    Runnable mActive;\n\n    public synchronized void execute(final Runnable r) {\n        mTasks.offer(new Runnable() {\n            public void run() {\n                try {\n                    r.run();\n                } finally {\n                    scheduleNext();\n                }\n            }\n        });\n        if (mActive == null) {\n            scheduleNext();\n        }\n    }\n\n    protected synchronized void scheduleNext() {\n        if ((mActive = mTasks.poll()) != null) {\n            THREAD_POOL_EXECUTOR.execute(mActive);\n        }\n    }\n}\n```\n在 AsyncTask 执行时，首先将 参数封装成 FutureTask 对象，然后将其传入到 SerialExecutor 的 execute 方法中处理，首先通过  mTasks.offer() 方法将其添加到任务队列中，如果没有正在活动的任务，执行下一个任务 scheduleNext()。这里可以发现 AsyncTask 是串行执行的。 THREAD_POOL_EXECUTOR 是一个 线程池，真正的执行任务，而 SerialExecutor 负责任务的排队，InternalHandler 负责将执行环境从线程池切换到主线程中。\n\n由于 FutureTask 的run方法最终会调用 mWorker 中call方法，这里回看前面 AsyncTask 的构造方法，在 mWorker 中call方法中 先将 mTaskInvoked 设置为true ，表示当前任务已被调用过，然后执行 doInBackground 方法，并将其结果传给 postResult 方法，而 postResult 方法主要是 通过 sHandler （InternalHandler对象）发送一个  MESSAGE_POST_PROGRESS 消息，最后调用到 AsyncTask 的 finish方法，通过传入的 Result ，在 finish 中 最后确定是调用取消（`onCancelled(result)`）还是执行完成（`onPostExecute(result)`）。到此 ，AsyncTask 的整个工作流程结束。\n\nInternalHandler 是一个 静态的 Handler 对象，为了能将执行环境切换到主线程，则 sHandler 必须在主线程中创建，同时 变相要求了 AsyncTask 要在 主线程中 创建。\n\n\n\n### 1.2 HandlerThread\n\n`HandlerThread` 类继承自 Thread ，是一个可以使用 Handler 的 Thread。主要是**在其 run 方法中创建了消息队列和开启消息循环**。这样就可以 在 HandlerThread 中创建Handler。\n如下其 run方法：\n```\npublic void run() {\n    mTid = Process.myTid();\n    Looper.prepare();\n    synchronized (this) {\n        mLooper = Looper.myLooper();\n        notifyAll();\n    }\n    Process.setThreadPriority(mPriority);\n    onLooperPrepared();\n    Looper.loop();\n    mTid = -1;\n}\n```\nHandlerThread 的run 方法是一个无线循环方法，在不需要时可以 通过 `quit` 或者 `quitSafely` 进行终止。 HandlerThread 主要用在 IntentService 中，\n\n### 1.3 IntentService\n\n`IntentService` 是一个特殊的 service  ，继承自 Service，并且是一个抽象类，使用时必须创建其子类方可使用，它主要用于执行后台耗时任务，完成后自动关闭，它的优先级比普通的线程高，比较适合执行一些高优先级的后台任务。在其内部封装了 `HandlerThread` 和 `Handler（ServiceHandler）` 。如下其 `onCreate` 方法：\n```\npublic void onCreate()\n{\n    super.onCreate();\n    HandlerThread thread = new HandlerThread (\"IntentService[\" + mName + \"]\");\n    thread.start();\n\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = new ServiceHandler (mServiceLooper);\n}\n```\nIntentService 在初次启动时调用 onCreate 方法，此时创建 HandlerThread ，然后通过它的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最后都在 HandlerThread 中处理，这导致 IntentService 也是顺序执行后台任务的。\n\n每次启动 IntentService ，它的 onStartCommand 会被调用，处理每一个后台任务，调用了 onStart 方法 ,通过 mServiceHandler 发送一个消息，最后在 HandlerThread 中处理。\n```\npublic int onStartCommand (@Nullable Intent intent, int flags, int startId)\n{\n    onStart (intent, startId);\n    return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;\n}\n\npublic void onStart (@Nullable Intent intent, int startId)\n{\n    Message msg = mServiceHandler.obtainMessage();\n    msg.arg1 = startId;\n    msg.obj = intent;\n    mServiceHandler.sendMessage (msg);\n}\n```\n如下是 ServiceHandler 类的定义：\n```\nprivate final class ServiceHandler extends Handler\n{\n    public ServiceHandler (Looper looper)\n    {\n        super (looper);\n    }\n\n    @Override\n    public void handleMessage (Message msg)\n    {\n        onHandleIntent ( (Intent) msg.obj);\n        stopSelf (msg.arg1);\n    }\n}\n```\nmServiceHandler 收到消息后会将 Intent 对象传递给 onHandleIntent 处理，这里的 Intent 和 startService(intent) 中的 intent 完全一致，这样通过 这个 intent 就可以解析出外界启动 IntentService 所传递的参数，在 onHandleIntent 方法 中对不同的后台任务做处理。当 onHandleIntent 执行完后 调用 stopSelf ，停止服务。\n\n上面提到的 onHandleIntent 方法是一个抽象方法，在使用时需要实现。\n\n## 二、android中的线程池\n线程池主要有如下几个优点：\n\n- 重用线程池中的线程，避免因线程的重复创建和销毁导致的性能开销；\n- 能有效控制线程池的最大并发数，避免线程相互抢占资源导致阻塞；\n- 能够对线程进行简单的管理，提供定时执行等功能。\n\n### 2.1  ThreadPoolExecutor\nandroid 中的线程池 源于 java 中的 Exector,Exector是一个接口，真正的线程池的实现类为 ThreadPoolExecutor 类，它提供了一系列的参数来配置线程池，通过不同的参数可以创建不同的线程池。\n如下他它的一个常用构造方法的声明：\n```\npublic ThreadPoolExecutor (int corePoolSize,\n                           int maximumPoolSize,\n                           long keepAliveTime,\n                           TimeUnit unit,\n                           BlockingQueue<Runnable> workQueue,\n                           ThreadFactory threadFactory)\n```\n参数说明：\n\n- **corePoolSize** \n核心线程数，默认情况下 一直存活着，即使处于闲置状态。将 allowCoreThreadTimeOut 属性设置为 true 时，闲置的核心线程等待新任务到来时会有超时策略，改时间间隔由 keepAliveTime 所指定，当时间超过 keepAliveTime 后，线程会被终止。\n- **maximumPoolSize**\n最大线程数，当线程数达到该值后，后续的线程会被阻塞。\n- **keepAliveTime**\n非核心线程闲置的超时时长，超过后就会被回收。\n- **unit**\n指定 keepAliveTime 参数的时间单位，常用的有 TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）等\n- **workQueue**\n线程池中的任务队列\n- **threadFactory**\n线程工厂，为线程池提供创建新线程的功能，是一个 接口。\n\n如下是 AsyncTask 中 THREAD_POOL_EXECUTOR 线程池的配置：\n```\n//cpu 数\nprivate static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();\n//核心线程 \nprivate static final int CORE_POOL_SIZE = Math.max (2, Math.min (CPU_COUNT - 1, 4) );\n//线程池最大线程数 \nprivate static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;\n//闲置超时时间 30s\nprivate static final int KEEP_ALIVE_SECONDS = 30;\n\nprivate static final ThreadFactory sThreadFactory = new ThreadFactory()\n{\n    private final AtomicInteger mCount = new AtomicInteger (1);\n\n    public Thread newThread (Runnable r)\n    {\n        return new Thread (r, \"AsyncTask #\" + mCount.getAndIncrement() );\n    }\n};\n//任务队列容量 128\nprivate static final BlockingQueue<Runnable> sPoolWorkQueue =\n    new LinkedBlockingQueue<Runnable> (128);\npublic static final Executor THREAD_POOL_EXECUTOR;\n\nstatic\n{\n    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor (\n        CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,\n        sPoolWorkQueue, sThreadFactory);\n    threadPoolExecutor.allowCoreThreadTimeOut (true);\n    THREAD_POOL_EXECUTOR = threadPoolExecutor;\n}\n```\n### 2.2 线程池的分类\n\n除了 前面 的 ThreadPoolExecutor ，android 中还有如下四类线程池，他们都直接或者间接的通过配置 ThreadPoolExecutor 来实现自己的功能，通过 `Executors` 对应的new方法来创建。\n\n- **FixedThreadPool**\n通过 `Executors.newFixedThreadPool()` 创建，线程数固定的线程池，线程空闲时不会被回收，除非线程池被关闭。这种方式创建的线程池中只有核心线程且不会超时，任务队列无大小限制，能够更快的响应外界的请求。\n \n ```\n public static ExecutorService newFixedThreadPool (int nThreads)\n{\n    return new ThreadPoolExecutor (nThreads, nThreads,\n                                   0L, TimeUnit.MILLISECONDS,\n                                   new LinkedBlockingQueue<Runnable>() );\n}\n ```\n \n- **CachedThreadPool**\n通过 `Executors.newCachedThreadPool()` 创建，是一种线程数不固定的线程池，只有核心线程，最大数为 Integer.MAX_VALUE，超时时间60s。\n\n ```\n public static ExecutorService newCachedThreadPool()\n{\n    return new ThreadPoolExecutor (0, Integer.MAX_VALUE,\n                                   60L, TimeUnit.SECONDS,\n                                   new SynchronousQueue<Runnable>() );\n}\n ```\n\n- **ScheduledThreadPool**\n通过 `Executors.newScheduledThreadPool()` 创建，是一种核心线程数固定，非核心线程数不固定的线程池。主要用于执行定时任务和具有固定周期的重复任务。\n\n ```\n public static ScheduledExecutorService newScheduledThreadPool (int corePoolSize)\n{\n    return new ScheduledThreadPoolExecutor (corePoolSize);\n}\npublic ScheduledThreadPoolExecutor (int corePoolSize)\n{\n    super (corePoolSize, Integer.MAX_VALUE,\n           DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,\n           new DelayedWorkQueue() );\n}\n ```\n \n- **SingleThreadExecutor**\n通过 `Executors.newSingleThreadExecutor()` 创建，内部只有一个线程，可以确保所有的任务都在同一个线程中顺序执行，可以统一外界的任务到一个线程中。\n \n ```\n public static ExecutorService newSingleThreadExecutor()\n{\n    return new FinalizableDelegatedExecutorService\n           (new ThreadPoolExecutor (1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>() ) );\n}\n\n ```\n这是系统提供的四种常见的 线程池，此外还可以根据自己的实际需要灵活的配置线程池。\n\n\n\n","source":"_posts/AsyncTask 工作原理及线程池.md","raw":"\n---\ntitle: AsyncTask 工作原理及线程池\ndate: 2017-1-6 16:06:25\ncategories: [android,学习笔记]\ntags: [AsyncTask,线程池]\n---\n\n> 读书笔记： 《Android 开发艺术探索》 ——第十一章：android 线程及线程池\n\n在 android 中，线程通常为主线程和子线程，前者主要处理和界面相关的事情，而后者主要用于耗时操作。\nandroid 中的线程主要有 `Thread`、`AsyncTask`、`IntentService` 和 `HandlerThread` 。\n<!--more-->\n## 一、android 中的线程形态\n\nAsyncTask、IntentService 和 HandlerThread 的底层实现都是线程，但都有特殊的表现形式，各有优缺点。 \n**AsyncTask** 封装了 线程池 和 Handler ，主要用于子线程更新UI；**HandlerThread** 是一种具有消息循环的线程，内部可以使用 Handler ； **IntentService** 是一个服务，内部采用 HandlerThread 执行任务，它类似一个后台线程，但是一个服务，不容易被杀死。\n\n### 1.1 AsyncTask\n\nAsyncTask 是一个轻量级的异步线程任务类，它在线程池中执行后台任务，然后把进度和最终结果传递给主线程并在主线程中更新UI，它封装了 Thread 和 Handler，但不适合特别耗时的后台任务，对于特别耗时的任务可以用线程池。\n\n\nAsyncTask 是一个**抽象的泛型类**，有 Params, Progress, Result 三个泛型参数，分别表示参数类型、后台任务执行进度类型、后台任务返回结果类型。如果不需要具体的参数，可用 Void 代替。\n```\npublic abstract class AsyncTask<Params, Progress, Result> {}\n```\n\n核心方法如下：\n\n- **onPreExecute()**\n在主线程中执行，异步任务之前调用，一般用于做准备工作。\n- **doInBackground(Params... params)**\n在线程池中执行异步任务，可以通过 publishProgress （最终会调用onProgressUpdate）方法更新任务进度，次啊外该方法需要计算返回结果给onPostExecute。\n- **onProgressUpdate((Progress... values)**\n在主线程中当任务进度改变后被调用\n- **onPostExecute(Result result)**\n在主线程中执行，异步任务执行完后，result 是 doInBackground 返回的值。\n\n使用时注意事项：\n\n-  AsyncTask 必须在主线程中加载\n- AsyncTask 的对象必须在主线程中创建\n- execute 方法必须在UI线程中调用\n- 不要在程序中直接调用 上述和新方法\n- 一个 AsyncTask 对象只能调用一次 execute 方法\n- AsyncTask 在 android3.0后 ，用一个线程串行执行任务。\n\n\n在使用 AsyncTask 时调用了 execute方法，而该方法调用了 executeOnExecutor ，如下源码：\n\n```\n @MainThread\npublic final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n}\n@MainThread\npublic final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,\n        Params... params) {\n    if (mStatus != Status.PENDING) {\n        switch (mStatus) {\n            case RUNNING:\n                throw new IllegalStateException(\"Cannot execute task:\"\n                        + \" the task is already running.\");\n            case FINISHED:\n                throw new IllegalStateException(\"Cannot execute task:\"\n                        + \" the task has already been executed \"\n                        + \"(a task can be executed only once)\");\n        }\n    }\n\n    mStatus = Status.RUNNING;\n\n    onPreExecute();\n\n    mWorker.mParams = params;\n    exec.execute(mFuture);\n\n    return this;\n}\n```\nsDefaultExecutor 是一个串行的线程池，所有的任务都在该线程池中排队执行。这里也可以发现 AsyncTask 的 onPreExecute 方法是先执行的。mFuture 是一个 FutureTask（一个并发类） 对象，在AsyncTask的构造函数中通过 mWorker 进行实例化，而 mWorker 中 保存的有AsyncTask的参数。\n如下 AsyncTask 的构造方法：\n```\npublic AsyncTask() {\n    mWorker = new WorkerRunnable<Params, Result>() {\n        public Result call() throws Exception {\n            mTaskInvoked.set(true);\n            Result result = null;\n            try {\n                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                //noinspection unchecked\n                result = doInBackground(mParams);\n                Binder.flushPendingCommands();\n            } catch (Throwable tr) {\n                mCancelled.set(true);\n                throw tr;\n            } finally {\n                postResult(result);\n            }\n            return result;\n        }\n    };\n\n    mFuture = new FutureTask<Result>(mWorker) {\n        @Override\n        protected void done() {\n            try {\n                postResultIfNotInvoked(get());\n            } catch (InterruptedException e) {\n                android.util.Log.w(LOG_TAG, e);\n            } catch (ExecutionException e) {\n                throw new RuntimeException(\"An error occurred while executing doInBackground()\",\n                        e.getCause());\n            } catch (CancellationException e) {\n                postResultIfNotInvoked(null);\n            }\n        }\n    };\n}\n```\n\n下面是线程池的执行过程：\n\n```\npublic static final Executor SERIAL_EXECUTOR = new SerialExecutor();\nprivate static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;\n//...\nprivate static class SerialExecutor implements Executor {\n    final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n    Runnable mActive;\n\n    public synchronized void execute(final Runnable r) {\n        mTasks.offer(new Runnable() {\n            public void run() {\n                try {\n                    r.run();\n                } finally {\n                    scheduleNext();\n                }\n            }\n        });\n        if (mActive == null) {\n            scheduleNext();\n        }\n    }\n\n    protected synchronized void scheduleNext() {\n        if ((mActive = mTasks.poll()) != null) {\n            THREAD_POOL_EXECUTOR.execute(mActive);\n        }\n    }\n}\n```\n在 AsyncTask 执行时，首先将 参数封装成 FutureTask 对象，然后将其传入到 SerialExecutor 的 execute 方法中处理，首先通过  mTasks.offer() 方法将其添加到任务队列中，如果没有正在活动的任务，执行下一个任务 scheduleNext()。这里可以发现 AsyncTask 是串行执行的。 THREAD_POOL_EXECUTOR 是一个 线程池，真正的执行任务，而 SerialExecutor 负责任务的排队，InternalHandler 负责将执行环境从线程池切换到主线程中。\n\n由于 FutureTask 的run方法最终会调用 mWorker 中call方法，这里回看前面 AsyncTask 的构造方法，在 mWorker 中call方法中 先将 mTaskInvoked 设置为true ，表示当前任务已被调用过，然后执行 doInBackground 方法，并将其结果传给 postResult 方法，而 postResult 方法主要是 通过 sHandler （InternalHandler对象）发送一个  MESSAGE_POST_PROGRESS 消息，最后调用到 AsyncTask 的 finish方法，通过传入的 Result ，在 finish 中 最后确定是调用取消（`onCancelled(result)`）还是执行完成（`onPostExecute(result)`）。到此 ，AsyncTask 的整个工作流程结束。\n\nInternalHandler 是一个 静态的 Handler 对象，为了能将执行环境切换到主线程，则 sHandler 必须在主线程中创建，同时 变相要求了 AsyncTask 要在 主线程中 创建。\n\n\n\n### 1.2 HandlerThread\n\n`HandlerThread` 类继承自 Thread ，是一个可以使用 Handler 的 Thread。主要是**在其 run 方法中创建了消息队列和开启消息循环**。这样就可以 在 HandlerThread 中创建Handler。\n如下其 run方法：\n```\npublic void run() {\n    mTid = Process.myTid();\n    Looper.prepare();\n    synchronized (this) {\n        mLooper = Looper.myLooper();\n        notifyAll();\n    }\n    Process.setThreadPriority(mPriority);\n    onLooperPrepared();\n    Looper.loop();\n    mTid = -1;\n}\n```\nHandlerThread 的run 方法是一个无线循环方法，在不需要时可以 通过 `quit` 或者 `quitSafely` 进行终止。 HandlerThread 主要用在 IntentService 中，\n\n### 1.3 IntentService\n\n`IntentService` 是一个特殊的 service  ，继承自 Service，并且是一个抽象类，使用时必须创建其子类方可使用，它主要用于执行后台耗时任务，完成后自动关闭，它的优先级比普通的线程高，比较适合执行一些高优先级的后台任务。在其内部封装了 `HandlerThread` 和 `Handler（ServiceHandler）` 。如下其 `onCreate` 方法：\n```\npublic void onCreate()\n{\n    super.onCreate();\n    HandlerThread thread = new HandlerThread (\"IntentService[\" + mName + \"]\");\n    thread.start();\n\n    mServiceLooper = thread.getLooper();\n    mServiceHandler = new ServiceHandler (mServiceLooper);\n}\n```\nIntentService 在初次启动时调用 onCreate 方法，此时创建 HandlerThread ，然后通过它的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最后都在 HandlerThread 中处理，这导致 IntentService 也是顺序执行后台任务的。\n\n每次启动 IntentService ，它的 onStartCommand 会被调用，处理每一个后台任务，调用了 onStart 方法 ,通过 mServiceHandler 发送一个消息，最后在 HandlerThread 中处理。\n```\npublic int onStartCommand (@Nullable Intent intent, int flags, int startId)\n{\n    onStart (intent, startId);\n    return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;\n}\n\npublic void onStart (@Nullable Intent intent, int startId)\n{\n    Message msg = mServiceHandler.obtainMessage();\n    msg.arg1 = startId;\n    msg.obj = intent;\n    mServiceHandler.sendMessage (msg);\n}\n```\n如下是 ServiceHandler 类的定义：\n```\nprivate final class ServiceHandler extends Handler\n{\n    public ServiceHandler (Looper looper)\n    {\n        super (looper);\n    }\n\n    @Override\n    public void handleMessage (Message msg)\n    {\n        onHandleIntent ( (Intent) msg.obj);\n        stopSelf (msg.arg1);\n    }\n}\n```\nmServiceHandler 收到消息后会将 Intent 对象传递给 onHandleIntent 处理，这里的 Intent 和 startService(intent) 中的 intent 完全一致，这样通过 这个 intent 就可以解析出外界启动 IntentService 所传递的参数，在 onHandleIntent 方法 中对不同的后台任务做处理。当 onHandleIntent 执行完后 调用 stopSelf ，停止服务。\n\n上面提到的 onHandleIntent 方法是一个抽象方法，在使用时需要实现。\n\n## 二、android中的线程池\n线程池主要有如下几个优点：\n\n- 重用线程池中的线程，避免因线程的重复创建和销毁导致的性能开销；\n- 能有效控制线程池的最大并发数，避免线程相互抢占资源导致阻塞；\n- 能够对线程进行简单的管理，提供定时执行等功能。\n\n### 2.1  ThreadPoolExecutor\nandroid 中的线程池 源于 java 中的 Exector,Exector是一个接口，真正的线程池的实现类为 ThreadPoolExecutor 类，它提供了一系列的参数来配置线程池，通过不同的参数可以创建不同的线程池。\n如下他它的一个常用构造方法的声明：\n```\npublic ThreadPoolExecutor (int corePoolSize,\n                           int maximumPoolSize,\n                           long keepAliveTime,\n                           TimeUnit unit,\n                           BlockingQueue<Runnable> workQueue,\n                           ThreadFactory threadFactory)\n```\n参数说明：\n\n- **corePoolSize** \n核心线程数，默认情况下 一直存活着，即使处于闲置状态。将 allowCoreThreadTimeOut 属性设置为 true 时，闲置的核心线程等待新任务到来时会有超时策略，改时间间隔由 keepAliveTime 所指定，当时间超过 keepAliveTime 后，线程会被终止。\n- **maximumPoolSize**\n最大线程数，当线程数达到该值后，后续的线程会被阻塞。\n- **keepAliveTime**\n非核心线程闲置的超时时长，超过后就会被回收。\n- **unit**\n指定 keepAliveTime 参数的时间单位，常用的有 TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）等\n- **workQueue**\n线程池中的任务队列\n- **threadFactory**\n线程工厂，为线程池提供创建新线程的功能，是一个 接口。\n\n如下是 AsyncTask 中 THREAD_POOL_EXECUTOR 线程池的配置：\n```\n//cpu 数\nprivate static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();\n//核心线程 \nprivate static final int CORE_POOL_SIZE = Math.max (2, Math.min (CPU_COUNT - 1, 4) );\n//线程池最大线程数 \nprivate static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;\n//闲置超时时间 30s\nprivate static final int KEEP_ALIVE_SECONDS = 30;\n\nprivate static final ThreadFactory sThreadFactory = new ThreadFactory()\n{\n    private final AtomicInteger mCount = new AtomicInteger (1);\n\n    public Thread newThread (Runnable r)\n    {\n        return new Thread (r, \"AsyncTask #\" + mCount.getAndIncrement() );\n    }\n};\n//任务队列容量 128\nprivate static final BlockingQueue<Runnable> sPoolWorkQueue =\n    new LinkedBlockingQueue<Runnable> (128);\npublic static final Executor THREAD_POOL_EXECUTOR;\n\nstatic\n{\n    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor (\n        CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,\n        sPoolWorkQueue, sThreadFactory);\n    threadPoolExecutor.allowCoreThreadTimeOut (true);\n    THREAD_POOL_EXECUTOR = threadPoolExecutor;\n}\n```\n### 2.2 线程池的分类\n\n除了 前面 的 ThreadPoolExecutor ，android 中还有如下四类线程池，他们都直接或者间接的通过配置 ThreadPoolExecutor 来实现自己的功能，通过 `Executors` 对应的new方法来创建。\n\n- **FixedThreadPool**\n通过 `Executors.newFixedThreadPool()` 创建，线程数固定的线程池，线程空闲时不会被回收，除非线程池被关闭。这种方式创建的线程池中只有核心线程且不会超时，任务队列无大小限制，能够更快的响应外界的请求。\n \n ```\n public static ExecutorService newFixedThreadPool (int nThreads)\n{\n    return new ThreadPoolExecutor (nThreads, nThreads,\n                                   0L, TimeUnit.MILLISECONDS,\n                                   new LinkedBlockingQueue<Runnable>() );\n}\n ```\n \n- **CachedThreadPool**\n通过 `Executors.newCachedThreadPool()` 创建，是一种线程数不固定的线程池，只有核心线程，最大数为 Integer.MAX_VALUE，超时时间60s。\n\n ```\n public static ExecutorService newCachedThreadPool()\n{\n    return new ThreadPoolExecutor (0, Integer.MAX_VALUE,\n                                   60L, TimeUnit.SECONDS,\n                                   new SynchronousQueue<Runnable>() );\n}\n ```\n\n- **ScheduledThreadPool**\n通过 `Executors.newScheduledThreadPool()` 创建，是一种核心线程数固定，非核心线程数不固定的线程池。主要用于执行定时任务和具有固定周期的重复任务。\n\n ```\n public static ScheduledExecutorService newScheduledThreadPool (int corePoolSize)\n{\n    return new ScheduledThreadPoolExecutor (corePoolSize);\n}\npublic ScheduledThreadPoolExecutor (int corePoolSize)\n{\n    super (corePoolSize, Integer.MAX_VALUE,\n           DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,\n           new DelayedWorkQueue() );\n}\n ```\n \n- **SingleThreadExecutor**\n通过 `Executors.newSingleThreadExecutor()` 创建，内部只有一个线程，可以确保所有的任务都在同一个线程中顺序执行，可以统一外界的任务到一个线程中。\n \n ```\n public static ExecutorService newSingleThreadExecutor()\n{\n    return new FinalizableDelegatedExecutorService\n           (new ThreadPoolExecutor (1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>() ) );\n}\n\n ```\n这是系统提供的四种常见的 线程池，此外还可以根据自己的实际需要灵活的配置线程池。\n\n\n\n","slug":"AsyncTask 工作原理及线程池","published":1,"updated":"2017-01-07T08:15:20.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuceu0009g0g5zz2u4bdb","content":"<blockquote>\n<p>读书笔记： 《Android 开发艺术探索》 ——第十一章：android 线程及线程池</p>\n</blockquote>\n<p>在 android 中，线程通常为主线程和子线程，前者主要处理和界面相关的事情，而后者主要用于耗时操作。<br>android 中的线程主要有 <code>Thread</code>、<code>AsyncTask</code>、<code>IntentService</code> 和 <code>HandlerThread</code> 。<br><a id=\"more\"></a></p>\n<h2 id=\"一、android-中的线程形态\"><a href=\"#一、android-中的线程形态\" class=\"headerlink\" title=\"一、android 中的线程形态\"></a>一、android 中的线程形态</h2><p>AsyncTask、IntentService 和 HandlerThread 的底层实现都是线程，但都有特殊的表现形式，各有优缺点。<br><strong>AsyncTask</strong> 封装了 线程池 和 Handler ，主要用于子线程更新UI；<strong>HandlerThread</strong> 是一种具有消息循环的线程，内部可以使用 Handler ； <strong>IntentService</strong> 是一个服务，内部采用 HandlerThread 执行任务，它类似一个后台线程，但是一个服务，不容易被杀死。</p>\n<h3 id=\"1-1-AsyncTask\"><a href=\"#1-1-AsyncTask\" class=\"headerlink\" title=\"1.1 AsyncTask\"></a>1.1 AsyncTask</h3><p>AsyncTask 是一个轻量级的异步线程任务类，它在线程池中执行后台任务，然后把进度和最终结果传递给主线程并在主线程中更新UI，它封装了 Thread 和 Handler，但不适合特别耗时的后台任务，对于特别耗时的任务可以用线程池。</p>\n<p>AsyncTask 是一个<strong>抽象的泛型类</strong>，有 Params, Progress, Result 三个泛型参数，分别表示参数类型、后台任务执行进度类型、后台任务返回结果类型。如果不需要具体的参数，可用 Void 代替。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>核心方法如下：</p>\n<ul>\n<li><strong>onPreExecute()</strong><br>在主线程中执行，异步任务之前调用，一般用于做准备工作。</li>\n<li><strong>doInBackground(Params… params)</strong><br>在线程池中执行异步任务，可以通过 publishProgress （最终会调用onProgressUpdate）方法更新任务进度，次啊外该方法需要计算返回结果给onPostExecute。</li>\n<li><strong>onProgressUpdate((Progress… values)</strong><br>在主线程中当任务进度改变后被调用</li>\n<li><strong>onPostExecute(Result result)</strong><br>在主线程中执行，异步任务执行完后，result 是 doInBackground 返回的值。</li>\n</ul>\n<p>使用时注意事项：</p>\n<ul>\n<li>AsyncTask 必须在主线程中加载</li>\n<li>AsyncTask 的对象必须在主线程中创建</li>\n<li>execute 方法必须在UI线程中调用</li>\n<li>不要在程序中直接调用 上述和新方法</li>\n<li>一个 AsyncTask 对象只能调用一次 execute 方法</li>\n<li>AsyncTask 在 android3.0后 ，用一个线程串行执行任务。</li>\n</ul>\n<p>在使用 AsyncTask 时调用了 execute方法，而该方法调用了 executeOnExecutor ，如下源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> @MainThread</span><br><span class=\"line\">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class=\"line\">        return executeOnExecutor(sDefaultExecutor, params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@MainThread</span><br><span class=\"line\">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class=\"line\">        Params... params) &#123;</span><br><span class=\"line\">    if (mStatus != Status.PENDING) &#123;</span><br><span class=\"line\">        switch (mStatus) &#123;</span><br><span class=\"line\">            case RUNNING:</span><br><span class=\"line\">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class=\"line\">                        + &quot; the task is already running.&quot;);</span><br><span class=\"line\">            case FINISHED:</span><br><span class=\"line\">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class=\"line\">                        + &quot; the task has already been executed &quot;</span><br><span class=\"line\">                        + &quot;(a task can be executed only once)&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mStatus = Status.RUNNING;</span><br><span class=\"line\"></span><br><span class=\"line\">    onPreExecute();</span><br><span class=\"line\"></span><br><span class=\"line\">    mWorker.mParams = params;</span><br><span class=\"line\">    exec.execute(mFuture);</span><br><span class=\"line\"></span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sDefaultExecutor 是一个串行的线程池，所有的任务都在该线程池中排队执行。这里也可以发现 AsyncTask 的 onPreExecute 方法是先执行的。mFuture 是一个 FutureTask（一个并发类） 对象，在AsyncTask的构造函数中通过 mWorker 进行实例化，而 mWorker 中 保存的有AsyncTask的参数。<br>如下 AsyncTask 的构造方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AsyncTask() &#123;</span><br><span class=\"line\">    mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class=\"line\">        public Result call() throws Exception &#123;</span><br><span class=\"line\">            mTaskInvoked.set(true);</span><br><span class=\"line\">            Result result = null;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">                //noinspection unchecked</span><br><span class=\"line\">                result = doInBackground(mParams);</span><br><span class=\"line\">                Binder.flushPendingCommands();</span><br><span class=\"line\">            &#125; catch (Throwable tr) &#123;</span><br><span class=\"line\">                mCancelled.set(true);</span><br><span class=\"line\">                throw tr;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                postResult(result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected void done() &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                postResultIfNotInvoked(get());</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                android.util.Log.w(LOG_TAG, e);</span><br><span class=\"line\">            &#125; catch (ExecutionException e) &#123;</span><br><span class=\"line\">                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</span><br><span class=\"line\">                        e.getCause());</span><br><span class=\"line\">            &#125; catch (CancellationException e) &#123;</span><br><span class=\"line\">                postResultIfNotInvoked(null);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面是线程池的执行过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</span><br><span class=\"line\">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class=\"line\">//...</span><br><span class=\"line\">private static class SerialExecutor implements Executor &#123;</span><br><span class=\"line\">    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class=\"line\">    Runnable mActive;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void execute(final Runnable r) &#123;</span><br><span class=\"line\">        mTasks.offer(new Runnable() &#123;</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    r.run();</span><br><span class=\"line\">                &#125; finally &#123;</span><br><span class=\"line\">                    scheduleNext();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        if (mActive == null) &#123;</span><br><span class=\"line\">            scheduleNext();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected synchronized void scheduleNext() &#123;</span><br><span class=\"line\">        if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class=\"line\">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 AsyncTask 执行时，首先将 参数封装成 FutureTask 对象，然后将其传入到 SerialExecutor 的 execute 方法中处理，首先通过  mTasks.offer() 方法将其添加到任务队列中，如果没有正在活动的任务，执行下一个任务 scheduleNext()。这里可以发现 AsyncTask 是串行执行的。 THREAD_POOL_EXECUTOR 是一个 线程池，真正的执行任务，而 SerialExecutor 负责任务的排队，InternalHandler 负责将执行环境从线程池切换到主线程中。</p>\n<p>由于 FutureTask 的run方法最终会调用 mWorker 中call方法，这里回看前面 AsyncTask 的构造方法，在 mWorker 中call方法中 先将 mTaskInvoked 设置为true ，表示当前任务已被调用过，然后执行 doInBackground 方法，并将其结果传给 postResult 方法，而 postResult 方法主要是 通过 sHandler （InternalHandler对象）发送一个  MESSAGE_POST_PROGRESS 消息，最后调用到 AsyncTask 的 finish方法，通过传入的 Result ，在 finish 中 最后确定是调用取消（<code>onCancelled(result)</code>）还是执行完成（<code>onPostExecute(result)</code>）。到此 ，AsyncTask 的整个工作流程结束。</p>\n<p>InternalHandler 是一个 静态的 Handler 对象，为了能将执行环境切换到主线程，则 sHandler 必须在主线程中创建，同时 变相要求了 AsyncTask 要在 主线程中 创建。</p>\n<h3 id=\"1-2-HandlerThread\"><a href=\"#1-2-HandlerThread\" class=\"headerlink\" title=\"1.2 HandlerThread\"></a>1.2 HandlerThread</h3><p><code>HandlerThread</code> 类继承自 Thread ，是一个可以使用 Handler 的 Thread。主要是<strong>在其 run 方法中创建了消息队列和开启消息循环</strong>。这样就可以 在 HandlerThread 中创建Handler。<br>如下其 run方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">    mTid = Process.myTid();</span><br><span class=\"line\">    Looper.prepare();</span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        mLooper = Looper.myLooper();</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Process.setThreadPriority(mPriority);</span><br><span class=\"line\">    onLooperPrepared();</span><br><span class=\"line\">    Looper.loop();</span><br><span class=\"line\">    mTid = -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HandlerThread 的run 方法是一个无线循环方法，在不需要时可以 通过 <code>quit</code> 或者 <code>quitSafely</code> 进行终止。 HandlerThread 主要用在 IntentService 中，</p>\n<h3 id=\"1-3-IntentService\"><a href=\"#1-3-IntentService\" class=\"headerlink\" title=\"1.3 IntentService\"></a>1.3 IntentService</h3><p><code>IntentService</code> 是一个特殊的 service  ，继承自 Service，并且是一个抽象类，使用时必须创建其子类方可使用，它主要用于执行后台耗时任务，完成后自动关闭，它的优先级比普通的线程高，比较适合执行一些高优先级的后台任务。在其内部封装了 <code>HandlerThread</code> 和 <code>Handler（ServiceHandler）</code> 。如下其 <code>onCreate</code> 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onCreate()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    super.onCreate();</span><br><span class=\"line\">    HandlerThread thread = new HandlerThread (&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    mServiceLooper = thread.getLooper();</span><br><span class=\"line\">    mServiceHandler = new ServiceHandler (mServiceLooper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>IntentService 在初次启动时调用 onCreate 方法，此时创建 HandlerThread ，然后通过它的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最后都在 HandlerThread 中处理，这导致 IntentService 也是顺序执行后台任务的。</p>\n<p>每次启动 IntentService ，它的 onStartCommand 会被调用，处理每一个后台任务，调用了 onStart 方法 ,通过 mServiceHandler 发送一个消息，最后在 HandlerThread 中处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int onStartCommand (@Nullable Intent intent, int flags, int startId)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    onStart (intent, startId);</span><br><span class=\"line\">    return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void onStart (@Nullable Intent intent, int startId)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Message msg = mServiceHandler.obtainMessage();</span><br><span class=\"line\">    msg.arg1 = startId;</span><br><span class=\"line\">    msg.obj = intent;</span><br><span class=\"line\">    mServiceHandler.sendMessage (msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如下是 ServiceHandler 类的定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final class ServiceHandler extends Handler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public ServiceHandler (Looper looper)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super (looper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void handleMessage (Message msg)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        onHandleIntent ( (Intent) msg.obj);</span><br><span class=\"line\">        stopSelf (msg.arg1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mServiceHandler 收到消息后会将 Intent 对象传递给 onHandleIntent 处理，这里的 Intent 和 startService(intent) 中的 intent 完全一致，这样通过 这个 intent 就可以解析出外界启动 IntentService 所传递的参数，在 onHandleIntent 方法 中对不同的后台任务做处理。当 onHandleIntent 执行完后 调用 stopSelf ，停止服务。</p>\n<p>上面提到的 onHandleIntent 方法是一个抽象方法，在使用时需要实现。</p>\n<h2 id=\"二、android中的线程池\"><a href=\"#二、android中的线程池\" class=\"headerlink\" title=\"二、android中的线程池\"></a>二、android中的线程池</h2><p>线程池主要有如下几个优点：</p>\n<ul>\n<li>重用线程池中的线程，避免因线程的重复创建和销毁导致的性能开销；</li>\n<li>能有效控制线程池的最大并发数，避免线程相互抢占资源导致阻塞；</li>\n<li>能够对线程进行简单的管理，提供定时执行等功能。</li>\n</ul>\n<h3 id=\"2-1-ThreadPoolExecutor\"><a href=\"#2-1-ThreadPoolExecutor\" class=\"headerlink\" title=\"2.1  ThreadPoolExecutor\"></a>2.1  ThreadPoolExecutor</h3><p>android 中的线程池 源于 java 中的 Exector,Exector是一个接口，真正的线程池的实现类为 ThreadPoolExecutor 类，它提供了一系列的参数来配置线程池，通过不同的参数可以创建不同的线程池。<br>如下他它的一个常用构造方法的声明：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ThreadPoolExecutor (int corePoolSize,</span><br><span class=\"line\">                           int maximumPoolSize,</span><br><span class=\"line\">                           long keepAliveTime,</span><br><span class=\"line\">                           TimeUnit unit,</span><br><span class=\"line\">                           BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                           ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure></p>\n<p>参数说明：</p>\n<ul>\n<li><strong>corePoolSize</strong><br>核心线程数，默认情况下 一直存活着，即使处于闲置状态。将 allowCoreThreadTimeOut 属性设置为 true 时，闲置的核心线程等待新任务到来时会有超时策略，改时间间隔由 keepAliveTime 所指定，当时间超过 keepAliveTime 后，线程会被终止。</li>\n<li><strong>maximumPoolSize</strong><br>最大线程数，当线程数达到该值后，后续的线程会被阻塞。</li>\n<li><strong>keepAliveTime</strong><br>非核心线程闲置的超时时长，超过后就会被回收。</li>\n<li><strong>unit</strong><br>指定 keepAliveTime 参数的时间单位，常用的有 TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）等</li>\n<li><strong>workQueue</strong><br>线程池中的任务队列</li>\n<li><strong>threadFactory</strong><br>线程工厂，为线程池提供创建新线程的功能，是一个 接口。</li>\n</ul>\n<p>如下是 AsyncTask 中 THREAD_POOL_EXECUTOR 线程池的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//cpu 数</span><br><span class=\"line\">private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class=\"line\">//核心线程 </span><br><span class=\"line\">private static final int CORE_POOL_SIZE = Math.max (2, Math.min (CPU_COUNT - 1, 4) );</span><br><span class=\"line\">//线程池最大线程数 </span><br><span class=\"line\">private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;</span><br><span class=\"line\">//闲置超时时间 30s</span><br><span class=\"line\">private static final int KEEP_ALIVE_SECONDS = 30;</span><br><span class=\"line\"></span><br><span class=\"line\">private static final ThreadFactory sThreadFactory = new ThreadFactory()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private final AtomicInteger mCount = new AtomicInteger (1);</span><br><span class=\"line\"></span><br><span class=\"line\">    public Thread newThread (Runnable r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return new Thread (r, &quot;AsyncTask #&quot; + mCount.getAndIncrement() );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//任务队列容量 128</span><br><span class=\"line\">private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</span><br><span class=\"line\">    new LinkedBlockingQueue&lt;Runnable&gt; (128);</span><br><span class=\"line\">public static final Executor THREAD_POOL_EXECUTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">static</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor (</span><br><span class=\"line\">        CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class=\"line\">        sPoolWorkQueue, sThreadFactory);</span><br><span class=\"line\">    threadPoolExecutor.allowCoreThreadTimeOut (true);</span><br><span class=\"line\">    THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-线程池的分类\"><a href=\"#2-2-线程池的分类\" class=\"headerlink\" title=\"2.2 线程池的分类\"></a>2.2 线程池的分类</h3><p>除了 前面 的 ThreadPoolExecutor ，android 中还有如下四类线程池，他们都直接或者间接的通过配置 ThreadPoolExecutor 来实现自己的功能，通过 <code>Executors</code> 对应的new方法来创建。</p>\n<ul>\n<li><p><strong>FixedThreadPool</strong><br>通过 <code>Executors.newFixedThreadPool()</code> 创建，线程数固定的线程池，线程空闲时不会被回收，除非线程池被关闭。这种方式创建的线程池中只有核心线程且不会超时，任务队列无大小限制，能够更快的响应外界的请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static ExecutorService newFixedThreadPool (int nThreads)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return new ThreadPoolExecutor (nThreads, nThreads,</span><br><span class=\"line\">                                   0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                   new LinkedBlockingQueue&lt;Runnable&gt;() );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><strong>CachedThreadPool</strong><br>通过 <code>Executors.newCachedThreadPool()</code> 创建，是一种线程数不固定的线程池，只有核心线程，最大数为 Integer.MAX_VALUE，超时时间60s。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static ExecutorService newCachedThreadPool()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return new ThreadPoolExecutor (0, Integer.MAX_VALUE,</span><br><span class=\"line\">                                   60L, TimeUnit.SECONDS,</span><br><span class=\"line\">                                   new SynchronousQueue&lt;Runnable&gt;() );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>ScheduledThreadPool</strong><br>通过 <code>Executors.newScheduledThreadPool()</code> 创建，是一种核心线程数固定，非核心线程数不固定的线程池。主要用于执行定时任务和具有固定周期的重复任务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static ScheduledExecutorService newScheduledThreadPool (int corePoolSize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return new ScheduledThreadPoolExecutor (corePoolSize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public ScheduledThreadPoolExecutor (int corePoolSize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    super (corePoolSize, Integer.MAX_VALUE,</span><br><span class=\"line\">           DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class=\"line\">           new DelayedWorkQueue() );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><strong>SingleThreadExecutor</strong><br>通过 <code>Executors.newSingleThreadExecutor()</code> 创建，内部只有一个线程，可以确保所有的任务都在同一个线程中顺序执行，可以统一外界的任务到一个线程中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static ExecutorService newSingleThreadExecutor()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return new FinalizableDelegatedExecutorService</span><br><span class=\"line\">           (new ThreadPoolExecutor (1, 1,</span><br><span class=\"line\">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                    new LinkedBlockingQueue&lt;Runnable&gt;() ) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这是系统提供的四种常见的 线程池，此外还可以根据自己的实际需要灵活的配置线程池。</p>\n","excerpt":"<blockquote>\n<p>读书笔记： 《Android 开发艺术探索》 ——第十一章：android 线程及线程池</p>\n</blockquote>\n<p>在 android 中，线程通常为主线程和子线程，前者主要处理和界面相关的事情，而后者主要用于耗时操作。<br>android 中的线程主要有 <code>Thread</code>、<code>AsyncTask</code>、<code>IntentService</code> 和 <code>HandlerThread</code> 。<br>","more":"</p>\n<h2 id=\"一、android-中的线程形态\"><a href=\"#一、android-中的线程形态\" class=\"headerlink\" title=\"一、android 中的线程形态\"></a>一、android 中的线程形态</h2><p>AsyncTask、IntentService 和 HandlerThread 的底层实现都是线程，但都有特殊的表现形式，各有优缺点。<br><strong>AsyncTask</strong> 封装了 线程池 和 Handler ，主要用于子线程更新UI；<strong>HandlerThread</strong> 是一种具有消息循环的线程，内部可以使用 Handler ； <strong>IntentService</strong> 是一个服务，内部采用 HandlerThread 执行任务，它类似一个后台线程，但是一个服务，不容易被杀死。</p>\n<h3 id=\"1-1-AsyncTask\"><a href=\"#1-1-AsyncTask\" class=\"headerlink\" title=\"1.1 AsyncTask\"></a>1.1 AsyncTask</h3><p>AsyncTask 是一个轻量级的异步线程任务类，它在线程池中执行后台任务，然后把进度和最终结果传递给主线程并在主线程中更新UI，它封装了 Thread 和 Handler，但不适合特别耗时的后台任务，对于特别耗时的任务可以用线程池。</p>\n<p>AsyncTask 是一个<strong>抽象的泛型类</strong>，有 Params, Progress, Result 三个泛型参数，分别表示参数类型、后台任务执行进度类型、后台任务返回结果类型。如果不需要具体的参数，可用 Void 代替。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>核心方法如下：</p>\n<ul>\n<li><strong>onPreExecute()</strong><br>在主线程中执行，异步任务之前调用，一般用于做准备工作。</li>\n<li><strong>doInBackground(Params… params)</strong><br>在线程池中执行异步任务，可以通过 publishProgress （最终会调用onProgressUpdate）方法更新任务进度，次啊外该方法需要计算返回结果给onPostExecute。</li>\n<li><strong>onProgressUpdate((Progress… values)</strong><br>在主线程中当任务进度改变后被调用</li>\n<li><strong>onPostExecute(Result result)</strong><br>在主线程中执行，异步任务执行完后，result 是 doInBackground 返回的值。</li>\n</ul>\n<p>使用时注意事项：</p>\n<ul>\n<li>AsyncTask 必须在主线程中加载</li>\n<li>AsyncTask 的对象必须在主线程中创建</li>\n<li>execute 方法必须在UI线程中调用</li>\n<li>不要在程序中直接调用 上述和新方法</li>\n<li>一个 AsyncTask 对象只能调用一次 execute 方法</li>\n<li>AsyncTask 在 android3.0后 ，用一个线程串行执行任务。</li>\n</ul>\n<p>在使用 AsyncTask 时调用了 execute方法，而该方法调用了 executeOnExecutor ，如下源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> @MainThread</span><br><span class=\"line\">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class=\"line\">        return executeOnExecutor(sDefaultExecutor, params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@MainThread</span><br><span class=\"line\">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class=\"line\">        Params... params) &#123;</span><br><span class=\"line\">    if (mStatus != Status.PENDING) &#123;</span><br><span class=\"line\">        switch (mStatus) &#123;</span><br><span class=\"line\">            case RUNNING:</span><br><span class=\"line\">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class=\"line\">                        + &quot; the task is already running.&quot;);</span><br><span class=\"line\">            case FINISHED:</span><br><span class=\"line\">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class=\"line\">                        + &quot; the task has already been executed &quot;</span><br><span class=\"line\">                        + &quot;(a task can be executed only once)&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mStatus = Status.RUNNING;</span><br><span class=\"line\"></span><br><span class=\"line\">    onPreExecute();</span><br><span class=\"line\"></span><br><span class=\"line\">    mWorker.mParams = params;</span><br><span class=\"line\">    exec.execute(mFuture);</span><br><span class=\"line\"></span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sDefaultExecutor 是一个串行的线程池，所有的任务都在该线程池中排队执行。这里也可以发现 AsyncTask 的 onPreExecute 方法是先执行的。mFuture 是一个 FutureTask（一个并发类） 对象，在AsyncTask的构造函数中通过 mWorker 进行实例化，而 mWorker 中 保存的有AsyncTask的参数。<br>如下 AsyncTask 的构造方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AsyncTask() &#123;</span><br><span class=\"line\">    mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class=\"line\">        public Result call() throws Exception &#123;</span><br><span class=\"line\">            mTaskInvoked.set(true);</span><br><span class=\"line\">            Result result = null;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">                //noinspection unchecked</span><br><span class=\"line\">                result = doInBackground(mParams);</span><br><span class=\"line\">                Binder.flushPendingCommands();</span><br><span class=\"line\">            &#125; catch (Throwable tr) &#123;</span><br><span class=\"line\">                mCancelled.set(true);</span><br><span class=\"line\">                throw tr;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                postResult(result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected void done() &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                postResultIfNotInvoked(get());</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                android.util.Log.w(LOG_TAG, e);</span><br><span class=\"line\">            &#125; catch (ExecutionException e) &#123;</span><br><span class=\"line\">                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</span><br><span class=\"line\">                        e.getCause());</span><br><span class=\"line\">            &#125; catch (CancellationException e) &#123;</span><br><span class=\"line\">                postResultIfNotInvoked(null);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面是线程池的执行过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</span><br><span class=\"line\">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class=\"line\">//...</span><br><span class=\"line\">private static class SerialExecutor implements Executor &#123;</span><br><span class=\"line\">    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class=\"line\">    Runnable mActive;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void execute(final Runnable r) &#123;</span><br><span class=\"line\">        mTasks.offer(new Runnable() &#123;</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    r.run();</span><br><span class=\"line\">                &#125; finally &#123;</span><br><span class=\"line\">                    scheduleNext();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        if (mActive == null) &#123;</span><br><span class=\"line\">            scheduleNext();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected synchronized void scheduleNext() &#123;</span><br><span class=\"line\">        if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class=\"line\">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 AsyncTask 执行时，首先将 参数封装成 FutureTask 对象，然后将其传入到 SerialExecutor 的 execute 方法中处理，首先通过  mTasks.offer() 方法将其添加到任务队列中，如果没有正在活动的任务，执行下一个任务 scheduleNext()。这里可以发现 AsyncTask 是串行执行的。 THREAD_POOL_EXECUTOR 是一个 线程池，真正的执行任务，而 SerialExecutor 负责任务的排队，InternalHandler 负责将执行环境从线程池切换到主线程中。</p>\n<p>由于 FutureTask 的run方法最终会调用 mWorker 中call方法，这里回看前面 AsyncTask 的构造方法，在 mWorker 中call方法中 先将 mTaskInvoked 设置为true ，表示当前任务已被调用过，然后执行 doInBackground 方法，并将其结果传给 postResult 方法，而 postResult 方法主要是 通过 sHandler （InternalHandler对象）发送一个  MESSAGE_POST_PROGRESS 消息，最后调用到 AsyncTask 的 finish方法，通过传入的 Result ，在 finish 中 最后确定是调用取消（<code>onCancelled(result)</code>）还是执行完成（<code>onPostExecute(result)</code>）。到此 ，AsyncTask 的整个工作流程结束。</p>\n<p>InternalHandler 是一个 静态的 Handler 对象，为了能将执行环境切换到主线程，则 sHandler 必须在主线程中创建，同时 变相要求了 AsyncTask 要在 主线程中 创建。</p>\n<h3 id=\"1-2-HandlerThread\"><a href=\"#1-2-HandlerThread\" class=\"headerlink\" title=\"1.2 HandlerThread\"></a>1.2 HandlerThread</h3><p><code>HandlerThread</code> 类继承自 Thread ，是一个可以使用 Handler 的 Thread。主要是<strong>在其 run 方法中创建了消息队列和开启消息循环</strong>。这样就可以 在 HandlerThread 中创建Handler。<br>如下其 run方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">    mTid = Process.myTid();</span><br><span class=\"line\">    Looper.prepare();</span><br><span class=\"line\">    synchronized (this) &#123;</span><br><span class=\"line\">        mLooper = Looper.myLooper();</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Process.setThreadPriority(mPriority);</span><br><span class=\"line\">    onLooperPrepared();</span><br><span class=\"line\">    Looper.loop();</span><br><span class=\"line\">    mTid = -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HandlerThread 的run 方法是一个无线循环方法，在不需要时可以 通过 <code>quit</code> 或者 <code>quitSafely</code> 进行终止。 HandlerThread 主要用在 IntentService 中，</p>\n<h3 id=\"1-3-IntentService\"><a href=\"#1-3-IntentService\" class=\"headerlink\" title=\"1.3 IntentService\"></a>1.3 IntentService</h3><p><code>IntentService</code> 是一个特殊的 service  ，继承自 Service，并且是一个抽象类，使用时必须创建其子类方可使用，它主要用于执行后台耗时任务，完成后自动关闭，它的优先级比普通的线程高，比较适合执行一些高优先级的后台任务。在其内部封装了 <code>HandlerThread</code> 和 <code>Handler（ServiceHandler）</code> 。如下其 <code>onCreate</code> 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onCreate()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    super.onCreate();</span><br><span class=\"line\">    HandlerThread thread = new HandlerThread (&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    mServiceLooper = thread.getLooper();</span><br><span class=\"line\">    mServiceHandler = new ServiceHandler (mServiceLooper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>IntentService 在初次启动时调用 onCreate 方法，此时创建 HandlerThread ，然后通过它的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最后都在 HandlerThread 中处理，这导致 IntentService 也是顺序执行后台任务的。</p>\n<p>每次启动 IntentService ，它的 onStartCommand 会被调用，处理每一个后台任务，调用了 onStart 方法 ,通过 mServiceHandler 发送一个消息，最后在 HandlerThread 中处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int onStartCommand (@Nullable Intent intent, int flags, int startId)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    onStart (intent, startId);</span><br><span class=\"line\">    return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void onStart (@Nullable Intent intent, int startId)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Message msg = mServiceHandler.obtainMessage();</span><br><span class=\"line\">    msg.arg1 = startId;</span><br><span class=\"line\">    msg.obj = intent;</span><br><span class=\"line\">    mServiceHandler.sendMessage (msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如下是 ServiceHandler 类的定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final class ServiceHandler extends Handler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public ServiceHandler (Looper looper)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super (looper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void handleMessage (Message msg)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        onHandleIntent ( (Intent) msg.obj);</span><br><span class=\"line\">        stopSelf (msg.arg1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mServiceHandler 收到消息后会将 Intent 对象传递给 onHandleIntent 处理，这里的 Intent 和 startService(intent) 中的 intent 完全一致，这样通过 这个 intent 就可以解析出外界启动 IntentService 所传递的参数，在 onHandleIntent 方法 中对不同的后台任务做处理。当 onHandleIntent 执行完后 调用 stopSelf ，停止服务。</p>\n<p>上面提到的 onHandleIntent 方法是一个抽象方法，在使用时需要实现。</p>\n<h2 id=\"二、android中的线程池\"><a href=\"#二、android中的线程池\" class=\"headerlink\" title=\"二、android中的线程池\"></a>二、android中的线程池</h2><p>线程池主要有如下几个优点：</p>\n<ul>\n<li>重用线程池中的线程，避免因线程的重复创建和销毁导致的性能开销；</li>\n<li>能有效控制线程池的最大并发数，避免线程相互抢占资源导致阻塞；</li>\n<li>能够对线程进行简单的管理，提供定时执行等功能。</li>\n</ul>\n<h3 id=\"2-1-ThreadPoolExecutor\"><a href=\"#2-1-ThreadPoolExecutor\" class=\"headerlink\" title=\"2.1  ThreadPoolExecutor\"></a>2.1  ThreadPoolExecutor</h3><p>android 中的线程池 源于 java 中的 Exector,Exector是一个接口，真正的线程池的实现类为 ThreadPoolExecutor 类，它提供了一系列的参数来配置线程池，通过不同的参数可以创建不同的线程池。<br>如下他它的一个常用构造方法的声明：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ThreadPoolExecutor (int corePoolSize,</span><br><span class=\"line\">                           int maximumPoolSize,</span><br><span class=\"line\">                           long keepAliveTime,</span><br><span class=\"line\">                           TimeUnit unit,</span><br><span class=\"line\">                           BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                           ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure></p>\n<p>参数说明：</p>\n<ul>\n<li><strong>corePoolSize</strong><br>核心线程数，默认情况下 一直存活着，即使处于闲置状态。将 allowCoreThreadTimeOut 属性设置为 true 时，闲置的核心线程等待新任务到来时会有超时策略，改时间间隔由 keepAliveTime 所指定，当时间超过 keepAliveTime 后，线程会被终止。</li>\n<li><strong>maximumPoolSize</strong><br>最大线程数，当线程数达到该值后，后续的线程会被阻塞。</li>\n<li><strong>keepAliveTime</strong><br>非核心线程闲置的超时时长，超过后就会被回收。</li>\n<li><strong>unit</strong><br>指定 keepAliveTime 参数的时间单位，常用的有 TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）等</li>\n<li><strong>workQueue</strong><br>线程池中的任务队列</li>\n<li><strong>threadFactory</strong><br>线程工厂，为线程池提供创建新线程的功能，是一个 接口。</li>\n</ul>\n<p>如下是 AsyncTask 中 THREAD_POOL_EXECUTOR 线程池的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//cpu 数</span><br><span class=\"line\">private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class=\"line\">//核心线程 </span><br><span class=\"line\">private static final int CORE_POOL_SIZE = Math.max (2, Math.min (CPU_COUNT - 1, 4) );</span><br><span class=\"line\">//线程池最大线程数 </span><br><span class=\"line\">private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;</span><br><span class=\"line\">//闲置超时时间 30s</span><br><span class=\"line\">private static final int KEEP_ALIVE_SECONDS = 30;</span><br><span class=\"line\"></span><br><span class=\"line\">private static final ThreadFactory sThreadFactory = new ThreadFactory()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private final AtomicInteger mCount = new AtomicInteger (1);</span><br><span class=\"line\"></span><br><span class=\"line\">    public Thread newThread (Runnable r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return new Thread (r, &quot;AsyncTask #&quot; + mCount.getAndIncrement() );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//任务队列容量 128</span><br><span class=\"line\">private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</span><br><span class=\"line\">    new LinkedBlockingQueue&lt;Runnable&gt; (128);</span><br><span class=\"line\">public static final Executor THREAD_POOL_EXECUTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">static</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor (</span><br><span class=\"line\">        CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class=\"line\">        sPoolWorkQueue, sThreadFactory);</span><br><span class=\"line\">    threadPoolExecutor.allowCoreThreadTimeOut (true);</span><br><span class=\"line\">    THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-线程池的分类\"><a href=\"#2-2-线程池的分类\" class=\"headerlink\" title=\"2.2 线程池的分类\"></a>2.2 线程池的分类</h3><p>除了 前面 的 ThreadPoolExecutor ，android 中还有如下四类线程池，他们都直接或者间接的通过配置 ThreadPoolExecutor 来实现自己的功能，通过 <code>Executors</code> 对应的new方法来创建。</p>\n<ul>\n<li><p><strong>FixedThreadPool</strong><br>通过 <code>Executors.newFixedThreadPool()</code> 创建，线程数固定的线程池，线程空闲时不会被回收，除非线程池被关闭。这种方式创建的线程池中只有核心线程且不会超时，任务队列无大小限制，能够更快的响应外界的请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static ExecutorService newFixedThreadPool (int nThreads)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return new ThreadPoolExecutor (nThreads, nThreads,</span><br><span class=\"line\">                                   0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                   new LinkedBlockingQueue&lt;Runnable&gt;() );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><strong>CachedThreadPool</strong><br>通过 <code>Executors.newCachedThreadPool()</code> 创建，是一种线程数不固定的线程池，只有核心线程，最大数为 Integer.MAX_VALUE，超时时间60s。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static ExecutorService newCachedThreadPool()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return new ThreadPoolExecutor (0, Integer.MAX_VALUE,</span><br><span class=\"line\">                                   60L, TimeUnit.SECONDS,</span><br><span class=\"line\">                                   new SynchronousQueue&lt;Runnable&gt;() );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>ScheduledThreadPool</strong><br>通过 <code>Executors.newScheduledThreadPool()</code> 创建，是一种核心线程数固定，非核心线程数不固定的线程池。主要用于执行定时任务和具有固定周期的重复任务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static ScheduledExecutorService newScheduledThreadPool (int corePoolSize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return new ScheduledThreadPoolExecutor (corePoolSize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public ScheduledThreadPoolExecutor (int corePoolSize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    super (corePoolSize, Integer.MAX_VALUE,</span><br><span class=\"line\">           DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class=\"line\">           new DelayedWorkQueue() );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><strong>SingleThreadExecutor</strong><br>通过 <code>Executors.newSingleThreadExecutor()</code> 创建，内部只有一个线程，可以确保所有的任务都在同一个线程中顺序执行，可以统一外界的任务到一个线程中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public static ExecutorService newSingleThreadExecutor()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return new FinalizableDelegatedExecutorService</span><br><span class=\"line\">           (new ThreadPoolExecutor (1, 1,</span><br><span class=\"line\">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                    new LinkedBlockingQueue&lt;Runnable&gt;() ) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这是系统提供的四种常见的 线程池，此外还可以根据自己的实际需要灵活的配置线程池。</p>"},{"title":"Eventbus 开源库的使用","date":"2016-04-23T08:26:25.000Z","_content":"EventBus是一款用用于android上的事件分发/订阅的总线，包含发布者、订阅者、事件和总线。主要用于android中intent,handler等在activity，fragment等组件间传递消息。<!--more-->它极好的将消息的发送者和接收者解耦，方便组件间的通信。\n下载地址：\n            原地址：https://github.com/greenrobot/EventBus\n            涛哥的地址：https://github.com/kymjs/EventBus （包含部分中文注释）\n\n### 1、简单使用\n\n首先下载改开源库，导入项目中。接下来就是具体的使用了。如下几个方法：\n\n -  EventBus.getDefault().register(this);注册订阅者\n -  EventBus.getDefault().post(\"点击按钮，发送消息\");发送消息，传入的是自己的事件类对象\n -  重写 onEventMainThread(Object object) 方法；接收处理消息，这里参数与发送消息的类型一致。\n -  在 onDestroy()中注销当订阅者。\n \n这里仅仅为了说明用法，简单的实现代码如下：\n```\npackage com.tx.eventbusdemo;\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport de.greenrobot.event.EventBus;\n\npublic class MainActivity extends Activity {\n\n\tprivate Button mbtnSend;\n\tprivate TextView mtvShowmsg;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\t//当前类注册为事件订阅者\n\t\tEventBus.getDefault().register(this);\n\t\tmbtnSend = (Button) findViewById(R.id.btn);\n\t\tmtvShowmsg = (TextView) findViewById(R.id.show);\n\n\t\tmbtnSend.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\t//发送消息\n\t\t\tEventBus.getDefault().post(\"点击按钮，发送消息\");\n\t\t\t}\n\t\t});\n\t}\n\t//接收处理消息\n\tpublic void onEventMainThread(Object object) {  \n\t\tmtvShowmsg.setText(object.toString());\n\t}\n\t@Override\n\tprotected void onDestroy() {\n\t\tsuper.onDestroy();\n\t\t//注销注册\n\t\tEventBus.getDefault().unregister(this);\n\t}\n}\n```\n效果图：\n![](http://img.blog.csdn.net/20151230182722984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n### 2、解析实现过程\n\n首先在oncreate方法中注册订阅者，它就会扫描当前类，把onEvent开头的方法记录到map中（Key为方法的参数类型，Value中包含我们的方法）；\n当子线程执行完毕后，调用post方法，根据其参数查找对应的方法，通过反射来执行相关的方法。\n\nEventBus包含4个ThreadMode：PostThread，MainThread，BackgroundThread，Async。\n对应的方法及功能为：\n**onEventPostThread**   在当前发布事件的线程中执行\n**onEventMainThread**   在ui线程中执行\n**onEventAsync**   加入后台任务队列，使用线程池调用。\n**onEventBackgroundThread**   在非UI线程发布的事件，则直接执行；否则，加入后台任务队列，使用线程池一个接一个调用。\n","source":"_posts/Eventbus-simple-use.md","raw":"---\ntitle: Eventbus 开源库的使用\ndate: 2016-04-23 16:26:25\ncategories: [android,学习笔记]\ntags: [Eventbus,开源框架]\n---\nEventBus是一款用用于android上的事件分发/订阅的总线，包含发布者、订阅者、事件和总线。主要用于android中intent,handler等在activity，fragment等组件间传递消息。<!--more-->它极好的将消息的发送者和接收者解耦，方便组件间的通信。\n下载地址：\n            原地址：https://github.com/greenrobot/EventBus\n            涛哥的地址：https://github.com/kymjs/EventBus （包含部分中文注释）\n\n### 1、简单使用\n\n首先下载改开源库，导入项目中。接下来就是具体的使用了。如下几个方法：\n\n -  EventBus.getDefault().register(this);注册订阅者\n -  EventBus.getDefault().post(\"点击按钮，发送消息\");发送消息，传入的是自己的事件类对象\n -  重写 onEventMainThread(Object object) 方法；接收处理消息，这里参数与发送消息的类型一致。\n -  在 onDestroy()中注销当订阅者。\n \n这里仅仅为了说明用法，简单的实现代码如下：\n```\npackage com.tx.eventbusdemo;\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport de.greenrobot.event.EventBus;\n\npublic class MainActivity extends Activity {\n\n\tprivate Button mbtnSend;\n\tprivate TextView mtvShowmsg;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\t//当前类注册为事件订阅者\n\t\tEventBus.getDefault().register(this);\n\t\tmbtnSend = (Button) findViewById(R.id.btn);\n\t\tmtvShowmsg = (TextView) findViewById(R.id.show);\n\n\t\tmbtnSend.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\t//发送消息\n\t\t\tEventBus.getDefault().post(\"点击按钮，发送消息\");\n\t\t\t}\n\t\t});\n\t}\n\t//接收处理消息\n\tpublic void onEventMainThread(Object object) {  \n\t\tmtvShowmsg.setText(object.toString());\n\t}\n\t@Override\n\tprotected void onDestroy() {\n\t\tsuper.onDestroy();\n\t\t//注销注册\n\t\tEventBus.getDefault().unregister(this);\n\t}\n}\n```\n效果图：\n![](http://img.blog.csdn.net/20151230182722984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n### 2、解析实现过程\n\n首先在oncreate方法中注册订阅者，它就会扫描当前类，把onEvent开头的方法记录到map中（Key为方法的参数类型，Value中包含我们的方法）；\n当子线程执行完毕后，调用post方法，根据其参数查找对应的方法，通过反射来执行相关的方法。\n\nEventBus包含4个ThreadMode：PostThread，MainThread，BackgroundThread，Async。\n对应的方法及功能为：\n**onEventPostThread**   在当前发布事件的线程中执行\n**onEventMainThread**   在ui线程中执行\n**onEventAsync**   加入后台任务队列，使用线程池调用。\n**onEventBackgroundThread**   在非UI线程发布的事件，则直接执行；否则，加入后台任务队列，使用线程池一个接一个调用。\n","slug":"Eventbus-simple-use","published":1,"updated":"2016-04-23T10:07:49.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuceu000bg0g54i5aro9j","content":"<p>EventBus是一款用用于android上的事件分发/订阅的总线，包含发布者、订阅者、事件和总线。主要用于android中intent,handler等在activity，fragment等组件间传递消息。<a id=\"more\"></a>它极好的将消息的发送者和接收者解耦，方便组件间的通信。<br>下载地址：<br>            原地址：<a href=\"https://github.com/greenrobot/EventBus\" target=\"_blank\" rel=\"external\">https://github.com/greenrobot/EventBus</a><br>            涛哥的地址：<a href=\"https://github.com/kymjs/EventBus\" target=\"_blank\" rel=\"external\">https://github.com/kymjs/EventBus</a> （包含部分中文注释）</p>\n<h3 id=\"1、简单使用\"><a href=\"#1、简单使用\" class=\"headerlink\" title=\"1、简单使用\"></a>1、简单使用</h3><p>首先下载改开源库，导入项目中。接下来就是具体的使用了。如下几个方法：</p>\n<ul>\n<li>EventBus.getDefault().register(this);注册订阅者</li>\n<li>EventBus.getDefault().post(“点击按钮，发送消息”);发送消息，传入的是自己的事件类对象</li>\n<li>重写 onEventMainThread(Object object) 方法；接收处理消息，这里参数与发送消息的类型一致。</li>\n<li>在 onDestroy()中注销当订阅者。</li>\n</ul>\n<p>这里仅仅为了说明用法，简单的实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tx.eventbusdemo;</span><br><span class=\"line\">import android.app.Activity;</span><br><span class=\"line\">import android.os.Bundle;</span><br><span class=\"line\">import android.view.View;</span><br><span class=\"line\">import android.view.View.OnClickListener;</span><br><span class=\"line\">import android.widget.Button;</span><br><span class=\"line\">import android.widget.TextView;</span><br><span class=\"line\">import de.greenrobot.event.EventBus;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MainActivity extends Activity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Button mbtnSend;</span><br><span class=\"line\">\tprivate TextView mtvShowmsg;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\t\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\t\tsetContentView(R.layout.activity_main);</span><br><span class=\"line\">\t\t//当前类注册为事件订阅者</span><br><span class=\"line\">\t\tEventBus.getDefault().register(this);</span><br><span class=\"line\">\t\tmbtnSend = (Button) findViewById(R.id.btn);</span><br><span class=\"line\">\t\tmtvShowmsg = (TextView) findViewById(R.id.show);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmbtnSend.setOnClickListener(new OnClickListener() &#123;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic void onClick(View v) &#123;</span><br><span class=\"line\">\t\t\t\t//发送消息</span><br><span class=\"line\">\t\t\tEventBus.getDefault().post(&quot;点击按钮，发送消息&quot;);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//接收处理消息</span><br><span class=\"line\">\tpublic void onEventMainThread(Object object) &#123;  </span><br><span class=\"line\">\t\tmtvShowmsg.setText(object.toString());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onDestroy() &#123;</span><br><span class=\"line\">\t\tsuper.onDestroy();</span><br><span class=\"line\">\t\t//注销注册</span><br><span class=\"line\">\t\tEventBus.getDefault().unregister(this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果图：<br><img src=\"http://img.blog.csdn.net/20151230182722984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h3 id=\"2、解析实现过程\"><a href=\"#2、解析实现过程\" class=\"headerlink\" title=\"2、解析实现过程\"></a>2、解析实现过程</h3><p>首先在oncreate方法中注册订阅者，它就会扫描当前类，把onEvent开头的方法记录到map中（Key为方法的参数类型，Value中包含我们的方法）；<br>当子线程执行完毕后，调用post方法，根据其参数查找对应的方法，通过反射来执行相关的方法。</p>\n<p>EventBus包含4个ThreadMode：PostThread，MainThread，BackgroundThread，Async。<br>对应的方法及功能为：<br><strong>onEventPostThread</strong>   在当前发布事件的线程中执行<br><strong>onEventMainThread</strong>   在ui线程中执行<br><strong>onEventAsync</strong>   加入后台任务队列，使用线程池调用。<br><strong>onEventBackgroundThread</strong>   在非UI线程发布的事件，则直接执行；否则，加入后台任务队列，使用线程池一个接一个调用。</p>\n","excerpt":"<p>EventBus是一款用用于android上的事件分发/订阅的总线，包含发布者、订阅者、事件和总线。主要用于android中intent,handler等在activity，fragment等组件间传递消息。","more":"它极好的将消息的发送者和接收者解耦，方便组件间的通信。<br>下载地址：<br>            原地址：<a href=\"https://github.com/greenrobot/EventBus\">https://github.com/greenrobot/EventBus</a><br>            涛哥的地址：<a href=\"https://github.com/kymjs/EventBus\">https://github.com/kymjs/EventBus</a> （包含部分中文注释）</p>\n<h3 id=\"1、简单使用\"><a href=\"#1、简单使用\" class=\"headerlink\" title=\"1、简单使用\"></a>1、简单使用</h3><p>首先下载改开源库，导入项目中。接下来就是具体的使用了。如下几个方法：</p>\n<ul>\n<li>EventBus.getDefault().register(this);注册订阅者</li>\n<li>EventBus.getDefault().post(“点击按钮，发送消息”);发送消息，传入的是自己的事件类对象</li>\n<li>重写 onEventMainThread(Object object) 方法；接收处理消息，这里参数与发送消息的类型一致。</li>\n<li>在 onDestroy()中注销当订阅者。</li>\n</ul>\n<p>这里仅仅为了说明用法，简单的实现代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tx.eventbusdemo;</span><br><span class=\"line\">import android.app.Activity;</span><br><span class=\"line\">import android.os.Bundle;</span><br><span class=\"line\">import android.view.View;</span><br><span class=\"line\">import android.view.View.OnClickListener;</span><br><span class=\"line\">import android.widget.Button;</span><br><span class=\"line\">import android.widget.TextView;</span><br><span class=\"line\">import de.greenrobot.event.EventBus;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MainActivity extends Activity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Button mbtnSend;</span><br><span class=\"line\">\tprivate TextView mtvShowmsg;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\t\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\t\tsetContentView(R.layout.activity_main);</span><br><span class=\"line\">\t\t//当前类注册为事件订阅者</span><br><span class=\"line\">\t\tEventBus.getDefault().register(this);</span><br><span class=\"line\">\t\tmbtnSend = (Button) findViewById(R.id.btn);</span><br><span class=\"line\">\t\tmtvShowmsg = (TextView) findViewById(R.id.show);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmbtnSend.setOnClickListener(new OnClickListener() &#123;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic void onClick(View v) &#123;</span><br><span class=\"line\">\t\t\t\t//发送消息</span><br><span class=\"line\">\t\t\tEventBus.getDefault().post(&quot;点击按钮，发送消息&quot;);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//接收处理消息</span><br><span class=\"line\">\tpublic void onEventMainThread(Object object) &#123;  </span><br><span class=\"line\">\t\tmtvShowmsg.setText(object.toString());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onDestroy() &#123;</span><br><span class=\"line\">\t\tsuper.onDestroy();</span><br><span class=\"line\">\t\t//注销注册</span><br><span class=\"line\">\t\tEventBus.getDefault().unregister(this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果图：<br><img src=\"http://img.blog.csdn.net/20151230182722984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h3 id=\"2、解析实现过程\"><a href=\"#2、解析实现过程\" class=\"headerlink\" title=\"2、解析实现过程\"></a>2、解析实现过程</h3><p>首先在oncreate方法中注册订阅者，它就会扫描当前类，把onEvent开头的方法记录到map中（Key为方法的参数类型，Value中包含我们的方法）；<br>当子线程执行完毕后，调用post方法，根据其参数查找对应的方法，通过反射来执行相关的方法。</p>\n<p>EventBus包含4个ThreadMode：PostThread，MainThread，BackgroundThread，Async。<br>对应的方法及功能为：<br><strong>onEventPostThread</strong>   在当前发布事件的线程中执行<br><strong>onEventMainThread</strong>   在ui线程中执行<br><strong>onEventAsync</strong>   加入后台任务队列，使用线程池调用。<br><strong>onEventBackgroundThread</strong>   在非UI线程发布的事件，则直接执行；否则，加入后台任务队列，使用线程池一个接一个调用。</p>"},{"title":"PhotoView与GifView的使用","date":"2016-04-23T08:11:25.000Z","_content":"为了解决图片的缩放和gif格式的图片显示问题，这里采用了开源库PhototView(处理图片缩放问题)和GifView(显示gif格式图片)。<!--more-->\n[PhototView下载路径](http://download.csdn.net/detail/txadf/9204419)，[GifView下载路径](http://download.csdn.net/detail/txadf/9204413)，[Demo下载路径](http://download.csdn.net/detail/txadf/9204481)\n### 1、PhotoView加载本地图片\n```\n/**\n * PhotoView 加载本地图片\n */\n\nprivate ImageView mImageView;\nprivate PhotoViewAttacher mPhotoViewAttacher;\n\nprotected void onCreate(Bundle savedInstanceState) {\n\tsuper.onCreate(savedInstanceState);\n\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\tsetContentView(R.layout.photoview_local);\n\tmImageView = (ImageView) findViewById(R.id.iv_img);\n\tmPhotoViewAttacher = new PhotoViewAttacher(mImageView);\n\n\ttry {\n\t\tInputStream inputStream = getAssets().open(\"testPhotoView.jpg\");\n\n\t\tBitmap bitmap = BitmapFactory.decodeStream(inputStream);\n\t\tmImageView.setImageBitmap(bitmap);</span>\n\t} catch (IOException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\n}\n```\n\t\n### 2、PhotoView加载网络图片：\n```\n/**\n * PhotoView 加载网络图片\n */\n\nprivate PhotoView mImageView;\nprivate PhotoViewAttacher mPhotoViewAttacher;\n\nprivate ImageLoader mImageLoader;\n\nprivate  String URL = \"http://pic3.nipic.com/20090525/2416945_231841034_2.jpg\";\n\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\t// TODO Auto-generated method stub\n\tsuper.onCreate(savedInstanceState);\n\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\tsetContentView(R.layout.photoview_network);\n\n\tmImageView = (PhotoView) findViewById(R.id.iv_img);\n\n\tmPhotoViewAttacher = new PhotoViewAttacher(mImageView);\n\tmImageLoader = ImageLoader.getInstance();\n\tmImageLoader.displayImage(URL, mImageView);\n\n\tmImageView.setOnPhotoTapListener(new OnPhotoTapListener() {\n\n\t\t@Override\n\t\tpublic void onPhotoTap(View arg0, float arg1, float arg2) {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t}\n\t});\n}\n```\n布局文件：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\" >\n\n    <uk.co.senab.photoview.PhotoView\n        android:id=\"@+id/iv_img\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\" />\n\n</LinearLayout></span>\n```\n### 3、GifView加载本地图片：\n```\nprivate GifView mGifView;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\t// TODO Auto-generated method stub\n\tsuper.onCreate(savedInstanceState);\n\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\tsetContentView(R.layout.gifview);\n\n\tmGifView = (GifView) findViewById(R.id.gifview);\n\t//加载本地图片\n\tmGifView.setGifImage(R.drawable.gifview);\n}\n```\n布局文件：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    android:orientation=\"vertical\" >\n\n    <com.ant.liao.GifView\n        android:id=\"@+id/gifview\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\" />\n\n</LinearLayout></span>\n```","source":"_posts/PhotoView_GifView.md","raw":"---\ntitle: PhotoView与GifView的使用\ndate: 2016-04-23 16:11:25\ncategories: [android,学习笔记]\ntags: [android,图片缩放,gif]\n---\n为了解决图片的缩放和gif格式的图片显示问题，这里采用了开源库PhototView(处理图片缩放问题)和GifView(显示gif格式图片)。<!--more-->\n[PhototView下载路径](http://download.csdn.net/detail/txadf/9204419)，[GifView下载路径](http://download.csdn.net/detail/txadf/9204413)，[Demo下载路径](http://download.csdn.net/detail/txadf/9204481)\n### 1、PhotoView加载本地图片\n```\n/**\n * PhotoView 加载本地图片\n */\n\nprivate ImageView mImageView;\nprivate PhotoViewAttacher mPhotoViewAttacher;\n\nprotected void onCreate(Bundle savedInstanceState) {\n\tsuper.onCreate(savedInstanceState);\n\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\tsetContentView(R.layout.photoview_local);\n\tmImageView = (ImageView) findViewById(R.id.iv_img);\n\tmPhotoViewAttacher = new PhotoViewAttacher(mImageView);\n\n\ttry {\n\t\tInputStream inputStream = getAssets().open(\"testPhotoView.jpg\");\n\n\t\tBitmap bitmap = BitmapFactory.decodeStream(inputStream);\n\t\tmImageView.setImageBitmap(bitmap);</span>\n\t} catch (IOException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\n}\n```\n\t\n### 2、PhotoView加载网络图片：\n```\n/**\n * PhotoView 加载网络图片\n */\n\nprivate PhotoView mImageView;\nprivate PhotoViewAttacher mPhotoViewAttacher;\n\nprivate ImageLoader mImageLoader;\n\nprivate  String URL = \"http://pic3.nipic.com/20090525/2416945_231841034_2.jpg\";\n\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\t// TODO Auto-generated method stub\n\tsuper.onCreate(savedInstanceState);\n\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\tsetContentView(R.layout.photoview_network);\n\n\tmImageView = (PhotoView) findViewById(R.id.iv_img);\n\n\tmPhotoViewAttacher = new PhotoViewAttacher(mImageView);\n\tmImageLoader = ImageLoader.getInstance();\n\tmImageLoader.displayImage(URL, mImageView);\n\n\tmImageView.setOnPhotoTapListener(new OnPhotoTapListener() {\n\n\t\t@Override\n\t\tpublic void onPhotoTap(View arg0, float arg1, float arg2) {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t}\n\t});\n}\n```\n布局文件：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\" >\n\n    <uk.co.senab.photoview.PhotoView\n        android:id=\"@+id/iv_img\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\" />\n\n</LinearLayout></span>\n```\n### 3、GifView加载本地图片：\n```\nprivate GifView mGifView;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\t// TODO Auto-generated method stub\n\tsuper.onCreate(savedInstanceState);\n\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\tsetContentView(R.layout.gifview);\n\n\tmGifView = (GifView) findViewById(R.id.gifview);\n\t//加载本地图片\n\tmGifView.setGifImage(R.drawable.gifview);\n}\n```\n布局文件：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    android:orientation=\"vertical\" >\n\n    <com.ant.liao.GifView\n        android:id=\"@+id/gifview\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\" />\n\n</LinearLayout></span>\n```","slug":"PhotoView_GifView","published":1,"updated":"2016-04-23T09:29:07.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucfa000dg0g5x3buf32v","content":"<p>为了解决图片的缩放和gif格式的图片显示问题，这里采用了开源库PhototView(处理图片缩放问题)和GifView(显示gif格式图片)。<a id=\"more\"></a><br><a href=\"http://download.csdn.net/detail/txadf/9204419\" target=\"_blank\" rel=\"external\">PhototView下载路径</a>，<a href=\"http://download.csdn.net/detail/txadf/9204413\" target=\"_blank\" rel=\"external\">GifView下载路径</a>，<a href=\"http://download.csdn.net/detail/txadf/9204481\" target=\"_blank\" rel=\"external\">Demo下载路径</a></p>\n<h3 id=\"1、PhotoView加载本地图片\"><a href=\"#1、PhotoView加载本地图片\" class=\"headerlink\" title=\"1、PhotoView加载本地图片\"></a>1、PhotoView加载本地图片</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * PhotoView 加载本地图片</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">private ImageView mImageView;</span><br><span class=\"line\">private PhotoViewAttacher mPhotoViewAttacher;</span><br><span class=\"line\"></span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\trequestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class=\"line\">\tsetContentView(R.layout.photoview_local);</span><br><span class=\"line\">\tmImageView = (ImageView) findViewById(R.id.iv_img);</span><br><span class=\"line\">\tmPhotoViewAttacher = new PhotoViewAttacher(mImageView);</span><br><span class=\"line\"></span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tInputStream inputStream = getAssets().open(&quot;testPhotoView.jpg&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tBitmap bitmap = BitmapFactory.decodeStream(inputStream);</span><br><span class=\"line\">\t\tmImageView.setImageBitmap(bitmap);&lt;/span&gt;</span><br><span class=\"line\">\t&#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated catch block</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、PhotoView加载网络图片：\"><a href=\"#2、PhotoView加载网络图片：\" class=\"headerlink\" title=\"2、PhotoView加载网络图片：\"></a>2、PhotoView加载网络图片：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * PhotoView 加载网络图片</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">private PhotoView mImageView;</span><br><span class=\"line\">private PhotoViewAttacher mPhotoViewAttacher;</span><br><span class=\"line\"></span><br><span class=\"line\">private ImageLoader mImageLoader;</span><br><span class=\"line\"></span><br><span class=\"line\">private  String URL = &quot;http://pic3.nipic.com/20090525/2416945_231841034_2.jpg&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\t// TODO Auto-generated method stub</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\trequestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class=\"line\">\tsetContentView(R.layout.photoview_network);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmImageView = (PhotoView) findViewById(R.id.iv_img);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmPhotoViewAttacher = new PhotoViewAttacher(mImageView);</span><br><span class=\"line\">\tmImageLoader = ImageLoader.getInstance();</span><br><span class=\"line\">\tmImageLoader.displayImage(URL, mImageView);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmImageView.setOnPhotoTapListener(new OnPhotoTapListener() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void onPhotoTap(View arg0, float arg1, float arg2) &#123;</span><br><span class=\"line\">\t\t\t// TODO Auto-generated method stub</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>布局文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:orientation=&quot;vertical&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;uk.co.senab.photoview.PhotoView</span><br><span class=\"line\">        android:id=&quot;@+id/iv_img&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;fill_parent&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/LinearLayout&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3、GifView加载本地图片：\"><a href=\"#3、GifView加载本地图片：\" class=\"headerlink\" title=\"3、GifView加载本地图片：\"></a>3、GifView加载本地图片：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private GifView mGifView;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\t// TODO Auto-generated method stub</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\trequestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class=\"line\">\tsetContentView(R.layout.gifview);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmGifView = (GifView) findViewById(R.id.gifview);</span><br><span class=\"line\">\t//加载本地图片</span><br><span class=\"line\">\tmGifView.setGifImage(R.drawable.gifview);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>布局文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:gravity=&quot;center&quot;</span><br><span class=\"line\">    android:orientation=&quot;vertical&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;com.ant.liao.GifView</span><br><span class=\"line\">        android:id=&quot;@+id/gifview&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;fill_parent&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/LinearLayout&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<p>为了解决图片的缩放和gif格式的图片显示问题，这里采用了开源库PhototView(处理图片缩放问题)和GifView(显示gif格式图片)。","more":"<br><a href=\"http://download.csdn.net/detail/txadf/9204419\">PhototView下载路径</a>，<a href=\"http://download.csdn.net/detail/txadf/9204413\">GifView下载路径</a>，<a href=\"http://download.csdn.net/detail/txadf/9204481\">Demo下载路径</a></p>\n<h3 id=\"1、PhotoView加载本地图片\"><a href=\"#1、PhotoView加载本地图片\" class=\"headerlink\" title=\"1、PhotoView加载本地图片\"></a>1、PhotoView加载本地图片</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * PhotoView 加载本地图片</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">private ImageView mImageView;</span><br><span class=\"line\">private PhotoViewAttacher mPhotoViewAttacher;</span><br><span class=\"line\"></span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\trequestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class=\"line\">\tsetContentView(R.layout.photoview_local);</span><br><span class=\"line\">\tmImageView = (ImageView) findViewById(R.id.iv_img);</span><br><span class=\"line\">\tmPhotoViewAttacher = new PhotoViewAttacher(mImageView);</span><br><span class=\"line\"></span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tInputStream inputStream = getAssets().open(&quot;testPhotoView.jpg&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tBitmap bitmap = BitmapFactory.decodeStream(inputStream);</span><br><span class=\"line\">\t\tmImageView.setImageBitmap(bitmap);&lt;/span&gt;</span><br><span class=\"line\">\t&#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated catch block</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、PhotoView加载网络图片：\"><a href=\"#2、PhotoView加载网络图片：\" class=\"headerlink\" title=\"2、PhotoView加载网络图片：\"></a>2、PhotoView加载网络图片：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * PhotoView 加载网络图片</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">private PhotoView mImageView;</span><br><span class=\"line\">private PhotoViewAttacher mPhotoViewAttacher;</span><br><span class=\"line\"></span><br><span class=\"line\">private ImageLoader mImageLoader;</span><br><span class=\"line\"></span><br><span class=\"line\">private  String URL = &quot;http://pic3.nipic.com/20090525/2416945_231841034_2.jpg&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\t// TODO Auto-generated method stub</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\trequestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class=\"line\">\tsetContentView(R.layout.photoview_network);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmImageView = (PhotoView) findViewById(R.id.iv_img);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmPhotoViewAttacher = new PhotoViewAttacher(mImageView);</span><br><span class=\"line\">\tmImageLoader = ImageLoader.getInstance();</span><br><span class=\"line\">\tmImageLoader.displayImage(URL, mImageView);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmImageView.setOnPhotoTapListener(new OnPhotoTapListener() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void onPhotoTap(View arg0, float arg1, float arg2) &#123;</span><br><span class=\"line\">\t\t\t// TODO Auto-generated method stub</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>布局文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:orientation=&quot;vertical&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;uk.co.senab.photoview.PhotoView</span><br><span class=\"line\">        android:id=&quot;@+id/iv_img&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;fill_parent&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/LinearLayout&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3、GifView加载本地图片：\"><a href=\"#3、GifView加载本地图片：\" class=\"headerlink\" title=\"3、GifView加载本地图片：\"></a>3、GifView加载本地图片：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private GifView mGifView;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\t// TODO Auto-generated method stub</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\trequestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class=\"line\">\tsetContentView(R.layout.gifview);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmGifView = (GifView) findViewById(R.id.gifview);</span><br><span class=\"line\">\t//加载本地图片</span><br><span class=\"line\">\tmGifView.setGifImage(R.drawable.gifview);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>布局文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:gravity=&quot;center&quot;</span><br><span class=\"line\">    android:orientation=&quot;vertical&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;com.ant.liao.GifView</span><br><span class=\"line\">        android:id=&quot;@+id/gifview&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;fill_parent&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/LinearLayout&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>"},{"title":"属性动画详解（Animator）","date":"2016-04-25T11:00:38.000Z","_content":"# 1、概述\n对于之前介绍的Animation，它属于**视图动画**（View Animation）(可参见：[Animation 动画详解](http://imtianx.cn/2016/04/25/view-Animation/))，包括**补间动画**（Tween Animation）和**逐帧动画**（Tween Animation）；而在android中还有另一种动画，那就是**属性动画**（Property Animator），它包括**ValueAnimator** 和 **ObjectAnimator**。\n<!--more-->\n两者的**区别**：\n\n - 引入时间不同\n   视图动画在API Level 1 引入的，而属性动画在API Level 11（即 android 3.0）引入的； \n - 所在包不同\n 视图动画在 **android.view.animation.Animation**包下，属性动画在：**android.animation**包下\n - 动画类的命名不同\n 视图动画中类的名字为：**XXXAnimation**，而在属性动画中是：**XXXAnimator**\n - **作用的对象不同**（这个也是引入属性动画的原因）\n **视图动画是对控件做动画，不能改变控件内部的属性，对所有的控件都可以；而属性动画是通过改变控件的属性来实现动画，但使用ObjectAnimator时要求作用的控件的属性要有get,set方法。如果控件的属性没有get/set方法，可以通过包装类间接的设置get/set方法，或者使用ValueAnimator 实现。**\n\n# 2、ValueAnimator 的基本使用\nValueAnimator是动画的核心，但不提供任何动画效果，它更像一个数值发生器，产生具有一定规律的数字，然后让调用者来控制动画的实现过程。用法如下：\n\n - **创建ValueAnimator实例**\n 例：创建0到500的动画，时间为1s:\n ```\nValueAnimator animator = ValueAnimator.ofInt(0,500);  \nanimator.setDuration(1000); \n ```\n代码中可以看出，它不与任何控件关联，只对动画做运算。\n\n - **添加它的监听事件**\n 下面是给它添加监听事件，实现动画的。\n ``` \n animator.addUpdateListener(new ValueAnimator.\n                        AnimatorUpdateListener() {\n                    @Override\n                    public void onAnimationUpdate(ValueAnimator animation) {\n                        //具体处理动画逻辑\n                    }\n                });\n                //开启动画\n                animator.start();\n    \n ```\n 具体示例：\n 点击按钮使textView从(200,200)移动到（600，,600）\n  ```\n  btnStartAnim = (Button) findViewById(R.id.btn);\ntv = (TextView) findViewById(R.id.tv);\nbtnStartAnim.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        //设置数据\n        ValueAnimator animator = ValueAnimator.ofInt(200, 600);\n        animator.setDuration(1000);\n        //监听动画\n        animator.addUpdateListener(new ValueAnimator.\n                AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                //获取当前动画的值\n                int curValue = (int) animation.getAnimatedValue();\n                //设置tv的位置\n                tv.layout(curValue, curValue,\n                        curValue + tv.getWidth(),\n                        curValue + tv.getHeight());\n            }\n        });\n        //开启动画\n        animator.start();\n    }\n});\n  ```\n示例效果：\n![](/img/article_img/ValueAnimator-simple-demo.gif)\n\n# 3、ValueAnimator 常用方法\n \n```\n/**\n* 设置动画参数，参数类型为可变参数\n*/\nValueAnimator ofInt(int... values);\nValueAnimator ofFloat(int... values);\n\n/**\n* 设置动画时长，单位是毫秒\n*/\nValueAnimator setDuration(long duration);\n\n/**\n* 获取 ValueAnimator 在运动时，当前运动点的值\n*/\nObject getAnimatedValue();\n\n/**\n* 开始动画\n*/\nvoid start();\n\n/**\n* 设置循环次数,设置为 INFINITE 表示无限循环\n*/\nvoid setRepeatCount(int value);\n\n/**\n* 设置循环模式\n* value 取值有 RESTART，REVERSE（分别为：重新开始，倒序重新开始）\n*/\nvoid setRepeatMode(int value);\n\n/**\n* 取消动画\n*/\nvoid cancel();\n```\n通过源码，发现ofInt和ofFloat方法内部实现一样的，他们的区别在于传入的参数类型不同，需要注意的是在使用**getAnimatedValue**方法时，如果前面**使用的是ofInt,要强转成int 类型**，否则，转为float类型。\n此外，如果不需要动画，可以调用移除动画监听方法，但需要先调用cancel方法取消动画。\n# 4、ObjectAnimator 的基本使用\nObjectAnimator 类继承自ValueAnimator，使用时通过静态工厂类直接返回一个对象，参数包括对象和对象的属性名，但该属性必须要有get和set函数，这样可以真实的控制一个view的属性值，因此它基本可以实现所有的动画效果。\n使用示例：\n使textView的translationX从0变化到200在变化到500，持续时间为1s,代码如下：\n```\nObjectAnimator animator = ObjectAnimator.ofFloat(textView,\n            \"translationX\",new float[]{200,500});\n    animator.setDuration(1000);\n    animator.start();\n```\nofFloat的参数：第一个是要操纵的View；第二个是要操纵的属性；第三个是参数，是一个可变数组。同样的，可以给它设置显示时长，插值器等。\n在开始提到了，ObjectAnimator用于有get，set属性的控件，对于没有的可以通过一个包装类来实现，如下：\n```\n/**\n * 包装类，给width添加get，set方法\n */\npublic static class WrapperView {\n    private View mTarget;\n\n    public WrapperView(View target) {\n        mTarget = target;\n    }\n\n    public int getWidth() {\n        return mTarget.getLayoutParams().width;\n    }\n\n    public void setWidth(int width) {\n        mTarget.getLayoutParams().width = width;\n        mTarget.requestLayout();\n    }\n}\n```\n使用时，直接操纵包装类，如下：\n```\nWrapperView mWrapperView = new WrapperView(btnStartAnim);\nObjectAnimator animator = ObjectAnimator.ofInt(\n        mWrapperView,\"width\",500).setDuration(500);\nanimator.start();\n```\n通过上面，可以知道，ObjectAnimator 实现动画主要是通过set方法来设置控件的对应的属性实现动画。\n\n# 5、ObjectAnimator 的常用方法\n除了上面的ofInt,ofFloat方法，对于要改变背景色的，可以使用**ArgbEvaluator**，用法如下,给textView设置背景色在三种颜色间变化：\n```\nObjectAnimator animator = ObjectAnimator.ofInt(textView,\n        \"BackgroundColor\",0xffff00ff, 0xffffff00, 0xffff00ff);\nanimator.setDuration(2000);\nanimator.setEvaluator(new ArgbEvaluator());\nanimator.start();\n```\n其他常用函数如下：\n摘抄于：http://wiki.jikexueyuan.com/project/android-animation/7.html\n```\n/** \n * 设置动画时长，单位是毫秒 \n */  \nValueAnimator setDuration(long duration)  \n/** \n * 获取 ValueAnimator 在运动时，当前运动点的值 \n */  \nObject getAnimatedValue();  \n/** \n * 开始动画 \n */  \nvoid start()  \n/** \n * 设置循环次数,设置为 INFINITE 表示无限循环 \n */  \nvoid setRepeatCount(int value)  \n/** \n * 设置循环模式 \n * value 取值有 RESTART，REVERSE， \n */  \nvoid setRepeatMode(int value)  \n/** \n * 取消动画 \n */  \nvoid cancel() \n```\n监听相关的方法：\n```\n/** \n * 监听器一：监听动画变化时的实时值 \n */  \npublic static interface AnimatorUpdateListener {  \n    void onAnimationUpdate(ValueAnimator animation);  \n}  \n//添加方法为：public void addUpdateListener(AnimatorUpdateListener listener)  \n/** \n * 监听器二：监听动画变化时四个状态 \n */  \npublic static interface AnimatorListener {  \n    void onAnimationStart(Animator animation);  \n    void onAnimationEnd(Animator animation);  \n    void onAnimationCancel(Animator animation);  \n    void onAnimationRepeat(Animator animation);  \n}  \n//添加方法为：public void addListener(AnimatorListener listener)\n```\n插值器与 Evaluator:\n```\n/** \n * 设置插值器 \n */  \npublic void setInterpolator(TimeInterpolator value)  \n/** \n * 设置 Evaluator \n */  \npublic void setEvaluator(TypeEvaluator value) \n```\n\n更多方法可以查看api\n# 6、AnimatorSet的使用\n在视图动画中  AnimationSet 来处理混合动画，同样的，这里的AnimatorSet来处理多个动画的。它出了实现多种动画，还可以精确的进行顺序控制。\n示例代码：\n```\nObjectAnimator animator1 = ObjectAnimator.ofFloat(textView, \"translationX\", 300);\nObjectAnimator animator2 = ObjectAnimator.ofFloat(textView, \"scaleX\", 1, 0, 1);\nObjectAnimator animator3 = ObjectAnimator.ofFloat(textView, \"scaleY\", 1, 0, 1);\nAnimatorSet animatorSet = new AnimatorSet();\nanimatorSet.setDuration(1000);\nanimatorSet.playTogether(animator1, animator2, animator3);\nanimatorSet.start();\n```\n示例效果：\n![](/img/article_img/AnimatorSet.gif)\n\n以上示例设置textView在x轴方向移动300，x和y方向先缩小到一倍再还原到一倍三种动画是同时执行。\n若需要按顺序执行，可以调用Animator的**playSequentially**方法。\n\n# 7、PropertyValuesHolder 的使用\n除了上面讲的AnimatorSet 实现多种动画，还可以通过PropertyValuesHolder来实现，比如上面的例子在平移的过程中实现x,y轴的缩放。如下代码;\n```\nPropertyValuesHolder valuesHolder1 = PropertyValuesHolder\n    .ofFloat(\"translationX\", 300);\nPropertyValuesHolder valuesHolder2 = PropertyValuesHolder\n    .ofFloat(\"scaleX\", 1, 0, 1);\nPropertyValuesHolder valuesHolder3 = PropertyValuesHolder\n    .ofFloat(\"scaleY\", 1, 0, 1);\nObjectAnimator.ofPropertyValuesHolder(tv, valuesHolder1,\n    valuesHolder2, valuesHolder3).setDuration(1000).start();\n```\n\n运行效果同AnimatorSet中的示例。\n它的实现是先分别用PropertyValuesHolder的对象来控制不同的属性，最后调用ofPropertyValuesHolder方法实现多个属性动画的共同作用。\n\n# 8、在XML文件中实现属性动画\n先在xml文件中定义属性，如下示例：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    android:duration=1000\"\n    android:propertyName=\"scaleX\"\n    android:valueFrom=\"1.0\"\n    android:valueTo=\"2.0\"\n    android:valueType=\"floatType\"\n</objectAnimator>\n```\n在java代码代码中使用：\n```\nAnimator animator = AnimatorInflater.\n        loadAnimator(MainActivity.this,\n        R.animator.scalex);\nanimator.setTarget(tv);\nanimator.start();\n```\n需要注意的是，xml文件的定义需要放在res/animator下，而且根节点只能是：set,objectAnimator,valueAnimator三者之一。如果使用的set，可以为其指定播放的方式，属性名为：ordering=[\"together\"]|[\"sequentially\"]，\n默认值为：“together”，对于其他具体的属性这里不再赘述了，可以参见文档。\n在实际开发中建议使用代码实现动画，比较简单，而且很多时候某些属性的起始值无法确定。\n\n# 8、View的animate方法\n在android3.0之后，添加了animate方法来直接驱动属性动画，它其实是对属性动画的简写，如下示例：\n```\n view.animate()\n        .alpha(0)\n        .y(300)\n        .setDuration(1000)\n        .withStartAction(new Runnable() {\n            @Override\n            public void run() {\n\n            }\n        })\n        .withEndAction(new Runnable() {\n            @Override\n            public void run() {\n\n            }\n        }).start();\n\n```\n上面的例子很好理解，可以通过属性来确定他的含义。\n总之，在实现动画时，可以根据自己的实际情况选择相应的方式实现动画，必要的时候还可以自定义实现动画，往往在使用时，不只是一种动画，我们要选择合适的方式实现多种动画。","source":"_posts/Property-animatorValueAnimator_ObjectAnimation.md","raw":"---\ntitle: 属性动画详解（Animator）\ndate: 2016-04-25 19:00:38\ncategories: [android,学习笔记]\ntags: [android,Animator,属性动画]\n---\n# 1、概述\n对于之前介绍的Animation，它属于**视图动画**（View Animation）(可参见：[Animation 动画详解](http://imtianx.cn/2016/04/25/view-Animation/))，包括**补间动画**（Tween Animation）和**逐帧动画**（Tween Animation）；而在android中还有另一种动画，那就是**属性动画**（Property Animator），它包括**ValueAnimator** 和 **ObjectAnimator**。\n<!--more-->\n两者的**区别**：\n\n - 引入时间不同\n   视图动画在API Level 1 引入的，而属性动画在API Level 11（即 android 3.0）引入的； \n - 所在包不同\n 视图动画在 **android.view.animation.Animation**包下，属性动画在：**android.animation**包下\n - 动画类的命名不同\n 视图动画中类的名字为：**XXXAnimation**，而在属性动画中是：**XXXAnimator**\n - **作用的对象不同**（这个也是引入属性动画的原因）\n **视图动画是对控件做动画，不能改变控件内部的属性，对所有的控件都可以；而属性动画是通过改变控件的属性来实现动画，但使用ObjectAnimator时要求作用的控件的属性要有get,set方法。如果控件的属性没有get/set方法，可以通过包装类间接的设置get/set方法，或者使用ValueAnimator 实现。**\n\n# 2、ValueAnimator 的基本使用\nValueAnimator是动画的核心，但不提供任何动画效果，它更像一个数值发生器，产生具有一定规律的数字，然后让调用者来控制动画的实现过程。用法如下：\n\n - **创建ValueAnimator实例**\n 例：创建0到500的动画，时间为1s:\n ```\nValueAnimator animator = ValueAnimator.ofInt(0,500);  \nanimator.setDuration(1000); \n ```\n代码中可以看出，它不与任何控件关联，只对动画做运算。\n\n - **添加它的监听事件**\n 下面是给它添加监听事件，实现动画的。\n ``` \n animator.addUpdateListener(new ValueAnimator.\n                        AnimatorUpdateListener() {\n                    @Override\n                    public void onAnimationUpdate(ValueAnimator animation) {\n                        //具体处理动画逻辑\n                    }\n                });\n                //开启动画\n                animator.start();\n    \n ```\n 具体示例：\n 点击按钮使textView从(200,200)移动到（600，,600）\n  ```\n  btnStartAnim = (Button) findViewById(R.id.btn);\ntv = (TextView) findViewById(R.id.tv);\nbtnStartAnim.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        //设置数据\n        ValueAnimator animator = ValueAnimator.ofInt(200, 600);\n        animator.setDuration(1000);\n        //监听动画\n        animator.addUpdateListener(new ValueAnimator.\n                AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                //获取当前动画的值\n                int curValue = (int) animation.getAnimatedValue();\n                //设置tv的位置\n                tv.layout(curValue, curValue,\n                        curValue + tv.getWidth(),\n                        curValue + tv.getHeight());\n            }\n        });\n        //开启动画\n        animator.start();\n    }\n});\n  ```\n示例效果：\n![](/img/article_img/ValueAnimator-simple-demo.gif)\n\n# 3、ValueAnimator 常用方法\n \n```\n/**\n* 设置动画参数，参数类型为可变参数\n*/\nValueAnimator ofInt(int... values);\nValueAnimator ofFloat(int... values);\n\n/**\n* 设置动画时长，单位是毫秒\n*/\nValueAnimator setDuration(long duration);\n\n/**\n* 获取 ValueAnimator 在运动时，当前运动点的值\n*/\nObject getAnimatedValue();\n\n/**\n* 开始动画\n*/\nvoid start();\n\n/**\n* 设置循环次数,设置为 INFINITE 表示无限循环\n*/\nvoid setRepeatCount(int value);\n\n/**\n* 设置循环模式\n* value 取值有 RESTART，REVERSE（分别为：重新开始，倒序重新开始）\n*/\nvoid setRepeatMode(int value);\n\n/**\n* 取消动画\n*/\nvoid cancel();\n```\n通过源码，发现ofInt和ofFloat方法内部实现一样的，他们的区别在于传入的参数类型不同，需要注意的是在使用**getAnimatedValue**方法时，如果前面**使用的是ofInt,要强转成int 类型**，否则，转为float类型。\n此外，如果不需要动画，可以调用移除动画监听方法，但需要先调用cancel方法取消动画。\n# 4、ObjectAnimator 的基本使用\nObjectAnimator 类继承自ValueAnimator，使用时通过静态工厂类直接返回一个对象，参数包括对象和对象的属性名，但该属性必须要有get和set函数，这样可以真实的控制一个view的属性值，因此它基本可以实现所有的动画效果。\n使用示例：\n使textView的translationX从0变化到200在变化到500，持续时间为1s,代码如下：\n```\nObjectAnimator animator = ObjectAnimator.ofFloat(textView,\n            \"translationX\",new float[]{200,500});\n    animator.setDuration(1000);\n    animator.start();\n```\nofFloat的参数：第一个是要操纵的View；第二个是要操纵的属性；第三个是参数，是一个可变数组。同样的，可以给它设置显示时长，插值器等。\n在开始提到了，ObjectAnimator用于有get，set属性的控件，对于没有的可以通过一个包装类来实现，如下：\n```\n/**\n * 包装类，给width添加get，set方法\n */\npublic static class WrapperView {\n    private View mTarget;\n\n    public WrapperView(View target) {\n        mTarget = target;\n    }\n\n    public int getWidth() {\n        return mTarget.getLayoutParams().width;\n    }\n\n    public void setWidth(int width) {\n        mTarget.getLayoutParams().width = width;\n        mTarget.requestLayout();\n    }\n}\n```\n使用时，直接操纵包装类，如下：\n```\nWrapperView mWrapperView = new WrapperView(btnStartAnim);\nObjectAnimator animator = ObjectAnimator.ofInt(\n        mWrapperView,\"width\",500).setDuration(500);\nanimator.start();\n```\n通过上面，可以知道，ObjectAnimator 实现动画主要是通过set方法来设置控件的对应的属性实现动画。\n\n# 5、ObjectAnimator 的常用方法\n除了上面的ofInt,ofFloat方法，对于要改变背景色的，可以使用**ArgbEvaluator**，用法如下,给textView设置背景色在三种颜色间变化：\n```\nObjectAnimator animator = ObjectAnimator.ofInt(textView,\n        \"BackgroundColor\",0xffff00ff, 0xffffff00, 0xffff00ff);\nanimator.setDuration(2000);\nanimator.setEvaluator(new ArgbEvaluator());\nanimator.start();\n```\n其他常用函数如下：\n摘抄于：http://wiki.jikexueyuan.com/project/android-animation/7.html\n```\n/** \n * 设置动画时长，单位是毫秒 \n */  \nValueAnimator setDuration(long duration)  \n/** \n * 获取 ValueAnimator 在运动时，当前运动点的值 \n */  \nObject getAnimatedValue();  \n/** \n * 开始动画 \n */  \nvoid start()  \n/** \n * 设置循环次数,设置为 INFINITE 表示无限循环 \n */  \nvoid setRepeatCount(int value)  \n/** \n * 设置循环模式 \n * value 取值有 RESTART，REVERSE， \n */  \nvoid setRepeatMode(int value)  \n/** \n * 取消动画 \n */  \nvoid cancel() \n```\n监听相关的方法：\n```\n/** \n * 监听器一：监听动画变化时的实时值 \n */  \npublic static interface AnimatorUpdateListener {  \n    void onAnimationUpdate(ValueAnimator animation);  \n}  \n//添加方法为：public void addUpdateListener(AnimatorUpdateListener listener)  \n/** \n * 监听器二：监听动画变化时四个状态 \n */  \npublic static interface AnimatorListener {  \n    void onAnimationStart(Animator animation);  \n    void onAnimationEnd(Animator animation);  \n    void onAnimationCancel(Animator animation);  \n    void onAnimationRepeat(Animator animation);  \n}  \n//添加方法为：public void addListener(AnimatorListener listener)\n```\n插值器与 Evaluator:\n```\n/** \n * 设置插值器 \n */  \npublic void setInterpolator(TimeInterpolator value)  \n/** \n * 设置 Evaluator \n */  \npublic void setEvaluator(TypeEvaluator value) \n```\n\n更多方法可以查看api\n# 6、AnimatorSet的使用\n在视图动画中  AnimationSet 来处理混合动画，同样的，这里的AnimatorSet来处理多个动画的。它出了实现多种动画，还可以精确的进行顺序控制。\n示例代码：\n```\nObjectAnimator animator1 = ObjectAnimator.ofFloat(textView, \"translationX\", 300);\nObjectAnimator animator2 = ObjectAnimator.ofFloat(textView, \"scaleX\", 1, 0, 1);\nObjectAnimator animator3 = ObjectAnimator.ofFloat(textView, \"scaleY\", 1, 0, 1);\nAnimatorSet animatorSet = new AnimatorSet();\nanimatorSet.setDuration(1000);\nanimatorSet.playTogether(animator1, animator2, animator3);\nanimatorSet.start();\n```\n示例效果：\n![](/img/article_img/AnimatorSet.gif)\n\n以上示例设置textView在x轴方向移动300，x和y方向先缩小到一倍再还原到一倍三种动画是同时执行。\n若需要按顺序执行，可以调用Animator的**playSequentially**方法。\n\n# 7、PropertyValuesHolder 的使用\n除了上面讲的AnimatorSet 实现多种动画，还可以通过PropertyValuesHolder来实现，比如上面的例子在平移的过程中实现x,y轴的缩放。如下代码;\n```\nPropertyValuesHolder valuesHolder1 = PropertyValuesHolder\n    .ofFloat(\"translationX\", 300);\nPropertyValuesHolder valuesHolder2 = PropertyValuesHolder\n    .ofFloat(\"scaleX\", 1, 0, 1);\nPropertyValuesHolder valuesHolder3 = PropertyValuesHolder\n    .ofFloat(\"scaleY\", 1, 0, 1);\nObjectAnimator.ofPropertyValuesHolder(tv, valuesHolder1,\n    valuesHolder2, valuesHolder3).setDuration(1000).start();\n```\n\n运行效果同AnimatorSet中的示例。\n它的实现是先分别用PropertyValuesHolder的对象来控制不同的属性，最后调用ofPropertyValuesHolder方法实现多个属性动画的共同作用。\n\n# 8、在XML文件中实现属性动画\n先在xml文件中定义属性，如下示例：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    android:duration=1000\"\n    android:propertyName=\"scaleX\"\n    android:valueFrom=\"1.0\"\n    android:valueTo=\"2.0\"\n    android:valueType=\"floatType\"\n</objectAnimator>\n```\n在java代码代码中使用：\n```\nAnimator animator = AnimatorInflater.\n        loadAnimator(MainActivity.this,\n        R.animator.scalex);\nanimator.setTarget(tv);\nanimator.start();\n```\n需要注意的是，xml文件的定义需要放在res/animator下，而且根节点只能是：set,objectAnimator,valueAnimator三者之一。如果使用的set，可以为其指定播放的方式，属性名为：ordering=[\"together\"]|[\"sequentially\"]，\n默认值为：“together”，对于其他具体的属性这里不再赘述了，可以参见文档。\n在实际开发中建议使用代码实现动画，比较简单，而且很多时候某些属性的起始值无法确定。\n\n# 8、View的animate方法\n在android3.0之后，添加了animate方法来直接驱动属性动画，它其实是对属性动画的简写，如下示例：\n```\n view.animate()\n        .alpha(0)\n        .y(300)\n        .setDuration(1000)\n        .withStartAction(new Runnable() {\n            @Override\n            public void run() {\n\n            }\n        })\n        .withEndAction(new Runnable() {\n            @Override\n            public void run() {\n\n            }\n        }).start();\n\n```\n上面的例子很好理解，可以通过属性来确定他的含义。\n总之，在实现动画时，可以根据自己的实际情况选择相应的方式实现动画，必要的时候还可以自定义实现动画，往往在使用时，不只是一种动画，我们要选择合适的方式实现多种动画。","slug":"Property-animatorValueAnimator_ObjectAnimation","published":1,"updated":"2016-04-25T12:25:21.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucfa000eg0g5pz5kkt2j","content":"<h1 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h1><p>对于之前介绍的Animation，它属于<strong>视图动画</strong>（View Animation）(可参见：<a href=\"http://imtianx.cn/2016/04/25/view-Animation/\">Animation 动画详解</a>)，包括<strong>补间动画</strong>（Tween Animation）和<strong>逐帧动画</strong>（Tween Animation）；而在android中还有另一种动画，那就是<strong>属性动画</strong>（Property Animator），它包括<strong>ValueAnimator</strong> 和 <strong>ObjectAnimator</strong>。<br><a id=\"more\"></a><br>两者的<strong>区别</strong>：</p>\n<ul>\n<li>引入时间不同<br>视图动画在API Level 1 引入的，而属性动画在API Level 11（即 android 3.0）引入的； </li>\n<li>所在包不同<br>视图动画在 <strong>android.view.animation.Animation</strong>包下，属性动画在：<strong>android.animation</strong>包下</li>\n<li>动画类的命名不同<br>视图动画中类的名字为：<strong>XXXAnimation</strong>，而在属性动画中是：<strong>XXXAnimator</strong></li>\n<li><strong>作用的对象不同</strong>（这个也是引入属性动画的原因）<br><strong>视图动画是对控件做动画，不能改变控件内部的属性，对所有的控件都可以；而属性动画是通过改变控件的属性来实现动画，但使用ObjectAnimator时要求作用的控件的属性要有get,set方法。如果控件的属性没有get/set方法，可以通过包装类间接的设置get/set方法，或者使用ValueAnimator 实现。</strong></li>\n</ul>\n<h1 id=\"2、ValueAnimator-的基本使用\"><a href=\"#2、ValueAnimator-的基本使用\" class=\"headerlink\" title=\"2、ValueAnimator 的基本使用\"></a>2、ValueAnimator 的基本使用</h1><p>ValueAnimator是动画的核心，但不提供任何动画效果，它更像一个数值发生器，产生具有一定规律的数字，然后让调用者来控制动画的实现过程。用法如下：</p>\n<ul>\n<li><strong>创建ValueAnimator实例</strong><br>例：创建0到500的动画，时间为1s:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ValueAnimator animator = ValueAnimator.ofInt(0,500);  </span><br><span class=\"line\">animator.setDuration(1000);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>代码中可以看出，它不与任何控件关联，只对动画做运算。</p>\n<ul>\n<li><p><strong>添加它的监听事件</strong><br>下面是给它添加监听事件，实现动画的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animator.addUpdateListener(new ValueAnimator.</span><br><span class=\"line\">                       AnimatorUpdateListener() &#123;</span><br><span class=\"line\">                   @Override</span><br><span class=\"line\">                   public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class=\"line\">                       //具体处理动画逻辑</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">               //开启动画</span><br><span class=\"line\">               animator.start();</span><br></pre></td></tr></table></figure>\n<p>具体示例：<br>点击按钮使textView从(200,200)移动到（600，,600）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  btnStartAnim = (Button) findViewById(R.id.btn);</span><br><span class=\"line\">tv = (TextView) findViewById(R.id.tv);</span><br><span class=\"line\">btnStartAnim.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onClick(View v) &#123;</span><br><span class=\"line\">        //设置数据</span><br><span class=\"line\">        ValueAnimator animator = ValueAnimator.ofInt(200, 600);</span><br><span class=\"line\">        animator.setDuration(1000);</span><br><span class=\"line\">        //监听动画</span><br><span class=\"line\">        animator.addUpdateListener(new ValueAnimator.</span><br><span class=\"line\">                AnimatorUpdateListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class=\"line\">                //获取当前动画的值</span><br><span class=\"line\">                int curValue = (int) animation.getAnimatedValue();</span><br><span class=\"line\">                //设置tv的位置</span><br><span class=\"line\">                tv.layout(curValue, curValue,</span><br><span class=\"line\">                        curValue + tv.getWidth(),</span><br><span class=\"line\">                        curValue + tv.getHeight());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        //开启动画</span><br><span class=\"line\">        animator.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>示例效果：<br><img src=\"/img/article_img/ValueAnimator-simple-demo.gif\" alt=\"\"></p>\n<h1 id=\"3、ValueAnimator-常用方法\"><a href=\"#3、ValueAnimator-常用方法\" class=\"headerlink\" title=\"3、ValueAnimator 常用方法\"></a>3、ValueAnimator 常用方法</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 设置动画参数，参数类型为可变参数</span><br><span class=\"line\">*/</span><br><span class=\"line\">ValueAnimator ofInt(int... values);</span><br><span class=\"line\">ValueAnimator ofFloat(int... values);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 设置动画时长，单位是毫秒</span><br><span class=\"line\">*/</span><br><span class=\"line\">ValueAnimator setDuration(long duration);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 获取 ValueAnimator 在运动时，当前运动点的值</span><br><span class=\"line\">*/</span><br><span class=\"line\">Object getAnimatedValue();</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 开始动画</span><br><span class=\"line\">*/</span><br><span class=\"line\">void start();</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 设置循环次数,设置为 INFINITE 表示无限循环</span><br><span class=\"line\">*/</span><br><span class=\"line\">void setRepeatCount(int value);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 设置循环模式</span><br><span class=\"line\">* value 取值有 RESTART，REVERSE（分别为：重新开始，倒序重新开始）</span><br><span class=\"line\">*/</span><br><span class=\"line\">void setRepeatMode(int value);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 取消动画</span><br><span class=\"line\">*/</span><br><span class=\"line\">void cancel();</span><br></pre></td></tr></table></figure>\n<p>通过源码，发现ofInt和ofFloat方法内部实现一样的，他们的区别在于传入的参数类型不同，需要注意的是在使用<strong>getAnimatedValue</strong>方法时，如果前面<strong>使用的是ofInt,要强转成int 类型</strong>，否则，转为float类型。<br>此外，如果不需要动画，可以调用移除动画监听方法，但需要先调用cancel方法取消动画。</p>\n<h1 id=\"4、ObjectAnimator-的基本使用\"><a href=\"#4、ObjectAnimator-的基本使用\" class=\"headerlink\" title=\"4、ObjectAnimator 的基本使用\"></a>4、ObjectAnimator 的基本使用</h1><p>ObjectAnimator 类继承自ValueAnimator，使用时通过静态工厂类直接返回一个对象，参数包括对象和对象的属性名，但该属性必须要有get和set函数，这样可以真实的控制一个view的属性值，因此它基本可以实现所有的动画效果。<br>使用示例：<br>使textView的translationX从0变化到200在变化到500，持续时间为1s,代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofFloat(textView,</span><br><span class=\"line\">            &quot;translationX&quot;,new float[]&#123;200,500&#125;);</span><br><span class=\"line\">    animator.setDuration(1000);</span><br><span class=\"line\">    animator.start();</span><br></pre></td></tr></table></figure></p>\n<p>ofFloat的参数：第一个是要操纵的View；第二个是要操纵的属性；第三个是参数，是一个可变数组。同样的，可以给它设置显示时长，插值器等。<br>在开始提到了，ObjectAnimator用于有get，set属性的控件，对于没有的可以通过一个包装类来实现，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 包装类，给width添加get，set方法</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static class WrapperView &#123;</span><br><span class=\"line\">    private View mTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">    public WrapperView(View target) &#123;</span><br><span class=\"line\">        mTarget = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getWidth() &#123;</span><br><span class=\"line\">        return mTarget.getLayoutParams().width;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setWidth(int width) &#123;</span><br><span class=\"line\">        mTarget.getLayoutParams().width = width;</span><br><span class=\"line\">        mTarget.requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用时，直接操纵包装类，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WrapperView mWrapperView = new WrapperView(btnStartAnim);</span><br><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofInt(</span><br><span class=\"line\">        mWrapperView,&quot;width&quot;,500).setDuration(500);</span><br><span class=\"line\">animator.start();</span><br></pre></td></tr></table></figure></p>\n<p>通过上面，可以知道，ObjectAnimator 实现动画主要是通过set方法来设置控件的对应的属性实现动画。</p>\n<h1 id=\"5、ObjectAnimator-的常用方法\"><a href=\"#5、ObjectAnimator-的常用方法\" class=\"headerlink\" title=\"5、ObjectAnimator 的常用方法\"></a>5、ObjectAnimator 的常用方法</h1><p>除了上面的ofInt,ofFloat方法，对于要改变背景色的，可以使用<strong>ArgbEvaluator</strong>，用法如下,给textView设置背景色在三种颜色间变化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofInt(textView,</span><br><span class=\"line\">        &quot;BackgroundColor&quot;,0xffff00ff, 0xffffff00, 0xffff00ff);</span><br><span class=\"line\">animator.setDuration(2000);</span><br><span class=\"line\">animator.setEvaluator(new ArgbEvaluator());</span><br><span class=\"line\">animator.start();</span><br></pre></td></tr></table></figure></p>\n<p>其他常用函数如下：<br>摘抄于：<a href=\"http://wiki.jikexueyuan.com/project/android-animation/7.html\" target=\"_blank\" rel=\"external\">http://wiki.jikexueyuan.com/project/android-animation/7.html</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** </span><br><span class=\"line\"> * 设置动画时长，单位是毫秒 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">ValueAnimator setDuration(long duration)  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 获取 ValueAnimator 在运动时，当前运动点的值 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">Object getAnimatedValue();  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 开始动画 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">void start()  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 设置循环次数,设置为 INFINITE 表示无限循环 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">void setRepeatCount(int value)  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 设置循环模式 </span><br><span class=\"line\"> * value 取值有 RESTART，REVERSE， </span><br><span class=\"line\"> */  </span><br><span class=\"line\">void setRepeatMode(int value)  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 取消动画 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">void cancel()</span><br></pre></td></tr></table></figure></p>\n<p>监听相关的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** </span><br><span class=\"line\"> * 监听器一：监听动画变化时的实时值 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public static interface AnimatorUpdateListener &#123;  </span><br><span class=\"line\">    void onAnimationUpdate(ValueAnimator animation);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">//添加方法为：public void addUpdateListener(AnimatorUpdateListener listener)  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 监听器二：监听动画变化时四个状态 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public static interface AnimatorListener &#123;  </span><br><span class=\"line\">    void onAnimationStart(Animator animation);  </span><br><span class=\"line\">    void onAnimationEnd(Animator animation);  </span><br><span class=\"line\">    void onAnimationCancel(Animator animation);  </span><br><span class=\"line\">    void onAnimationRepeat(Animator animation);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">//添加方法为：public void addListener(AnimatorListener listener)</span><br></pre></td></tr></table></figure></p>\n<p>插值器与 Evaluator:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** </span><br><span class=\"line\"> * 设置插值器 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public void setInterpolator(TimeInterpolator value)  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 设置 Evaluator </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public void setEvaluator(TypeEvaluator value)</span><br></pre></td></tr></table></figure></p>\n<p>更多方法可以查看api</p>\n<h1 id=\"6、AnimatorSet的使用\"><a href=\"#6、AnimatorSet的使用\" class=\"headerlink\" title=\"6、AnimatorSet的使用\"></a>6、AnimatorSet的使用</h1><p>在视图动画中  AnimationSet 来处理混合动画，同样的，这里的AnimatorSet来处理多个动画的。它出了实现多种动画，还可以精确的进行顺序控制。<br>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectAnimator animator1 = ObjectAnimator.ofFloat(textView, &quot;translationX&quot;, 300);</span><br><span class=\"line\">ObjectAnimator animator2 = ObjectAnimator.ofFloat(textView, &quot;scaleX&quot;, 1, 0, 1);</span><br><span class=\"line\">ObjectAnimator animator3 = ObjectAnimator.ofFloat(textView, &quot;scaleY&quot;, 1, 0, 1);</span><br><span class=\"line\">AnimatorSet animatorSet = new AnimatorSet();</span><br><span class=\"line\">animatorSet.setDuration(1000);</span><br><span class=\"line\">animatorSet.playTogether(animator1, animator2, animator3);</span><br><span class=\"line\">animatorSet.start();</span><br></pre></td></tr></table></figure></p>\n<p>示例效果：<br><img src=\"/img/article_img/AnimatorSet.gif\" alt=\"\"></p>\n<p>以上示例设置textView在x轴方向移动300，x和y方向先缩小到一倍再还原到一倍三种动画是同时执行。<br>若需要按顺序执行，可以调用Animator的<strong>playSequentially</strong>方法。</p>\n<h1 id=\"7、PropertyValuesHolder-的使用\"><a href=\"#7、PropertyValuesHolder-的使用\" class=\"headerlink\" title=\"7、PropertyValuesHolder 的使用\"></a>7、PropertyValuesHolder 的使用</h1><p>除了上面讲的AnimatorSet 实现多种动画，还可以通过PropertyValuesHolder来实现，比如上面的例子在平移的过程中实现x,y轴的缩放。如下代码;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PropertyValuesHolder valuesHolder1 = PropertyValuesHolder</span><br><span class=\"line\">    .ofFloat(&quot;translationX&quot;, 300);</span><br><span class=\"line\">PropertyValuesHolder valuesHolder2 = PropertyValuesHolder</span><br><span class=\"line\">    .ofFloat(&quot;scaleX&quot;, 1, 0, 1);</span><br><span class=\"line\">PropertyValuesHolder valuesHolder3 = PropertyValuesHolder</span><br><span class=\"line\">    .ofFloat(&quot;scaleY&quot;, 1, 0, 1);</span><br><span class=\"line\">ObjectAnimator.ofPropertyValuesHolder(tv, valuesHolder1,</span><br><span class=\"line\">    valuesHolder2, valuesHolder3).setDuration(1000).start();</span><br></pre></td></tr></table></figure></p>\n<p>运行效果同AnimatorSet中的示例。<br>它的实现是先分别用PropertyValuesHolder的对象来控制不同的属性，最后调用ofPropertyValuesHolder方法实现多个属性动画的共同作用。</p>\n<h1 id=\"8、在XML文件中实现属性动画\"><a href=\"#8、在XML文件中实现属性动画\" class=\"headerlink\" title=\"8、在XML文件中实现属性动画\"></a>8、在XML文件中实现属性动画</h1><p>先在xml文件中定义属性，如下示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">    android:duration=1000&quot;</span><br><span class=\"line\">    android:propertyName=&quot;scaleX&quot;</span><br><span class=\"line\">    android:valueFrom=&quot;1.0&quot;</span><br><span class=\"line\">    android:valueTo=&quot;2.0&quot;</span><br><span class=\"line\">    android:valueType=&quot;floatType&quot;</span><br><span class=\"line\">&lt;/objectAnimator&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在java代码代码中使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animator animator = AnimatorInflater.</span><br><span class=\"line\">        loadAnimator(MainActivity.this,</span><br><span class=\"line\">        R.animator.scalex);</span><br><span class=\"line\">animator.setTarget(tv);</span><br><span class=\"line\">animator.start();</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，xml文件的定义需要放在res/animator下，而且根节点只能是：set,objectAnimator,valueAnimator三者之一。如果使用的set，可以为其指定播放的方式，属性名为：ordering=[“together”]|[“sequentially”]，<br>默认值为：“together”，对于其他具体的属性这里不再赘述了，可以参见文档。<br>在实际开发中建议使用代码实现动画，比较简单，而且很多时候某些属性的起始值无法确定。</p>\n<h1 id=\"8、View的animate方法\"><a href=\"#8、View的animate方法\" class=\"headerlink\" title=\"8、View的animate方法\"></a>8、View的animate方法</h1><p>在android3.0之后，添加了animate方法来直接驱动属性动画，它其实是对属性动画的简写，如下示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.animate()</span><br><span class=\"line\">       .alpha(0)</span><br><span class=\"line\">       .y(300)</span><br><span class=\"line\">       .setDuration(1000)</span><br><span class=\"line\">       .withStartAction(new Runnable() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">       .withEndAction(new Runnable() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;).start();</span><br></pre></td></tr></table></figure></p>\n<p>上面的例子很好理解，可以通过属性来确定他的含义。<br>总之，在实现动画时，可以根据自己的实际情况选择相应的方式实现动画，必要的时候还可以自定义实现动画，往往在使用时，不只是一种动画，我们要选择合适的方式实现多种动画。</p>\n","excerpt":"<h1 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h1><p>对于之前介绍的Animation，它属于<strong>视图动画</strong>（View Animation）(可参见：<a href=\"http://imtianx.cn/2016/04/25/view-Animation/\">Animation 动画详解</a>)，包括<strong>补间动画</strong>（Tween Animation）和<strong>逐帧动画</strong>（Tween Animation）；而在android中还有另一种动画，那就是<strong>属性动画</strong>（Property Animator），它包括<strong>ValueAnimator</strong> 和 <strong>ObjectAnimator</strong>。<br>","more":"<br>两者的<strong>区别</strong>：</p>\n<ul>\n<li>引入时间不同<br>视图动画在API Level 1 引入的，而属性动画在API Level 11（即 android 3.0）引入的； </li>\n<li>所在包不同<br>视图动画在 <strong>android.view.animation.Animation</strong>包下，属性动画在：<strong>android.animation</strong>包下</li>\n<li>动画类的命名不同<br>视图动画中类的名字为：<strong>XXXAnimation</strong>，而在属性动画中是：<strong>XXXAnimator</strong></li>\n<li><strong>作用的对象不同</strong>（这个也是引入属性动画的原因）<br><strong>视图动画是对控件做动画，不能改变控件内部的属性，对所有的控件都可以；而属性动画是通过改变控件的属性来实现动画，但使用ObjectAnimator时要求作用的控件的属性要有get,set方法。如果控件的属性没有get/set方法，可以通过包装类间接的设置get/set方法，或者使用ValueAnimator 实现。</strong></li>\n</ul>\n<h1 id=\"2、ValueAnimator-的基本使用\"><a href=\"#2、ValueAnimator-的基本使用\" class=\"headerlink\" title=\"2、ValueAnimator 的基本使用\"></a>2、ValueAnimator 的基本使用</h1><p>ValueAnimator是动画的核心，但不提供任何动画效果，它更像一个数值发生器，产生具有一定规律的数字，然后让调用者来控制动画的实现过程。用法如下：</p>\n<ul>\n<li><strong>创建ValueAnimator实例</strong><br>例：创建0到500的动画，时间为1s:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ValueAnimator animator = ValueAnimator.ofInt(0,500);  </span><br><span class=\"line\">animator.setDuration(1000);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>代码中可以看出，它不与任何控件关联，只对动画做运算。</p>\n<ul>\n<li><p><strong>添加它的监听事件</strong><br>下面是给它添加监听事件，实现动画的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animator.addUpdateListener(new ValueAnimator.</span><br><span class=\"line\">                       AnimatorUpdateListener() &#123;</span><br><span class=\"line\">                   @Override</span><br><span class=\"line\">                   public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class=\"line\">                       //具体处理动画逻辑</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">               //开启动画</span><br><span class=\"line\">               animator.start();</span><br></pre></td></tr></table></figure>\n<p>具体示例：<br>点击按钮使textView从(200,200)移动到（600，,600）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  btnStartAnim = (Button) findViewById(R.id.btn);</span><br><span class=\"line\">tv = (TextView) findViewById(R.id.tv);</span><br><span class=\"line\">btnStartAnim.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onClick(View v) &#123;</span><br><span class=\"line\">        //设置数据</span><br><span class=\"line\">        ValueAnimator animator = ValueAnimator.ofInt(200, 600);</span><br><span class=\"line\">        animator.setDuration(1000);</span><br><span class=\"line\">        //监听动画</span><br><span class=\"line\">        animator.addUpdateListener(new ValueAnimator.</span><br><span class=\"line\">                AnimatorUpdateListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class=\"line\">                //获取当前动画的值</span><br><span class=\"line\">                int curValue = (int) animation.getAnimatedValue();</span><br><span class=\"line\">                //设置tv的位置</span><br><span class=\"line\">                tv.layout(curValue, curValue,</span><br><span class=\"line\">                        curValue + tv.getWidth(),</span><br><span class=\"line\">                        curValue + tv.getHeight());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        //开启动画</span><br><span class=\"line\">        animator.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>示例效果：<br><img src=\"/img/article_img/ValueAnimator-simple-demo.gif\" alt=\"\"></p>\n<h1 id=\"3、ValueAnimator-常用方法\"><a href=\"#3、ValueAnimator-常用方法\" class=\"headerlink\" title=\"3、ValueAnimator 常用方法\"></a>3、ValueAnimator 常用方法</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 设置动画参数，参数类型为可变参数</span><br><span class=\"line\">*/</span><br><span class=\"line\">ValueAnimator ofInt(int... values);</span><br><span class=\"line\">ValueAnimator ofFloat(int... values);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 设置动画时长，单位是毫秒</span><br><span class=\"line\">*/</span><br><span class=\"line\">ValueAnimator setDuration(long duration);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 获取 ValueAnimator 在运动时，当前运动点的值</span><br><span class=\"line\">*/</span><br><span class=\"line\">Object getAnimatedValue();</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 开始动画</span><br><span class=\"line\">*/</span><br><span class=\"line\">void start();</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 设置循环次数,设置为 INFINITE 表示无限循环</span><br><span class=\"line\">*/</span><br><span class=\"line\">void setRepeatCount(int value);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 设置循环模式</span><br><span class=\"line\">* value 取值有 RESTART，REVERSE（分别为：重新开始，倒序重新开始）</span><br><span class=\"line\">*/</span><br><span class=\"line\">void setRepeatMode(int value);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 取消动画</span><br><span class=\"line\">*/</span><br><span class=\"line\">void cancel();</span><br></pre></td></tr></table></figure>\n<p>通过源码，发现ofInt和ofFloat方法内部实现一样的，他们的区别在于传入的参数类型不同，需要注意的是在使用<strong>getAnimatedValue</strong>方法时，如果前面<strong>使用的是ofInt,要强转成int 类型</strong>，否则，转为float类型。<br>此外，如果不需要动画，可以调用移除动画监听方法，但需要先调用cancel方法取消动画。</p>\n<h1 id=\"4、ObjectAnimator-的基本使用\"><a href=\"#4、ObjectAnimator-的基本使用\" class=\"headerlink\" title=\"4、ObjectAnimator 的基本使用\"></a>4、ObjectAnimator 的基本使用</h1><p>ObjectAnimator 类继承自ValueAnimator，使用时通过静态工厂类直接返回一个对象，参数包括对象和对象的属性名，但该属性必须要有get和set函数，这样可以真实的控制一个view的属性值，因此它基本可以实现所有的动画效果。<br>使用示例：<br>使textView的translationX从0变化到200在变化到500，持续时间为1s,代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofFloat(textView,</span><br><span class=\"line\">            &quot;translationX&quot;,new float[]&#123;200,500&#125;);</span><br><span class=\"line\">    animator.setDuration(1000);</span><br><span class=\"line\">    animator.start();</span><br></pre></td></tr></table></figure></p>\n<p>ofFloat的参数：第一个是要操纵的View；第二个是要操纵的属性；第三个是参数，是一个可变数组。同样的，可以给它设置显示时长，插值器等。<br>在开始提到了，ObjectAnimator用于有get，set属性的控件，对于没有的可以通过一个包装类来实现，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 包装类，给width添加get，set方法</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static class WrapperView &#123;</span><br><span class=\"line\">    private View mTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">    public WrapperView(View target) &#123;</span><br><span class=\"line\">        mTarget = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getWidth() &#123;</span><br><span class=\"line\">        return mTarget.getLayoutParams().width;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setWidth(int width) &#123;</span><br><span class=\"line\">        mTarget.getLayoutParams().width = width;</span><br><span class=\"line\">        mTarget.requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用时，直接操纵包装类，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WrapperView mWrapperView = new WrapperView(btnStartAnim);</span><br><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofInt(</span><br><span class=\"line\">        mWrapperView,&quot;width&quot;,500).setDuration(500);</span><br><span class=\"line\">animator.start();</span><br></pre></td></tr></table></figure></p>\n<p>通过上面，可以知道，ObjectAnimator 实现动画主要是通过set方法来设置控件的对应的属性实现动画。</p>\n<h1 id=\"5、ObjectAnimator-的常用方法\"><a href=\"#5、ObjectAnimator-的常用方法\" class=\"headerlink\" title=\"5、ObjectAnimator 的常用方法\"></a>5、ObjectAnimator 的常用方法</h1><p>除了上面的ofInt,ofFloat方法，对于要改变背景色的，可以使用<strong>ArgbEvaluator</strong>，用法如下,给textView设置背景色在三种颜色间变化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofInt(textView,</span><br><span class=\"line\">        &quot;BackgroundColor&quot;,0xffff00ff, 0xffffff00, 0xffff00ff);</span><br><span class=\"line\">animator.setDuration(2000);</span><br><span class=\"line\">animator.setEvaluator(new ArgbEvaluator());</span><br><span class=\"line\">animator.start();</span><br></pre></td></tr></table></figure></p>\n<p>其他常用函数如下：<br>摘抄于：<a href=\"http://wiki.jikexueyuan.com/project/android-animation/7.html\">http://wiki.jikexueyuan.com/project/android-animation/7.html</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** </span><br><span class=\"line\"> * 设置动画时长，单位是毫秒 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">ValueAnimator setDuration(long duration)  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 获取 ValueAnimator 在运动时，当前运动点的值 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">Object getAnimatedValue();  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 开始动画 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">void start()  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 设置循环次数,设置为 INFINITE 表示无限循环 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">void setRepeatCount(int value)  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 设置循环模式 </span><br><span class=\"line\"> * value 取值有 RESTART，REVERSE， </span><br><span class=\"line\"> */  </span><br><span class=\"line\">void setRepeatMode(int value)  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 取消动画 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">void cancel()</span><br></pre></td></tr></table></figure></p>\n<p>监听相关的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** </span><br><span class=\"line\"> * 监听器一：监听动画变化时的实时值 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public static interface AnimatorUpdateListener &#123;  </span><br><span class=\"line\">    void onAnimationUpdate(ValueAnimator animation);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">//添加方法为：public void addUpdateListener(AnimatorUpdateListener listener)  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 监听器二：监听动画变化时四个状态 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public static interface AnimatorListener &#123;  </span><br><span class=\"line\">    void onAnimationStart(Animator animation);  </span><br><span class=\"line\">    void onAnimationEnd(Animator animation);  </span><br><span class=\"line\">    void onAnimationCancel(Animator animation);  </span><br><span class=\"line\">    void onAnimationRepeat(Animator animation);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">//添加方法为：public void addListener(AnimatorListener listener)</span><br></pre></td></tr></table></figure></p>\n<p>插值器与 Evaluator:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** </span><br><span class=\"line\"> * 设置插值器 </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public void setInterpolator(TimeInterpolator value)  </span><br><span class=\"line\">/** </span><br><span class=\"line\"> * 设置 Evaluator </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public void setEvaluator(TypeEvaluator value)</span><br></pre></td></tr></table></figure></p>\n<p>更多方法可以查看api</p>\n<h1 id=\"6、AnimatorSet的使用\"><a href=\"#6、AnimatorSet的使用\" class=\"headerlink\" title=\"6、AnimatorSet的使用\"></a>6、AnimatorSet的使用</h1><p>在视图动画中  AnimationSet 来处理混合动画，同样的，这里的AnimatorSet来处理多个动画的。它出了实现多种动画，还可以精确的进行顺序控制。<br>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectAnimator animator1 = ObjectAnimator.ofFloat(textView, &quot;translationX&quot;, 300);</span><br><span class=\"line\">ObjectAnimator animator2 = ObjectAnimator.ofFloat(textView, &quot;scaleX&quot;, 1, 0, 1);</span><br><span class=\"line\">ObjectAnimator animator3 = ObjectAnimator.ofFloat(textView, &quot;scaleY&quot;, 1, 0, 1);</span><br><span class=\"line\">AnimatorSet animatorSet = new AnimatorSet();</span><br><span class=\"line\">animatorSet.setDuration(1000);</span><br><span class=\"line\">animatorSet.playTogether(animator1, animator2, animator3);</span><br><span class=\"line\">animatorSet.start();</span><br></pre></td></tr></table></figure></p>\n<p>示例效果：<br><img src=\"/img/article_img/AnimatorSet.gif\" alt=\"\"></p>\n<p>以上示例设置textView在x轴方向移动300，x和y方向先缩小到一倍再还原到一倍三种动画是同时执行。<br>若需要按顺序执行，可以调用Animator的<strong>playSequentially</strong>方法。</p>\n<h1 id=\"7、PropertyValuesHolder-的使用\"><a href=\"#7、PropertyValuesHolder-的使用\" class=\"headerlink\" title=\"7、PropertyValuesHolder 的使用\"></a>7、PropertyValuesHolder 的使用</h1><p>除了上面讲的AnimatorSet 实现多种动画，还可以通过PropertyValuesHolder来实现，比如上面的例子在平移的过程中实现x,y轴的缩放。如下代码;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PropertyValuesHolder valuesHolder1 = PropertyValuesHolder</span><br><span class=\"line\">    .ofFloat(&quot;translationX&quot;, 300);</span><br><span class=\"line\">PropertyValuesHolder valuesHolder2 = PropertyValuesHolder</span><br><span class=\"line\">    .ofFloat(&quot;scaleX&quot;, 1, 0, 1);</span><br><span class=\"line\">PropertyValuesHolder valuesHolder3 = PropertyValuesHolder</span><br><span class=\"line\">    .ofFloat(&quot;scaleY&quot;, 1, 0, 1);</span><br><span class=\"line\">ObjectAnimator.ofPropertyValuesHolder(tv, valuesHolder1,</span><br><span class=\"line\">    valuesHolder2, valuesHolder3).setDuration(1000).start();</span><br></pre></td></tr></table></figure></p>\n<p>运行效果同AnimatorSet中的示例。<br>它的实现是先分别用PropertyValuesHolder的对象来控制不同的属性，最后调用ofPropertyValuesHolder方法实现多个属性动画的共同作用。</p>\n<h1 id=\"8、在XML文件中实现属性动画\"><a href=\"#8、在XML文件中实现属性动画\" class=\"headerlink\" title=\"8、在XML文件中实现属性动画\"></a>8、在XML文件中实现属性动画</h1><p>先在xml文件中定义属性，如下示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">    android:duration=1000&quot;</span><br><span class=\"line\">    android:propertyName=&quot;scaleX&quot;</span><br><span class=\"line\">    android:valueFrom=&quot;1.0&quot;</span><br><span class=\"line\">    android:valueTo=&quot;2.0&quot;</span><br><span class=\"line\">    android:valueType=&quot;floatType&quot;</span><br><span class=\"line\">&lt;/objectAnimator&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在java代码代码中使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animator animator = AnimatorInflater.</span><br><span class=\"line\">        loadAnimator(MainActivity.this,</span><br><span class=\"line\">        R.animator.scalex);</span><br><span class=\"line\">animator.setTarget(tv);</span><br><span class=\"line\">animator.start();</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，xml文件的定义需要放在res/animator下，而且根节点只能是：set,objectAnimator,valueAnimator三者之一。如果使用的set，可以为其指定播放的方式，属性名为：ordering=[“together”]|[“sequentially”]，<br>默认值为：“together”，对于其他具体的属性这里不再赘述了，可以参见文档。<br>在实际开发中建议使用代码实现动画，比较简单，而且很多时候某些属性的起始值无法确定。</p>\n<h1 id=\"8、View的animate方法\"><a href=\"#8、View的animate方法\" class=\"headerlink\" title=\"8、View的animate方法\"></a>8、View的animate方法</h1><p>在android3.0之后，添加了animate方法来直接驱动属性动画，它其实是对属性动画的简写，如下示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.animate()</span><br><span class=\"line\">       .alpha(0)</span><br><span class=\"line\">       .y(300)</span><br><span class=\"line\">       .setDuration(1000)</span><br><span class=\"line\">       .withStartAction(new Runnable() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">       .withEndAction(new Runnable() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;).start();</span><br></pre></td></tr></table></figure></p>\n<p>上面的例子很好理解，可以通过属性来确定他的含义。<br>总之，在实现动画时，可以根据自己的实际情况选择相应的方式实现动画，必要的时候还可以自定义实现动画，往往在使用时，不只是一种动画，我们要选择合适的方式实现多种动画。</p>"},{"title":"SwipeRefreshLayout+RecyclerView实现下拉刷新","date":"2016-04-23T08:36:25.000Z","_content":"SwipeRefreshLayout+RecyclerView实现下拉刷新\n另外还使用了CardView（一个容器类布局，它继承自FrameLayout）。<br/><!--more-->\n效果图如下：\n![这里写图片描述](http://img.blog.csdn.net/20160411115226554)\n\n\n## 具体的使用：\n\n#### 1.CardView<br>\n首先，引入依赖：<br>\n\t```\n\tcompile 'com.android.support:cardview-v7:23.3.0'\n\t```\n 接着，在布局中引用，需要添加新的名字空间<br>\n\t```\n\txmlns:card_view=\"http://schemas.android.com/apk/res-auto\"\n\t```\n 通过名字空间添加两个新的属性,通过名字很容易知道，第一个是设置背景颜色，第二个是设置圆角<br>\n\t```\n\tcard_view:cardBackgroundColor=\"#b911e8\"\n\tcard_view:cardCornerRadius=\"4dp\"\n\t```\n这里，RecyclerView 的每一个item都是一个CardView<br><br>\n####  2.SwipeRefreshLayout\n它在V4 包下，使用代码如下：[activity_main.xml](https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fres%2Flayout%2Factivity_main.xml)\n\t\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.v4.widget.SwipeRefreshLayout\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:id=\"@+id/swipe_container\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\">\n\n<android.support.v7.widget.RecyclerView\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:id=\"@+id/relv\">\n</android.support.v7.widget.RecyclerView>\n\n</android.support.v4.widget.SwipeRefreshLayout>\n```\n在activity中设置相关的方法：\n```\n//设置进度条颜色,最多可以有四个颜色\nsetColorSchemeResources(int… colorResIds);\n//设置进度圈背景颜色\nsetProgressBackgroundColorSchemeColor(int color);\n//设置监听,在OnRefresh()中处理结果\nsetOnRefreshListener(SwipeRefreshLayout.OnRefreshListener);\n//设置刷新状态\nsetRefreshing(Boolean refreshing);\n```\n\n####  3.RecyclerView\n\n它是谷歌对ListView的升级，效率更高，并对ViewHolder进行了封装。使用时，同样，需要依赖库:\n```\ncompile 'com.android.support:recyclerview-v7:23.3.0'\n```\n编写自己的adapter，继承自 RecyclerView.Adapter ，实现三个方法：(具体内容见：[RvAdapter.java](https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fjava%2Fcn%2Fimtianx%2Fswrvdemo%2FRvAdapter.java))\n```\n/**\n * 将布局转换成view 并传递给RecyclerView 封装好的 ViewHolder\n *\n * @param parent\n * @param viewType\n * @return\n */\n@Override\npublic ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n    View view = LayoutInflater.from(parent.getContext()).inflate(\n            R.layout.rv_item_cardview, parent, false);\n    return new ViewHolder(view);\n}\n\n/**\n * 建立ViewHolder中视图与数据的关联\n *\n * @param holder\n * @param position\n */\n@Override\npublic void onBindViewHolder(ViewHolder holder, int position) {\n    holder.imageView.setImageResource(R.mipmap.img);\n    holder.textView.setText(datas.get(position));\n}  \n```\n\n\n添加内部内ViewHolder继承自RecyclerView.ViewHolder, 由于android没有给RecyclerView设置点击事件，需要我们自己使用接口回调，设置监听。\n```\npublic class ViewHolder extends RecyclerView.ViewHolder\n{\n    public ImageView imageView;\n    public TextView textView;\n\n    public ViewHolder (final View itemView)\n    {\n        super (itemView);\n        imageView = (ImageView) itemView.findViewById (R.id.img_head);\n        textView = (TextView) itemView.findViewById (R.id.tv_title);\n\n        itemView.setOnClickListener (new View.OnClickListener()\n        {\n            @Override\n            public void onClick (View v)\n            {\n                itemClickListener.onItemClick (v, getPosition() );\n            }\n        });\n\n        textView.setOnClickListener (\n            new View.OnClickListener()\n        {\n            @Override\n            public void onClick (View v)\n            {\n                if (itemClickListener != null)\n                {\n                    itemClickListener.onTextClick (v, getPosition() );\n                }\n            }\n        });\n    }\n}\n\npublic OnItemClickListener itemClickListener;\n\n/**\n * 设置接口\n *\n * @param itemClickListener\n */\npublic void setItemClickListener (OnItemClickListener itemClickListener)\n{\n    this.itemClickListener = itemClickListener;\n}\n\n/**\n * 点击事件接口\n */\npublic interface OnItemClickListener\n{\n    //item的点击事件\n    void onItemClick (View view, int position);\n    //item中文字的点击事件\n    void onTextClick (View view, int position);\n}\n```\n最后在activity中设置监听，具体见：[MainActivity.java](https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo/src/main/java/cn/imtianx/swrvdemo/MainActivity.java)\n\n **[demon地址](https://github.com/imtianx/StudyDemoForAndroid/tree/master/A02-swrvdemo)**","source":"_posts/SwipeRefreshLayout-RecyclerView.md","raw":"---\ntitle: SwipeRefreshLayout+RecyclerView实现下拉刷新\ndate: 2016-04-23 16:36:25\ncategories: [android,学习笔记]\ntags: [5.X新特新,RecyclerView,CardView]\n---\nSwipeRefreshLayout+RecyclerView实现下拉刷新\n另外还使用了CardView（一个容器类布局，它继承自FrameLayout）。<br/><!--more-->\n效果图如下：\n![这里写图片描述](http://img.blog.csdn.net/20160411115226554)\n\n\n## 具体的使用：\n\n#### 1.CardView<br>\n首先，引入依赖：<br>\n\t```\n\tcompile 'com.android.support:cardview-v7:23.3.0'\n\t```\n 接着，在布局中引用，需要添加新的名字空间<br>\n\t```\n\txmlns:card_view=\"http://schemas.android.com/apk/res-auto\"\n\t```\n 通过名字空间添加两个新的属性,通过名字很容易知道，第一个是设置背景颜色，第二个是设置圆角<br>\n\t```\n\tcard_view:cardBackgroundColor=\"#b911e8\"\n\tcard_view:cardCornerRadius=\"4dp\"\n\t```\n这里，RecyclerView 的每一个item都是一个CardView<br><br>\n####  2.SwipeRefreshLayout\n它在V4 包下，使用代码如下：[activity_main.xml](https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fres%2Flayout%2Factivity_main.xml)\n\t\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.v4.widget.SwipeRefreshLayout\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:id=\"@+id/swipe_container\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\">\n\n<android.support.v7.widget.RecyclerView\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\"\nandroid:id=\"@+id/relv\">\n</android.support.v7.widget.RecyclerView>\n\n</android.support.v4.widget.SwipeRefreshLayout>\n```\n在activity中设置相关的方法：\n```\n//设置进度条颜色,最多可以有四个颜色\nsetColorSchemeResources(int… colorResIds);\n//设置进度圈背景颜色\nsetProgressBackgroundColorSchemeColor(int color);\n//设置监听,在OnRefresh()中处理结果\nsetOnRefreshListener(SwipeRefreshLayout.OnRefreshListener);\n//设置刷新状态\nsetRefreshing(Boolean refreshing);\n```\n\n####  3.RecyclerView\n\n它是谷歌对ListView的升级，效率更高，并对ViewHolder进行了封装。使用时，同样，需要依赖库:\n```\ncompile 'com.android.support:recyclerview-v7:23.3.0'\n```\n编写自己的adapter，继承自 RecyclerView.Adapter ，实现三个方法：(具体内容见：[RvAdapter.java](https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fjava%2Fcn%2Fimtianx%2Fswrvdemo%2FRvAdapter.java))\n```\n/**\n * 将布局转换成view 并传递给RecyclerView 封装好的 ViewHolder\n *\n * @param parent\n * @param viewType\n * @return\n */\n@Override\npublic ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n    View view = LayoutInflater.from(parent.getContext()).inflate(\n            R.layout.rv_item_cardview, parent, false);\n    return new ViewHolder(view);\n}\n\n/**\n * 建立ViewHolder中视图与数据的关联\n *\n * @param holder\n * @param position\n */\n@Override\npublic void onBindViewHolder(ViewHolder holder, int position) {\n    holder.imageView.setImageResource(R.mipmap.img);\n    holder.textView.setText(datas.get(position));\n}  \n```\n\n\n添加内部内ViewHolder继承自RecyclerView.ViewHolder, 由于android没有给RecyclerView设置点击事件，需要我们自己使用接口回调，设置监听。\n```\npublic class ViewHolder extends RecyclerView.ViewHolder\n{\n    public ImageView imageView;\n    public TextView textView;\n\n    public ViewHolder (final View itemView)\n    {\n        super (itemView);\n        imageView = (ImageView) itemView.findViewById (R.id.img_head);\n        textView = (TextView) itemView.findViewById (R.id.tv_title);\n\n        itemView.setOnClickListener (new View.OnClickListener()\n        {\n            @Override\n            public void onClick (View v)\n            {\n                itemClickListener.onItemClick (v, getPosition() );\n            }\n        });\n\n        textView.setOnClickListener (\n            new View.OnClickListener()\n        {\n            @Override\n            public void onClick (View v)\n            {\n                if (itemClickListener != null)\n                {\n                    itemClickListener.onTextClick (v, getPosition() );\n                }\n            }\n        });\n    }\n}\n\npublic OnItemClickListener itemClickListener;\n\n/**\n * 设置接口\n *\n * @param itemClickListener\n */\npublic void setItemClickListener (OnItemClickListener itemClickListener)\n{\n    this.itemClickListener = itemClickListener;\n}\n\n/**\n * 点击事件接口\n */\npublic interface OnItemClickListener\n{\n    //item的点击事件\n    void onItemClick (View view, int position);\n    //item中文字的点击事件\n    void onTextClick (View view, int position);\n}\n```\n最后在activity中设置监听，具体见：[MainActivity.java](https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo/src/main/java/cn/imtianx/swrvdemo/MainActivity.java)\n\n **[demon地址](https://github.com/imtianx/StudyDemoForAndroid/tree/master/A02-swrvdemo)**","slug":"SwipeRefreshLayout-RecyclerView","published":1,"updated":"2016-10-07T14:10:02.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucfa000hg0g5hb352hag","content":"<p>SwipeRefreshLayout+RecyclerView实现下拉刷新<br>另外还使用了CardView（一个容器类布局，它继承自FrameLayout）。<br><a id=\"more\"></a><br>效果图如下：<br><img src=\"http://img.blog.csdn.net/20160411115226554\" alt=\"这里写图片描述\"></p>\n<h2 id=\"具体的使用：\"><a href=\"#具体的使用：\" class=\"headerlink\" title=\"具体的使用：\"></a>具体的使用：</h2><h4 id=\"1-CardView\"><a href=\"#1-CardView\" class=\"headerlink\" title=\"1.CardView\"></a>1.CardView<br></h4><p>首先，引入依赖：<br><br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &apos;com.android.support:cardview-v7:23.3.0&apos;</span><br></pre></td></tr></table></figure></p>\n<p> 接着，在布局中引用，需要添加新的名字空间<br><br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlns:card_view=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br></pre></td></tr></table></figure></p>\n<p> 通过名字空间添加两个新的属性,通过名字很容易知道，第一个是设置背景颜色，第二个是设置圆角<br><br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">card_view:cardBackgroundColor=&quot;#b911e8&quot;</span><br><span class=\"line\">card_view:cardCornerRadius=&quot;4dp&quot;</span><br></pre></td></tr></table></figure></p>\n<p>这里，RecyclerView 的每一个item都是一个CardView<br><br></p>\n<h4 id=\"2-SwipeRefreshLayout\"><a href=\"#2-SwipeRefreshLayout\" class=\"headerlink\" title=\"2.SwipeRefreshLayout\"></a>2.SwipeRefreshLayout</h4><p>它在V4 包下，使用代码如下：<a href=\"https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fres%2Flayout%2Factivity_main.xml\" target=\"_blank\" rel=\"external\">activity_main.xml</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;android.support.v4.widget.SwipeRefreshLayout</span><br><span class=\"line\">xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">android:id=&quot;@+id/swipe_container&quot;</span><br><span class=\"line\">android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;android.support.v7.widget.RecyclerView</span><br><span class=\"line\">android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">android:id=&quot;@+id/relv&quot;&gt;</span><br><span class=\"line\">&lt;/android.support.v7.widget.RecyclerView&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>在activity中设置相关的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//设置进度条颜色,最多可以有四个颜色</span><br><span class=\"line\">setColorSchemeResources(int… colorResIds);</span><br><span class=\"line\">//设置进度圈背景颜色</span><br><span class=\"line\">setProgressBackgroundColorSchemeColor(int color);</span><br><span class=\"line\">//设置监听,在OnRefresh()中处理结果</span><br><span class=\"line\">setOnRefreshListener(SwipeRefreshLayout.OnRefreshListener);</span><br><span class=\"line\">//设置刷新状态</span><br><span class=\"line\">setRefreshing(Boolean refreshing);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-RecyclerView\"><a href=\"#3-RecyclerView\" class=\"headerlink\" title=\"3.RecyclerView\"></a>3.RecyclerView</h4><p>它是谷歌对ListView的升级，效率更高，并对ViewHolder进行了封装。使用时，同样，需要依赖库:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &apos;com.android.support:recyclerview-v7:23.3.0&apos;</span><br></pre></td></tr></table></figure></p>\n<p>编写自己的adapter，继承自 RecyclerView.Adapter ，实现三个方法：(具体内容见：<a href=\"https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fjava%2Fcn%2Fimtianx%2Fswrvdemo%2FRvAdapter.java\" target=\"_blank\" rel=\"external\">RvAdapter.java</a>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 将布局转换成view 并传递给RecyclerView 封装好的 ViewHolder</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param parent</span><br><span class=\"line\"> * @param viewType</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class=\"line\">    View view = LayoutInflater.from(parent.getContext()).inflate(</span><br><span class=\"line\">            R.layout.rv_item_cardview, parent, false);</span><br><span class=\"line\">    return new ViewHolder(view);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 建立ViewHolder中视图与数据的关联</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param holder</span><br><span class=\"line\"> * @param position</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void onBindViewHolder(ViewHolder holder, int position) &#123;</span><br><span class=\"line\">    holder.imageView.setImageResource(R.mipmap.img);</span><br><span class=\"line\">    holder.textView.setText(datas.get(position));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>添加内部内ViewHolder继承自RecyclerView.ViewHolder, 由于android没有给RecyclerView设置点击事件，需要我们自己使用接口回调，设置监听。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ViewHolder extends RecyclerView.ViewHolder</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public ImageView imageView;</span><br><span class=\"line\">    public TextView textView;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ViewHolder (final View itemView)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super (itemView);</span><br><span class=\"line\">        imageView = (ImageView) itemView.findViewById (R.id.img_head);</span><br><span class=\"line\">        textView = (TextView) itemView.findViewById (R.id.tv_title);</span><br><span class=\"line\"></span><br><span class=\"line\">        itemView.setOnClickListener (new View.OnClickListener()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick (View v)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                itemClickListener.onItemClick (v, getPosition() );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        textView.setOnClickListener (</span><br><span class=\"line\">            new View.OnClickListener()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick (View v)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (itemClickListener != null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    itemClickListener.onTextClick (v, getPosition() );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public OnItemClickListener itemClickListener;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 设置接口</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param itemClickListener</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void setItemClickListener (OnItemClickListener itemClickListener)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.itemClickListener = itemClickListener;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 点击事件接口</span><br><span class=\"line\"> */</span><br><span class=\"line\">public interface OnItemClickListener</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //item的点击事件</span><br><span class=\"line\">    void onItemClick (View view, int position);</span><br><span class=\"line\">    //item中文字的点击事件</span><br><span class=\"line\">    void onTextClick (View view, int position);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后在activity中设置监听，具体见：<a href=\"https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo/src/main/java/cn/imtianx/swrvdemo/MainActivity.java\" target=\"_blank\" rel=\"external\">MainActivity.java</a></p>\n<p> <strong><a href=\"https://github.com/imtianx/StudyDemoForAndroid/tree/master/A02-swrvdemo\" target=\"_blank\" rel=\"external\">demon地址</a></strong></p>\n","excerpt":"<p>SwipeRefreshLayout+RecyclerView实现下拉刷新<br>另外还使用了CardView（一个容器类布局，它继承自FrameLayout）。<br/>","more":"<br>效果图如下：<br><img src=\"http://img.blog.csdn.net/20160411115226554\" alt=\"这里写图片描述\"></p>\n<h2 id=\"具体的使用：\"><a href=\"#具体的使用：\" class=\"headerlink\" title=\"具体的使用：\"></a>具体的使用：</h2><h4 id=\"1-CardView\"><a href=\"#1-CardView\" class=\"headerlink\" title=\"1.CardView\"></a>1.CardView<br></h4><p>首先，引入依赖：<br><br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &apos;com.android.support:cardview-v7:23.3.0&apos;</span><br></pre></td></tr></table></figure></p>\n<p> 接着，在布局中引用，需要添加新的名字空间<br><br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlns:card_view=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br></pre></td></tr></table></figure></p>\n<p> 通过名字空间添加两个新的属性,通过名字很容易知道，第一个是设置背景颜色，第二个是设置圆角<br><br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">card_view:cardBackgroundColor=&quot;#b911e8&quot;</span><br><span class=\"line\">card_view:cardCornerRadius=&quot;4dp&quot;</span><br></pre></td></tr></table></figure></p>\n<p>这里，RecyclerView 的每一个item都是一个CardView<br><br></p>\n<h4 id=\"2-SwipeRefreshLayout\"><a href=\"#2-SwipeRefreshLayout\" class=\"headerlink\" title=\"2.SwipeRefreshLayout\"></a>2.SwipeRefreshLayout</h4><p>它在V4 包下，使用代码如下：<a href=\"https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fres%2Flayout%2Factivity_main.xml\">activity_main.xml</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;android.support.v4.widget.SwipeRefreshLayout</span><br><span class=\"line\">xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">android:id=&quot;@+id/swipe_container&quot;</span><br><span class=\"line\">android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;android.support.v7.widget.RecyclerView</span><br><span class=\"line\">android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">android:id=&quot;@+id/relv&quot;&gt;</span><br><span class=\"line\">&lt;/android.support.v7.widget.RecyclerView&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>在activity中设置相关的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//设置进度条颜色,最多可以有四个颜色</span><br><span class=\"line\">setColorSchemeResources(int… colorResIds);</span><br><span class=\"line\">//设置进度圈背景颜色</span><br><span class=\"line\">setProgressBackgroundColorSchemeColor(int color);</span><br><span class=\"line\">//设置监听,在OnRefresh()中处理结果</span><br><span class=\"line\">setOnRefreshListener(SwipeRefreshLayout.OnRefreshListener);</span><br><span class=\"line\">//设置刷新状态</span><br><span class=\"line\">setRefreshing(Boolean refreshing);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-RecyclerView\"><a href=\"#3-RecyclerView\" class=\"headerlink\" title=\"3.RecyclerView\"></a>3.RecyclerView</h4><p>它是谷歌对ListView的升级，效率更高，并对ViewHolder进行了封装。使用时，同样，需要依赖库:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &apos;com.android.support:recyclerview-v7:23.3.0&apos;</span><br></pre></td></tr></table></figure></p>\n<p>编写自己的adapter，继承自 RecyclerView.Adapter ，实现三个方法：(具体内容见：<a href=\"https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo%2Fsrc%2Fmain%2Fjava%2Fcn%2Fimtianx%2Fswrvdemo%2FRvAdapter.java\">RvAdapter.java</a>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 将布局转换成view 并传递给RecyclerView 封装好的 ViewHolder</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param parent</span><br><span class=\"line\"> * @param viewType</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class=\"line\">    View view = LayoutInflater.from(parent.getContext()).inflate(</span><br><span class=\"line\">            R.layout.rv_item_cardview, parent, false);</span><br><span class=\"line\">    return new ViewHolder(view);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 建立ViewHolder中视图与数据的关联</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param holder</span><br><span class=\"line\"> * @param position</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void onBindViewHolder(ViewHolder holder, int position) &#123;</span><br><span class=\"line\">    holder.imageView.setImageResource(R.mipmap.img);</span><br><span class=\"line\">    holder.textView.setText(datas.get(position));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>添加内部内ViewHolder继承自RecyclerView.ViewHolder, 由于android没有给RecyclerView设置点击事件，需要我们自己使用接口回调，设置监听。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ViewHolder extends RecyclerView.ViewHolder</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public ImageView imageView;</span><br><span class=\"line\">    public TextView textView;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ViewHolder (final View itemView)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super (itemView);</span><br><span class=\"line\">        imageView = (ImageView) itemView.findViewById (R.id.img_head);</span><br><span class=\"line\">        textView = (TextView) itemView.findViewById (R.id.tv_title);</span><br><span class=\"line\"></span><br><span class=\"line\">        itemView.setOnClickListener (new View.OnClickListener()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick (View v)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                itemClickListener.onItemClick (v, getPosition() );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        textView.setOnClickListener (</span><br><span class=\"line\">            new View.OnClickListener()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick (View v)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (itemClickListener != null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    itemClickListener.onTextClick (v, getPosition() );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public OnItemClickListener itemClickListener;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 设置接口</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param itemClickListener</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void setItemClickListener (OnItemClickListener itemClickListener)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.itemClickListener = itemClickListener;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 点击事件接口</span><br><span class=\"line\"> */</span><br><span class=\"line\">public interface OnItemClickListener</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //item的点击事件</span><br><span class=\"line\">    void onItemClick (View view, int position);</span><br><span class=\"line\">    //item中文字的点击事件</span><br><span class=\"line\">    void onTextClick (View view, int position);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后在activity中设置监听，具体见：<a href=\"https://github.com/imtianx/StudyDemoForAndroid/blob/master/A02-swrvdemo/src/main/java/cn/imtianx/swrvdemo/MainActivity.java\">MainActivity.java</a></p>\n<p> <strong><a href=\"https://github.com/imtianx/StudyDemoForAndroid/tree/master/A02-swrvdemo\">demon地址</a></strong></p>"},{"title":"TabLayout+ViewPager创建tab","date":"2016-05-28T04:00:25.000Z","_content":"\n在degingn库中有TabLayout控件，可以方便的实现tab切换的效果，配合ViewPager.\n<!--more-->\n如下展示效果：\n![](/img/article_img/TabLayout+ViewPager-create-tab.gif)\n### 1. 添加依design赖库\n```\n compile 'com.android.support:design:23.4.0'\n```\n### 2.编写主布局文件。\n使用TabLayout和ViewPager。TabLayout 有以下三个属性，方便我们设置tab的字体颜色，选中时字体的颜色及指示器的颜色：\n```\napp:tabTextColor=\"@android:color/black\"\napp:tabSelectedTextColor=\"@color/colorPrimary\"\napp:tabIndicatorColor=\"@color/colorPrimary\"\n```\n具体的使用，如下代码：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    tools:context=\"cn.imtianx.tablayoutdemo.MainActivity\">\n\n    <android.support.design.widget.TabLayout\n        android:id=\"@+id/tab\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"@android:color/white\"\n        app:tabIndicatorColor=\"@color/colorPrimary\"\n        app:tabSelectedTextColor=\"@color/colorPrimary\"\n        app:tabTextColor=\"@android:color/black\">\n    </android.support.design.widget.TabLayout>\n\n    <android.support.v4.view.ViewPager\n        android:id=\"@+id/container\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n\n    </android.support.v4.view.ViewPager>\n</LinearLayout>\n\n```\n### 3. 编写每个tab的布局。\n为了简单，根布局仅使用一个 LinearLayout 并给其背景设置了颜色。\n### 4. 创建适配器\n创建 FragmentAdapter类，继承FragmentPagerAdapter。\n```\n/**\n * Created by imtianx on 2016-5-27.\n */\npublic class FragmentAdapter extends FragmentPagerAdapter {\n\n    private List<String> mTitles; //标题\n    private List<Fragment> mFragments;//viewpager 显示的页面\n\n    public FragmentAdapter(FragmentManager fm, List<String> titles, List<Fragment> fragments) {\n        super(fm);\n        mTitles = titles;\n        mFragments = fragments;\n    }\n\n    @Override\n    public Fragment getItem(int position) {\n        return mFragments.get(position);\n    }\n\n    @Override\n    public int getCount() {\n        return mFragments.size();\n    }\n\n    /**\n     * tab 标题\n     *\n     * @param position\n     * @return\n     */\n    @Override\n    public CharSequence getPageTitle(int position) {\n        return mTitles.get(position);\n    }\n}\n\n```\n### 5. 新建fragment页面\n创建3个fragment，加载相应的布局。\n### 6.绑定控件\n在MainActicity 中绑定控件，设置adapter。\n```\npublic class MainActivity extends AppCompatActivity {\n\n    List<Fragment> mFragmentList;\n    List<String> mTitles;\n    TabFragment1 mFragment1;\n    TabFragment2 mFragment2;\n    TabFragment3 mFragment3;\n    FragmentAdapter mAdapter;\n\n    private TabLayout mTabLayout;\n    private ViewPager mViewPager;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        initView();\n    }\n\n    private void initView() {\n        mTabLayout = (TabLayout) findViewById(R.id.tab);\n        mViewPager = (ViewPager) findViewById(R.id.container);\n\n        //添加标题\n        mTitles = new ArrayList<>();\n        mTitles.add(\"报价中\");\n        mTitles.add(\"运输中\");\n        mTitles.add(\"已完成\");\n\n        //添加页面\n        mFragmentList = new ArrayList<>();\n        mFragment1 = new TabFragment1();\n        mFragment2 = new TabFragment2();\n        mFragment3 = new TabFragment3();\n        mFragmentList.add(mFragment1);\n        mFragmentList.add(mFragment2);\n        mFragmentList.add(mFragment3);\n\n        //初始化适配器\n        mAdapter = new FragmentAdapter(getSupportFragmentManager(),\n                mTitles, mFragmentList);\n        //设置适配器\n        mViewPager.setAdapter(mAdapter);\n        //加载viewpager\n        mTabLayout.setupWithViewPager(mViewPager);\n    }\n}\n\n```\n### 7. 带icon的tab\n效果图如下：\n![](/img/article_img/TabLayout+ViewPager-create-tab_icon.gif)\n\n- 1.布局基本没有变，只是在上面的布局基础下，将ViewPager和TabLayout的上下位置调换下。添加如下属性将TabLayout的指示条高度设为0，不可见：\n```\napp:tabIndicatorHeight=\"0dp\"\n```\n- 2.为每个tab添加selector。以第一个tab为例，具体如下：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <item android:drawable=\"@drawable/home_pressed\" android:state_selected=\"true\"/>\n    <item android:drawable=\"@drawable/home_normal\"/>\n\n</selector>\n```\n- 3.IconTabActivity中将定义的selector设置为TabLayout的icon:\n\n```\nmTabLayout.getTabAt(0).setIcon(getResources().getDrawable(R.drawable.tab_hall_bg));\nmTabLayout.getTabAt(1).setIcon(getResources().getDrawable(R.drawable.tab_joined_bg));\nmTabLayout.getTabAt(2).setIcon(getResources().getDrawable(R.drawable.tab_me_bg));\n```\n\n到此，已经完成了，TabLayout的使用和TabHost的使用类似，但它更为方便，使用起来较为简单。\n[Demo下载](https://github.com/imtianx/StudyDemoForAndroid/blob/master/A03-tablayoutdemo)<br>\n注：demo中,不带icon:的是MainActivity，带icon的是IconTabActivity。可在AndroidManifest切换运行查看\n\n\n\n\n","source":"_posts/TabLayout+ViewPager create tab.md","raw":"---\ntitle: TabLayout+ViewPager创建tab\ndate: 2016-05-28 12:00:25\ncategories: [android,学习笔记]\ntags: [5.X新特性,TabLayout]\n---\n\n在degingn库中有TabLayout控件，可以方便的实现tab切换的效果，配合ViewPager.\n<!--more-->\n如下展示效果：\n![](/img/article_img/TabLayout+ViewPager-create-tab.gif)\n### 1. 添加依design赖库\n```\n compile 'com.android.support:design:23.4.0'\n```\n### 2.编写主布局文件。\n使用TabLayout和ViewPager。TabLayout 有以下三个属性，方便我们设置tab的字体颜色，选中时字体的颜色及指示器的颜色：\n```\napp:tabTextColor=\"@android:color/black\"\napp:tabSelectedTextColor=\"@color/colorPrimary\"\napp:tabIndicatorColor=\"@color/colorPrimary\"\n```\n具体的使用，如下代码：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    tools:context=\"cn.imtianx.tablayoutdemo.MainActivity\">\n\n    <android.support.design.widget.TabLayout\n        android:id=\"@+id/tab\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"@android:color/white\"\n        app:tabIndicatorColor=\"@color/colorPrimary\"\n        app:tabSelectedTextColor=\"@color/colorPrimary\"\n        app:tabTextColor=\"@android:color/black\">\n    </android.support.design.widget.TabLayout>\n\n    <android.support.v4.view.ViewPager\n        android:id=\"@+id/container\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n\n    </android.support.v4.view.ViewPager>\n</LinearLayout>\n\n```\n### 3. 编写每个tab的布局。\n为了简单，根布局仅使用一个 LinearLayout 并给其背景设置了颜色。\n### 4. 创建适配器\n创建 FragmentAdapter类，继承FragmentPagerAdapter。\n```\n/**\n * Created by imtianx on 2016-5-27.\n */\npublic class FragmentAdapter extends FragmentPagerAdapter {\n\n    private List<String> mTitles; //标题\n    private List<Fragment> mFragments;//viewpager 显示的页面\n\n    public FragmentAdapter(FragmentManager fm, List<String> titles, List<Fragment> fragments) {\n        super(fm);\n        mTitles = titles;\n        mFragments = fragments;\n    }\n\n    @Override\n    public Fragment getItem(int position) {\n        return mFragments.get(position);\n    }\n\n    @Override\n    public int getCount() {\n        return mFragments.size();\n    }\n\n    /**\n     * tab 标题\n     *\n     * @param position\n     * @return\n     */\n    @Override\n    public CharSequence getPageTitle(int position) {\n        return mTitles.get(position);\n    }\n}\n\n```\n### 5. 新建fragment页面\n创建3个fragment，加载相应的布局。\n### 6.绑定控件\n在MainActicity 中绑定控件，设置adapter。\n```\npublic class MainActivity extends AppCompatActivity {\n\n    List<Fragment> mFragmentList;\n    List<String> mTitles;\n    TabFragment1 mFragment1;\n    TabFragment2 mFragment2;\n    TabFragment3 mFragment3;\n    FragmentAdapter mAdapter;\n\n    private TabLayout mTabLayout;\n    private ViewPager mViewPager;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        initView();\n    }\n\n    private void initView() {\n        mTabLayout = (TabLayout) findViewById(R.id.tab);\n        mViewPager = (ViewPager) findViewById(R.id.container);\n\n        //添加标题\n        mTitles = new ArrayList<>();\n        mTitles.add(\"报价中\");\n        mTitles.add(\"运输中\");\n        mTitles.add(\"已完成\");\n\n        //添加页面\n        mFragmentList = new ArrayList<>();\n        mFragment1 = new TabFragment1();\n        mFragment2 = new TabFragment2();\n        mFragment3 = new TabFragment3();\n        mFragmentList.add(mFragment1);\n        mFragmentList.add(mFragment2);\n        mFragmentList.add(mFragment3);\n\n        //初始化适配器\n        mAdapter = new FragmentAdapter(getSupportFragmentManager(),\n                mTitles, mFragmentList);\n        //设置适配器\n        mViewPager.setAdapter(mAdapter);\n        //加载viewpager\n        mTabLayout.setupWithViewPager(mViewPager);\n    }\n}\n\n```\n### 7. 带icon的tab\n效果图如下：\n![](/img/article_img/TabLayout+ViewPager-create-tab_icon.gif)\n\n- 1.布局基本没有变，只是在上面的布局基础下，将ViewPager和TabLayout的上下位置调换下。添加如下属性将TabLayout的指示条高度设为0，不可见：\n```\napp:tabIndicatorHeight=\"0dp\"\n```\n- 2.为每个tab添加selector。以第一个tab为例，具体如下：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <item android:drawable=\"@drawable/home_pressed\" android:state_selected=\"true\"/>\n    <item android:drawable=\"@drawable/home_normal\"/>\n\n</selector>\n```\n- 3.IconTabActivity中将定义的selector设置为TabLayout的icon:\n\n```\nmTabLayout.getTabAt(0).setIcon(getResources().getDrawable(R.drawable.tab_hall_bg));\nmTabLayout.getTabAt(1).setIcon(getResources().getDrawable(R.drawable.tab_joined_bg));\nmTabLayout.getTabAt(2).setIcon(getResources().getDrawable(R.drawable.tab_me_bg));\n```\n\n到此，已经完成了，TabLayout的使用和TabHost的使用类似，但它更为方便，使用起来较为简单。\n[Demo下载](https://github.com/imtianx/StudyDemoForAndroid/blob/master/A03-tablayoutdemo)<br>\n注：demo中,不带icon:的是MainActivity，带icon的是IconTabActivity。可在AndroidManifest切换运行查看\n\n\n\n\n","slug":"TabLayout+ViewPager create tab","published":1,"updated":"2016-10-22T08:28:24.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucfa000ig0g50y8t7uyl","content":"<p>在degingn库中有TabLayout控件，可以方便的实现tab切换的效果，配合ViewPager.<br><a id=\"more\"></a><br>如下展示效果：<br><img src=\"/img/article_img/TabLayout+ViewPager-create-tab.gif\" alt=\"\"></p>\n<h3 id=\"1-添加依design赖库\"><a href=\"#1-添加依design赖库\" class=\"headerlink\" title=\"1. 添加依design赖库\"></a>1. 添加依design赖库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &apos;com.android.support:design:23.4.0&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-编写主布局文件。\"><a href=\"#2-编写主布局文件。\" class=\"headerlink\" title=\"2.编写主布局文件。\"></a>2.编写主布局文件。</h3><p>使用TabLayout和ViewPager。TabLayout 有以下三个属性，方便我们设置tab的字体颜色，选中时字体的颜色及指示器的颜色：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:tabTextColor=&quot;@android:color/black&quot;</span><br><span class=\"line\">app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;</span><br><span class=\"line\">app:tabIndicatorColor=&quot;@color/colorPrimary&quot;</span><br></pre></td></tr></table></figure></p>\n<p>具体的使用，如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:orientation=&quot;vertical&quot;</span><br><span class=\"line\">    tools:context=&quot;cn.imtianx.tablayoutdemo.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.design.widget.TabLayout</span><br><span class=\"line\">        android:id=&quot;@+id/tab&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:background=&quot;@android:color/white&quot;</span><br><span class=\"line\">        app:tabIndicatorColor=&quot;@color/colorPrimary&quot;</span><br><span class=\"line\">        app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;</span><br><span class=\"line\">        app:tabTextColor=&quot;@android:color/black&quot;&gt;</span><br><span class=\"line\">    &lt;/android.support.design.widget.TabLayout&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.v4.view.ViewPager</span><br><span class=\"line\">        android:id=&quot;@+id/container&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/android.support.v4.view.ViewPager&gt;</span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-编写每个tab的布局。\"><a href=\"#3-编写每个tab的布局。\" class=\"headerlink\" title=\"3. 编写每个tab的布局。\"></a>3. 编写每个tab的布局。</h3><p>为了简单，根布局仅使用一个 LinearLayout 并给其背景设置了颜色。</p>\n<h3 id=\"4-创建适配器\"><a href=\"#4-创建适配器\" class=\"headerlink\" title=\"4. 创建适配器\"></a>4. 创建适配器</h3><p>创建 FragmentAdapter类，继承FragmentPagerAdapter。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Created by imtianx on 2016-5-27.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class FragmentAdapter extends FragmentPagerAdapter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;String&gt; mTitles; //标题</span><br><span class=\"line\">    private List&lt;Fragment&gt; mFragments;//viewpager 显示的页面</span><br><span class=\"line\"></span><br><span class=\"line\">    public FragmentAdapter(FragmentManager fm, List&lt;String&gt; titles, List&lt;Fragment&gt; fragments) &#123;</span><br><span class=\"line\">        super(fm);</span><br><span class=\"line\">        mTitles = titles;</span><br><span class=\"line\">        mFragments = fragments;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Fragment getItem(int position) &#123;</span><br><span class=\"line\">        return mFragments.get(position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getCount() &#123;</span><br><span class=\"line\">        return mFragments.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * tab 标题</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param position</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public CharSequence getPageTitle(int position) &#123;</span><br><span class=\"line\">        return mTitles.get(position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5-新建fragment页面\"><a href=\"#5-新建fragment页面\" class=\"headerlink\" title=\"5. 新建fragment页面\"></a>5. 新建fragment页面</h3><p>创建3个fragment，加载相应的布局。</p>\n<h3 id=\"6-绑定控件\"><a href=\"#6-绑定控件\" class=\"headerlink\" title=\"6.绑定控件\"></a>6.绑定控件</h3><p>在MainActicity 中绑定控件，设置adapter。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends AppCompatActivity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Fragment&gt; mFragmentList;</span><br><span class=\"line\">    List&lt;String&gt; mTitles;</span><br><span class=\"line\">    TabFragment1 mFragment1;</span><br><span class=\"line\">    TabFragment2 mFragment2;</span><br><span class=\"line\">    TabFragment3 mFragment3;</span><br><span class=\"line\">    FragmentAdapter mAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\">    private TabLayout mTabLayout;</span><br><span class=\"line\">    private ViewPager mViewPager;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        initView();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void initView() &#123;</span><br><span class=\"line\">        mTabLayout = (TabLayout) findViewById(R.id.tab);</span><br><span class=\"line\">        mViewPager = (ViewPager) findViewById(R.id.container);</span><br><span class=\"line\"></span><br><span class=\"line\">        //添加标题</span><br><span class=\"line\">        mTitles = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        mTitles.add(&quot;报价中&quot;);</span><br><span class=\"line\">        mTitles.add(&quot;运输中&quot;);</span><br><span class=\"line\">        mTitles.add(&quot;已完成&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        //添加页面</span><br><span class=\"line\">        mFragmentList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        mFragment1 = new TabFragment1();</span><br><span class=\"line\">        mFragment2 = new TabFragment2();</span><br><span class=\"line\">        mFragment3 = new TabFragment3();</span><br><span class=\"line\">        mFragmentList.add(mFragment1);</span><br><span class=\"line\">        mFragmentList.add(mFragment2);</span><br><span class=\"line\">        mFragmentList.add(mFragment3);</span><br><span class=\"line\"></span><br><span class=\"line\">        //初始化适配器</span><br><span class=\"line\">        mAdapter = new FragmentAdapter(getSupportFragmentManager(),</span><br><span class=\"line\">                mTitles, mFragmentList);</span><br><span class=\"line\">        //设置适配器</span><br><span class=\"line\">        mViewPager.setAdapter(mAdapter);</span><br><span class=\"line\">        //加载viewpager</span><br><span class=\"line\">        mTabLayout.setupWithViewPager(mViewPager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"7-带icon的tab\"><a href=\"#7-带icon的tab\" class=\"headerlink\" title=\"7. 带icon的tab\"></a>7. 带icon的tab</h3><p>效果图如下：<br><img src=\"/img/article_img/TabLayout+ViewPager-create-tab_icon.gif\" alt=\"\"></p>\n<ul>\n<li><p>1.布局基本没有变，只是在上面的布局基础下，将ViewPager和TabLayout的上下位置调换下。添加如下属性将TabLayout的指示条高度设为0，不可见：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:tabIndicatorHeight=&quot;0dp&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.为每个tab添加selector。以第一个tab为例，具体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item android:drawable=&quot;@drawable/home_pressed&quot; android:state_selected=&quot;true&quot;/&gt;</span><br><span class=\"line\">    &lt;item android:drawable=&quot;@drawable/home_normal&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.IconTabActivity中将定义的selector设置为TabLayout的icon:</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mTabLayout.getTabAt(0).setIcon(getResources().getDrawable(R.drawable.tab_hall_bg));</span><br><span class=\"line\">mTabLayout.getTabAt(1).setIcon(getResources().getDrawable(R.drawable.tab_joined_bg));</span><br><span class=\"line\">mTabLayout.getTabAt(2).setIcon(getResources().getDrawable(R.drawable.tab_me_bg));</span><br></pre></td></tr></table></figure>\n<p>到此，已经完成了，TabLayout的使用和TabHost的使用类似，但它更为方便，使用起来较为简单。<br><a href=\"https://github.com/imtianx/StudyDemoForAndroid/blob/master/A03-tablayoutdemo\" target=\"_blank\" rel=\"external\">Demo下载</a><br><br>注：demo中,不带icon:的是MainActivity，带icon的是IconTabActivity。可在AndroidManifest切换运行查看</p>\n","excerpt":"<p>在degingn库中有TabLayout控件，可以方便的实现tab切换的效果，配合ViewPager.<br>","more":"<br>如下展示效果：<br><img src=\"/img/article_img/TabLayout+ViewPager-create-tab.gif\" alt=\"\"></p>\n<h3 id=\"1-添加依design赖库\"><a href=\"#1-添加依design赖库\" class=\"headerlink\" title=\"1. 添加依design赖库\"></a>1. 添加依design赖库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &apos;com.android.support:design:23.4.0&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-编写主布局文件。\"><a href=\"#2-编写主布局文件。\" class=\"headerlink\" title=\"2.编写主布局文件。\"></a>2.编写主布局文件。</h3><p>使用TabLayout和ViewPager。TabLayout 有以下三个属性，方便我们设置tab的字体颜色，选中时字体的颜色及指示器的颜色：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:tabTextColor=&quot;@android:color/black&quot;</span><br><span class=\"line\">app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;</span><br><span class=\"line\">app:tabIndicatorColor=&quot;@color/colorPrimary&quot;</span><br></pre></td></tr></table></figure></p>\n<p>具体的使用，如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:orientation=&quot;vertical&quot;</span><br><span class=\"line\">    tools:context=&quot;cn.imtianx.tablayoutdemo.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.design.widget.TabLayout</span><br><span class=\"line\">        android:id=&quot;@+id/tab&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:background=&quot;@android:color/white&quot;</span><br><span class=\"line\">        app:tabIndicatorColor=&quot;@color/colorPrimary&quot;</span><br><span class=\"line\">        app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;</span><br><span class=\"line\">        app:tabTextColor=&quot;@android:color/black&quot;&gt;</span><br><span class=\"line\">    &lt;/android.support.design.widget.TabLayout&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.v4.view.ViewPager</span><br><span class=\"line\">        android:id=&quot;@+id/container&quot;</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/android.support.v4.view.ViewPager&gt;</span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-编写每个tab的布局。\"><a href=\"#3-编写每个tab的布局。\" class=\"headerlink\" title=\"3. 编写每个tab的布局。\"></a>3. 编写每个tab的布局。</h3><p>为了简单，根布局仅使用一个 LinearLayout 并给其背景设置了颜色。</p>\n<h3 id=\"4-创建适配器\"><a href=\"#4-创建适配器\" class=\"headerlink\" title=\"4. 创建适配器\"></a>4. 创建适配器</h3><p>创建 FragmentAdapter类，继承FragmentPagerAdapter。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Created by imtianx on 2016-5-27.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class FragmentAdapter extends FragmentPagerAdapter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;String&gt; mTitles; //标题</span><br><span class=\"line\">    private List&lt;Fragment&gt; mFragments;//viewpager 显示的页面</span><br><span class=\"line\"></span><br><span class=\"line\">    public FragmentAdapter(FragmentManager fm, List&lt;String&gt; titles, List&lt;Fragment&gt; fragments) &#123;</span><br><span class=\"line\">        super(fm);</span><br><span class=\"line\">        mTitles = titles;</span><br><span class=\"line\">        mFragments = fragments;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Fragment getItem(int position) &#123;</span><br><span class=\"line\">        return mFragments.get(position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getCount() &#123;</span><br><span class=\"line\">        return mFragments.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * tab 标题</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param position</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public CharSequence getPageTitle(int position) &#123;</span><br><span class=\"line\">        return mTitles.get(position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5-新建fragment页面\"><a href=\"#5-新建fragment页面\" class=\"headerlink\" title=\"5. 新建fragment页面\"></a>5. 新建fragment页面</h3><p>创建3个fragment，加载相应的布局。</p>\n<h3 id=\"6-绑定控件\"><a href=\"#6-绑定控件\" class=\"headerlink\" title=\"6.绑定控件\"></a>6.绑定控件</h3><p>在MainActicity 中绑定控件，设置adapter。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends AppCompatActivity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Fragment&gt; mFragmentList;</span><br><span class=\"line\">    List&lt;String&gt; mTitles;</span><br><span class=\"line\">    TabFragment1 mFragment1;</span><br><span class=\"line\">    TabFragment2 mFragment2;</span><br><span class=\"line\">    TabFragment3 mFragment3;</span><br><span class=\"line\">    FragmentAdapter mAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\">    private TabLayout mTabLayout;</span><br><span class=\"line\">    private ViewPager mViewPager;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        initView();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void initView() &#123;</span><br><span class=\"line\">        mTabLayout = (TabLayout) findViewById(R.id.tab);</span><br><span class=\"line\">        mViewPager = (ViewPager) findViewById(R.id.container);</span><br><span class=\"line\"></span><br><span class=\"line\">        //添加标题</span><br><span class=\"line\">        mTitles = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        mTitles.add(&quot;报价中&quot;);</span><br><span class=\"line\">        mTitles.add(&quot;运输中&quot;);</span><br><span class=\"line\">        mTitles.add(&quot;已完成&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        //添加页面</span><br><span class=\"line\">        mFragmentList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        mFragment1 = new TabFragment1();</span><br><span class=\"line\">        mFragment2 = new TabFragment2();</span><br><span class=\"line\">        mFragment3 = new TabFragment3();</span><br><span class=\"line\">        mFragmentList.add(mFragment1);</span><br><span class=\"line\">        mFragmentList.add(mFragment2);</span><br><span class=\"line\">        mFragmentList.add(mFragment3);</span><br><span class=\"line\"></span><br><span class=\"line\">        //初始化适配器</span><br><span class=\"line\">        mAdapter = new FragmentAdapter(getSupportFragmentManager(),</span><br><span class=\"line\">                mTitles, mFragmentList);</span><br><span class=\"line\">        //设置适配器</span><br><span class=\"line\">        mViewPager.setAdapter(mAdapter);</span><br><span class=\"line\">        //加载viewpager</span><br><span class=\"line\">        mTabLayout.setupWithViewPager(mViewPager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"7-带icon的tab\"><a href=\"#7-带icon的tab\" class=\"headerlink\" title=\"7. 带icon的tab\"></a>7. 带icon的tab</h3><p>效果图如下：<br><img src=\"/img/article_img/TabLayout+ViewPager-create-tab_icon.gif\" alt=\"\"></p>\n<ul>\n<li><p>1.布局基本没有变，只是在上面的布局基础下，将ViewPager和TabLayout的上下位置调换下。添加如下属性将TabLayout的指示条高度设为0，不可见：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:tabIndicatorHeight=&quot;0dp&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.为每个tab添加selector。以第一个tab为例，具体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item android:drawable=&quot;@drawable/home_pressed&quot; android:state_selected=&quot;true&quot;/&gt;</span><br><span class=\"line\">    &lt;item android:drawable=&quot;@drawable/home_normal&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3.IconTabActivity中将定义的selector设置为TabLayout的icon:</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mTabLayout.getTabAt(0).setIcon(getResources().getDrawable(R.drawable.tab_hall_bg));</span><br><span class=\"line\">mTabLayout.getTabAt(1).setIcon(getResources().getDrawable(R.drawable.tab_joined_bg));</span><br><span class=\"line\">mTabLayout.getTabAt(2).setIcon(getResources().getDrawable(R.drawable.tab_me_bg));</span><br></pre></td></tr></table></figure>\n<p>到此，已经完成了，TabLayout的使用和TabHost的使用类似，但它更为方便，使用起来较为简单。<br><a href=\"https://github.com/imtianx/StudyDemoForAndroid/blob/master/A03-tablayoutdemo\">Demo下载</a><br><br>注：demo中,不带icon:的是MainActivity，带icon的是IconTabActivity。可在AndroidManifest切换运行查看</p>"},{"title":"Tomcat中配置单IP多二级域名方法","date":"2017-01-11T08:06:25.000Z","_content":"\n由于一级域名 [imtianx.cn](http://imtianx.cn/) 作为博客主地址了，为了方便使用，通过二级域名来配置网站。这里简介二级域名的配置方式。\n<!--more-->\n作为学生，为了便宜采用 腾讯云 服务器。在 windows server 2012 服务器上配置网站，使用 toncat。\n\n# 一、设置域名解析\n\n我的域名 imtianx.cn 在阿里的万网购买的。登陆域名管理后台，添加域名解析。这里使用 `A 记录`，它是指向一个 IP 的。为了方便测试，这里有添加如下两条A记录的二级域名解析。\n\n![](http://img.imtianx.cn/domain_jiexi.png)\n\n所对应的是：test2.imtianx.cn 和 test1.imtianx.cn 两个二级域名。\n\n如下是万网的**记录类型**及其说明，**记录值**受他的影响：\n\n1. **A记录**：\n将域名指向一个IPv4地址（例如：10.10.10.10），需要增加A记录。\n2. **CNAME记录**\n如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。\n3. **MX记录**\n建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。\n4. **NS记录**\n域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录。\n5. **TXT记录**\n可任意填写（可为空），通常用做SPF记录（反垃圾邮件）使用。\n6. **AAAA记录**\n将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录。\n7. **SRV记录**\n记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。\n8. **显性URL**\n将域名指向一个http（s)协议地址，访问域名时，自动跳转至目标地址（例如：将www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。\n9. **隐性URL**\n与显性URL类似，但隐性转发会隐藏真实的目标地址（例如：将www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。\n\n对于**主机记录**则是域名的前缀，常见的如下：\n\n- **www** :将域名解析为www.example.com，填写www；\n- **@** ：\n将域名解析为example.com（不带www），填写@或者不填写；\n- **mail** ：\n将域名解析为mail.example.com，通常用于解析邮箱服务器；\n- **\\*** ：\n泛解析，所有子域名均被解析到统一地址（除单独设置的子域名解析）；\n- **二级域名** ：\n如：mail.example.com或abc.example.com，填写mail或abc；\n- **手机网站** ：\n如：m.example.com，填写m。\n\n\n# 二、配置tomcat\n\n首先将网站项目导出 war包放入 webapps ，然后修改Tomcat 的配置文件: `conf/server.xml`,在 `Engine`节点下添加host。\n如下：\n\n```\n<Host name=\"test1.imtianx.cn\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\">\n  <Alias>test1.imtianx.cn</Alias>\n  <Context path=\"\" docBase=\"./Test1\" reloadable=\"false\" />\n</Host>\n<Host name=\"test2.imtianx.cn\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\">\n  <Alias>test2.imtianx.cn</Alias>\n  <Context path=\"\" docBase=\"./Test2\" reloadable=\"false\" />\n</Host>\n```\n> 配置说明：\n name ： 指定域名\n appBase : 虚拟目录的路径\n path : 访问时的项目web名\n doBase : 项目的顶级目录\n >\n\n更改Tomcat配置文件后需要将tomcat重启才可生效，然后就可以通过二级域名访问网站了：\n\n![](http://img.imtianx.cn/domain_show.png)\n\n这个只是一种二级域名解析方法，设置完就可以方便的使用二级域名了。\n","source":"_posts/Tomcat中配置单IP多二级域名方法.md","raw":"---\ntitle: Tomcat中配置单IP多二级域名方法\ndate: 2017-1-11 16:06:25\ncategories: [后端,域名配置]\ntags: [tomcat,域名解析,二级域名]\n---\n\n由于一级域名 [imtianx.cn](http://imtianx.cn/) 作为博客主地址了，为了方便使用，通过二级域名来配置网站。这里简介二级域名的配置方式。\n<!--more-->\n作为学生，为了便宜采用 腾讯云 服务器。在 windows server 2012 服务器上配置网站，使用 toncat。\n\n# 一、设置域名解析\n\n我的域名 imtianx.cn 在阿里的万网购买的。登陆域名管理后台，添加域名解析。这里使用 `A 记录`，它是指向一个 IP 的。为了方便测试，这里有添加如下两条A记录的二级域名解析。\n\n![](http://img.imtianx.cn/domain_jiexi.png)\n\n所对应的是：test2.imtianx.cn 和 test1.imtianx.cn 两个二级域名。\n\n如下是万网的**记录类型**及其说明，**记录值**受他的影响：\n\n1. **A记录**：\n将域名指向一个IPv4地址（例如：10.10.10.10），需要增加A记录。\n2. **CNAME记录**\n如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。\n3. **MX记录**\n建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。\n4. **NS记录**\n域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录。\n5. **TXT记录**\n可任意填写（可为空），通常用做SPF记录（反垃圾邮件）使用。\n6. **AAAA记录**\n将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录。\n7. **SRV记录**\n记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。\n8. **显性URL**\n将域名指向一个http（s)协议地址，访问域名时，自动跳转至目标地址（例如：将www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。\n9. **隐性URL**\n与显性URL类似，但隐性转发会隐藏真实的目标地址（例如：将www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。\n\n对于**主机记录**则是域名的前缀，常见的如下：\n\n- **www** :将域名解析为www.example.com，填写www；\n- **@** ：\n将域名解析为example.com（不带www），填写@或者不填写；\n- **mail** ：\n将域名解析为mail.example.com，通常用于解析邮箱服务器；\n- **\\*** ：\n泛解析，所有子域名均被解析到统一地址（除单独设置的子域名解析）；\n- **二级域名** ：\n如：mail.example.com或abc.example.com，填写mail或abc；\n- **手机网站** ：\n如：m.example.com，填写m。\n\n\n# 二、配置tomcat\n\n首先将网站项目导出 war包放入 webapps ，然后修改Tomcat 的配置文件: `conf/server.xml`,在 `Engine`节点下添加host。\n如下：\n\n```\n<Host name=\"test1.imtianx.cn\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\">\n  <Alias>test1.imtianx.cn</Alias>\n  <Context path=\"\" docBase=\"./Test1\" reloadable=\"false\" />\n</Host>\n<Host name=\"test2.imtianx.cn\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\">\n  <Alias>test2.imtianx.cn</Alias>\n  <Context path=\"\" docBase=\"./Test2\" reloadable=\"false\" />\n</Host>\n```\n> 配置说明：\n name ： 指定域名\n appBase : 虚拟目录的路径\n path : 访问时的项目web名\n doBase : 项目的顶级目录\n >\n\n更改Tomcat配置文件后需要将tomcat重启才可生效，然后就可以通过二级域名访问网站了：\n\n![](http://img.imtianx.cn/domain_show.png)\n\n这个只是一种二级域名解析方法，设置完就可以方便的使用二级域名了。\n","slug":"Tomcat中配置单IP多二级域名方法","published":1,"updated":"2017-02-11T14:19:02.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucfq000lg0g524jsatk8","content":"<p>由于一级域名 <a href=\"http://imtianx.cn/\">imtianx.cn</a> 作为博客主地址了，为了方便使用，通过二级域名来配置网站。这里简介二级域名的配置方式。<br><a id=\"more\"></a><br>作为学生，为了便宜采用 腾讯云 服务器。在 windows server 2012 服务器上配置网站，使用 toncat。</p>\n<h1 id=\"一、设置域名解析\"><a href=\"#一、设置域名解析\" class=\"headerlink\" title=\"一、设置域名解析\"></a>一、设置域名解析</h1><p>我的域名 imtianx.cn 在阿里的万网购买的。登陆域名管理后台，添加域名解析。这里使用 <code>A 记录</code>，它是指向一个 IP 的。为了方便测试，这里有添加如下两条A记录的二级域名解析。</p>\n<p><img src=\"http://img.imtianx.cn/domain_jiexi.png\" alt=\"\"></p>\n<p>所对应的是：test2.imtianx.cn 和 test1.imtianx.cn 两个二级域名。</p>\n<p>如下是万网的<strong>记录类型</strong>及其说明，<strong>记录值</strong>受他的影响：</p>\n<ol>\n<li><strong>A记录</strong>：<br>将域名指向一个IPv4地址（例如：10.10.10.10），需要增加A记录。</li>\n<li><strong>CNAME记录</strong><br>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。</li>\n<li><strong>MX记录</strong><br>建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。</li>\n<li><strong>NS记录</strong><br>域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录。</li>\n<li><strong>TXT记录</strong><br>可任意填写（可为空），通常用做SPF记录（反垃圾邮件）使用。</li>\n<li><strong>AAAA记录</strong><br>将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录。</li>\n<li><strong>SRV记录</strong><br>记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。</li>\n<li><strong>显性URL</strong><br>将域名指向一个http（s)协议地址，访问域名时，自动跳转至目标地址（例如：将www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。</li>\n<li><strong>隐性URL</strong><br>与显性URL类似，但隐性转发会隐藏真实的目标地址（例如：将www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。</li>\n</ol>\n<p>对于<strong>主机记录</strong>则是域名的前缀，常见的如下：</p>\n<ul>\n<li><strong>www</strong> :将域名解析为www.example.com，填写www；</li>\n<li><strong>@</strong> ：<br>将域名解析为example.com（不带www），填写@或者不填写；</li>\n<li><strong>mail</strong> ：<br>将域名解析为mail.example.com，通常用于解析邮箱服务器；</li>\n<li><strong>*</strong> ：<br>泛解析，所有子域名均被解析到统一地址（除单独设置的子域名解析）；</li>\n<li><strong>二级域名</strong> ：<br>如：mail.example.com或abc.example.com，填写mail或abc；</li>\n<li><strong>手机网站</strong> ：<br>如：m.example.com，填写m。</li>\n</ul>\n<h1 id=\"二、配置tomcat\"><a href=\"#二、配置tomcat\" class=\"headerlink\" title=\"二、配置tomcat\"></a>二、配置tomcat</h1><p>首先将网站项目导出 war包放入 webapps ，然后修改Tomcat 的配置文件: <code>conf/server.xml</code>,在 <code>Engine</code>节点下添加host。<br>如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Host name=&quot;test1.imtianx.cn&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;</span><br><span class=\"line\">  &lt;Alias&gt;test1.imtianx.cn&lt;/Alias&gt;</span><br><span class=\"line\">  &lt;Context path=&quot;&quot; docBase=&quot;./Test1&quot; reloadable=&quot;false&quot; /&gt;</span><br><span class=\"line\">&lt;/Host&gt;</span><br><span class=\"line\">&lt;Host name=&quot;test2.imtianx.cn&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;</span><br><span class=\"line\">  &lt;Alias&gt;test2.imtianx.cn&lt;/Alias&gt;</span><br><span class=\"line\">  &lt;Context path=&quot;&quot; docBase=&quot;./Test2&quot; reloadable=&quot;false&quot; /&gt;</span><br><span class=\"line\">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>配置说明：<br> name ： 指定域名<br> appBase : 虚拟目录的路径<br> path : 访问时的项目web名<br> doBase : 项目的顶级目录</p>\n</blockquote>\n<p>更改Tomcat配置文件后需要将tomcat重启才可生效，然后就可以通过二级域名访问网站了：</p>\n<p><img src=\"http://img.imtianx.cn/domain_show.png\" alt=\"\"></p>\n<p>这个只是一种二级域名解析方法，设置完就可以方便的使用二级域名了。</p>\n","excerpt":"<p>由于一级域名 <a href=\"http://imtianx.cn/\">imtianx.cn</a> 作为博客主地址了，为了方便使用，通过二级域名来配置网站。这里简介二级域名的配置方式。<br>","more":"<br>作为学生，为了便宜采用 腾讯云 服务器。在 windows server 2012 服务器上配置网站，使用 toncat。</p>\n<h1 id=\"一、设置域名解析\"><a href=\"#一、设置域名解析\" class=\"headerlink\" title=\"一、设置域名解析\"></a>一、设置域名解析</h1><p>我的域名 imtianx.cn 在阿里的万网购买的。登陆域名管理后台，添加域名解析。这里使用 <code>A 记录</code>，它是指向一个 IP 的。为了方便测试，这里有添加如下两条A记录的二级域名解析。</p>\n<p><img src=\"http://img.imtianx.cn/domain_jiexi.png\" alt=\"\"></p>\n<p>所对应的是：test2.imtianx.cn 和 test1.imtianx.cn 两个二级域名。</p>\n<p>如下是万网的<strong>记录类型</strong>及其说明，<strong>记录值</strong>受他的影响：</p>\n<ol>\n<li><strong>A记录</strong>：<br>将域名指向一个IPv4地址（例如：10.10.10.10），需要增加A记录。</li>\n<li><strong>CNAME记录</strong><br>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。</li>\n<li><strong>MX记录</strong><br>建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。</li>\n<li><strong>NS记录</strong><br>域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录。</li>\n<li><strong>TXT记录</strong><br>可任意填写（可为空），通常用做SPF记录（反垃圾邮件）使用。</li>\n<li><strong>AAAA记录</strong><br>将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录。</li>\n<li><strong>SRV记录</strong><br>记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。</li>\n<li><strong>显性URL</strong><br>将域名指向一个http（s)协议地址，访问域名时，自动跳转至目标地址（例如：将www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。</li>\n<li><strong>隐性URL</strong><br>与显性URL类似，但隐性转发会隐藏真实的目标地址（例如：将www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。</li>\n</ol>\n<p>对于<strong>主机记录</strong>则是域名的前缀，常见的如下：</p>\n<ul>\n<li><strong>www</strong> :将域名解析为www.example.com，填写www；</li>\n<li><strong>@</strong> ：<br>将域名解析为example.com（不带www），填写@或者不填写；</li>\n<li><strong>mail</strong> ：<br>将域名解析为mail.example.com，通常用于解析邮箱服务器；</li>\n<li><strong>*</strong> ：<br>泛解析，所有子域名均被解析到统一地址（除单独设置的子域名解析）；</li>\n<li><strong>二级域名</strong> ：<br>如：mail.example.com或abc.example.com，填写mail或abc；</li>\n<li><strong>手机网站</strong> ：<br>如：m.example.com，填写m。</li>\n</ul>\n<h1 id=\"二、配置tomcat\"><a href=\"#二、配置tomcat\" class=\"headerlink\" title=\"二、配置tomcat\"></a>二、配置tomcat</h1><p>首先将网站项目导出 war包放入 webapps ，然后修改Tomcat 的配置文件: <code>conf/server.xml</code>,在 <code>Engine</code>节点下添加host。<br>如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Host name=&quot;test1.imtianx.cn&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;</span><br><span class=\"line\">  &lt;Alias&gt;test1.imtianx.cn&lt;/Alias&gt;</span><br><span class=\"line\">  &lt;Context path=&quot;&quot; docBase=&quot;./Test1&quot; reloadable=&quot;false&quot; /&gt;</span><br><span class=\"line\">&lt;/Host&gt;</span><br><span class=\"line\">&lt;Host name=&quot;test2.imtianx.cn&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;</span><br><span class=\"line\">  &lt;Alias&gt;test2.imtianx.cn&lt;/Alias&gt;</span><br><span class=\"line\">  &lt;Context path=&quot;&quot; docBase=&quot;./Test2&quot; reloadable=&quot;false&quot; /&gt;</span><br><span class=\"line\">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>配置说明：<br> name ： 指定域名<br> appBase : 虚拟目录的路径<br> path : 访问时的项目web名<br> doBase : 项目的顶级目录</p>\n</blockquote>\n<p>更改Tomcat配置文件后需要将tomcat重启才可生效，然后就可以通过二级域名访问网站了：</p>\n<p><img src=\"http://img.imtianx.cn/domain_show.png\" alt=\"\"></p>\n<p>这个只是一种二级域名解析方法，设置完就可以方便的使用二级域名了。</p>"},{"title":"activity 生命周期及调用栈详解","date":"2016-11-08T08:06:25.000Z","_content":"\n`Activity `作为android四大组件之首，是我们是使用最频繁的组件，只有熟练的掌握其生命周期和启动模式，才能使我们在编程中进行合理的控制，在合适的生命周期处理相关的业务，开发出高质量的应用。下面具体的介绍下他的生命周期及启动模式。([android 官方文档-activity](https://developer.android.com/guide/components/activities.html))\n<!--more-->\n### 一、activity 的四种状态\n1. **Active/Running**（活动）\n  此时，activity 处于栈顶，可见，与用户进行交互。系统会不惜一切代价保护她的活跃性的，如果需要，会取消栈中靠下的activity来保证它所需要的资源。\n2. **Paused**（暂停）\n  当activity 失去焦点，被一个新的非全屏的activity 或者透明的activity放置在栈顶时，它会进入该状态。此时，它失去了与用户交互的能力，但所有的状态信息、成员变量都还保持着，只有在系统内存极低的情况下会被回收。\n3. **Stopped**（停止）\n当一个activity 被完全覆盖，完全不可见时会进入此状态。但在系统内存中仍然保存着所有的状态和成员信息。当需要内存时，将直接回收。\n4. **Kill**（销毁）\n当activity 被回收或者从来没有创建过，处于此状态。改状态的activity 会从activity栈中移除。\n### 二、activity 的生命周期\n如下如，展示activity的整个生命周期及其切换过程。\n![](/img/article_img/2016/activity生命周期.png)\n\n> 说明：\n1. 当一个activity 第一次启动，回调方法如下：**onCreate**->**onStart**->**onResum**.\n2. 用户打开新的activity或者切换到桌面，回调方法如下：**onPause**->**onStop**,如果新打开的activity 主题为**透明的**，则不会回调**onStop**。\n3. 用户再次回到原activity，毁掉过程如下：**onRestart**->**onStart**->**onResume**。\n4. 对于整个生命周期，onCreatehe onDestroy是配对的，他们标志着activity 的创建和销毁，并且只会调用一次；对于activity 是否可见，onStart和onStop是配对的，随着用户的操作或者屏幕的电量和熄灭，会被调用多次，但是该状态下不能与用户进行交互；从activity 是否在前台来说，onResume 和onPause 是配对的，他们也会被回调多次。\n5.  当前activity 页面打开新的activity，先执行原activity 的 onPause 方法，然后才会启动新activity 。\n\n### 三、异常情况下的生命周期\n1. 资源相关配置改变导致activity销毁并重建\n对于横竖屏切换导致的activity异常销毁并重建，其创建过程如下图：\n![](/img/article_img/2016/activity异常重建.png)\n\n2. 资源内存不足导致低优先级activity 被杀死\n优先级从搞到低课分为如下三种情况：\n\n- 处于前台与用户交互的activity 的优先级最高；\n- 可见但非前台activity，如弹出的对话框，导致activity可见但无法与用户进行交互；\n- 后台activity（已被暂停的），如执行了onStop方法，优先级最低。\n\n当系统内存不足时，按照上面的优先级杀掉activity所在的进程。\n\n**onSaveInstanceState (Bundle outState)**\n当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，具体的有如下几种场景：\n1、当用户按下HOME键时。\n这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则\n\n2、长按HOME键，选择运行其他的程序时。\n3、按下电源按键（关闭屏幕显示）时。\n4、从activity A中启动一个新的activity时。\n5、屏幕方向切换时，例如从竖屏切换到横屏时。（如果不指定configchange属性） 在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行\n\n总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用。\n\n> **注意点**：\n1.布局中的每一个View默认实现了onSaveInstanceState()方法，这样的话，这个UI的任何改变都会自动的存储和在activity重新创建的时候自动的恢复。但是这种情况只有在你为这个UI提供了唯一的ID之后才起作用，如果没有提供ID，将不会存储它的状态。\n>\n2.由于默认的onSaveInstanceState()方法的实现帮助UI存储它的状态，所以如果你需要覆盖这个方法去存储额外的状态信息时，你应该在执行任何代码之前都调用父类的onSaveInstanceState()方法（super.onSaveInstanceState()）。 既然有现成的可用，那么我们到底还要不要自己实现onSaveInstanceState()?这得看情况了，如果你自己的派生类中有变量影响到UI，或你程序的行为，当然就要把这个变量也保存了，那么就需要自己实现，否则就不需要。\n\n> 3.由于onSaveInstanceState()方法调用的不确定性，你应该只使用这个方法去记录activity的瞬间状态（UI的状态）。不应该用这个方法去存储持久化数据。当用户离开这个activity的时候应该在onPause()方法中存储持久化数据（例如应该被存储到数据库中的数据）。\n\n> 4.onSaveInstanceState()如果被调用，这个方法会在onStop()前被触发，但系统并不保证是否在onPause()之前或者之后触发。\n\n\n**onRestoreInstanceState (Bundle outState)**\n至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的。\n\nonRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。\n\n另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。 还有onRestoreInstanceState在onstart之后执行。 至于这两个函数的使用，给出示范代码（留意自定义代码在调用super的前或后）：\n```\n@Override\npublic void onSaveInstanceState(Bundle savedInstanceState) {\n        savedInstanceState.putBoolean(\"MyBoolean\", true);\n        savedInstanceState.putDouble(\"myDouble\", 1.9);\n        savedInstanceState.putInt(\"MyInt\", 1);\n        savedInstanceState.putString(\"MyString\", \"Welcome back to Android\");\n        // etc.\n        super.onSaveInstanceState(savedInstanceState);\n}\n\n@Override\npublic void onRestoreInstanceState(Bundle savedInstanceState) {\n        super.onRestoreInstanceState(savedInstanceState);\n\n        boolean myBoolean = savedInstanceState.getBoolean(\"MyBoolean\");\n        double myDouble = savedInstanceState.getDouble(\"myDouble\");\n        int myInt = savedInstanceState.getInt(\"MyInt\");\n        String myString = savedInstanceState.getString(\"MyString\");\n}\n\n```\n\n**onSaveInstanceState 方法只适用于保存保存一些临时性的状态，而 onPause 方法适用于数据的持久化保存。**\n\n\n### 四、activity 启动模式\n**任务栈**是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名。\n\n在AndroidManifest中可以给声明的activity通过**android:launchMode=\"standard|singleInstance|singleTask|singleTop\"**属性指定设置如下四种启动的模式：\n**standard**\n默认的启动方式，每次都会创建新的实例，覆盖在原来的activity之上，可以被同时添加到多个任务栈中，并且每一个任务中可以有多个实例。（只有在该模式的activity 才可以使用startActivityForResult方法）\n**singleTop**\n若设置为该模式，在启动activity时，系统会判断当前栈顶的activity是否是要启动的activity，如果是则直接引用这个实例不创建新的，否则创建新的实例。\n**singleTask**\n与singleTop 类似，它是检测整个activity栈中是否存在当前需要启动的activity。如果存在，则将该activity置于栈顶，并销毁在它之上的activity（注：这是在一个app中）。\n如果其他程序以singleTask模式来启动这个activity，将创建一个新的任务栈，该模式有**clearTop**效果。\n**singleInstance**\n该模式的使用和浏览器的工作原理类似。在多个程序访问浏览器时，如果浏览器没有打开，则打开，否则再当前打开的浏览器中访问。声明为这种模式的activity，会出现在一个新的任务栈中，而且该任务栈只有这一个activity。\n\n### 五、Fragment和activity的生命周期关系\n如下图：\n![](/img/article_img/2016/fragment_and_activity_lifecycle.jpg)\n\n谷歌官方 fragment 的生命周期如下图：\n![](/img/article_img/2016/fragment-life.png)\n\n> 参考文献：\n《Android 开发艺术探索》\n《Android 群英传》\n《深入解析 Android虚拟机》","source":"_posts/activity 生命周期及调用栈详解.md","raw":"---\ntitle: activity 生命周期及调用栈详解\ndate: 2016-11-08 16:06:25\ncategories: [android,学习笔记]\ntags: [android,Activity,生命周期]\n---\n\n`Activity `作为android四大组件之首，是我们是使用最频繁的组件，只有熟练的掌握其生命周期和启动模式，才能使我们在编程中进行合理的控制，在合适的生命周期处理相关的业务，开发出高质量的应用。下面具体的介绍下他的生命周期及启动模式。([android 官方文档-activity](https://developer.android.com/guide/components/activities.html))\n<!--more-->\n### 一、activity 的四种状态\n1. **Active/Running**（活动）\n  此时，activity 处于栈顶，可见，与用户进行交互。系统会不惜一切代价保护她的活跃性的，如果需要，会取消栈中靠下的activity来保证它所需要的资源。\n2. **Paused**（暂停）\n  当activity 失去焦点，被一个新的非全屏的activity 或者透明的activity放置在栈顶时，它会进入该状态。此时，它失去了与用户交互的能力，但所有的状态信息、成员变量都还保持着，只有在系统内存极低的情况下会被回收。\n3. **Stopped**（停止）\n当一个activity 被完全覆盖，完全不可见时会进入此状态。但在系统内存中仍然保存着所有的状态和成员信息。当需要内存时，将直接回收。\n4. **Kill**（销毁）\n当activity 被回收或者从来没有创建过，处于此状态。改状态的activity 会从activity栈中移除。\n### 二、activity 的生命周期\n如下如，展示activity的整个生命周期及其切换过程。\n![](/img/article_img/2016/activity生命周期.png)\n\n> 说明：\n1. 当一个activity 第一次启动，回调方法如下：**onCreate**->**onStart**->**onResum**.\n2. 用户打开新的activity或者切换到桌面，回调方法如下：**onPause**->**onStop**,如果新打开的activity 主题为**透明的**，则不会回调**onStop**。\n3. 用户再次回到原activity，毁掉过程如下：**onRestart**->**onStart**->**onResume**。\n4. 对于整个生命周期，onCreatehe onDestroy是配对的，他们标志着activity 的创建和销毁，并且只会调用一次；对于activity 是否可见，onStart和onStop是配对的，随着用户的操作或者屏幕的电量和熄灭，会被调用多次，但是该状态下不能与用户进行交互；从activity 是否在前台来说，onResume 和onPause 是配对的，他们也会被回调多次。\n5.  当前activity 页面打开新的activity，先执行原activity 的 onPause 方法，然后才会启动新activity 。\n\n### 三、异常情况下的生命周期\n1. 资源相关配置改变导致activity销毁并重建\n对于横竖屏切换导致的activity异常销毁并重建，其创建过程如下图：\n![](/img/article_img/2016/activity异常重建.png)\n\n2. 资源内存不足导致低优先级activity 被杀死\n优先级从搞到低课分为如下三种情况：\n\n- 处于前台与用户交互的activity 的优先级最高；\n- 可见但非前台activity，如弹出的对话框，导致activity可见但无法与用户进行交互；\n- 后台activity（已被暂停的），如执行了onStop方法，优先级最低。\n\n当系统内存不足时，按照上面的优先级杀掉activity所在的进程。\n\n**onSaveInstanceState (Bundle outState)**\n当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，具体的有如下几种场景：\n1、当用户按下HOME键时。\n这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则\n\n2、长按HOME键，选择运行其他的程序时。\n3、按下电源按键（关闭屏幕显示）时。\n4、从activity A中启动一个新的activity时。\n5、屏幕方向切换时，例如从竖屏切换到横屏时。（如果不指定configchange属性） 在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行\n\n总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用。\n\n> **注意点**：\n1.布局中的每一个View默认实现了onSaveInstanceState()方法，这样的话，这个UI的任何改变都会自动的存储和在activity重新创建的时候自动的恢复。但是这种情况只有在你为这个UI提供了唯一的ID之后才起作用，如果没有提供ID，将不会存储它的状态。\n>\n2.由于默认的onSaveInstanceState()方法的实现帮助UI存储它的状态，所以如果你需要覆盖这个方法去存储额外的状态信息时，你应该在执行任何代码之前都调用父类的onSaveInstanceState()方法（super.onSaveInstanceState()）。 既然有现成的可用，那么我们到底还要不要自己实现onSaveInstanceState()?这得看情况了，如果你自己的派生类中有变量影响到UI，或你程序的行为，当然就要把这个变量也保存了，那么就需要自己实现，否则就不需要。\n\n> 3.由于onSaveInstanceState()方法调用的不确定性，你应该只使用这个方法去记录activity的瞬间状态（UI的状态）。不应该用这个方法去存储持久化数据。当用户离开这个activity的时候应该在onPause()方法中存储持久化数据（例如应该被存储到数据库中的数据）。\n\n> 4.onSaveInstanceState()如果被调用，这个方法会在onStop()前被触发，但系统并不保证是否在onPause()之前或者之后触发。\n\n\n**onRestoreInstanceState (Bundle outState)**\n至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的。\n\nonRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。\n\n另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。 还有onRestoreInstanceState在onstart之后执行。 至于这两个函数的使用，给出示范代码（留意自定义代码在调用super的前或后）：\n```\n@Override\npublic void onSaveInstanceState(Bundle savedInstanceState) {\n        savedInstanceState.putBoolean(\"MyBoolean\", true);\n        savedInstanceState.putDouble(\"myDouble\", 1.9);\n        savedInstanceState.putInt(\"MyInt\", 1);\n        savedInstanceState.putString(\"MyString\", \"Welcome back to Android\");\n        // etc.\n        super.onSaveInstanceState(savedInstanceState);\n}\n\n@Override\npublic void onRestoreInstanceState(Bundle savedInstanceState) {\n        super.onRestoreInstanceState(savedInstanceState);\n\n        boolean myBoolean = savedInstanceState.getBoolean(\"MyBoolean\");\n        double myDouble = savedInstanceState.getDouble(\"myDouble\");\n        int myInt = savedInstanceState.getInt(\"MyInt\");\n        String myString = savedInstanceState.getString(\"MyString\");\n}\n\n```\n\n**onSaveInstanceState 方法只适用于保存保存一些临时性的状态，而 onPause 方法适用于数据的持久化保存。**\n\n\n### 四、activity 启动模式\n**任务栈**是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名。\n\n在AndroidManifest中可以给声明的activity通过**android:launchMode=\"standard|singleInstance|singleTask|singleTop\"**属性指定设置如下四种启动的模式：\n**standard**\n默认的启动方式，每次都会创建新的实例，覆盖在原来的activity之上，可以被同时添加到多个任务栈中，并且每一个任务中可以有多个实例。（只有在该模式的activity 才可以使用startActivityForResult方法）\n**singleTop**\n若设置为该模式，在启动activity时，系统会判断当前栈顶的activity是否是要启动的activity，如果是则直接引用这个实例不创建新的，否则创建新的实例。\n**singleTask**\n与singleTop 类似，它是检测整个activity栈中是否存在当前需要启动的activity。如果存在，则将该activity置于栈顶，并销毁在它之上的activity（注：这是在一个app中）。\n如果其他程序以singleTask模式来启动这个activity，将创建一个新的任务栈，该模式有**clearTop**效果。\n**singleInstance**\n该模式的使用和浏览器的工作原理类似。在多个程序访问浏览器时，如果浏览器没有打开，则打开，否则再当前打开的浏览器中访问。声明为这种模式的activity，会出现在一个新的任务栈中，而且该任务栈只有这一个activity。\n\n### 五、Fragment和activity的生命周期关系\n如下图：\n![](/img/article_img/2016/fragment_and_activity_lifecycle.jpg)\n\n谷歌官方 fragment 的生命周期如下图：\n![](/img/article_img/2016/fragment-life.png)\n\n> 参考文献：\n《Android 开发艺术探索》\n《Android 群英传》\n《深入解析 Android虚拟机》","slug":"activity 生命周期及调用栈详解","published":1,"updated":"2016-11-12T09:44:45.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucfq000ng0g57d0ikmrb","content":"<p><code>Activity</code>作为android四大组件之首，是我们是使用最频繁的组件，只有熟练的掌握其生命周期和启动模式，才能使我们在编程中进行合理的控制，在合适的生命周期处理相关的业务，开发出高质量的应用。下面具体的介绍下他的生命周期及启动模式。(<a href=\"https://developer.android.com/guide/components/activities.html\" target=\"_blank\" rel=\"external\">android 官方文档-activity</a>)<br><a id=\"more\"></a></p>\n<h3 id=\"一、activity-的四种状态\"><a href=\"#一、activity-的四种状态\" class=\"headerlink\" title=\"一、activity 的四种状态\"></a>一、activity 的四种状态</h3><ol>\n<li><strong>Active/Running</strong>（活动）<br>此时，activity 处于栈顶，可见，与用户进行交互。系统会不惜一切代价保护她的活跃性的，如果需要，会取消栈中靠下的activity来保证它所需要的资源。</li>\n<li><strong>Paused</strong>（暂停）<br>当activity 失去焦点，被一个新的非全屏的activity 或者透明的activity放置在栈顶时，它会进入该状态。此时，它失去了与用户交互的能力，但所有的状态信息、成员变量都还保持着，只有在系统内存极低的情况下会被回收。</li>\n<li><strong>Stopped</strong>（停止）<br>当一个activity 被完全覆盖，完全不可见时会进入此状态。但在系统内存中仍然保存着所有的状态和成员信息。当需要内存时，将直接回收。</li>\n<li><strong>Kill</strong>（销毁）<br>当activity 被回收或者从来没有创建过，处于此状态。改状态的activity 会从activity栈中移除。<h3 id=\"二、activity-的生命周期\"><a href=\"#二、activity-的生命周期\" class=\"headerlink\" title=\"二、activity 的生命周期\"></a>二、activity 的生命周期</h3>如下如，展示activity的整个生命周期及其切换过程。<br><img src=\"/img/article_img/2016/activity生命周期.png\" alt=\"\"></li>\n</ol>\n<blockquote>\n<p>说明：</p>\n<ol>\n<li>当一个activity 第一次启动，回调方法如下：<strong>onCreate</strong>-&gt;<strong>onStart</strong>-&gt;<strong>onResum</strong>.</li>\n<li>用户打开新的activity或者切换到桌面，回调方法如下：<strong>onPause</strong>-&gt;<strong>onStop</strong>,如果新打开的activity 主题为<strong>透明的</strong>，则不会回调<strong>onStop</strong>。</li>\n<li>用户再次回到原activity，毁掉过程如下：<strong>onRestart</strong>-&gt;<strong>onStart</strong>-&gt;<strong>onResume</strong>。</li>\n<li>对于整个生命周期，onCreatehe onDestroy是配对的，他们标志着activity 的创建和销毁，并且只会调用一次；对于activity 是否可见，onStart和onStop是配对的，随着用户的操作或者屏幕的电量和熄灭，会被调用多次，但是该状态下不能与用户进行交互；从activity 是否在前台来说，onResume 和onPause 是配对的，他们也会被回调多次。</li>\n<li>当前activity 页面打开新的activity，先执行原activity 的 onPause 方法，然后才会启动新activity 。</li>\n</ol>\n</blockquote>\n<h3 id=\"三、异常情况下的生命周期\"><a href=\"#三、异常情况下的生命周期\" class=\"headerlink\" title=\"三、异常情况下的生命周期\"></a>三、异常情况下的生命周期</h3><ol>\n<li><p>资源相关配置改变导致activity销毁并重建<br>对于横竖屏切换导致的activity异常销毁并重建，其创建过程如下图：<br><img src=\"/img/article_img/2016/activity异常重建.png\" alt=\"\"></p>\n</li>\n<li><p>资源内存不足导致低优先级activity 被杀死<br>优先级从搞到低课分为如下三种情况：</p>\n</li>\n</ol>\n<ul>\n<li>处于前台与用户交互的activity 的优先级最高；</li>\n<li>可见但非前台activity，如弹出的对话框，导致activity可见但无法与用户进行交互；</li>\n<li>后台activity（已被暂停的），如执行了onStop方法，优先级最低。</li>\n</ul>\n<p>当系统内存不足时，按照上面的优先级杀掉activity所在的进程。</p>\n<p><strong>onSaveInstanceState (Bundle outState)</strong><br>当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，具体的有如下几种场景：<br>1、当用户按下HOME键时。<br>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</p>\n<p>2、长按HOME键，选择运行其他的程序时。<br>3、按下电源按键（关闭屏幕显示）时。<br>4、从activity A中启动一个新的activity时。<br>5、屏幕方向切换时，例如从竖屏切换到横屏时。（如果不指定configchange属性） 在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行</p>\n<p>总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用。</p>\n<blockquote>\n<p><strong>注意点</strong>：<br>1.布局中的每一个View默认实现了onSaveInstanceState()方法，这样的话，这个UI的任何改变都会自动的存储和在activity重新创建的时候自动的恢复。但是这种情况只有在你为这个UI提供了唯一的ID之后才起作用，如果没有提供ID，将不会存储它的状态。</p>\n<p>2.由于默认的onSaveInstanceState()方法的实现帮助UI存储它的状态，所以如果你需要覆盖这个方法去存储额外的状态信息时，你应该在执行任何代码之前都调用父类的onSaveInstanceState()方法（super.onSaveInstanceState()）。 既然有现成的可用，那么我们到底还要不要自己实现onSaveInstanceState()?这得看情况了，如果你自己的派生类中有变量影响到UI，或你程序的行为，当然就要把这个变量也保存了，那么就需要自己实现，否则就不需要。</p>\n<p>3.由于onSaveInstanceState()方法调用的不确定性，你应该只使用这个方法去记录activity的瞬间状态（UI的状态）。不应该用这个方法去存储持久化数据。当用户离开这个activity的时候应该在onPause()方法中存储持久化数据（例如应该被存储到数据库中的数据）。</p>\n<p>4.onSaveInstanceState()如果被调用，这个方法会在onStop()前被触发，但系统并不保证是否在onPause()之前或者之后触发。</p>\n</blockquote>\n<p><strong>onRestoreInstanceState (Bundle outState)</strong><br>至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的。</p>\n<p>onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。</p>\n<p>另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。 还有onRestoreInstanceState在onstart之后执行。 至于这两个函数的使用，给出示范代码（留意自定义代码在调用super的前或后）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onSaveInstanceState(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        savedInstanceState.putBoolean(&quot;MyBoolean&quot;, true);</span><br><span class=\"line\">        savedInstanceState.putDouble(&quot;myDouble&quot;, 1.9);</span><br><span class=\"line\">        savedInstanceState.putInt(&quot;MyInt&quot;, 1);</span><br><span class=\"line\">        savedInstanceState.putString(&quot;MyString&quot;, &quot;Welcome back to Android&quot;);</span><br><span class=\"line\">        // etc.</span><br><span class=\"line\">        super.onSaveInstanceState(savedInstanceState);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void onRestoreInstanceState(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onRestoreInstanceState(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">        boolean myBoolean = savedInstanceState.getBoolean(&quot;MyBoolean&quot;);</span><br><span class=\"line\">        double myDouble = savedInstanceState.getDouble(&quot;myDouble&quot;);</span><br><span class=\"line\">        int myInt = savedInstanceState.getInt(&quot;MyInt&quot;);</span><br><span class=\"line\">        String myString = savedInstanceState.getString(&quot;MyString&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>onSaveInstanceState 方法只适用于保存保存一些临时性的状态，而 onPause 方法适用于数据的持久化保存。</strong></p>\n<h3 id=\"四、activity-启动模式\"><a href=\"#四、activity-启动模式\" class=\"headerlink\" title=\"四、activity 启动模式\"></a>四、activity 启动模式</h3><p><strong>任务栈</strong>是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名。</p>\n<p>在AndroidManifest中可以给声明的activity通过<strong>android:launchMode=”standard|singleInstance|singleTask|singleTop”</strong>属性指定设置如下四种启动的模式：<br><strong>standard</strong><br>默认的启动方式，每次都会创建新的实例，覆盖在原来的activity之上，可以被同时添加到多个任务栈中，并且每一个任务中可以有多个实例。（只有在该模式的activity 才可以使用startActivityForResult方法）<br><strong>singleTop</strong><br>若设置为该模式，在启动activity时，系统会判断当前栈顶的activity是否是要启动的activity，如果是则直接引用这个实例不创建新的，否则创建新的实例。<br><strong>singleTask</strong><br>与singleTop 类似，它是检测整个activity栈中是否存在当前需要启动的activity。如果存在，则将该activity置于栈顶，并销毁在它之上的activity（注：这是在一个app中）。<br>如果其他程序以singleTask模式来启动这个activity，将创建一个新的任务栈，该模式有<strong>clearTop</strong>效果。<br><strong>singleInstance</strong><br>该模式的使用和浏览器的工作原理类似。在多个程序访问浏览器时，如果浏览器没有打开，则打开，否则再当前打开的浏览器中访问。声明为这种模式的activity，会出现在一个新的任务栈中，而且该任务栈只有这一个activity。</p>\n<h3 id=\"五、Fragment和activity的生命周期关系\"><a href=\"#五、Fragment和activity的生命周期关系\" class=\"headerlink\" title=\"五、Fragment和activity的生命周期关系\"></a>五、Fragment和activity的生命周期关系</h3><p>如下图：<br><img src=\"/img/article_img/2016/fragment_and_activity_lifecycle.jpg\" alt=\"\"></p>\n<p>谷歌官方 fragment 的生命周期如下图：<br><img src=\"/img/article_img/2016/fragment-life.png\" alt=\"\"></p>\n<blockquote>\n<p>参考文献：<br>《Android 开发艺术探索》<br>《Android 群英传》<br>《深入解析 Android虚拟机》</p>\n</blockquote>\n","excerpt":"<p><code>Activity</code>作为android四大组件之首，是我们是使用最频繁的组件，只有熟练的掌握其生命周期和启动模式，才能使我们在编程中进行合理的控制，在合适的生命周期处理相关的业务，开发出高质量的应用。下面具体的介绍下他的生命周期及启动模式。(<a href=\"https://developer.android.com/guide/components/activities.html\">android 官方文档-activity</a>)<br>","more":"</p>\n<h3 id=\"一、activity-的四种状态\"><a href=\"#一、activity-的四种状态\" class=\"headerlink\" title=\"一、activity 的四种状态\"></a>一、activity 的四种状态</h3><ol>\n<li><strong>Active/Running</strong>（活动）<br>此时，activity 处于栈顶，可见，与用户进行交互。系统会不惜一切代价保护她的活跃性的，如果需要，会取消栈中靠下的activity来保证它所需要的资源。</li>\n<li><strong>Paused</strong>（暂停）<br>当activity 失去焦点，被一个新的非全屏的activity 或者透明的activity放置在栈顶时，它会进入该状态。此时，它失去了与用户交互的能力，但所有的状态信息、成员变量都还保持着，只有在系统内存极低的情况下会被回收。</li>\n<li><strong>Stopped</strong>（停止）<br>当一个activity 被完全覆盖，完全不可见时会进入此状态。但在系统内存中仍然保存着所有的状态和成员信息。当需要内存时，将直接回收。</li>\n<li><strong>Kill</strong>（销毁）<br>当activity 被回收或者从来没有创建过，处于此状态。改状态的activity 会从activity栈中移除。<h3 id=\"二、activity-的生命周期\"><a href=\"#二、activity-的生命周期\" class=\"headerlink\" title=\"二、activity 的生命周期\"></a>二、activity 的生命周期</h3>如下如，展示activity的整个生命周期及其切换过程。<br><img src=\"/img/article_img/2016/activity生命周期.png\" alt=\"\"></li>\n</ol>\n<blockquote>\n<p>说明：</p>\n<ol>\n<li>当一个activity 第一次启动，回调方法如下：<strong>onCreate</strong>-&gt;<strong>onStart</strong>-&gt;<strong>onResum</strong>.</li>\n<li>用户打开新的activity或者切换到桌面，回调方法如下：<strong>onPause</strong>-&gt;<strong>onStop</strong>,如果新打开的activity 主题为<strong>透明的</strong>，则不会回调<strong>onStop</strong>。</li>\n<li>用户再次回到原activity，毁掉过程如下：<strong>onRestart</strong>-&gt;<strong>onStart</strong>-&gt;<strong>onResume</strong>。</li>\n<li>对于整个生命周期，onCreatehe onDestroy是配对的，他们标志着activity 的创建和销毁，并且只会调用一次；对于activity 是否可见，onStart和onStop是配对的，随着用户的操作或者屏幕的电量和熄灭，会被调用多次，但是该状态下不能与用户进行交互；从activity 是否在前台来说，onResume 和onPause 是配对的，他们也会被回调多次。</li>\n<li>当前activity 页面打开新的activity，先执行原activity 的 onPause 方法，然后才会启动新activity 。</li>\n</ol>\n</blockquote>\n<h3 id=\"三、异常情况下的生命周期\"><a href=\"#三、异常情况下的生命周期\" class=\"headerlink\" title=\"三、异常情况下的生命周期\"></a>三、异常情况下的生命周期</h3><ol>\n<li><p>资源相关配置改变导致activity销毁并重建<br>对于横竖屏切换导致的activity异常销毁并重建，其创建过程如下图：<br><img src=\"/img/article_img/2016/activity异常重建.png\" alt=\"\"></p>\n</li>\n<li><p>资源内存不足导致低优先级activity 被杀死<br>优先级从搞到低课分为如下三种情况：</p>\n</li>\n</ol>\n<ul>\n<li>处于前台与用户交互的activity 的优先级最高；</li>\n<li>可见但非前台activity，如弹出的对话框，导致activity可见但无法与用户进行交互；</li>\n<li>后台activity（已被暂停的），如执行了onStop方法，优先级最低。</li>\n</ul>\n<p>当系统内存不足时，按照上面的优先级杀掉activity所在的进程。</p>\n<p><strong>onSaveInstanceState (Bundle outState)</strong><br>当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，具体的有如下几种场景：<br>1、当用户按下HOME键时。<br>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</p>\n<p>2、长按HOME键，选择运行其他的程序时。<br>3、按下电源按键（关闭屏幕显示）时。<br>4、从activity A中启动一个新的activity时。<br>5、屏幕方向切换时，例如从竖屏切换到横屏时。（如果不指定configchange属性） 在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行</p>\n<p>总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用。</p>\n<blockquote>\n<p><strong>注意点</strong>：<br>1.布局中的每一个View默认实现了onSaveInstanceState()方法，这样的话，这个UI的任何改变都会自动的存储和在activity重新创建的时候自动的恢复。但是这种情况只有在你为这个UI提供了唯一的ID之后才起作用，如果没有提供ID，将不会存储它的状态。</p>\n<p>2.由于默认的onSaveInstanceState()方法的实现帮助UI存储它的状态，所以如果你需要覆盖这个方法去存储额外的状态信息时，你应该在执行任何代码之前都调用父类的onSaveInstanceState()方法（super.onSaveInstanceState()）。 既然有现成的可用，那么我们到底还要不要自己实现onSaveInstanceState()?这得看情况了，如果你自己的派生类中有变量影响到UI，或你程序的行为，当然就要把这个变量也保存了，那么就需要自己实现，否则就不需要。</p>\n<p>3.由于onSaveInstanceState()方法调用的不确定性，你应该只使用这个方法去记录activity的瞬间状态（UI的状态）。不应该用这个方法去存储持久化数据。当用户离开这个activity的时候应该在onPause()方法中存储持久化数据（例如应该被存储到数据库中的数据）。</p>\n<p>4.onSaveInstanceState()如果被调用，这个方法会在onStop()前被触发，但系统并不保证是否在onPause()之前或者之后触发。</p>\n</blockquote>\n<p><strong>onRestoreInstanceState (Bundle outState)</strong><br>至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的。</p>\n<p>onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。</p>\n<p>另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。 还有onRestoreInstanceState在onstart之后执行。 至于这两个函数的使用，给出示范代码（留意自定义代码在调用super的前或后）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onSaveInstanceState(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        savedInstanceState.putBoolean(&quot;MyBoolean&quot;, true);</span><br><span class=\"line\">        savedInstanceState.putDouble(&quot;myDouble&quot;, 1.9);</span><br><span class=\"line\">        savedInstanceState.putInt(&quot;MyInt&quot;, 1);</span><br><span class=\"line\">        savedInstanceState.putString(&quot;MyString&quot;, &quot;Welcome back to Android&quot;);</span><br><span class=\"line\">        // etc.</span><br><span class=\"line\">        super.onSaveInstanceState(savedInstanceState);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void onRestoreInstanceState(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onRestoreInstanceState(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">        boolean myBoolean = savedInstanceState.getBoolean(&quot;MyBoolean&quot;);</span><br><span class=\"line\">        double myDouble = savedInstanceState.getDouble(&quot;myDouble&quot;);</span><br><span class=\"line\">        int myInt = savedInstanceState.getInt(&quot;MyInt&quot;);</span><br><span class=\"line\">        String myString = savedInstanceState.getString(&quot;MyString&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>onSaveInstanceState 方法只适用于保存保存一些临时性的状态，而 onPause 方法适用于数据的持久化保存。</strong></p>\n<h3 id=\"四、activity-启动模式\"><a href=\"#四、activity-启动模式\" class=\"headerlink\" title=\"四、activity 启动模式\"></a>四、activity 启动模式</h3><p><strong>任务栈</strong>是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名。</p>\n<p>在AndroidManifest中可以给声明的activity通过<strong>android:launchMode=”standard|singleInstance|singleTask|singleTop”</strong>属性指定设置如下四种启动的模式：<br><strong>standard</strong><br>默认的启动方式，每次都会创建新的实例，覆盖在原来的activity之上，可以被同时添加到多个任务栈中，并且每一个任务中可以有多个实例。（只有在该模式的activity 才可以使用startActivityForResult方法）<br><strong>singleTop</strong><br>若设置为该模式，在启动activity时，系统会判断当前栈顶的activity是否是要启动的activity，如果是则直接引用这个实例不创建新的，否则创建新的实例。<br><strong>singleTask</strong><br>与singleTop 类似，它是检测整个activity栈中是否存在当前需要启动的activity。如果存在，则将该activity置于栈顶，并销毁在它之上的activity（注：这是在一个app中）。<br>如果其他程序以singleTask模式来启动这个activity，将创建一个新的任务栈，该模式有<strong>clearTop</strong>效果。<br><strong>singleInstance</strong><br>该模式的使用和浏览器的工作原理类似。在多个程序访问浏览器时，如果浏览器没有打开，则打开，否则再当前打开的浏览器中访问。声明为这种模式的activity，会出现在一个新的任务栈中，而且该任务栈只有这一个activity。</p>\n<h3 id=\"五、Fragment和activity的生命周期关系\"><a href=\"#五、Fragment和activity的生命周期关系\" class=\"headerlink\" title=\"五、Fragment和activity的生命周期关系\"></a>五、Fragment和activity的生命周期关系</h3><p>如下图：<br><img src=\"/img/article_img/2016/fragment_and_activity_lifecycle.jpg\" alt=\"\"></p>\n<p>谷歌官方 fragment 的生命周期如下图：<br><img src=\"/img/article_img/2016/fragment-life.png\" alt=\"\"></p>\n<blockquote>\n<p>参考文献：<br>《Android 开发艺术探索》<br>《Android 群英传》<br>《深入解析 Android虚拟机》</p>\n</blockquote>"},{"title":"android  多渠道打包","date":"2016-12-12T08:06:25.000Z","_content":"这里介绍使用友盟进行多渠道打包，[参考慕课视屏](http://www.imooc.com/learn/752)\n\n## 一、 配置环境\n使用 `gradle` 添加依赖：\n\n```\n//友盟统计\ncompile 'com.umeng.analytics:analytics:latest.integration'\n```\n<!-- more -->\n> 注：版本号使用 **latest.integration** 替换， 这种依赖方式可以保证每次使用的都是最新的sdk（但这种使用得sdk支持）；或者在具体版本号后添加 **+** 也可以。\n\n在 manifests文件中添加相关的权限、appkey及渠道号：\n\n```\n<!--相关权限 -->\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.READ_PHONE_STATE\"/>\n\n<activity >\n    <meta-data\n        android:name=\"UMENG_APPKEY\"\n        android:value=\"\t564ac7c1e0f55aff0a000569\"/> <!-- 友盟统计app id-->\n    <meta-data\n        android:name=\"UMENG_CHANNEL\"\n        android:value=\"${UMENG_CHANNEL_VALUES}\"/> <!--  渠道号-->\n</activity>\n\n```\n更多配置可参见[官方文档](http://dev.umeng.com/analytics/android-doc/integration?spm=0.0.0.0.RSo52l)。\n\n## 二、编写配置脚本\n主要是在model的gradle中编写相关的配置脚本，如下：\n\n```\ndefaultConfig{\n   //...\n   multiDexEnabled true //突破方法数65536的限制\n   manifestPlaceholders = [UMENG_CHANNEL_VALUES: \"umeng\"] //默认渠道号\n   //...\n}\nbuildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\n            //指定签名文件\n            signingConfig signingConfigs.release\n        }\n    }\n    //添加签名文件信息\n    signingConfigs {\n        debug {}\n        //release 包添加签名文件\n        release {\n            storeFile file(\"D:/workspace_ide_settings/imtianxappkey.jks\") //签名文件\n            storePassword \"123456\" //签名文件密码\n            keyAlias \"imtianx\" //别名\n            keyPassword \"123456\" //签名密码\n        }\n    }\n    //配置渠道号\n    productFlavors {\n\n        meizu {\n            //1.在每个渠道中指定渠道号\n           //manifestPlaceholders = [UMENG_CHANNEL_VALUES: \"meizu\"]\n           //指定相应渠道appname,需要将values/string中的 app_name隐藏\n            //resValue \"string\",\"app_name\",\"testxiaomi\"\n        }\n\n        xiaomi {\n         //manifestPlaceholders = [UMENG_CHANNEL_VALUES: \"xiaomi \"]\n        }\n    }\n    //2.使用脚本为每个渠道指定渠道号\n    productFlavors.all {\n        flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUES: name]\n    }\n```\n\n到此，脚本配置已经完成，在 terminal 中使用下面命定打包：\n\n```\n//打release 包\ngradle assembleRelease\n//打debug包\ngradle assembleDebug\n//打指渠道的release包\ngradle assemblemeizuRelease\n```\n如果是第一次使用，打造包时会下载一些相应的工具包，速度较慢。打包完成后，在 `build/outputs/apk/`文件下下就会看见相应的，这里打的是 releas包，名字为：`app名-渠道名-release.apk`\n\n如果想改变包名，可以配置如下代码进行指定包名：\n\n```\n  buildTypes {\n        release {\n        //...\n         //指定release包名 为市场名\n         applicationVariants.all {\n            variant ->\n                variant.outputs.each {\n                    output ->\n                        def outputFile = output.outputFile\n                        if (outputFile != null && outputFile.name.endsWith(\".apk\")) {\n                            def fileName = \"${variant.productFlavors[0].name}\" + \".apk\"\n                            output.outputFile = new File(outputFile.parent, fileName);\n                        }\n                }\n        }\n    }\n}\n\n```\n\n然后在 terminal 中进行执行命令打包。\n\n\n\n\n\n\n\n","source":"_posts/android  多渠道打包.md","raw":"---\ntitle: android  多渠道打包\ndate: 2016-12-12 16:06:25\ncategories: [android,学习笔记]\ntags: [android,多渠道打包]\n---\n这里介绍使用友盟进行多渠道打包，[参考慕课视屏](http://www.imooc.com/learn/752)\n\n## 一、 配置环境\n使用 `gradle` 添加依赖：\n\n```\n//友盟统计\ncompile 'com.umeng.analytics:analytics:latest.integration'\n```\n<!-- more -->\n> 注：版本号使用 **latest.integration** 替换， 这种依赖方式可以保证每次使用的都是最新的sdk（但这种使用得sdk支持）；或者在具体版本号后添加 **+** 也可以。\n\n在 manifests文件中添加相关的权限、appkey及渠道号：\n\n```\n<!--相关权限 -->\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.READ_PHONE_STATE\"/>\n\n<activity >\n    <meta-data\n        android:name=\"UMENG_APPKEY\"\n        android:value=\"\t564ac7c1e0f55aff0a000569\"/> <!-- 友盟统计app id-->\n    <meta-data\n        android:name=\"UMENG_CHANNEL\"\n        android:value=\"${UMENG_CHANNEL_VALUES}\"/> <!--  渠道号-->\n</activity>\n\n```\n更多配置可参见[官方文档](http://dev.umeng.com/analytics/android-doc/integration?spm=0.0.0.0.RSo52l)。\n\n## 二、编写配置脚本\n主要是在model的gradle中编写相关的配置脚本，如下：\n\n```\ndefaultConfig{\n   //...\n   multiDexEnabled true //突破方法数65536的限制\n   manifestPlaceholders = [UMENG_CHANNEL_VALUES: \"umeng\"] //默认渠道号\n   //...\n}\nbuildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\n            //指定签名文件\n            signingConfig signingConfigs.release\n        }\n    }\n    //添加签名文件信息\n    signingConfigs {\n        debug {}\n        //release 包添加签名文件\n        release {\n            storeFile file(\"D:/workspace_ide_settings/imtianxappkey.jks\") //签名文件\n            storePassword \"123456\" //签名文件密码\n            keyAlias \"imtianx\" //别名\n            keyPassword \"123456\" //签名密码\n        }\n    }\n    //配置渠道号\n    productFlavors {\n\n        meizu {\n            //1.在每个渠道中指定渠道号\n           //manifestPlaceholders = [UMENG_CHANNEL_VALUES: \"meizu\"]\n           //指定相应渠道appname,需要将values/string中的 app_name隐藏\n            //resValue \"string\",\"app_name\",\"testxiaomi\"\n        }\n\n        xiaomi {\n         //manifestPlaceholders = [UMENG_CHANNEL_VALUES: \"xiaomi \"]\n        }\n    }\n    //2.使用脚本为每个渠道指定渠道号\n    productFlavors.all {\n        flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUES: name]\n    }\n```\n\n到此，脚本配置已经完成，在 terminal 中使用下面命定打包：\n\n```\n//打release 包\ngradle assembleRelease\n//打debug包\ngradle assembleDebug\n//打指渠道的release包\ngradle assemblemeizuRelease\n```\n如果是第一次使用，打造包时会下载一些相应的工具包，速度较慢。打包完成后，在 `build/outputs/apk/`文件下下就会看见相应的，这里打的是 releas包，名字为：`app名-渠道名-release.apk`\n\n如果想改变包名，可以配置如下代码进行指定包名：\n\n```\n  buildTypes {\n        release {\n        //...\n         //指定release包名 为市场名\n         applicationVariants.all {\n            variant ->\n                variant.outputs.each {\n                    output ->\n                        def outputFile = output.outputFile\n                        if (outputFile != null && outputFile.name.endsWith(\".apk\")) {\n                            def fileName = \"${variant.productFlavors[0].name}\" + \".apk\"\n                            output.outputFile = new File(outputFile.parent, fileName);\n                        }\n                }\n        }\n    }\n}\n\n```\n\n然后在 terminal 中进行执行命令打包。\n\n\n\n\n\n\n\n","slug":"android  多渠道打包","published":1,"updated":"2016-12-16T09:19:55.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucfq000rg0g58urm3p6t","content":"<p>这里介绍使用友盟进行多渠道打包，<a href=\"http://www.imooc.com/learn/752\" target=\"_blank\" rel=\"external\">参考慕课视屏</a></p>\n<h2 id=\"一、-配置环境\"><a href=\"#一、-配置环境\" class=\"headerlink\" title=\"一、 配置环境\"></a>一、 配置环境</h2><p>使用 <code>gradle</code> 添加依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//友盟统计</span><br><span class=\"line\">compile &apos;com.umeng.analytics:analytics:latest.integration&apos;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<blockquote>\n<p>注：版本号使用 <strong>latest.integration</strong> 替换， 这种依赖方式可以保证每次使用的都是最新的sdk（但这种使用得sdk支持）；或者在具体版本号后添加 <strong>+</strong> 也可以。</p>\n</blockquote>\n<p>在 manifests文件中添加相关的权限、appkey及渠道号：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--相关权限 --&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;activity &gt;</span><br><span class=\"line\">    &lt;meta-data</span><br><span class=\"line\">        android:name=&quot;UMENG_APPKEY&quot;</span><br><span class=\"line\">        android:value=&quot;\t564ac7c1e0f55aff0a000569&quot;/&gt; &lt;!-- 友盟统计app id--&gt;</span><br><span class=\"line\">    &lt;meta-data</span><br><span class=\"line\">        android:name=&quot;UMENG_CHANNEL&quot;</span><br><span class=\"line\">        android:value=&quot;$&#123;UMENG_CHANNEL_VALUES&#125;&quot;/&gt; &lt;!--  渠道号--&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>\n<p>更多配置可参见<a href=\"http://dev.umeng.com/analytics/android-doc/integration?spm=0.0.0.0.RSo52l\" target=\"_blank\" rel=\"external\">官方文档</a>。</p>\n<h2 id=\"二、编写配置脚本\"><a href=\"#二、编写配置脚本\" class=\"headerlink\" title=\"二、编写配置脚本\"></a>二、编写配置脚本</h2><p>主要是在model的gradle中编写相关的配置脚本，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultConfig&#123;</span><br><span class=\"line\">   //...</span><br><span class=\"line\">   multiDexEnabled true //突破方法数65536的限制</span><br><span class=\"line\">   manifestPlaceholders = [UMENG_CHANNEL_VALUES: &quot;umeng&quot;] //默认渠道号</span><br><span class=\"line\">   //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled false</span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">            //指定签名文件</span><br><span class=\"line\">            signingConfig signingConfigs.release</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //添加签名文件信息</span><br><span class=\"line\">    signingConfigs &#123;</span><br><span class=\"line\">        debug &#123;&#125;</span><br><span class=\"line\">        //release 包添加签名文件</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            storeFile file(&quot;D:/workspace_ide_settings/imtianxappkey.jks&quot;) //签名文件</span><br><span class=\"line\">            storePassword &quot;123456&quot; //签名文件密码</span><br><span class=\"line\">            keyAlias &quot;imtianx&quot; //别名</span><br><span class=\"line\">            keyPassword &quot;123456&quot; //签名密码</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //配置渠道号</span><br><span class=\"line\">    productFlavors &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        meizu &#123;</span><br><span class=\"line\">            //1.在每个渠道中指定渠道号</span><br><span class=\"line\">           //manifestPlaceholders = [UMENG_CHANNEL_VALUES: &quot;meizu&quot;]</span><br><span class=\"line\">           //指定相应渠道appname,需要将values/string中的 app_name隐藏</span><br><span class=\"line\">            //resValue &quot;string&quot;,&quot;app_name&quot;,&quot;testxiaomi&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        xiaomi &#123;</span><br><span class=\"line\">         //manifestPlaceholders = [UMENG_CHANNEL_VALUES: &quot;xiaomi &quot;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //2.使用脚本为每个渠道指定渠道号</span><br><span class=\"line\">    productFlavors.all &#123;</span><br><span class=\"line\">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUES: name]</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>到此，脚本配置已经完成，在 terminal 中使用下面命定打包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//打release 包</span><br><span class=\"line\">gradle assembleRelease</span><br><span class=\"line\">//打debug包</span><br><span class=\"line\">gradle assembleDebug</span><br><span class=\"line\">//打指渠道的release包</span><br><span class=\"line\">gradle assemblemeizuRelease</span><br></pre></td></tr></table></figure>\n<p>如果是第一次使用，打造包时会下载一些相应的工具包，速度较慢。打包完成后，在 <code>build/outputs/apk/</code>文件下下就会看见相应的，这里打的是 releas包，名字为：<code>app名-渠道名-release.apk</code></p>\n<p>如果想改变包名，可以配置如下代码进行指定包名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">        //...</span><br><span class=\"line\">         //指定release包名 为市场名</span><br><span class=\"line\">         applicationVariants.all &#123;</span><br><span class=\"line\">            variant -&gt;</span><br><span class=\"line\">                variant.outputs.each &#123;</span><br><span class=\"line\">                    output -&gt;</span><br><span class=\"line\">                        def outputFile = output.outputFile</span><br><span class=\"line\">                        if (outputFile != null &amp;&amp; outputFile.name.endsWith(&quot;.apk&quot;)) &#123;</span><br><span class=\"line\">                            def fileName = &quot;$&#123;variant.productFlavors[0].name&#125;&quot; + &quot;.apk&quot;</span><br><span class=\"line\">                            output.outputFile = new File(outputFile.parent, fileName);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在 terminal 中进行执行命令打包。</p>\n","excerpt":"<p>这里介绍使用友盟进行多渠道打包，<a href=\"http://www.imooc.com/learn/752\">参考慕课视屏</a></p>\n<h2 id=\"一、-配置环境\"><a href=\"#一、-配置环境\" class=\"headerlink\" title=\"一、 配置环境\"></a>一、 配置环境</h2><p>使用 <code>gradle</code> 添加依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//友盟统计</span><br><span class=\"line\">compile &apos;com.umeng.analytics:analytics:latest.integration&apos;</span><br></pre></td></tr></table></figure>","more":"<blockquote>\n<p>注：版本号使用 <strong>latest.integration</strong> 替换， 这种依赖方式可以保证每次使用的都是最新的sdk（但这种使用得sdk支持）；或者在具体版本号后添加 <strong>+</strong> 也可以。</p>\n</blockquote>\n<p>在 manifests文件中添加相关的权限、appkey及渠道号：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--相关权限 --&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;activity &gt;</span><br><span class=\"line\">    &lt;meta-data</span><br><span class=\"line\">        android:name=&quot;UMENG_APPKEY&quot;</span><br><span class=\"line\">        android:value=&quot;\t564ac7c1e0f55aff0a000569&quot;/&gt; &lt;!-- 友盟统计app id--&gt;</span><br><span class=\"line\">    &lt;meta-data</span><br><span class=\"line\">        android:name=&quot;UMENG_CHANNEL&quot;</span><br><span class=\"line\">        android:value=&quot;$&#123;UMENG_CHANNEL_VALUES&#125;&quot;/&gt; &lt;!--  渠道号--&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>\n<p>更多配置可参见<a href=\"http://dev.umeng.com/analytics/android-doc/integration?spm=0.0.0.0.RSo52l\">官方文档</a>。</p>\n<h2 id=\"二、编写配置脚本\"><a href=\"#二、编写配置脚本\" class=\"headerlink\" title=\"二、编写配置脚本\"></a>二、编写配置脚本</h2><p>主要是在model的gradle中编写相关的配置脚本，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultConfig&#123;</span><br><span class=\"line\">   //...</span><br><span class=\"line\">   multiDexEnabled true //突破方法数65536的限制</span><br><span class=\"line\">   manifestPlaceholders = [UMENG_CHANNEL_VALUES: &quot;umeng&quot;] //默认渠道号</span><br><span class=\"line\">   //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled false</span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">            //指定签名文件</span><br><span class=\"line\">            signingConfig signingConfigs.release</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //添加签名文件信息</span><br><span class=\"line\">    signingConfigs &#123;</span><br><span class=\"line\">        debug &#123;&#125;</span><br><span class=\"line\">        //release 包添加签名文件</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            storeFile file(&quot;D:/workspace_ide_settings/imtianxappkey.jks&quot;) //签名文件</span><br><span class=\"line\">            storePassword &quot;123456&quot; //签名文件密码</span><br><span class=\"line\">            keyAlias &quot;imtianx&quot; //别名</span><br><span class=\"line\">            keyPassword &quot;123456&quot; //签名密码</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //配置渠道号</span><br><span class=\"line\">    productFlavors &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        meizu &#123;</span><br><span class=\"line\">            //1.在每个渠道中指定渠道号</span><br><span class=\"line\">           //manifestPlaceholders = [UMENG_CHANNEL_VALUES: &quot;meizu&quot;]</span><br><span class=\"line\">           //指定相应渠道appname,需要将values/string中的 app_name隐藏</span><br><span class=\"line\">            //resValue &quot;string&quot;,&quot;app_name&quot;,&quot;testxiaomi&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        xiaomi &#123;</span><br><span class=\"line\">         //manifestPlaceholders = [UMENG_CHANNEL_VALUES: &quot;xiaomi &quot;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //2.使用脚本为每个渠道指定渠道号</span><br><span class=\"line\">    productFlavors.all &#123;</span><br><span class=\"line\">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUES: name]</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>到此，脚本配置已经完成，在 terminal 中使用下面命定打包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//打release 包</span><br><span class=\"line\">gradle assembleRelease</span><br><span class=\"line\">//打debug包</span><br><span class=\"line\">gradle assembleDebug</span><br><span class=\"line\">//打指渠道的release包</span><br><span class=\"line\">gradle assemblemeizuRelease</span><br></pre></td></tr></table></figure>\n<p>如果是第一次使用，打造包时会下载一些相应的工具包，速度较慢。打包完成后，在 <code>build/outputs/apk/</code>文件下下就会看见相应的，这里打的是 releas包，名字为：<code>app名-渠道名-release.apk</code></p>\n<p>如果想改变包名，可以配置如下代码进行指定包名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">        //...</span><br><span class=\"line\">         //指定release包名 为市场名</span><br><span class=\"line\">         applicationVariants.all &#123;</span><br><span class=\"line\">            variant -&gt;</span><br><span class=\"line\">                variant.outputs.each &#123;</span><br><span class=\"line\">                    output -&gt;</span><br><span class=\"line\">                        def outputFile = output.outputFile</span><br><span class=\"line\">                        if (outputFile != null &amp;&amp; outputFile.name.endsWith(&quot;.apk&quot;)) &#123;</span><br><span class=\"line\">                            def fileName = &quot;$&#123;variant.productFlavors[0].name&#125;&quot; + &quot;.apk&quot;</span><br><span class=\"line\">                            output.outputFile = new File(outputFile.parent, fileName);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在 terminal 中进行执行命令打包。</p>"},{"title":"android 7.0相机拍照适配","date":"2017-03-05T08:06:25.000Z","_content":"\n最近，之前一个项目的用户反馈APP拍照崩溃，查看了线上Crash日志，发现是  `EVA-AL10` 和 `ZUK Z2131` 两款手机，android 版本都是7.0的<!--more-->，看了下具体的错误消息，如下：\n```\n//...\nCaused by: android.os.FileUriExposedException: file:///storage/emulated/0/1489548204216.jpg exposed beyond app through ClipData.Item.getUri()\nat android.os.StrictMode.onFileUriExposed(StrictMode.java:1816)\n//...\n```\n在 Stackoverflow 查了下，发现是google 在 android N 之后，提高了私有文件的安全性，应用私有目录将被限制访问，无法通过  ` file:// URI 类型的Uri` 进行应用间文件共享，必须使用 `content:// URI类型的Ur,并授予 URI 临时访问权限。`\n\n下面是官方对7.0权限和文件共享的说明：\n\n![](http://img.imtianx.cn/android-7.0-permission-file-change.png)\n\n具体内容请查看[  官方说明-7.0行为变更](https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html#perm)(无需翻墙)\n\n如下是 android N 相机的适配过程：\n\n一、 **在manifest清单文件中注册provider**\n\n 添加如下代码：\n\n```\n<provider\n    android:name=\"android.support.v4.content.FileProvider\"\n    android:authorities=\"com.puyue.www.moneysteward.provider\"\n    android:exported=\"false\"\n    android:grantUriPermissions=\"true\">\n    <meta-data\n        android:name=\"android.support.FILE_PROVIDER_PATHS\"\n        android:resource=\"@xml/provider_paths\"/>\n</provider>\n```\n > 说明：\nexported:要求必须为false，为true则会报安全异，\ngrantUriPermissions:true，表示授予 URI 临时访问权限\nauthorities：**包名.provider**，准确的说应该是 applicationId。\n\n二、 **指定共享的目录**\n\n在 `res` 下新建 `xml` 目录，然后新建 `file_paths.xml`文件，该文件名无限制，但须和上面 provider 中的 resource 指定的一致，内容如下：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<paths>\n    <external-path\n        name=\"temp_photo\"\n        path=\".\"/>\n</paths>\n```\n> 说明：\n**path=\"\"**：它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为**path=\"pictures\"**， \n那么它代表着根目录下的pictures目录(/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的。\n\n三、**使用 FileProvider**\n\n如下具体的拍照做法：\n\n```\ntempCameraFilePath = Environment\n                     .getExternalStorageDirectory() +\n                     \"/takePic/\" +\n                     System.currentTimeMillis() + \".jpg\";\nFile file = new File (tempCameraFilePath);\nif (!file.exists() )\n{\n    file.getParentFile().mkdirs();\n}\nIntent intent = new Intent (MediaStore.ACTION_IMAGE_CAPTURE);\nUri uri = Uri.fromFile (new File (tempCameraFilePath) );\n\n//适配7.0\nif (Build.VERSION.SDK_INT > Build.VERSION_CODES.M)\n{\n    uri = FileProvider\n          .getUriForFile (this,\n                          BuildConfig.APPLICATION_ID +\n                          \".provider\", file);\n}\nintent.putExtra (MediaStore.EXTRA_OUTPUT, uri);\nstartActivityForResult (intent, REQUEST_CODE_CAMERA);\n}\n```\n\n需要对手机版本进行判断，否则直接用 `FileProvider` 在低版本手机上会导致相机 停止运行。注意需要申明下面两个权限：\n\n```\n<uses-permission android:name=\"android.permission.CAMERA\"/>\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n此外，由于拍照指定了 uri ,在 `onActivityResult`返回的 data 往往是 空的。\n\n在开发中，除了拍照，经常还会遇见 打开相册选取图片，下面是最近遇到的坑。\n\n对于大多手机，都可以通过 `ACTION_PICK` 来打开相册，选取图片，如下：\n\n```\nIntent intent = new Intent(Intent.ACTION_PICK, null);\nintent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, \"image/*\");\nstartActivityForResult(intent, REQUEST_CODE_ALBUM);\n```\n\n然而对于小米手机，却无法获取返回的路径，以下是对返回的 URI 的处理办法(来自网络)：\n\n```\n/**\n * 解决小米手机 相册 返回 null\n *\n * @param intent\n * @return\n */\npublic Uri getPictureUri (android.content.Intent intent)\n{\n    Uri uri = intent.getData();\n    String type = intent.getType();\n    if (uri.getScheme().equals (\"file\") && (type.contains (\"image/\") ) )\n    {\n        String path = uri.getEncodedPath();\n        if (path != null)\n        {\n            path = Uri.decode (path);\n            ContentResolver cr = this.getContentResolver();\n            StringBuffer buff = new StringBuffer();\n            buff.append (\"(\").append (MediaStore.Images.ImageColumns.DATA).append (\"=\")\n            .append (\"'\" + path + \"'\").append (\")\");\n            Cursor cur = cr.query (MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                                   new String[] {MediaStore.Images.ImageColumns._ID},\n                                   buff.toString(), null, null);\n            int index = 0;\n            for (cur.moveToFirst(); !cur.isAfterLast(); cur.moveToNext() )\n            {\n                index = cur.getColumnIndex (MediaStore.Images.ImageColumns._ID);\n                // set _id value\n                index = cur.getInt (index);\n            }\n            if (index == 0)\n            {\n                // do nothing\n            }\n            else\n            {\n                Uri uri_temp = Uri\n                               .parse (\"content://media/external/images/media/\"\n                                       + index);\n                if (uri_temp != null)\n                {\n                    uri = uri_temp;\n                }\n            }\n        }\n    }\n    return uri;\n}\n```\n\n然后在 `onActivityResult`进行处理返回的uri:\n\n```\n@Override\nprotected void onActivityResult (int requestCode, int resultCode, Intent data)\n{\n    super.onActivityResult (requestCode, resultCode, data);\n    switch (requestCode)\n    {\n    case REQUEST_CODE_ALBUM:   //相册\n    {\n        if (resultCode == RESULT_OK)\n        {\n            if (data != null)\n            {\n                Uri uri = getPictureUri (data); //处理返回的uri\n                String path = \"\";\n                String[] proj = {MediaStore.Images.Media.DATA};\n                Cursor cursor = getContentResolver().query (uri, proj, null, null, null);\n                if (cursor != null)\n                {\n                    int index = cursor.getColumnIndexOrThrow (\n                                    MediaStore.Images.Media.DATA);\n                    cursor.moveToFirst();\n                    path = cursor.getString (index);\n                    cursor.close();\n                    //do something\n                }\n            }\n        }\n        break;\n    }\n\n    }\n}\n```\n自己开发 用nexus6 测试毫无问题，却被测试妹子发现了，国内的手机厂商对room的阉割，导致 android 的适配变得很难，最近在做权限的处理时，又一次遇到了各种坑。\n\n","source":"_posts/android 7.0-take-photo.md","raw":"---\ntitle: android 7.0相机拍照适配\ndate: 2017-03-05 16:06:25\ncategories: [android,学习笔记]\ntags: [android7.0,拍照适配,相册]\n---\n\n最近，之前一个项目的用户反馈APP拍照崩溃，查看了线上Crash日志，发现是  `EVA-AL10` 和 `ZUK Z2131` 两款手机，android 版本都是7.0的<!--more-->，看了下具体的错误消息，如下：\n```\n//...\nCaused by: android.os.FileUriExposedException: file:///storage/emulated/0/1489548204216.jpg exposed beyond app through ClipData.Item.getUri()\nat android.os.StrictMode.onFileUriExposed(StrictMode.java:1816)\n//...\n```\n在 Stackoverflow 查了下，发现是google 在 android N 之后，提高了私有文件的安全性，应用私有目录将被限制访问，无法通过  ` file:// URI 类型的Uri` 进行应用间文件共享，必须使用 `content:// URI类型的Ur,并授予 URI 临时访问权限。`\n\n下面是官方对7.0权限和文件共享的说明：\n\n![](http://img.imtianx.cn/android-7.0-permission-file-change.png)\n\n具体内容请查看[  官方说明-7.0行为变更](https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html#perm)(无需翻墙)\n\n如下是 android N 相机的适配过程：\n\n一、 **在manifest清单文件中注册provider**\n\n 添加如下代码：\n\n```\n<provider\n    android:name=\"android.support.v4.content.FileProvider\"\n    android:authorities=\"com.puyue.www.moneysteward.provider\"\n    android:exported=\"false\"\n    android:grantUriPermissions=\"true\">\n    <meta-data\n        android:name=\"android.support.FILE_PROVIDER_PATHS\"\n        android:resource=\"@xml/provider_paths\"/>\n</provider>\n```\n > 说明：\nexported:要求必须为false，为true则会报安全异，\ngrantUriPermissions:true，表示授予 URI 临时访问权限\nauthorities：**包名.provider**，准确的说应该是 applicationId。\n\n二、 **指定共享的目录**\n\n在 `res` 下新建 `xml` 目录，然后新建 `file_paths.xml`文件，该文件名无限制，但须和上面 provider 中的 resource 指定的一致，内容如下：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<paths>\n    <external-path\n        name=\"temp_photo\"\n        path=\".\"/>\n</paths>\n```\n> 说明：\n**path=\"\"**：它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为**path=\"pictures\"**， \n那么它代表着根目录下的pictures目录(/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的。\n\n三、**使用 FileProvider**\n\n如下具体的拍照做法：\n\n```\ntempCameraFilePath = Environment\n                     .getExternalStorageDirectory() +\n                     \"/takePic/\" +\n                     System.currentTimeMillis() + \".jpg\";\nFile file = new File (tempCameraFilePath);\nif (!file.exists() )\n{\n    file.getParentFile().mkdirs();\n}\nIntent intent = new Intent (MediaStore.ACTION_IMAGE_CAPTURE);\nUri uri = Uri.fromFile (new File (tempCameraFilePath) );\n\n//适配7.0\nif (Build.VERSION.SDK_INT > Build.VERSION_CODES.M)\n{\n    uri = FileProvider\n          .getUriForFile (this,\n                          BuildConfig.APPLICATION_ID +\n                          \".provider\", file);\n}\nintent.putExtra (MediaStore.EXTRA_OUTPUT, uri);\nstartActivityForResult (intent, REQUEST_CODE_CAMERA);\n}\n```\n\n需要对手机版本进行判断，否则直接用 `FileProvider` 在低版本手机上会导致相机 停止运行。注意需要申明下面两个权限：\n\n```\n<uses-permission android:name=\"android.permission.CAMERA\"/>\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n此外，由于拍照指定了 uri ,在 `onActivityResult`返回的 data 往往是 空的。\n\n在开发中，除了拍照，经常还会遇见 打开相册选取图片，下面是最近遇到的坑。\n\n对于大多手机，都可以通过 `ACTION_PICK` 来打开相册，选取图片，如下：\n\n```\nIntent intent = new Intent(Intent.ACTION_PICK, null);\nintent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, \"image/*\");\nstartActivityForResult(intent, REQUEST_CODE_ALBUM);\n```\n\n然而对于小米手机，却无法获取返回的路径，以下是对返回的 URI 的处理办法(来自网络)：\n\n```\n/**\n * 解决小米手机 相册 返回 null\n *\n * @param intent\n * @return\n */\npublic Uri getPictureUri (android.content.Intent intent)\n{\n    Uri uri = intent.getData();\n    String type = intent.getType();\n    if (uri.getScheme().equals (\"file\") && (type.contains (\"image/\") ) )\n    {\n        String path = uri.getEncodedPath();\n        if (path != null)\n        {\n            path = Uri.decode (path);\n            ContentResolver cr = this.getContentResolver();\n            StringBuffer buff = new StringBuffer();\n            buff.append (\"(\").append (MediaStore.Images.ImageColumns.DATA).append (\"=\")\n            .append (\"'\" + path + \"'\").append (\")\");\n            Cursor cur = cr.query (MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                                   new String[] {MediaStore.Images.ImageColumns._ID},\n                                   buff.toString(), null, null);\n            int index = 0;\n            for (cur.moveToFirst(); !cur.isAfterLast(); cur.moveToNext() )\n            {\n                index = cur.getColumnIndex (MediaStore.Images.ImageColumns._ID);\n                // set _id value\n                index = cur.getInt (index);\n            }\n            if (index == 0)\n            {\n                // do nothing\n            }\n            else\n            {\n                Uri uri_temp = Uri\n                               .parse (\"content://media/external/images/media/\"\n                                       + index);\n                if (uri_temp != null)\n                {\n                    uri = uri_temp;\n                }\n            }\n        }\n    }\n    return uri;\n}\n```\n\n然后在 `onActivityResult`进行处理返回的uri:\n\n```\n@Override\nprotected void onActivityResult (int requestCode, int resultCode, Intent data)\n{\n    super.onActivityResult (requestCode, resultCode, data);\n    switch (requestCode)\n    {\n    case REQUEST_CODE_ALBUM:   //相册\n    {\n        if (resultCode == RESULT_OK)\n        {\n            if (data != null)\n            {\n                Uri uri = getPictureUri (data); //处理返回的uri\n                String path = \"\";\n                String[] proj = {MediaStore.Images.Media.DATA};\n                Cursor cursor = getContentResolver().query (uri, proj, null, null, null);\n                if (cursor != null)\n                {\n                    int index = cursor.getColumnIndexOrThrow (\n                                    MediaStore.Images.Media.DATA);\n                    cursor.moveToFirst();\n                    path = cursor.getString (index);\n                    cursor.close();\n                    //do something\n                }\n            }\n        }\n        break;\n    }\n\n    }\n}\n```\n自己开发 用nexus6 测试毫无问题，却被测试妹子发现了，国内的手机厂商对room的阉割，导致 android 的适配变得很难，最近在做权限的处理时，又一次遇到了各种坑。\n\n","slug":"android 7.0-take-photo","published":1,"updated":"2017-03-24T14:07:30.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucfq000tg0g5cyl5xlfe","content":"<p>最近，之前一个项目的用户反馈APP拍照崩溃，查看了线上Crash日志，发现是  <code>EVA-AL10</code> 和 <code>ZUK Z2131</code> 两款手机，android 版本都是7.0的<a id=\"more\"></a>，看了下具体的错误消息，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//...</span><br><span class=\"line\">Caused by: android.os.FileUriExposedException: file:///storage/emulated/0/1489548204216.jpg exposed beyond app through ClipData.Item.getUri()</span><br><span class=\"line\">at android.os.StrictMode.onFileUriExposed(StrictMode.java:1816)</span><br><span class=\"line\">//...</span><br></pre></td></tr></table></figure></p>\n<p>在 Stackoverflow 查了下，发现是google 在 android N 之后，提高了私有文件的安全性，应用私有目录将被限制访问，无法通过  <code>file:// URI 类型的Uri</code> 进行应用间文件共享，必须使用 <code>content:// URI类型的Ur,并授予 URI 临时访问权限。</code></p>\n<p>下面是官方对7.0权限和文件共享的说明：</p>\n<p><img src=\"http://img.imtianx.cn/android-7.0-permission-file-change.png\" alt=\"\"></p>\n<p>具体内容请查看<a href=\"https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html#perm\" target=\"_blank\" rel=\"external\">  官方说明-7.0行为变更</a>(无需翻墙)</p>\n<p>如下是 android N 相机的适配过程：</p>\n<p>一、 <strong>在manifest清单文件中注册provider</strong></p>\n<p> 添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;provider</span><br><span class=\"line\">    android:name=&quot;android.support.v4.content.FileProvider&quot;</span><br><span class=\"line\">    android:authorities=&quot;com.puyue.www.moneysteward.provider&quot;</span><br><span class=\"line\">    android:exported=&quot;false&quot;</span><br><span class=\"line\">    android:grantUriPermissions=&quot;true&quot;&gt;</span><br><span class=\"line\">    &lt;meta-data</span><br><span class=\"line\">        android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;</span><br><span class=\"line\">        android:resource=&quot;@xml/provider_paths&quot;/&gt;</span><br><span class=\"line\">&lt;/provider&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>说明：<br>exported:要求必须为false，为true则会报安全异，<br>grantUriPermissions:true，表示授予 URI 临时访问权限<br>authorities：<strong>包名.provider</strong>，准确的说应该是 applicationId。</p>\n</blockquote>\n<p>二、 <strong>指定共享的目录</strong></p>\n<p>在 <code>res</code> 下新建 <code>xml</code> 目录，然后新建 <code>file_paths.xml</code>文件，该文件名无限制，但须和上面 provider 中的 resource 指定的一致，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;paths&gt;</span><br><span class=\"line\">    &lt;external-path</span><br><span class=\"line\">        name=&quot;temp_photo&quot;</span><br><span class=\"line\">        path=&quot;.&quot;/&gt;</span><br><span class=\"line\">&lt;/paths&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>说明：<br><strong>path=””</strong>：它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为<strong>path=”pictures”</strong>，<br>那么它代表着根目录下的pictures目录(/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的。</p>\n</blockquote>\n<p>三、<strong>使用 FileProvider</strong></p>\n<p>如下具体的拍照做法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tempCameraFilePath = Environment</span><br><span class=\"line\">                     .getExternalStorageDirectory() +</span><br><span class=\"line\">                     &quot;/takePic/&quot; +</span><br><span class=\"line\">                     System.currentTimeMillis() + &quot;.jpg&quot;;</span><br><span class=\"line\">File file = new File (tempCameraFilePath);</span><br><span class=\"line\">if (!file.exists() )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    file.getParentFile().mkdirs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Intent intent = new Intent (MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class=\"line\">Uri uri = Uri.fromFile (new File (tempCameraFilePath) );</span><br><span class=\"line\"></span><br><span class=\"line\">//适配7.0</span><br><span class=\"line\">if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.M)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    uri = FileProvider</span><br><span class=\"line\">          .getUriForFile (this,</span><br><span class=\"line\">                          BuildConfig.APPLICATION_ID +</span><br><span class=\"line\">                          &quot;.provider&quot;, file);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">intent.putExtra (MediaStore.EXTRA_OUTPUT, uri);</span><br><span class=\"line\">startActivityForResult (intent, REQUEST_CODE_CAMERA);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要对手机版本进行判断，否则直接用 <code>FileProvider</code> 在低版本手机上会导致相机 停止运行。注意需要申明下面两个权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>此外，由于拍照指定了 uri ,在 <code>onActivityResult</code>返回的 data 往往是 空的。</p>\n<p>在开发中，除了拍照，经常还会遇见 打开相册选取图片，下面是最近遇到的坑。</p>\n<p>对于大多手机，都可以通过 <code>ACTION_PICK</code> 来打开相册，选取图片，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = new Intent(Intent.ACTION_PICK, null);</span><br><span class=\"line\">intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;);</span><br><span class=\"line\">startActivityForResult(intent, REQUEST_CODE_ALBUM);</span><br></pre></td></tr></table></figure>\n<p>然而对于小米手机，却无法获取返回的路径，以下是对返回的 URI 的处理办法(来自网络)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 解决小米手机 相册 返回 null</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param intent</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public Uri getPictureUri (android.content.Intent intent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Uri uri = intent.getData();</span><br><span class=\"line\">    String type = intent.getType();</span><br><span class=\"line\">    if (uri.getScheme().equals (&quot;file&quot;) &amp;&amp; (type.contains (&quot;image/&quot;) ) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        String path = uri.getEncodedPath();</span><br><span class=\"line\">        if (path != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            path = Uri.decode (path);</span><br><span class=\"line\">            ContentResolver cr = this.getContentResolver();</span><br><span class=\"line\">            StringBuffer buff = new StringBuffer();</span><br><span class=\"line\">            buff.append (&quot;(&quot;).append (MediaStore.Images.ImageColumns.DATA).append (&quot;=&quot;)</span><br><span class=\"line\">            .append (&quot;&apos;&quot; + path + &quot;&apos;&quot;).append (&quot;)&quot;);</span><br><span class=\"line\">            Cursor cur = cr.query (MediaStore.Images.Media.EXTERNAL_CONTENT_URI,</span><br><span class=\"line\">                                   new String[] &#123;MediaStore.Images.ImageColumns._ID&#125;,</span><br><span class=\"line\">                                   buff.toString(), null, null);</span><br><span class=\"line\">            int index = 0;</span><br><span class=\"line\">            for (cur.moveToFirst(); !cur.isAfterLast(); cur.moveToNext() )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                index = cur.getColumnIndex (MediaStore.Images.ImageColumns._ID);</span><br><span class=\"line\">                // set _id value</span><br><span class=\"line\">                index = cur.getInt (index);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (index == 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                // do nothing</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Uri uri_temp = Uri</span><br><span class=\"line\">                               .parse (&quot;content://media/external/images/media/&quot;</span><br><span class=\"line\">                                       + index);</span><br><span class=\"line\">                if (uri_temp != null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    uri = uri_temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return uri;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在 <code>onActivityResult</code>进行处理返回的uri:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onActivityResult (int requestCode, int resultCode, Intent data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    super.onActivityResult (requestCode, resultCode, data);</span><br><span class=\"line\">    switch (requestCode)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    case REQUEST_CODE_ALBUM:   //相册</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (resultCode == RESULT_OK)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (data != null)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Uri uri = getPictureUri (data); //处理返回的uri</span><br><span class=\"line\">                String path = &quot;&quot;;</span><br><span class=\"line\">                String[] proj = &#123;MediaStore.Images.Media.DATA&#125;;</span><br><span class=\"line\">                Cursor cursor = getContentResolver().query (uri, proj, null, null, null);</span><br><span class=\"line\">                if (cursor != null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    int index = cursor.getColumnIndexOrThrow (</span><br><span class=\"line\">                                    MediaStore.Images.Media.DATA);</span><br><span class=\"line\">                    cursor.moveToFirst();</span><br><span class=\"line\">                    path = cursor.getString (index);</span><br><span class=\"line\">                    cursor.close();</span><br><span class=\"line\">                    //do something</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自己开发 用nexus6 测试毫无问题，却被测试妹子发现了，国内的手机厂商对room的阉割，导致 android 的适配变得很难，最近在做权限的处理时，又一次遇到了各种坑。</p>\n","excerpt":"<p>最近，之前一个项目的用户反馈APP拍照崩溃，查看了线上Crash日志，发现是  <code>EVA-AL10</code> 和 <code>ZUK Z2131</code> 两款手机，android 版本都是7.0的","more":"，看了下具体的错误消息，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//...</span><br><span class=\"line\">Caused by: android.os.FileUriExposedException: file:///storage/emulated/0/1489548204216.jpg exposed beyond app through ClipData.Item.getUri()</span><br><span class=\"line\">at android.os.StrictMode.onFileUriExposed(StrictMode.java:1816)</span><br><span class=\"line\">//...</span><br></pre></td></tr></table></figure></p>\n<p>在 Stackoverflow 查了下，发现是google 在 android N 之后，提高了私有文件的安全性，应用私有目录将被限制访问，无法通过  <code>file:// URI 类型的Uri</code> 进行应用间文件共享，必须使用 <code>content:// URI类型的Ur,并授予 URI 临时访问权限。</code></p>\n<p>下面是官方对7.0权限和文件共享的说明：</p>\n<p><img src=\"http://img.imtianx.cn/android-7.0-permission-file-change.png\" alt=\"\"></p>\n<p>具体内容请查看<a href=\"https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html#perm\">  官方说明-7.0行为变更</a>(无需翻墙)</p>\n<p>如下是 android N 相机的适配过程：</p>\n<p>一、 <strong>在manifest清单文件中注册provider</strong></p>\n<p> 添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;provider</span><br><span class=\"line\">    android:name=&quot;android.support.v4.content.FileProvider&quot;</span><br><span class=\"line\">    android:authorities=&quot;com.puyue.www.moneysteward.provider&quot;</span><br><span class=\"line\">    android:exported=&quot;false&quot;</span><br><span class=\"line\">    android:grantUriPermissions=&quot;true&quot;&gt;</span><br><span class=\"line\">    &lt;meta-data</span><br><span class=\"line\">        android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;</span><br><span class=\"line\">        android:resource=&quot;@xml/provider_paths&quot;/&gt;</span><br><span class=\"line\">&lt;/provider&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>说明：<br>exported:要求必须为false，为true则会报安全异，<br>grantUriPermissions:true，表示授予 URI 临时访问权限<br>authorities：<strong>包名.provider</strong>，准确的说应该是 applicationId。</p>\n</blockquote>\n<p>二、 <strong>指定共享的目录</strong></p>\n<p>在 <code>res</code> 下新建 <code>xml</code> 目录，然后新建 <code>file_paths.xml</code>文件，该文件名无限制，但须和上面 provider 中的 resource 指定的一致，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;paths&gt;</span><br><span class=\"line\">    &lt;external-path</span><br><span class=\"line\">        name=&quot;temp_photo&quot;</span><br><span class=\"line\">        path=&quot;.&quot;/&gt;</span><br><span class=\"line\">&lt;/paths&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>说明：<br><strong>path=””</strong>：它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为<strong>path=”pictures”</strong>，<br>那么它代表着根目录下的pictures目录(/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的。</p>\n</blockquote>\n<p>三、<strong>使用 FileProvider</strong></p>\n<p>如下具体的拍照做法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tempCameraFilePath = Environment</span><br><span class=\"line\">                     .getExternalStorageDirectory() +</span><br><span class=\"line\">                     &quot;/takePic/&quot; +</span><br><span class=\"line\">                     System.currentTimeMillis() + &quot;.jpg&quot;;</span><br><span class=\"line\">File file = new File (tempCameraFilePath);</span><br><span class=\"line\">if (!file.exists() )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    file.getParentFile().mkdirs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Intent intent = new Intent (MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class=\"line\">Uri uri = Uri.fromFile (new File (tempCameraFilePath) );</span><br><span class=\"line\"></span><br><span class=\"line\">//适配7.0</span><br><span class=\"line\">if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.M)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    uri = FileProvider</span><br><span class=\"line\">          .getUriForFile (this,</span><br><span class=\"line\">                          BuildConfig.APPLICATION_ID +</span><br><span class=\"line\">                          &quot;.provider&quot;, file);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">intent.putExtra (MediaStore.EXTRA_OUTPUT, uri);</span><br><span class=\"line\">startActivityForResult (intent, REQUEST_CODE_CAMERA);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要对手机版本进行判断，否则直接用 <code>FileProvider</code> 在低版本手机上会导致相机 停止运行。注意需要申明下面两个权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>此外，由于拍照指定了 uri ,在 <code>onActivityResult</code>返回的 data 往往是 空的。</p>\n<p>在开发中，除了拍照，经常还会遇见 打开相册选取图片，下面是最近遇到的坑。</p>\n<p>对于大多手机，都可以通过 <code>ACTION_PICK</code> 来打开相册，选取图片，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = new Intent(Intent.ACTION_PICK, null);</span><br><span class=\"line\">intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;);</span><br><span class=\"line\">startActivityForResult(intent, REQUEST_CODE_ALBUM);</span><br></pre></td></tr></table></figure>\n<p>然而对于小米手机，却无法获取返回的路径，以下是对返回的 URI 的处理办法(来自网络)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 解决小米手机 相册 返回 null</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param intent</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public Uri getPictureUri (android.content.Intent intent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Uri uri = intent.getData();</span><br><span class=\"line\">    String type = intent.getType();</span><br><span class=\"line\">    if (uri.getScheme().equals (&quot;file&quot;) &amp;&amp; (type.contains (&quot;image/&quot;) ) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        String path = uri.getEncodedPath();</span><br><span class=\"line\">        if (path != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            path = Uri.decode (path);</span><br><span class=\"line\">            ContentResolver cr = this.getContentResolver();</span><br><span class=\"line\">            StringBuffer buff = new StringBuffer();</span><br><span class=\"line\">            buff.append (&quot;(&quot;).append (MediaStore.Images.ImageColumns.DATA).append (&quot;=&quot;)</span><br><span class=\"line\">            .append (&quot;&apos;&quot; + path + &quot;&apos;&quot;).append (&quot;)&quot;);</span><br><span class=\"line\">            Cursor cur = cr.query (MediaStore.Images.Media.EXTERNAL_CONTENT_URI,</span><br><span class=\"line\">                                   new String[] &#123;MediaStore.Images.ImageColumns._ID&#125;,</span><br><span class=\"line\">                                   buff.toString(), null, null);</span><br><span class=\"line\">            int index = 0;</span><br><span class=\"line\">            for (cur.moveToFirst(); !cur.isAfterLast(); cur.moveToNext() )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                index = cur.getColumnIndex (MediaStore.Images.ImageColumns._ID);</span><br><span class=\"line\">                // set _id value</span><br><span class=\"line\">                index = cur.getInt (index);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (index == 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                // do nothing</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Uri uri_temp = Uri</span><br><span class=\"line\">                               .parse (&quot;content://media/external/images/media/&quot;</span><br><span class=\"line\">                                       + index);</span><br><span class=\"line\">                if (uri_temp != null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    uri = uri_temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return uri;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在 <code>onActivityResult</code>进行处理返回的uri:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onActivityResult (int requestCode, int resultCode, Intent data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    super.onActivityResult (requestCode, resultCode, data);</span><br><span class=\"line\">    switch (requestCode)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    case REQUEST_CODE_ALBUM:   //相册</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (resultCode == RESULT_OK)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (data != null)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Uri uri = getPictureUri (data); //处理返回的uri</span><br><span class=\"line\">                String path = &quot;&quot;;</span><br><span class=\"line\">                String[] proj = &#123;MediaStore.Images.Media.DATA&#125;;</span><br><span class=\"line\">                Cursor cursor = getContentResolver().query (uri, proj, null, null, null);</span><br><span class=\"line\">                if (cursor != null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    int index = cursor.getColumnIndexOrThrow (</span><br><span class=\"line\">                                    MediaStore.Images.Media.DATA);</span><br><span class=\"line\">                    cursor.moveToFirst();</span><br><span class=\"line\">                    path = cursor.getString (index);</span><br><span class=\"line\">                    cursor.close();</span><br><span class=\"line\">                    //do something</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自己开发 用nexus6 测试毫无问题，却被测试妹子发现了，国内的手机厂商对room的阉割，导致 android 的适配变得很难，最近在做权限的处理时，又一次遇到了各种坑。</p>"},{"title":"android IPC 机制及进程通信","date":"2016-12-14T08:06:25.000Z","_content":"\n > 本文为读书笔记： 《Android 开发艺术探索 》——第二章 IPC 机制\n\n\nandroid  开发中有时候需要用到多进程，那么了解进程间通信对我们开发就尤为重要。往往多进程分为两种情况： 一是一个应用因某些原因需要多进程（如某些模块需要在单独的进程中，或者是为了加大本应用所能使用的内存空间等）；二是当前应用需要想起他应用获取数据。<!-- more -->\n\n## 一、IPC简介\n\n**IPC** 是 `Inter-Process Communication` 的缩写，含义为进程间通信或者跨进程通信，指两个进程间进行数据交互的过程。\n**进程**:是cpu调度的最小单位，是一种有限的系统资源，一般只一个执行单元。在PC或者移动设备上指一个程序或者一个应用。而一个进程可以包含多个进程。\n\nIPC 不是android 中所独有的，任何操作系统都有。Windows上可以通过剪切板、管道和邮槽等来进行进程间通信；Linux 上可以通过命名管道、共享内存、信号量等进行通信;而android 他是一种基于linux 内核的移动操作系统，他的进程间通信方式并不完全继承自linux, 却有着自己独特的方式——`Binder`，此外，还可以使用Socket进行进程间通信。\n\n## 二、android 中的多进程模式\n\n在android 中如果使用多进程，通过给四大组件指定 `android:process` 属性即可开启多进程，此外还可以通过 JNI 在native 层 fork 一个新的进程。\n如下activity 配置示例代码：\n\n```\n <activity android:name=\".activity.MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n </activity>\n\n<activity\n    android:name=\".activity.SecondActivity\"\n    android:configChanges=\"screenLayout\"\n    android:label=\"@string/app_name\"\n    android:process=\":remote\"/>\n<activity android:name=\".activity.ThirdActivity\"\n    android:configChanges=\"screenLayout\"\n    android:label=\"@string/app_name\"\n    android:process=\"com.imtianx.ipcdemo.remote\"/>\n\n```\n通过 MainActivity 启动 SecondActivity ，SecondActivity 启动 ThirdActivity。\n这三个activity 分别运行在三个不同的进程中：\n```\n//在as中打开terminal 输入下面命令\nadb shell\n//查看进程：ps|grep 包名\nps|grep cn.imtianx.ipcdemo\n//三个进程如下\nUSER      PID   PPID  VSIZE  RSS   WCHAN            PC  NAME\nu0_a106   3682  1680  1136428 57512 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo\nu0_a106   3808  1680  1134324 57360 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo:remote\nu0_a106   3918  1680  1166916 57920 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo.remote\n```\n\n或者在monitor界面也可以查看。MainActivity没有指定process属性，则他在应用的包名 `cn.imtianx.ipcdemo` 对应的进程中,其他两个分别 SecondActivity、ThirdActivity 所在的进程。对于SecondActivity ，他的进程是 以 **：** 申明的，是指在当前的进程名前加上包名，为 **私有进程**，其他应用不可与其在同一进程中；而不以 “ ：”开头的进程，属于 **全局进程** ，则可以。\n\n> 对于每个进程，都有一个独立的虚拟机，在内存中都有着不同的地址，这会导致不同虚拟机访问同一对象会产生多个副本，互不影响，若在一个进程中修改了数据，在另一个进程中不会变。即多进程下不能通过内存共享数据。\n\n一般多进程会造成如下几个问题：\n\n- 静态成员和单利失效\n- 多线程同步进制失效\n- SharedPreference 的可靠性下降\n  底层是通过读写XML实现的，并发读写是会出问题的\n- Application 会被多次重建\n  运行在同一进程中的组件属于同一个虚拟机和同一个Application的\n\n\n## 三、IPC 基础概念\n只有明白了 IPC 中的 **Serializable接口、 Parcelable接口 和 Binder**相关的基础概念  ，才能更好的理解跨进程通信。  Serializable接口和 Parcelable接口 是实现序列化的两种方式。对于Intent 和 Binder 传输数据、对象持久化到本地或者网络传输，都需要使用。\n\n### 3.1 Serializable接口\n\nSerializable接口 是java 中的，是一个空的接口，使用时直接实现，添加如下标识，即可自动实现序列化和反序列化操作。在使用过程中开销较大，需要大量操作io。\n\n```\nprivate static final long serialVersionUID = 1L;\n```\n对于 `transient` 标识的属性和静态成员变量 ， 不参与序列化。\n\n\n### 3.2 Parcelable接口\nParcelable接口 是android 特有的序列化方式，使用起来稍微麻烦，但是效率较高，主要用于内存序列化。如下使用示例：\n\n```\npublic class User implements Parcelable{\n\n    private String id;\n    private String name;\n    private String sex;\n    private int age;\n\n    protected User(Parcel in) {\n        id = in.readString();\n        name = in.readString();\n        sex = in.readString();\n        age = in.readInt();\n    }\n\n    //用于反序列化\n    public static final Creator<User> CREATOR = new Creator<User>() {\n        /**\n         * 从序列化对象中创建原始对象\n         * @param in\n         * @return\n         */\n        @Override\n        public User createFromParcel(Parcel in) {\n            return new User(in);\n        }\n\n        /**\n         * 创建指定长度的原始对象数组\n         * @param size\n         * @return\n         */\n        @Override\n        public User[] newArray(int size) {\n            return new User[size];\n        }\n    };\n\n    /**\n     * 内容功能描述\n     * 大多数返回0，仅当当前对象中存在文件描述符时返回1\n     * @return\n     */\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    /**\n     * 当前对象写入序列化结构\n     * @param dest\n     * @param flags\n     */\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(id);\n        dest.writeString(name);\n        dest.writeString(sex);\n        dest.writeInt(age);\n    }\n}\n\n```\n\n这里虽然看着很复杂，但这些方法全部可以自动生成，不用手动编写。android 中的 Intent 、Bundle、Bitmap等都实现了Parcelable接口，都是可以进行序列化的。\n\n### 3.3 Binder\n\nBinder 实现了 IBinder接口。从ipc角度，binder是一种跨进程通信方式，还可以理解为一种虚拟的物理设备，其驱动是 /dev/binder ;从 android Framework 角度说，Binder 是 ServiceManager 连接各种 Manager（ActivityManager、WindowManger，...）和相应 ManagerServices的桥梁；从 android 应用层来说，Binder是客户端与服务器端进行通信的媒介。\n\nandroid中 Binder 主要用在Services中，包括 AIDL 和 Messenger , Messenger 底层是 AIDL 实现的。\n\n如下是Binder的工作流程图：\n\n![](/img/article_img/2016/Binder 工作机制.png)\n\n## 四、android 中的IPC 方式\n\n如下各种 IPC 方式的优缺点对比：\n\n|名称 |优点 |缺点|使用场景|\n|------|:----:|:----:|:----:|\n|Bundle|简单易用|只能传输Bundle支持的数据类型|四大组件间的进程通信|\n|文件共享|简单易用|不适合高并发场景，并且无法做到进程间的即时通讯|无并发访问情形，交换简单的数据，实时性不高|\n|AIDL|功能强大，支持一对多并发通信，实时通信|使用复杂，需要处理好线程同步|一对多通信且有RPC需求|\n|Messenger|功能一般，支持一对多串行通信，实时通信|不能很好处理高并发情形，不支持RPC，数据通过Message进行传输（只能传输Bundle支持的数据类型）|低并发的一对多即时通讯，无RPC需求，或者无需返回结果|\n|ContentProvider|在数据源访问方面功能强大，支持一对多并发数据共享，可以通过Call方法扩展其他操作|可以理解为受约束的AIDL，主要提供数据源的CRUD操作|一对多的进程数据共享|\n|Socket|功能强大，可以通过网络传输字节流，支持一对多实时通信|实现复杂，不支持直接的RPC|网络数据交换|\n\n\n## 五、AIDL 的简单使用\n\n只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。\n\n使用 AIDL 创建绑定服务的基本步骤如下：\n\n1. 创建 .aidl 文件\n在android studio 中 ，可以直接创建 AIDL ，自动创建相关的 aidl 包，这里创建 `IAddAidlInterface.aidl` 文件，具体内容如下：\n\n \n ```\n // IAddAidlInterface.aidl\n package cn.imtianx.ipcdemo;\n interface IAddAidlInterface {\n //计算两个数的和\n int add(int num1 ,int num2);\n }\n ```\n 编译后会自动生成相应的 java 类，这里是在 `build/generated/source/aidl/debug/包名/IAddAidlInterface.java` ,它包含一个内部类：Stub,继承自 `Binder`,实现了我们定义的 AIDL 接口，IAddAidlInterface，是用于定义服务的 RPC 接口。\n\n2. 实现接口\n  \n ```\n  private IBinder mIBinder = new IAddAidlInterface.Stub(){\n       @Override\n       public int add(int num1, int num2) throws RemoteException {\n        return num1+num2;\n       }\n   };\n ```\n\n3. 向客户端公开接口\n 自定义服务，便于客户端调用。\n\n ```\n public class IAddService extends Service {\n        public IAddService() {\n        }\n    \n        @Override\n        public IBinder onBind(Intent intent) {\n            // TODO: Return the communication channel to the service.\n            return mIBinder;\n        }\n        private IBinder mIBinder = new IAddAidlInterface.Stub(){\n            @Override\n            public int add(int num1, int num2) throws RemoteException {\n                return num1+num2;\n            }\n        };\n}\n ```\n\n 具体的调用(部分代码)：\n \n ```\n private IAddAidlInterface mIAddAidlInterface;\n    private ServiceConnection mConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            //获取远程服务对象\n            mIAddAidlInterface = IAddAidlInterface.Stub.asInterface(service);\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            mIAddAidlInterface = null;\n        }\n    };\n    \n    //绑定服务\n    Intent intent = new Intent(AIDLActivity.this,IAddService.class);\n    intent.setAction(IAddService.class.getName());\n    bindService(intent,mConnection, Context.BIND_AUTO_CREATE);\n    \n    //调用远程服务方法\n    int result  = mIAddAidlInterface.add(num1,num2);\n     \n    //解绑服务\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unbindService(mConnection);\n    }\n ```\n \n 上述是一个简单的 AIDL 的使用，通过调用远程服务获取 计算结果。\n \n接下来，分析下as 建立aidl文件编译后自动生成的java 类：\n \n```\npackage cn.imtianx.ipcdemo;\npublic interface IAddAidlInterface extends android.os.IInterface\n{\n    public static abstract class Stub extends android.os.Binder implements cn.imtianx.ipcdemo.IAddAidlInterface\n    {\n        //binder 的唯一标示，一般是binder的类名\n        private static final java.lang.String DESCRIPTOR = \"cn.imtianx.ipcdemo.IAddAidlInterface\";\n        /** Construct the stub at attach it to the interface. */\n        public Stub()\n        {\n            this.attachInterface (this, DESCRIPTOR);\n        }\n\n        /**\n         * 用于将服务器端的binder 转换成客户端所需要的AIDL 的接口类型\n         * @param obj\n         * @return 如果客户端和服务器端在同一进程，则返回服务端的stub对象，否则返回 Stub.proxy对象\n        */\n        public static cn.imtianx.ipcdemo.IAddAidlInterface asInterface (android.os.IBinder obj)\n        {\n            if ( (obj == null) )\n            {\n                return null;\n            }\n            android.os.IInterface iin = obj.queryLocalInterface (DESCRIPTOR);\n            if ( ( (iin != null) && (iin instanceof cn.imtianx.ipcdemo.IAddAidlInterface) ) )\n            {\n                return ( (cn.imtianx.ipcdemo.IAddAidlInterface) iin);\n            }\n            return new cn.imtianx.ipcdemo.IAddAidlInterface.Stub.Proxy (obj);\n        }\n        /**\n         * 返回当前binder对象\n         * @return\n         */\n        @Override public android.os.IBinder asBinder()\n        {\n            return this;\n        }\n        /**\n        * 运行在服务端的Binder线程池中\n        * @param code 确定请求的方法\n        * @param data 获取目标方法所需参数\n        * @param reply 写入返回值\n        * @param flags\n        * @return 若返回false，则为失败，可以此做权限验证\n        * @throws android.os.RemoteException\n        */\n        @Override public boolean onTransact (int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException\n        {\n            switch (code)\n            {\n            case INTERFACE_TRANSACTION:\n            {\n                reply.writeString (DESCRIPTOR);\n                return true;\n            }\n\n            case TRANSACTION_add:\n            {\n                data.enforceInterface (DESCRIPTOR);\n                int _arg0;\n                _arg0 = data.readInt();\n                int _arg1;\n                _arg1 = data.readInt();\n                int _result = this.add (_arg0, _arg1);\n                reply.writeNoException();\n                reply.writeInt (_result);\n                return true;\n            }\n            }\n            return super.onTransact (code, data, reply, flags);\n        }\n        //代理对象\n        private static class Proxy implements cn.imtianx.ipcdemo.IAddAidlInterface\n        {\n            private android.os.IBinder mRemote;\n            Proxy (android.os.IBinder remote)\n            {\n                mRemote = remote;\n            }\n            @Override public android.os.IBinder asBinder()\n            {\n                return mRemote;\n            }\n            public java.lang.String getInterfaceDescriptor()\n            {\n                return DESCRIPTOR;\n            }\n            @Override public int add (int num1, int num2) throws android.os.RemoteException\n            {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                int _result;\n                try {\n                    _data.writeInterfaceToken (DESCRIPTOR);\n                    _data.writeInt (num1);\n                    _data.writeInt (num2);\n                    mRemote.transact (Stub.TRANSACTION_add, _data, _reply, 0);\n                    _reply.readException();\n                    _result = _reply.readInt();\n                }\n                finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n                return _result;\n            }\n        }\n\n        /**\n        * 方法标示符\n        * 格式：TRANSACTION_方法名 = (android.os.IBinder.FIRST_CALL_TRANSACTION + \n        *       i);其中i按方法数自增\n        */\n        static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n\n    }\n    public int add (int num1, int num2) throws android.os.RemoteException;\n}\n\n```\n\n更多AIDL 的资料，可参见[官方文档](https://developer.android.google.cn/guide/components/aidl.html#Defining)，对于Socket、ContentProvider等方式，之前接触过，这里不做介绍。\n ","source":"_posts/android IPC 机制及进程通信.md","raw":"\n---\ntitle: android IPC 机制及进程通信\ndate: 2016-12-14 16:06:25\ncategories: [android,学习笔记]\ntags: [IPC,AIDL,进程通信]\n---\n\n > 本文为读书笔记： 《Android 开发艺术探索 》——第二章 IPC 机制\n\n\nandroid  开发中有时候需要用到多进程，那么了解进程间通信对我们开发就尤为重要。往往多进程分为两种情况： 一是一个应用因某些原因需要多进程（如某些模块需要在单独的进程中，或者是为了加大本应用所能使用的内存空间等）；二是当前应用需要想起他应用获取数据。<!-- more -->\n\n## 一、IPC简介\n\n**IPC** 是 `Inter-Process Communication` 的缩写，含义为进程间通信或者跨进程通信，指两个进程间进行数据交互的过程。\n**进程**:是cpu调度的最小单位，是一种有限的系统资源，一般只一个执行单元。在PC或者移动设备上指一个程序或者一个应用。而一个进程可以包含多个进程。\n\nIPC 不是android 中所独有的，任何操作系统都有。Windows上可以通过剪切板、管道和邮槽等来进行进程间通信；Linux 上可以通过命名管道、共享内存、信号量等进行通信;而android 他是一种基于linux 内核的移动操作系统，他的进程间通信方式并不完全继承自linux, 却有着自己独特的方式——`Binder`，此外，还可以使用Socket进行进程间通信。\n\n## 二、android 中的多进程模式\n\n在android 中如果使用多进程，通过给四大组件指定 `android:process` 属性即可开启多进程，此外还可以通过 JNI 在native 层 fork 一个新的进程。\n如下activity 配置示例代码：\n\n```\n <activity android:name=\".activity.MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n </activity>\n\n<activity\n    android:name=\".activity.SecondActivity\"\n    android:configChanges=\"screenLayout\"\n    android:label=\"@string/app_name\"\n    android:process=\":remote\"/>\n<activity android:name=\".activity.ThirdActivity\"\n    android:configChanges=\"screenLayout\"\n    android:label=\"@string/app_name\"\n    android:process=\"com.imtianx.ipcdemo.remote\"/>\n\n```\n通过 MainActivity 启动 SecondActivity ，SecondActivity 启动 ThirdActivity。\n这三个activity 分别运行在三个不同的进程中：\n```\n//在as中打开terminal 输入下面命令\nadb shell\n//查看进程：ps|grep 包名\nps|grep cn.imtianx.ipcdemo\n//三个进程如下\nUSER      PID   PPID  VSIZE  RSS   WCHAN            PC  NAME\nu0_a106   3682  1680  1136428 57512 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo\nu0_a106   3808  1680  1134324 57360 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo:remote\nu0_a106   3918  1680  1166916 57920 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo.remote\n```\n\n或者在monitor界面也可以查看。MainActivity没有指定process属性，则他在应用的包名 `cn.imtianx.ipcdemo` 对应的进程中,其他两个分别 SecondActivity、ThirdActivity 所在的进程。对于SecondActivity ，他的进程是 以 **：** 申明的，是指在当前的进程名前加上包名，为 **私有进程**，其他应用不可与其在同一进程中；而不以 “ ：”开头的进程，属于 **全局进程** ，则可以。\n\n> 对于每个进程，都有一个独立的虚拟机，在内存中都有着不同的地址，这会导致不同虚拟机访问同一对象会产生多个副本，互不影响，若在一个进程中修改了数据，在另一个进程中不会变。即多进程下不能通过内存共享数据。\n\n一般多进程会造成如下几个问题：\n\n- 静态成员和单利失效\n- 多线程同步进制失效\n- SharedPreference 的可靠性下降\n  底层是通过读写XML实现的，并发读写是会出问题的\n- Application 会被多次重建\n  运行在同一进程中的组件属于同一个虚拟机和同一个Application的\n\n\n## 三、IPC 基础概念\n只有明白了 IPC 中的 **Serializable接口、 Parcelable接口 和 Binder**相关的基础概念  ，才能更好的理解跨进程通信。  Serializable接口和 Parcelable接口 是实现序列化的两种方式。对于Intent 和 Binder 传输数据、对象持久化到本地或者网络传输，都需要使用。\n\n### 3.1 Serializable接口\n\nSerializable接口 是java 中的，是一个空的接口，使用时直接实现，添加如下标识，即可自动实现序列化和反序列化操作。在使用过程中开销较大，需要大量操作io。\n\n```\nprivate static final long serialVersionUID = 1L;\n```\n对于 `transient` 标识的属性和静态成员变量 ， 不参与序列化。\n\n\n### 3.2 Parcelable接口\nParcelable接口 是android 特有的序列化方式，使用起来稍微麻烦，但是效率较高，主要用于内存序列化。如下使用示例：\n\n```\npublic class User implements Parcelable{\n\n    private String id;\n    private String name;\n    private String sex;\n    private int age;\n\n    protected User(Parcel in) {\n        id = in.readString();\n        name = in.readString();\n        sex = in.readString();\n        age = in.readInt();\n    }\n\n    //用于反序列化\n    public static final Creator<User> CREATOR = new Creator<User>() {\n        /**\n         * 从序列化对象中创建原始对象\n         * @param in\n         * @return\n         */\n        @Override\n        public User createFromParcel(Parcel in) {\n            return new User(in);\n        }\n\n        /**\n         * 创建指定长度的原始对象数组\n         * @param size\n         * @return\n         */\n        @Override\n        public User[] newArray(int size) {\n            return new User[size];\n        }\n    };\n\n    /**\n     * 内容功能描述\n     * 大多数返回0，仅当当前对象中存在文件描述符时返回1\n     * @return\n     */\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    /**\n     * 当前对象写入序列化结构\n     * @param dest\n     * @param flags\n     */\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(id);\n        dest.writeString(name);\n        dest.writeString(sex);\n        dest.writeInt(age);\n    }\n}\n\n```\n\n这里虽然看着很复杂，但这些方法全部可以自动生成，不用手动编写。android 中的 Intent 、Bundle、Bitmap等都实现了Parcelable接口，都是可以进行序列化的。\n\n### 3.3 Binder\n\nBinder 实现了 IBinder接口。从ipc角度，binder是一种跨进程通信方式，还可以理解为一种虚拟的物理设备，其驱动是 /dev/binder ;从 android Framework 角度说，Binder 是 ServiceManager 连接各种 Manager（ActivityManager、WindowManger，...）和相应 ManagerServices的桥梁；从 android 应用层来说，Binder是客户端与服务器端进行通信的媒介。\n\nandroid中 Binder 主要用在Services中，包括 AIDL 和 Messenger , Messenger 底层是 AIDL 实现的。\n\n如下是Binder的工作流程图：\n\n![](/img/article_img/2016/Binder 工作机制.png)\n\n## 四、android 中的IPC 方式\n\n如下各种 IPC 方式的优缺点对比：\n\n|名称 |优点 |缺点|使用场景|\n|------|:----:|:----:|:----:|\n|Bundle|简单易用|只能传输Bundle支持的数据类型|四大组件间的进程通信|\n|文件共享|简单易用|不适合高并发场景，并且无法做到进程间的即时通讯|无并发访问情形，交换简单的数据，实时性不高|\n|AIDL|功能强大，支持一对多并发通信，实时通信|使用复杂，需要处理好线程同步|一对多通信且有RPC需求|\n|Messenger|功能一般，支持一对多串行通信，实时通信|不能很好处理高并发情形，不支持RPC，数据通过Message进行传输（只能传输Bundle支持的数据类型）|低并发的一对多即时通讯，无RPC需求，或者无需返回结果|\n|ContentProvider|在数据源访问方面功能强大，支持一对多并发数据共享，可以通过Call方法扩展其他操作|可以理解为受约束的AIDL，主要提供数据源的CRUD操作|一对多的进程数据共享|\n|Socket|功能强大，可以通过网络传输字节流，支持一对多实时通信|实现复杂，不支持直接的RPC|网络数据交换|\n\n\n## 五、AIDL 的简单使用\n\n只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。\n\n使用 AIDL 创建绑定服务的基本步骤如下：\n\n1. 创建 .aidl 文件\n在android studio 中 ，可以直接创建 AIDL ，自动创建相关的 aidl 包，这里创建 `IAddAidlInterface.aidl` 文件，具体内容如下：\n\n \n ```\n // IAddAidlInterface.aidl\n package cn.imtianx.ipcdemo;\n interface IAddAidlInterface {\n //计算两个数的和\n int add(int num1 ,int num2);\n }\n ```\n 编译后会自动生成相应的 java 类，这里是在 `build/generated/source/aidl/debug/包名/IAddAidlInterface.java` ,它包含一个内部类：Stub,继承自 `Binder`,实现了我们定义的 AIDL 接口，IAddAidlInterface，是用于定义服务的 RPC 接口。\n\n2. 实现接口\n  \n ```\n  private IBinder mIBinder = new IAddAidlInterface.Stub(){\n       @Override\n       public int add(int num1, int num2) throws RemoteException {\n        return num1+num2;\n       }\n   };\n ```\n\n3. 向客户端公开接口\n 自定义服务，便于客户端调用。\n\n ```\n public class IAddService extends Service {\n        public IAddService() {\n        }\n    \n        @Override\n        public IBinder onBind(Intent intent) {\n            // TODO: Return the communication channel to the service.\n            return mIBinder;\n        }\n        private IBinder mIBinder = new IAddAidlInterface.Stub(){\n            @Override\n            public int add(int num1, int num2) throws RemoteException {\n                return num1+num2;\n            }\n        };\n}\n ```\n\n 具体的调用(部分代码)：\n \n ```\n private IAddAidlInterface mIAddAidlInterface;\n    private ServiceConnection mConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            //获取远程服务对象\n            mIAddAidlInterface = IAddAidlInterface.Stub.asInterface(service);\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            mIAddAidlInterface = null;\n        }\n    };\n    \n    //绑定服务\n    Intent intent = new Intent(AIDLActivity.this,IAddService.class);\n    intent.setAction(IAddService.class.getName());\n    bindService(intent,mConnection, Context.BIND_AUTO_CREATE);\n    \n    //调用远程服务方法\n    int result  = mIAddAidlInterface.add(num1,num2);\n     \n    //解绑服务\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unbindService(mConnection);\n    }\n ```\n \n 上述是一个简单的 AIDL 的使用，通过调用远程服务获取 计算结果。\n \n接下来，分析下as 建立aidl文件编译后自动生成的java 类：\n \n```\npackage cn.imtianx.ipcdemo;\npublic interface IAddAidlInterface extends android.os.IInterface\n{\n    public static abstract class Stub extends android.os.Binder implements cn.imtianx.ipcdemo.IAddAidlInterface\n    {\n        //binder 的唯一标示，一般是binder的类名\n        private static final java.lang.String DESCRIPTOR = \"cn.imtianx.ipcdemo.IAddAidlInterface\";\n        /** Construct the stub at attach it to the interface. */\n        public Stub()\n        {\n            this.attachInterface (this, DESCRIPTOR);\n        }\n\n        /**\n         * 用于将服务器端的binder 转换成客户端所需要的AIDL 的接口类型\n         * @param obj\n         * @return 如果客户端和服务器端在同一进程，则返回服务端的stub对象，否则返回 Stub.proxy对象\n        */\n        public static cn.imtianx.ipcdemo.IAddAidlInterface asInterface (android.os.IBinder obj)\n        {\n            if ( (obj == null) )\n            {\n                return null;\n            }\n            android.os.IInterface iin = obj.queryLocalInterface (DESCRIPTOR);\n            if ( ( (iin != null) && (iin instanceof cn.imtianx.ipcdemo.IAddAidlInterface) ) )\n            {\n                return ( (cn.imtianx.ipcdemo.IAddAidlInterface) iin);\n            }\n            return new cn.imtianx.ipcdemo.IAddAidlInterface.Stub.Proxy (obj);\n        }\n        /**\n         * 返回当前binder对象\n         * @return\n         */\n        @Override public android.os.IBinder asBinder()\n        {\n            return this;\n        }\n        /**\n        * 运行在服务端的Binder线程池中\n        * @param code 确定请求的方法\n        * @param data 获取目标方法所需参数\n        * @param reply 写入返回值\n        * @param flags\n        * @return 若返回false，则为失败，可以此做权限验证\n        * @throws android.os.RemoteException\n        */\n        @Override public boolean onTransact (int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException\n        {\n            switch (code)\n            {\n            case INTERFACE_TRANSACTION:\n            {\n                reply.writeString (DESCRIPTOR);\n                return true;\n            }\n\n            case TRANSACTION_add:\n            {\n                data.enforceInterface (DESCRIPTOR);\n                int _arg0;\n                _arg0 = data.readInt();\n                int _arg1;\n                _arg1 = data.readInt();\n                int _result = this.add (_arg0, _arg1);\n                reply.writeNoException();\n                reply.writeInt (_result);\n                return true;\n            }\n            }\n            return super.onTransact (code, data, reply, flags);\n        }\n        //代理对象\n        private static class Proxy implements cn.imtianx.ipcdemo.IAddAidlInterface\n        {\n            private android.os.IBinder mRemote;\n            Proxy (android.os.IBinder remote)\n            {\n                mRemote = remote;\n            }\n            @Override public android.os.IBinder asBinder()\n            {\n                return mRemote;\n            }\n            public java.lang.String getInterfaceDescriptor()\n            {\n                return DESCRIPTOR;\n            }\n            @Override public int add (int num1, int num2) throws android.os.RemoteException\n            {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                int _result;\n                try {\n                    _data.writeInterfaceToken (DESCRIPTOR);\n                    _data.writeInt (num1);\n                    _data.writeInt (num2);\n                    mRemote.transact (Stub.TRANSACTION_add, _data, _reply, 0);\n                    _reply.readException();\n                    _result = _reply.readInt();\n                }\n                finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n                return _result;\n            }\n        }\n\n        /**\n        * 方法标示符\n        * 格式：TRANSACTION_方法名 = (android.os.IBinder.FIRST_CALL_TRANSACTION + \n        *       i);其中i按方法数自增\n        */\n        static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n\n    }\n    public int add (int num1, int num2) throws android.os.RemoteException;\n}\n\n```\n\n更多AIDL 的资料，可参见[官方文档](https://developer.android.google.cn/guide/components/aidl.html#Defining)，对于Socket、ContentProvider等方式，之前接触过，这里不做介绍。\n ","slug":"android IPC 机制及进程通信","published":1,"updated":"2016-12-17T04:36:33.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucg5000xg0g5id4tolgd","content":"<blockquote>\n<p>本文为读书笔记： 《Android 开发艺术探索 》——第二章 IPC 机制</p>\n</blockquote>\n<p>android  开发中有时候需要用到多进程，那么了解进程间通信对我们开发就尤为重要。往往多进程分为两种情况： 一是一个应用因某些原因需要多进程（如某些模块需要在单独的进程中，或者是为了加大本应用所能使用的内存空间等）；二是当前应用需要想起他应用获取数据。<a id=\"more\"></a></p>\n<h2 id=\"一、IPC简介\"><a href=\"#一、IPC简介\" class=\"headerlink\" title=\"一、IPC简介\"></a>一、IPC简介</h2><p><strong>IPC</strong> 是 <code>Inter-Process Communication</code> 的缩写，含义为进程间通信或者跨进程通信，指两个进程间进行数据交互的过程。<br><strong>进程</strong>:是cpu调度的最小单位，是一种有限的系统资源，一般只一个执行单元。在PC或者移动设备上指一个程序或者一个应用。而一个进程可以包含多个进程。</p>\n<p>IPC 不是android 中所独有的，任何操作系统都有。Windows上可以通过剪切板、管道和邮槽等来进行进程间通信；Linux 上可以通过命名管道、共享内存、信号量等进行通信;而android 他是一种基于linux 内核的移动操作系统，他的进程间通信方式并不完全继承自linux, 却有着自己独特的方式——<code>Binder</code>，此外，还可以使用Socket进行进程间通信。</p>\n<h2 id=\"二、android-中的多进程模式\"><a href=\"#二、android-中的多进程模式\" class=\"headerlink\" title=\"二、android 中的多进程模式\"></a>二、android 中的多进程模式</h2><p>在android 中如果使用多进程，通过给四大组件指定 <code>android:process</code> 属性即可开启多进程，此外还可以通过 JNI 在native 层 fork 一个新的进程。<br>如下activity 配置示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;activity android:name=&quot;.activity.MainActivity&quot;&gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\"> &lt;/activity&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;activity</span><br><span class=\"line\">    android:name=&quot;.activity.SecondActivity&quot;</span><br><span class=\"line\">    android:configChanges=&quot;screenLayout&quot;</span><br><span class=\"line\">    android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">    android:process=&quot;:remote&quot;/&gt;</span><br><span class=\"line\">&lt;activity android:name=&quot;.activity.ThirdActivity&quot;</span><br><span class=\"line\">    android:configChanges=&quot;screenLayout&quot;</span><br><span class=\"line\">    android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">    android:process=&quot;com.imtianx.ipcdemo.remote&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>通过 MainActivity 启动 SecondActivity ，SecondActivity 启动 ThirdActivity。<br>这三个activity 分别运行在三个不同的进程中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在as中打开terminal 输入下面命令</span><br><span class=\"line\">adb shell</span><br><span class=\"line\">//查看进程：ps|grep 包名</span><br><span class=\"line\">ps|grep cn.imtianx.ipcdemo</span><br><span class=\"line\">//三个进程如下</span><br><span class=\"line\">USER      PID   PPID  VSIZE  RSS   WCHAN            PC  NAME</span><br><span class=\"line\">u0_a106   3682  1680  1136428 57512 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo</span><br><span class=\"line\">u0_a106   3808  1680  1134324 57360 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo:remote</span><br><span class=\"line\">u0_a106   3918  1680  1166916 57920 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo.remote</span><br></pre></td></tr></table></figure></p>\n<p>或者在monitor界面也可以查看。MainActivity没有指定process属性，则他在应用的包名 <code>cn.imtianx.ipcdemo</code> 对应的进程中,其他两个分别 SecondActivity、ThirdActivity 所在的进程。对于SecondActivity ，他的进程是 以 <strong>：</strong> 申明的，是指在当前的进程名前加上包名，为 <strong>私有进程</strong>，其他应用不可与其在同一进程中；而不以 “ ：”开头的进程，属于 <strong>全局进程</strong> ，则可以。</p>\n<blockquote>\n<p>对于每个进程，都有一个独立的虚拟机，在内存中都有着不同的地址，这会导致不同虚拟机访问同一对象会产生多个副本，互不影响，若在一个进程中修改了数据，在另一个进程中不会变。即多进程下不能通过内存共享数据。</p>\n</blockquote>\n<p>一般多进程会造成如下几个问题：</p>\n<ul>\n<li>静态成员和单利失效</li>\n<li>多线程同步进制失效</li>\n<li>SharedPreference 的可靠性下降<br>底层是通过读写XML实现的，并发读写是会出问题的</li>\n<li>Application 会被多次重建<br>运行在同一进程中的组件属于同一个虚拟机和同一个Application的</li>\n</ul>\n<h2 id=\"三、IPC-基础概念\"><a href=\"#三、IPC-基础概念\" class=\"headerlink\" title=\"三、IPC 基础概念\"></a>三、IPC 基础概念</h2><p>只有明白了 IPC 中的 <strong>Serializable接口、 Parcelable接口 和 Binder</strong>相关的基础概念  ，才能更好的理解跨进程通信。  Serializable接口和 Parcelable接口 是实现序列化的两种方式。对于Intent 和 Binder 传输数据、对象持久化到本地或者网络传输，都需要使用。</p>\n<h3 id=\"3-1-Serializable接口\"><a href=\"#3-1-Serializable接口\" class=\"headerlink\" title=\"3.1 Serializable接口\"></a>3.1 Serializable接口</h3><p>Serializable接口 是java 中的，是一个空的接口，使用时直接实现，添加如下标识，即可自动实现序列化和反序列化操作。在使用过程中开销较大，需要大量操作io。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final long serialVersionUID = 1L;</span><br></pre></td></tr></table></figure>\n<p>对于 <code>transient</code> 标识的属性和静态成员变量 ， 不参与序列化。</p>\n<h3 id=\"3-2-Parcelable接口\"><a href=\"#3-2-Parcelable接口\" class=\"headerlink\" title=\"3.2 Parcelable接口\"></a>3.2 Parcelable接口</h3><p>Parcelable接口 是android 特有的序列化方式，使用起来稍微麻烦，但是效率较高，主要用于内存序列化。如下使用示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class User implements Parcelable&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String sex;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected User(Parcel in) &#123;</span><br><span class=\"line\">        id = in.readString();</span><br><span class=\"line\">        name = in.readString();</span><br><span class=\"line\">        sex = in.readString();</span><br><span class=\"line\">        age = in.readInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //用于反序列化</span><br><span class=\"line\">    public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 从序列化对象中创建原始对象</span><br><span class=\"line\">         * @param in</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public User createFromParcel(Parcel in) &#123;</span><br><span class=\"line\">            return new User(in);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 创建指定长度的原始对象数组</span><br><span class=\"line\">         * @param size</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public User[] newArray(int size) &#123;</span><br><span class=\"line\">            return new User[size];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 内容功能描述</span><br><span class=\"line\">     * 大多数返回0，仅当当前对象中存在文件描述符时返回1</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int describeContents() &#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 当前对象写入序列化结构</span><br><span class=\"line\">     * @param dest</span><br><span class=\"line\">     * @param flags</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class=\"line\">        dest.writeString(id);</span><br><span class=\"line\">        dest.writeString(name);</span><br><span class=\"line\">        dest.writeString(sex);</span><br><span class=\"line\">        dest.writeInt(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里虽然看着很复杂，但这些方法全部可以自动生成，不用手动编写。android 中的 Intent 、Bundle、Bitmap等都实现了Parcelable接口，都是可以进行序列化的。</p>\n<h3 id=\"3-3-Binder\"><a href=\"#3-3-Binder\" class=\"headerlink\" title=\"3.3 Binder\"></a>3.3 Binder</h3><p>Binder 实现了 IBinder接口。从ipc角度，binder是一种跨进程通信方式，还可以理解为一种虚拟的物理设备，其驱动是 /dev/binder ;从 android Framework 角度说，Binder 是 ServiceManager 连接各种 Manager（ActivityManager、WindowManger，…）和相应 ManagerServices的桥梁；从 android 应用层来说，Binder是客户端与服务器端进行通信的媒介。</p>\n<p>android中 Binder 主要用在Services中，包括 AIDL 和 Messenger , Messenger 底层是 AIDL 实现的。</p>\n<p>如下是Binder的工作流程图：</p>\n<p><img src=\"/img/article_img/2016/Binder 工作机制.png\" alt=\"\"></p>\n<h2 id=\"四、android-中的IPC-方式\"><a href=\"#四、android-中的IPC-方式\" class=\"headerlink\" title=\"四、android 中的IPC 方式\"></a>四、android 中的IPC 方式</h2><p>如下各种 IPC 方式的优缺点对比：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点</th>\n<th style=\"text-align:center\">使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bundle</td>\n<td style=\"text-align:center\">简单易用</td>\n<td style=\"text-align:center\">只能传输Bundle支持的数据类型</td>\n<td style=\"text-align:center\">四大组件间的进程通信</td>\n</tr>\n<tr>\n<td>文件共享</td>\n<td style=\"text-align:center\">简单易用</td>\n<td style=\"text-align:center\">不适合高并发场景，并且无法做到进程间的即时通讯</td>\n<td style=\"text-align:center\">无并发访问情形，交换简单的数据，实时性不高</td>\n</tr>\n<tr>\n<td>AIDL</td>\n<td style=\"text-align:center\">功能强大，支持一对多并发通信，实时通信</td>\n<td style=\"text-align:center\">使用复杂，需要处理好线程同步</td>\n<td style=\"text-align:center\">一对多通信且有RPC需求</td>\n</tr>\n<tr>\n<td>Messenger</td>\n<td style=\"text-align:center\">功能一般，支持一对多串行通信，实时通信</td>\n<td style=\"text-align:center\">不能很好处理高并发情形，不支持RPC，数据通过Message进行传输（只能传输Bundle支持的数据类型）</td>\n<td style=\"text-align:center\">低并发的一对多即时通讯，无RPC需求，或者无需返回结果</td>\n</tr>\n<tr>\n<td>ContentProvider</td>\n<td style=\"text-align:center\">在数据源访问方面功能强大，支持一对多并发数据共享，可以通过Call方法扩展其他操作</td>\n<td style=\"text-align:center\">可以理解为受约束的AIDL，主要提供数据源的CRUD操作</td>\n<td style=\"text-align:center\">一对多的进程数据共享</td>\n</tr>\n<tr>\n<td>Socket</td>\n<td style=\"text-align:center\">功能强大，可以通过网络传输字节流，支持一对多实时通信</td>\n<td style=\"text-align:center\">实现复杂，不支持直接的RPC</td>\n<td style=\"text-align:center\">网络数据交换</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五、AIDL-的简单使用\"><a href=\"#五、AIDL-的简单使用\" class=\"headerlink\" title=\"五、AIDL 的简单使用\"></a>五、AIDL 的简单使用</h2><p>只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。</p>\n<p>使用 AIDL 创建绑定服务的基本步骤如下：</p>\n<ol>\n<li>创建 .aidl 文件<br>在android studio 中 ，可以直接创建 AIDL ，自动创建相关的 aidl 包，这里创建 <code>IAddAidlInterface.aidl</code> 文件，具体内容如下：</li>\n</ol>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// IAddAidlInterface.aidl</span><br><span class=\"line\">package cn.imtianx.ipcdemo;</span><br><span class=\"line\">interface IAddAidlInterface &#123;</span><br><span class=\"line\">//计算两个数的和</span><br><span class=\"line\">int add(int num1 ,int num2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 编译后会自动生成相应的 java 类，这里是在 <code>build/generated/source/aidl/debug/包名/IAddAidlInterface.java</code> ,它包含一个内部类：Stub,继承自 <code>Binder</code>,实现了我们定义的 AIDL 接口，IAddAidlInterface，是用于定义服务的 RPC 接口。</p>\n<ol>\n<li><p>实现接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private IBinder mIBinder = new IAddAidlInterface.Stub()&#123;</span><br><span class=\"line\">     @Override</span><br><span class=\"line\">     public int add(int num1, int num2) throws RemoteException &#123;</span><br><span class=\"line\">      return num1+num2;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>向客户端公开接口<br>自定义服务，便于客户端调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public class IAddService extends Service &#123;</span><br><span class=\"line\">        public IAddService() &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public IBinder onBind(Intent intent) &#123;</span><br><span class=\"line\">            // TODO: Return the communication channel to the service.</span><br><span class=\"line\">            return mIBinder;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        private IBinder mIBinder = new IAddAidlInterface.Stub()&#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public int add(int num1, int num2) throws RemoteException &#123;</span><br><span class=\"line\">                return num1+num2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体的调用(部分代码)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private IAddAidlInterface mIAddAidlInterface;</span><br><span class=\"line\">   private ServiceConnection mConnection = new ServiceConnection() &#123;</span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class=\"line\">           //获取远程服务对象</span><br><span class=\"line\">           mIAddAidlInterface = IAddAidlInterface.Stub.asInterface(service);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class=\"line\">           mIAddAidlInterface = null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   </span><br><span class=\"line\">   //绑定服务</span><br><span class=\"line\">   Intent intent = new Intent(AIDLActivity.this,IAddService.class);</span><br><span class=\"line\">   intent.setAction(IAddService.class.getName());</span><br><span class=\"line\">   bindService(intent,mConnection, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">   </span><br><span class=\"line\">   //调用远程服务方法</span><br><span class=\"line\">   int result  = mIAddAidlInterface.add(num1,num2);</span><br><span class=\"line\">    </span><br><span class=\"line\">   //解绑服务</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">   protected void onDestroy() &#123;</span><br><span class=\"line\">       super.onDestroy();</span><br><span class=\"line\">       unbindService(mConnection);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p> 上述是一个简单的 AIDL 的使用，通过调用远程服务获取 计算结果。</p>\n<p>接下来，分析下as 建立aidl文件编译后自动生成的java 类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.imtianx.ipcdemo;</span><br><span class=\"line\">public interface IAddAidlInterface extends android.os.IInterface</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public static abstract class Stub extends android.os.Binder implements cn.imtianx.ipcdemo.IAddAidlInterface</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //binder 的唯一标示，一般是binder的类名</span><br><span class=\"line\">        private static final java.lang.String DESCRIPTOR = &quot;cn.imtianx.ipcdemo.IAddAidlInterface&quot;;</span><br><span class=\"line\">        /** Construct the stub at attach it to the interface. */</span><br><span class=\"line\">        public Stub()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            this.attachInterface (this, DESCRIPTOR);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 用于将服务器端的binder 转换成客户端所需要的AIDL 的接口类型</span><br><span class=\"line\">         * @param obj</span><br><span class=\"line\">         * @return 如果客户端和服务器端在同一进程，则返回服务端的stub对象，否则返回 Stub.proxy对象</span><br><span class=\"line\">        */</span><br><span class=\"line\">        public static cn.imtianx.ipcdemo.IAddAidlInterface asInterface (android.os.IBinder obj)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( (obj == null) )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            android.os.IInterface iin = obj.queryLocalInterface (DESCRIPTOR);</span><br><span class=\"line\">            if ( ( (iin != null) &amp;&amp; (iin instanceof cn.imtianx.ipcdemo.IAddAidlInterface) ) )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return ( (cn.imtianx.ipcdemo.IAddAidlInterface) iin);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return new cn.imtianx.ipcdemo.IAddAidlInterface.Stub.Proxy (obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 返回当前binder对象</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override public android.os.IBinder asBinder()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return this;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">        * 运行在服务端的Binder线程池中</span><br><span class=\"line\">        * @param code 确定请求的方法</span><br><span class=\"line\">        * @param data 获取目标方法所需参数</span><br><span class=\"line\">        * @param reply 写入返回值</span><br><span class=\"line\">        * @param flags</span><br><span class=\"line\">        * @return 若返回false，则为失败，可以此做权限验证</span><br><span class=\"line\">        * @throws android.os.RemoteException</span><br><span class=\"line\">        */</span><br><span class=\"line\">        @Override public boolean onTransact (int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            switch (code)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            case INTERFACE_TRANSACTION:</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                reply.writeString (DESCRIPTOR);</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            case TRANSACTION_add:</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                data.enforceInterface (DESCRIPTOR);</span><br><span class=\"line\">                int _arg0;</span><br><span class=\"line\">                _arg0 = data.readInt();</span><br><span class=\"line\">                int _arg1;</span><br><span class=\"line\">                _arg1 = data.readInt();</span><br><span class=\"line\">                int _result = this.add (_arg0, _arg1);</span><br><span class=\"line\">                reply.writeNoException();</span><br><span class=\"line\">                reply.writeInt (_result);</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return super.onTransact (code, data, reply, flags);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //代理对象</span><br><span class=\"line\">        private static class Proxy implements cn.imtianx.ipcdemo.IAddAidlInterface</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            private android.os.IBinder mRemote;</span><br><span class=\"line\">            Proxy (android.os.IBinder remote)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mRemote = remote;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            @Override public android.os.IBinder asBinder()</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return mRemote;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            public java.lang.String getInterfaceDescriptor()</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return DESCRIPTOR;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            @Override public int add (int num1, int num2) throws android.os.RemoteException</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class=\"line\">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class=\"line\">                int _result;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    _data.writeInterfaceToken (DESCRIPTOR);</span><br><span class=\"line\">                    _data.writeInt (num1);</span><br><span class=\"line\">                    _data.writeInt (num2);</span><br><span class=\"line\">                    mRemote.transact (Stub.TRANSACTION_add, _data, _reply, 0);</span><br><span class=\"line\">                    _reply.readException();</span><br><span class=\"line\">                    _result = _reply.readInt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                finally &#123;</span><br><span class=\"line\">                    _reply.recycle();</span><br><span class=\"line\">                    _data.recycle();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return _result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">        * 方法标示符</span><br><span class=\"line\">        * 格式：TRANSACTION_方法名 = (android.os.IBinder.FIRST_CALL_TRANSACTION + </span><br><span class=\"line\">        *       i);其中i按方法数自增</span><br><span class=\"line\">        */</span><br><span class=\"line\">        static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public int add (int num1, int num2) throws android.os.RemoteException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多AIDL 的资料，可参见<a href=\"https://developer.android.google.cn/guide/components/aidl.html#Defining\" target=\"_blank\" rel=\"external\">官方文档</a>，对于Socket、ContentProvider等方式，之前接触过，这里不做介绍。</p>\n","excerpt":"<blockquote>\n<p>本文为读书笔记： 《Android 开发艺术探索 》——第二章 IPC 机制</p>\n</blockquote>\n<p>android  开发中有时候需要用到多进程，那么了解进程间通信对我们开发就尤为重要。往往多进程分为两种情况： 一是一个应用因某些原因需要多进程（如某些模块需要在单独的进程中，或者是为了加大本应用所能使用的内存空间等）；二是当前应用需要想起他应用获取数据。","more":"</p>\n<h2 id=\"一、IPC简介\"><a href=\"#一、IPC简介\" class=\"headerlink\" title=\"一、IPC简介\"></a>一、IPC简介</h2><p><strong>IPC</strong> 是 <code>Inter-Process Communication</code> 的缩写，含义为进程间通信或者跨进程通信，指两个进程间进行数据交互的过程。<br><strong>进程</strong>:是cpu调度的最小单位，是一种有限的系统资源，一般只一个执行单元。在PC或者移动设备上指一个程序或者一个应用。而一个进程可以包含多个进程。</p>\n<p>IPC 不是android 中所独有的，任何操作系统都有。Windows上可以通过剪切板、管道和邮槽等来进行进程间通信；Linux 上可以通过命名管道、共享内存、信号量等进行通信;而android 他是一种基于linux 内核的移动操作系统，他的进程间通信方式并不完全继承自linux, 却有着自己独特的方式——<code>Binder</code>，此外，还可以使用Socket进行进程间通信。</p>\n<h2 id=\"二、android-中的多进程模式\"><a href=\"#二、android-中的多进程模式\" class=\"headerlink\" title=\"二、android 中的多进程模式\"></a>二、android 中的多进程模式</h2><p>在android 中如果使用多进程，通过给四大组件指定 <code>android:process</code> 属性即可开启多进程，此外还可以通过 JNI 在native 层 fork 一个新的进程。<br>如下activity 配置示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;activity android:name=&quot;.activity.MainActivity&quot;&gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\"> &lt;/activity&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;activity</span><br><span class=\"line\">    android:name=&quot;.activity.SecondActivity&quot;</span><br><span class=\"line\">    android:configChanges=&quot;screenLayout&quot;</span><br><span class=\"line\">    android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">    android:process=&quot;:remote&quot;/&gt;</span><br><span class=\"line\">&lt;activity android:name=&quot;.activity.ThirdActivity&quot;</span><br><span class=\"line\">    android:configChanges=&quot;screenLayout&quot;</span><br><span class=\"line\">    android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">    android:process=&quot;com.imtianx.ipcdemo.remote&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>通过 MainActivity 启动 SecondActivity ，SecondActivity 启动 ThirdActivity。<br>这三个activity 分别运行在三个不同的进程中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在as中打开terminal 输入下面命令</span><br><span class=\"line\">adb shell</span><br><span class=\"line\">//查看进程：ps|grep 包名</span><br><span class=\"line\">ps|grep cn.imtianx.ipcdemo</span><br><span class=\"line\">//三个进程如下</span><br><span class=\"line\">USER      PID   PPID  VSIZE  RSS   WCHAN            PC  NAME</span><br><span class=\"line\">u0_a106   3682  1680  1136428 57512 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo</span><br><span class=\"line\">u0_a106   3808  1680  1134324 57360 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo:remote</span><br><span class=\"line\">u0_a106   3918  1680  1166916 57920 SyS_epoll_ 00000000 S cn.imtianx.ipcdemo.remote</span><br></pre></td></tr></table></figure></p>\n<p>或者在monitor界面也可以查看。MainActivity没有指定process属性，则他在应用的包名 <code>cn.imtianx.ipcdemo</code> 对应的进程中,其他两个分别 SecondActivity、ThirdActivity 所在的进程。对于SecondActivity ，他的进程是 以 <strong>：</strong> 申明的，是指在当前的进程名前加上包名，为 <strong>私有进程</strong>，其他应用不可与其在同一进程中；而不以 “ ：”开头的进程，属于 <strong>全局进程</strong> ，则可以。</p>\n<blockquote>\n<p>对于每个进程，都有一个独立的虚拟机，在内存中都有着不同的地址，这会导致不同虚拟机访问同一对象会产生多个副本，互不影响，若在一个进程中修改了数据，在另一个进程中不会变。即多进程下不能通过内存共享数据。</p>\n</blockquote>\n<p>一般多进程会造成如下几个问题：</p>\n<ul>\n<li>静态成员和单利失效</li>\n<li>多线程同步进制失效</li>\n<li>SharedPreference 的可靠性下降<br>底层是通过读写XML实现的，并发读写是会出问题的</li>\n<li>Application 会被多次重建<br>运行在同一进程中的组件属于同一个虚拟机和同一个Application的</li>\n</ul>\n<h2 id=\"三、IPC-基础概念\"><a href=\"#三、IPC-基础概念\" class=\"headerlink\" title=\"三、IPC 基础概念\"></a>三、IPC 基础概念</h2><p>只有明白了 IPC 中的 <strong>Serializable接口、 Parcelable接口 和 Binder</strong>相关的基础概念  ，才能更好的理解跨进程通信。  Serializable接口和 Parcelable接口 是实现序列化的两种方式。对于Intent 和 Binder 传输数据、对象持久化到本地或者网络传输，都需要使用。</p>\n<h3 id=\"3-1-Serializable接口\"><a href=\"#3-1-Serializable接口\" class=\"headerlink\" title=\"3.1 Serializable接口\"></a>3.1 Serializable接口</h3><p>Serializable接口 是java 中的，是一个空的接口，使用时直接实现，添加如下标识，即可自动实现序列化和反序列化操作。在使用过程中开销较大，需要大量操作io。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final long serialVersionUID = 1L;</span><br></pre></td></tr></table></figure>\n<p>对于 <code>transient</code> 标识的属性和静态成员变量 ， 不参与序列化。</p>\n<h3 id=\"3-2-Parcelable接口\"><a href=\"#3-2-Parcelable接口\" class=\"headerlink\" title=\"3.2 Parcelable接口\"></a>3.2 Parcelable接口</h3><p>Parcelable接口 是android 特有的序列化方式，使用起来稍微麻烦，但是效率较高，主要用于内存序列化。如下使用示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class User implements Parcelable&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String sex;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected User(Parcel in) &#123;</span><br><span class=\"line\">        id = in.readString();</span><br><span class=\"line\">        name = in.readString();</span><br><span class=\"line\">        sex = in.readString();</span><br><span class=\"line\">        age = in.readInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //用于反序列化</span><br><span class=\"line\">    public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 从序列化对象中创建原始对象</span><br><span class=\"line\">         * @param in</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public User createFromParcel(Parcel in) &#123;</span><br><span class=\"line\">            return new User(in);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 创建指定长度的原始对象数组</span><br><span class=\"line\">         * @param size</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public User[] newArray(int size) &#123;</span><br><span class=\"line\">            return new User[size];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 内容功能描述</span><br><span class=\"line\">     * 大多数返回0，仅当当前对象中存在文件描述符时返回1</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int describeContents() &#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 当前对象写入序列化结构</span><br><span class=\"line\">     * @param dest</span><br><span class=\"line\">     * @param flags</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class=\"line\">        dest.writeString(id);</span><br><span class=\"line\">        dest.writeString(name);</span><br><span class=\"line\">        dest.writeString(sex);</span><br><span class=\"line\">        dest.writeInt(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里虽然看着很复杂，但这些方法全部可以自动生成，不用手动编写。android 中的 Intent 、Bundle、Bitmap等都实现了Parcelable接口，都是可以进行序列化的。</p>\n<h3 id=\"3-3-Binder\"><a href=\"#3-3-Binder\" class=\"headerlink\" title=\"3.3 Binder\"></a>3.3 Binder</h3><p>Binder 实现了 IBinder接口。从ipc角度，binder是一种跨进程通信方式，还可以理解为一种虚拟的物理设备，其驱动是 /dev/binder ;从 android Framework 角度说，Binder 是 ServiceManager 连接各种 Manager（ActivityManager、WindowManger，…）和相应 ManagerServices的桥梁；从 android 应用层来说，Binder是客户端与服务器端进行通信的媒介。</p>\n<p>android中 Binder 主要用在Services中，包括 AIDL 和 Messenger , Messenger 底层是 AIDL 实现的。</p>\n<p>如下是Binder的工作流程图：</p>\n<p><img src=\"/img/article_img/2016/Binder 工作机制.png\" alt=\"\"></p>\n<h2 id=\"四、android-中的IPC-方式\"><a href=\"#四、android-中的IPC-方式\" class=\"headerlink\" title=\"四、android 中的IPC 方式\"></a>四、android 中的IPC 方式</h2><p>如下各种 IPC 方式的优缺点对比：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点</th>\n<th style=\"text-align:center\">使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bundle</td>\n<td style=\"text-align:center\">简单易用</td>\n<td style=\"text-align:center\">只能传输Bundle支持的数据类型</td>\n<td style=\"text-align:center\">四大组件间的进程通信</td>\n</tr>\n<tr>\n<td>文件共享</td>\n<td style=\"text-align:center\">简单易用</td>\n<td style=\"text-align:center\">不适合高并发场景，并且无法做到进程间的即时通讯</td>\n<td style=\"text-align:center\">无并发访问情形，交换简单的数据，实时性不高</td>\n</tr>\n<tr>\n<td>AIDL</td>\n<td style=\"text-align:center\">功能强大，支持一对多并发通信，实时通信</td>\n<td style=\"text-align:center\">使用复杂，需要处理好线程同步</td>\n<td style=\"text-align:center\">一对多通信且有RPC需求</td>\n</tr>\n<tr>\n<td>Messenger</td>\n<td style=\"text-align:center\">功能一般，支持一对多串行通信，实时通信</td>\n<td style=\"text-align:center\">不能很好处理高并发情形，不支持RPC，数据通过Message进行传输（只能传输Bundle支持的数据类型）</td>\n<td style=\"text-align:center\">低并发的一对多即时通讯，无RPC需求，或者无需返回结果</td>\n</tr>\n<tr>\n<td>ContentProvider</td>\n<td style=\"text-align:center\">在数据源访问方面功能强大，支持一对多并发数据共享，可以通过Call方法扩展其他操作</td>\n<td style=\"text-align:center\">可以理解为受约束的AIDL，主要提供数据源的CRUD操作</td>\n<td style=\"text-align:center\">一对多的进程数据共享</td>\n</tr>\n<tr>\n<td>Socket</td>\n<td style=\"text-align:center\">功能强大，可以通过网络传输字节流，支持一对多实时通信</td>\n<td style=\"text-align:center\">实现复杂，不支持直接的RPC</td>\n<td style=\"text-align:center\">网络数据交换</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五、AIDL-的简单使用\"><a href=\"#五、AIDL-的简单使用\" class=\"headerlink\" title=\"五、AIDL 的简单使用\"></a>五、AIDL 的简单使用</h2><p>只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。</p>\n<p>使用 AIDL 创建绑定服务的基本步骤如下：</p>\n<ol>\n<li>创建 .aidl 文件<br>在android studio 中 ，可以直接创建 AIDL ，自动创建相关的 aidl 包，这里创建 <code>IAddAidlInterface.aidl</code> 文件，具体内容如下：</li>\n</ol>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// IAddAidlInterface.aidl</span><br><span class=\"line\">package cn.imtianx.ipcdemo;</span><br><span class=\"line\">interface IAddAidlInterface &#123;</span><br><span class=\"line\">//计算两个数的和</span><br><span class=\"line\">int add(int num1 ,int num2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 编译后会自动生成相应的 java 类，这里是在 <code>build/generated/source/aidl/debug/包名/IAddAidlInterface.java</code> ,它包含一个内部类：Stub,继承自 <code>Binder</code>,实现了我们定义的 AIDL 接口，IAddAidlInterface，是用于定义服务的 RPC 接口。</p>\n<ol>\n<li><p>实现接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private IBinder mIBinder = new IAddAidlInterface.Stub()&#123;</span><br><span class=\"line\">     @Override</span><br><span class=\"line\">     public int add(int num1, int num2) throws RemoteException &#123;</span><br><span class=\"line\">      return num1+num2;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>向客户端公开接口<br>自定义服务，便于客户端调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public class IAddService extends Service &#123;</span><br><span class=\"line\">        public IAddService() &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public IBinder onBind(Intent intent) &#123;</span><br><span class=\"line\">            // TODO: Return the communication channel to the service.</span><br><span class=\"line\">            return mIBinder;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        private IBinder mIBinder = new IAddAidlInterface.Stub()&#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public int add(int num1, int num2) throws RemoteException &#123;</span><br><span class=\"line\">                return num1+num2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体的调用(部分代码)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private IAddAidlInterface mIAddAidlInterface;</span><br><span class=\"line\">   private ServiceConnection mConnection = new ServiceConnection() &#123;</span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class=\"line\">           //获取远程服务对象</span><br><span class=\"line\">           mIAddAidlInterface = IAddAidlInterface.Stub.asInterface(service);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class=\"line\">           mIAddAidlInterface = null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   </span><br><span class=\"line\">   //绑定服务</span><br><span class=\"line\">   Intent intent = new Intent(AIDLActivity.this,IAddService.class);</span><br><span class=\"line\">   intent.setAction(IAddService.class.getName());</span><br><span class=\"line\">   bindService(intent,mConnection, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">   </span><br><span class=\"line\">   //调用远程服务方法</span><br><span class=\"line\">   int result  = mIAddAidlInterface.add(num1,num2);</span><br><span class=\"line\">    </span><br><span class=\"line\">   //解绑服务</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">   protected void onDestroy() &#123;</span><br><span class=\"line\">       super.onDestroy();</span><br><span class=\"line\">       unbindService(mConnection);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p> 上述是一个简单的 AIDL 的使用，通过调用远程服务获取 计算结果。</p>\n<p>接下来，分析下as 建立aidl文件编译后自动生成的java 类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.imtianx.ipcdemo;</span><br><span class=\"line\">public interface IAddAidlInterface extends android.os.IInterface</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public static abstract class Stub extends android.os.Binder implements cn.imtianx.ipcdemo.IAddAidlInterface</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //binder 的唯一标示，一般是binder的类名</span><br><span class=\"line\">        private static final java.lang.String DESCRIPTOR = &quot;cn.imtianx.ipcdemo.IAddAidlInterface&quot;;</span><br><span class=\"line\">        /** Construct the stub at attach it to the interface. */</span><br><span class=\"line\">        public Stub()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            this.attachInterface (this, DESCRIPTOR);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 用于将服务器端的binder 转换成客户端所需要的AIDL 的接口类型</span><br><span class=\"line\">         * @param obj</span><br><span class=\"line\">         * @return 如果客户端和服务器端在同一进程，则返回服务端的stub对象，否则返回 Stub.proxy对象</span><br><span class=\"line\">        */</span><br><span class=\"line\">        public static cn.imtianx.ipcdemo.IAddAidlInterface asInterface (android.os.IBinder obj)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if ( (obj == null) )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            android.os.IInterface iin = obj.queryLocalInterface (DESCRIPTOR);</span><br><span class=\"line\">            if ( ( (iin != null) &amp;&amp; (iin instanceof cn.imtianx.ipcdemo.IAddAidlInterface) ) )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return ( (cn.imtianx.ipcdemo.IAddAidlInterface) iin);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return new cn.imtianx.ipcdemo.IAddAidlInterface.Stub.Proxy (obj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 返回当前binder对象</span><br><span class=\"line\">         * @return</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override public android.os.IBinder asBinder()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return this;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">        * 运行在服务端的Binder线程池中</span><br><span class=\"line\">        * @param code 确定请求的方法</span><br><span class=\"line\">        * @param data 获取目标方法所需参数</span><br><span class=\"line\">        * @param reply 写入返回值</span><br><span class=\"line\">        * @param flags</span><br><span class=\"line\">        * @return 若返回false，则为失败，可以此做权限验证</span><br><span class=\"line\">        * @throws android.os.RemoteException</span><br><span class=\"line\">        */</span><br><span class=\"line\">        @Override public boolean onTransact (int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            switch (code)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            case INTERFACE_TRANSACTION:</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                reply.writeString (DESCRIPTOR);</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            case TRANSACTION_add:</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                data.enforceInterface (DESCRIPTOR);</span><br><span class=\"line\">                int _arg0;</span><br><span class=\"line\">                _arg0 = data.readInt();</span><br><span class=\"line\">                int _arg1;</span><br><span class=\"line\">                _arg1 = data.readInt();</span><br><span class=\"line\">                int _result = this.add (_arg0, _arg1);</span><br><span class=\"line\">                reply.writeNoException();</span><br><span class=\"line\">                reply.writeInt (_result);</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return super.onTransact (code, data, reply, flags);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //代理对象</span><br><span class=\"line\">        private static class Proxy implements cn.imtianx.ipcdemo.IAddAidlInterface</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            private android.os.IBinder mRemote;</span><br><span class=\"line\">            Proxy (android.os.IBinder remote)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                mRemote = remote;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            @Override public android.os.IBinder asBinder()</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return mRemote;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            public java.lang.String getInterfaceDescriptor()</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return DESCRIPTOR;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            @Override public int add (int num1, int num2) throws android.os.RemoteException</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class=\"line\">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class=\"line\">                int _result;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    _data.writeInterfaceToken (DESCRIPTOR);</span><br><span class=\"line\">                    _data.writeInt (num1);</span><br><span class=\"line\">                    _data.writeInt (num2);</span><br><span class=\"line\">                    mRemote.transact (Stub.TRANSACTION_add, _data, _reply, 0);</span><br><span class=\"line\">                    _reply.readException();</span><br><span class=\"line\">                    _result = _reply.readInt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                finally &#123;</span><br><span class=\"line\">                    _reply.recycle();</span><br><span class=\"line\">                    _data.recycle();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return _result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">        * 方法标示符</span><br><span class=\"line\">        * 格式：TRANSACTION_方法名 = (android.os.IBinder.FIRST_CALL_TRANSACTION + </span><br><span class=\"line\">        *       i);其中i按方法数自增</span><br><span class=\"line\">        */</span><br><span class=\"line\">        static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public int add (int num1, int num2) throws android.os.RemoteException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多AIDL 的资料，可参见<a href=\"https://developer.android.google.cn/guide/components/aidl.html#Defining\">官方文档</a>，对于Socket、ContentProvider等方式，之前接触过，这里不做介绍。</p>"},{"title":"android studio 生成aar和jar","date":"2016-10-20T08:06:25.000Z","_content":"\n\n### 1. aar包\n**aar**包是android studio 下打包android 工程中的src、res、lib后生成的aar文件，以便导入到其他的as工程中使用。\n在as中它的生成方式较为简单，主要步骤如下：\n> 1.新建model，选择 android Library；\n> 2.编写好自己的代码后，将gradle中的 **minifyEnabled**属性 设置成**true**<!--more-->，重新build下项目（**Build->Rebuild Project**,或者使用gradle中的build 命令）\n> 3.将as的项目调节为project,进入model下，在**build/outputs/aar/**文件夹下会生成相应的aar文件，如下图：\n\n![](/img/article_img/2016/show_aar.png)\n\n### 2. jar包\n在as中，不像ec那样可以直接导出jar,需要在gradle 中编写task,主要步骤：\n>1.新建model 选择 Java Library，\n>2.先写自己的代码\n>3.在当前model 的gradle 中添写如下代码，**rebuid后便会在build/libs下生成相应的jar**\n```\n//Copy类型\ntask makeJar(type: Copy) {\n    //删除存在的\n    delete 'build/libs/javajarlib.jar'\n    //设置拷贝的文件\n    from('build/intermediates/bundles/release/')\n    //打进jar包后的文件目录\n    into('build/libs/')\n    //include ,exclude参数来设置过滤\n    include('classes.jar')\n    //重命名\n    rename('classes.jar', 'javajarlib.jar')\n}\nmakeJar.dependsOn(build)\n```\n但是这种方法，生成的jar是和改model 的名字一样的，即使在上面指定了名字。\n\n### 3. 具体使用\n在具体的model中使用时，将生成的相应的包拷贝到libs文件夹中，对于jar可以右键 添加到library中，或者手动在 gradle 中添加。而，对于aar,则只能在gradle中手动添加，如下配置代码：\n\n```\nrepositories{\n    flatDir{\n        dirs 'libs'\n    }\n}\n//在dependencies 中添加，androidlibrary-release值aar包的名字\ncompile(name:'androidlibrary-release', ext:'aar')\n```\n通过上面的配置就可以直接在代码中使用了。\n\n\n\n","source":"_posts/android studio 生成aar和jar.md","raw":"---\ntitle: android studio 生成aar和jar\ndate: 2016-10-20 16:06:25\ncategories: [android,学习笔记]\ntags: [android,aar,jar]\n---\n\n\n### 1. aar包\n**aar**包是android studio 下打包android 工程中的src、res、lib后生成的aar文件，以便导入到其他的as工程中使用。\n在as中它的生成方式较为简单，主要步骤如下：\n> 1.新建model，选择 android Library；\n> 2.编写好自己的代码后，将gradle中的 **minifyEnabled**属性 设置成**true**<!--more-->，重新build下项目（**Build->Rebuild Project**,或者使用gradle中的build 命令）\n> 3.将as的项目调节为project,进入model下，在**build/outputs/aar/**文件夹下会生成相应的aar文件，如下图：\n\n![](/img/article_img/2016/show_aar.png)\n\n### 2. jar包\n在as中，不像ec那样可以直接导出jar,需要在gradle 中编写task,主要步骤：\n>1.新建model 选择 Java Library，\n>2.先写自己的代码\n>3.在当前model 的gradle 中添写如下代码，**rebuid后便会在build/libs下生成相应的jar**\n```\n//Copy类型\ntask makeJar(type: Copy) {\n    //删除存在的\n    delete 'build/libs/javajarlib.jar'\n    //设置拷贝的文件\n    from('build/intermediates/bundles/release/')\n    //打进jar包后的文件目录\n    into('build/libs/')\n    //include ,exclude参数来设置过滤\n    include('classes.jar')\n    //重命名\n    rename('classes.jar', 'javajarlib.jar')\n}\nmakeJar.dependsOn(build)\n```\n但是这种方法，生成的jar是和改model 的名字一样的，即使在上面指定了名字。\n\n### 3. 具体使用\n在具体的model中使用时，将生成的相应的包拷贝到libs文件夹中，对于jar可以右键 添加到library中，或者手动在 gradle 中添加。而，对于aar,则只能在gradle中手动添加，如下配置代码：\n\n```\nrepositories{\n    flatDir{\n        dirs 'libs'\n    }\n}\n//在dependencies 中添加，androidlibrary-release值aar包的名字\ncompile(name:'androidlibrary-release', ext:'aar')\n```\n通过上面的配置就可以直接在代码中使用了。\n\n\n\n","slug":"android studio 生成aar和jar","published":1,"updated":"2016-11-01T14:36:12.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucg5000zg0g5sdoblqaz","content":"<h3 id=\"1-aar包\"><a href=\"#1-aar包\" class=\"headerlink\" title=\"1. aar包\"></a>1. aar包</h3><p><strong>aar</strong>包是android studio 下打包android 工程中的src、res、lib后生成的aar文件，以便导入到其他的as工程中使用。<br>在as中它的生成方式较为简单，主要步骤如下：</p>\n<blockquote>\n<p>1.新建model，选择 android Library；<br>2.编写好自己的代码后，将gradle中的 <strong>minifyEnabled</strong>属性 设置成<strong>true</strong><a id=\"more\"></a>，重新build下项目（<strong>Build-&gt;Rebuild Project</strong>,或者使用gradle中的build 命令）<br>3.将as的项目调节为project,进入model下，在<strong>build/outputs/aar/</strong>文件夹下会生成相应的aar文件，如下图：</p>\n</blockquote>\n<p><img src=\"/img/article_img/2016/show_aar.png\" alt=\"\"></p>\n<h3 id=\"2-jar包\"><a href=\"#2-jar包\" class=\"headerlink\" title=\"2. jar包\"></a>2. jar包</h3><p>在as中，不像ec那样可以直接导出jar,需要在gradle 中编写task,主要步骤：</p>\n<blockquote>\n<p>1.新建model 选择 Java Library，<br>2.先写自己的代码<br>3.在当前model 的gradle 中添写如下代码，<strong>rebuid后便会在build/libs下生成相应的jar</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Copy类型</span><br><span class=\"line\">task makeJar(type: Copy) &#123;</span><br><span class=\"line\">    //删除存在的</span><br><span class=\"line\">    delete &apos;build/libs/javajarlib.jar&apos;</span><br><span class=\"line\">    //设置拷贝的文件</span><br><span class=\"line\">    from(&apos;build/intermediates/bundles/release/&apos;)</span><br><span class=\"line\">    //打进jar包后的文件目录</span><br><span class=\"line\">    into(&apos;build/libs/&apos;)</span><br><span class=\"line\">    //include ,exclude参数来设置过滤</span><br><span class=\"line\">    include(&apos;classes.jar&apos;)</span><br><span class=\"line\">    //重命名</span><br><span class=\"line\">    rename(&apos;classes.jar&apos;, &apos;javajarlib.jar&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">makeJar.dependsOn(build)</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>但是这种方法，生成的jar是和改model 的名字一样的，即使在上面指定了名字。</p>\n<h3 id=\"3-具体使用\"><a href=\"#3-具体使用\" class=\"headerlink\" title=\"3. 具体使用\"></a>3. 具体使用</h3><p>在具体的model中使用时，将生成的相应的包拷贝到libs文件夹中，对于jar可以右键 添加到library中，或者手动在 gradle 中添加。而，对于aar,则只能在gradle中手动添加，如下配置代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories&#123;</span><br><span class=\"line\">    flatDir&#123;</span><br><span class=\"line\">        dirs &apos;libs&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//在dependencies 中添加，androidlibrary-release值aar包的名字</span><br><span class=\"line\">compile(name:&apos;androidlibrary-release&apos;, ext:&apos;aar&apos;)</span><br></pre></td></tr></table></figure>\n<p>通过上面的配置就可以直接在代码中使用了。</p>\n","excerpt":"<h3 id=\"1-aar包\"><a href=\"#1-aar包\" class=\"headerlink\" title=\"1. aar包\"></a>1. aar包</h3><p><strong>aar</strong>包是android studio 下打包android 工程中的src、res、lib后生成的aar文件，以便导入到其他的as工程中使用。<br>在as中它的生成方式较为简单，主要步骤如下：</p>\n<blockquote>\n<p>1.新建model，选择 android Library；<br>2.编写好自己的代码后，将gradle中的 <strong>minifyEnabled</strong>属性 设置成<strong>true</strong>","more":"，重新build下项目（<strong>Build-&gt;Rebuild Project</strong>,或者使用gradle中的build 命令）<br>3.将as的项目调节为project,进入model下，在<strong>build/outputs/aar/</strong>文件夹下会生成相应的aar文件，如下图：</p>\n</blockquote>\n<p><img src=\"/img/article_img/2016/show_aar.png\" alt=\"\"></p>\n<h3 id=\"2-jar包\"><a href=\"#2-jar包\" class=\"headerlink\" title=\"2. jar包\"></a>2. jar包</h3><p>在as中，不像ec那样可以直接导出jar,需要在gradle 中编写task,主要步骤：</p>\n<blockquote>\n<p>1.新建model 选择 Java Library，<br>2.先写自己的代码<br>3.在当前model 的gradle 中添写如下代码，<strong>rebuid后便会在build/libs下生成相应的jar</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Copy类型</span><br><span class=\"line\">task makeJar(type: Copy) &#123;</span><br><span class=\"line\">    //删除存在的</span><br><span class=\"line\">    delete &apos;build/libs/javajarlib.jar&apos;</span><br><span class=\"line\">    //设置拷贝的文件</span><br><span class=\"line\">    from(&apos;build/intermediates/bundles/release/&apos;)</span><br><span class=\"line\">    //打进jar包后的文件目录</span><br><span class=\"line\">    into(&apos;build/libs/&apos;)</span><br><span class=\"line\">    //include ,exclude参数来设置过滤</span><br><span class=\"line\">    include(&apos;classes.jar&apos;)</span><br><span class=\"line\">    //重命名</span><br><span class=\"line\">    rename(&apos;classes.jar&apos;, &apos;javajarlib.jar&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">makeJar.dependsOn(build)</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>但是这种方法，生成的jar是和改model 的名字一样的，即使在上面指定了名字。</p>\n<h3 id=\"3-具体使用\"><a href=\"#3-具体使用\" class=\"headerlink\" title=\"3. 具体使用\"></a>3. 具体使用</h3><p>在具体的model中使用时，将生成的相应的包拷贝到libs文件夹中，对于jar可以右键 添加到library中，或者手动在 gradle 中添加。而，对于aar,则只能在gradle中手动添加，如下配置代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories&#123;</span><br><span class=\"line\">    flatDir&#123;</span><br><span class=\"line\">        dirs &apos;libs&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//在dependencies 中添加，androidlibrary-release值aar包的名字</span><br><span class=\"line\">compile(name:&apos;androidlibrary-release&apos;, ext:&apos;aar&apos;)</span><br></pre></td></tr></table></figure>\n<p>通过上面的配置就可以直接在代码中使用了。</p>"},{"title":"android 消息机制及其原理","date":"2016-12-27T08:06:25.000Z","_content":"\n\n\n> 读书笔记： 《Android 开发艺术探索》 ——第十章：android 消息机制\n\n对于 android 中的消息机制，主要是指 **Handler** 的运行机制。在我们平时的开发中 ，对它并不陌生。由于android 是 单线程（UI线程）机制，对于一些耗时操作会在子线程中进行，如文件读取等.\n<!--more-->\n往往在操作完成后会有 UI 的更新，由于 android 中不允许在子线程中更新ui,所以我们 常常用 Handler 来更新UI ，但它的功能不仅仅如此。\n\n## 一、消息机制概述\n\n`Handler` 的运行 需要底层的 **MessageQueue** 和 **Looper** 支撑。`MessageQueue` 是指消息队列，在他内部存储了一组消息，以队列的形式对外提供增删。虽名为队列，但是其内部的实现是采用 单链表。`Looper` 主要是用于消息循环，他内部通过无线循环的方式，查看是否有消息，如果有就处理，否则阻塞等待着。 在 Looper 中 利用 `ThreadLocal` 进行存储数据，它可以保证各个线程中互不干扰的存储和提供数据。\n如果 使用 Handler 就必须为线程创建 Looper。我们能够在 Activity 只用它，主要是应为在 UI 线程( ActivityThread ) 创建是会初始化 looper。\n\nandroid 系统不允许 在子线程中访问UI ，主要是 很多控件时线程不安全的，如果多线程并发访问会出现不可预期的效果；同时由于 锁机制会让 UI 访问逻辑变复杂，并且会阻塞某些线程从而降低 UI 访问效率，并没有对 UI 线程进行加锁 操作。\n\n如下是 Handler 的 工作过程：\n\n![](/img/article_img/2016/Handler 消息机制.png)\n\n> 说明：首先 Handle 通过 `sendMessage()` 等方法发送一个消息，最终会调用 MessageQueue 的 **enqueueMessage** 方法 将消息添加到消息队列中；而 Looper 的 loop方法发现新消息后，从队列中取出消息，最后将其转发到 Handle 中，最终在 handleMessage 进行处理。而Looper 是运行在创建handler 的线程中，这样将Handler 中的业务逻辑切换到 穿件 Handler 的线程中去了。\n\n\n## 二、消息机制分析\n\n### 2.1 ThreadLocal 的工作原理\n\nThreadLocal 主要是线程内部的数据存储类，他可以在指定的线程中存储数据，然后只有指定的线程可以获取。，而其他线程则无法获取。这里使用它 可以方便的实现 Looper 在线程中的存取，此外，他还可以在复杂的逻辑下进行对象的传递，如监听器的传递。\n\n由于 api23 前后，ThreadLocal 的内部实现不同，这里不具体介绍。\n\n\n### 2.2  MessageQueue 的工作原理\n\n在消息队列 MessageQueue 中主要包括两个操作：插入和读取，在读取的同时伴随有删除。 插入和读取分别对应于 `enqueueMessage` 和 `next`。 enqueueMessage 是往队列中插入 一条数据，采用非的是单链表的插入操作，其内部采用了锁机制，而 next 是一个无限循环方法，若无消息，那么它将阻塞者，若有消息，则返回该消息并将其从消息队列中移除。\n\n### 2.3 Looper 的工作原理\n\nLooper 是消息循环的角色，不停的从 MessageQueue 中取消息，若存在则立即处理，否则阻塞。在 Looper 的构造方法中会创建一个MessageQueue对象。\nHandle  的工作需要 looper ，如果没有回报错，可以用 `prepare` 方法创建Looper：\n```\n// 创建looper\nLooper.prepare();\n//....\n//开启循环\nLooper.loop();\n```\n才外，还提供了 `prepareMainLooper` 方法为主线程创建Looper。对于退出循环，则提供了 `quit` 和 `quitSafely` 方法，前者是直接退出，后者则是设置个退出标记，等消息处理完后再退出。\n通常在子线程中创建的looper ,在执行完后应该退出，当执行退出后，次线程会立即终止，若handler 再次发送消息，则会返回 false。\n由于在 Looper 的 loop 方法中调用用了 MessageQueue 的 next方法，而next 方法是个阻塞的，导致loop阻塞。如下loop方法：\n\n```\npublic static void loop()\n{\n    final Looper me = myLooper();\n    if (me == null)\n    {\n        throw new RuntimeException (\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    final MessageQueue queue = me.mQueue;\n\n    // Make sure the identity of this thread is that of the local process,\n    // and keep track of what that identity token actually is.\n    Binder.clearCallingIdentity();\n    final long ident = Binder.clearCallingIdentity();\n\n    for (;;)\n    {\n        Message msg = queue.next(); // might block\n        if (msg == null)\n        {\n            // No message indicates that the message queue is quitting.\n            return;\n        }\n\n        // This must be in a local variable, in case a UI event sets the logger\n        final Printer logging = me.mLogging;\n        //...\n\n        final long traceTag = me.mTraceTag;\n        if (traceTag != 0 && Trace.isTagEnabled (traceTag) )\n        {\n            Trace.traceBegin (traceTag, msg.target.getTraceName (msg) );\n        }\n        try\n        {\n            msg.target.dispatchMessage (msg);\n        } finally\n        {\n            if (traceTag != 0)\n            {\n                Trace.traceEnd (traceTag);\n            }\n        }\n\n        //...\n        // Make sure that during the course of dispatching the\n        // identity of the thread wasn't corrupted.\n        final long newIdent = Binder.clearCallingIdentity();\n        //...\n\n        msg.recycleUnchecked();\n    }\n}\n```\n\n> 注意 `msg.target.dispatchMessage (msg);`一句，msg是一个从MessageQueue 中取出的Message对象，而 target 则是  Message 中的一个 Handler 类型的 成员变量，这样使得 loop方法将消息队列中的消息分发给 Handler 进行处理。\n\n### 2.4 Handler 的工作原理\n\nhandler 主要包括消息的发送和接受，主要包括一系列的post和send方法实现的,而post最终是通过 send实现的。如下各个方法：\n\n```\n public final boolean sendMessage(Message msg)\n{\n    return sendMessageDelayed(msg, 0);\n}\n public final boolean sendEmptyMessage(int what)\n{\n    return sendEmptyMessageDelayed(what, 0);\n}\n public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {\n    Message msg = Message.obtain();\n    msg.what = what;\n    return sendMessageDelayed(msg, delayMillis);\n}\n public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) {\n    Message msg = Message.obtain();\n    msg.what = what;\n    return sendMessageAtTime(msg, uptimeMillis);\n}\n public final boolean sendMessageDelayed(Message msg, long delayMillis)\n{\n    if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n      private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n        msg.target = this;\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n通过上面的各个方法，最终是往调用了 **enqueueMessage 方法 往 MessageQueue 中插入一条消息**。在Looper 中 调用了 MessageQueue 的next 方法，取出一条消息，通过 dispatchMessage 方法将消息分发给 Handler 处理,如下其具体实现：\n\n```\npublic void dispatchMessage(Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n```\n这里首先检查 callback 是否为null,不为空就调用 handleCallback 处理，它是一个 Runnable对象；其次检查 mCallback　是否为null ，mCallback　是一个Callback类型的接口，内部只有一个方法：\n```\npublic interface Callback {\n    public boolean handleMessage(Message msg);\n}\n```\n这里的 Callback 可以用来创建 Handle 对象，常见的创建 Handler 是重写 handleMessage 方法。\n如下 Handler 的消息处理流程：\n![](/img/article_img/2016/Handler消息处理流程.png)\n\n\n## 三、主线程消息循环\n\n主线程即ActivityThread ，其注入口方法为 main,在该方法中，通过 `Looper.prepareMainLooper();`  创建Looper，最后通过 `Looper.loop();`开启消息循环。\n\n\n```\npublic static void main (String[] args)\n{\n\n    //...\n   // 创建主线程的Looper\n    Looper.prepareMainLooper();\n\n    ActivityThread thread = new ActivityThread();\n    thread.attach (false);\n\n    if (sMainThreadHandler == null)\n    {\n        sMainThreadHandler = thread.getHandler();\n    }\n\n    if (false)\n    {\n        Looper.myLooper().setMessageLogging (new\n                                             LogPrinter (Log.DEBUG, \"ActivityThread\") );\n    }\n\n    // End of event ActivityThreadMain.\n    Trace.traceEnd (Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    //开启循环\n    Looper.loop();\n\n    throw new RuntimeException (\"Main thread loop unexpectedly exited\");\n}\n```\nActivityThread 的内部类 H 继承自 Handler ，其内部定义了一组消息类型，组要包括了四大组件的启动和停止。\n\n**主线程消息循环模型**：ActivityThread 内部通过 ApplicationThread 和 AMS 进行进程间通信，AMS 以进程间通信的方式完成 ActivityThread 的请求后回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 向 H 发送消息， H收到后将 ApplicationThread 中的逻辑切换到 ActivityThread 中去执行。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/android 消息机制及其原理.md","raw":"\n---\ntitle: android 消息机制及其原理\ndate: 2016-12-27 16:06:25\ncategories: [android,学习笔记]\ntags: [消息机制,Handler]\n---\n\n\n\n> 读书笔记： 《Android 开发艺术探索》 ——第十章：android 消息机制\n\n对于 android 中的消息机制，主要是指 **Handler** 的运行机制。在我们平时的开发中 ，对它并不陌生。由于android 是 单线程（UI线程）机制，对于一些耗时操作会在子线程中进行，如文件读取等.\n<!--more-->\n往往在操作完成后会有 UI 的更新，由于 android 中不允许在子线程中更新ui,所以我们 常常用 Handler 来更新UI ，但它的功能不仅仅如此。\n\n## 一、消息机制概述\n\n`Handler` 的运行 需要底层的 **MessageQueue** 和 **Looper** 支撑。`MessageQueue` 是指消息队列，在他内部存储了一组消息，以队列的形式对外提供增删。虽名为队列，但是其内部的实现是采用 单链表。`Looper` 主要是用于消息循环，他内部通过无线循环的方式，查看是否有消息，如果有就处理，否则阻塞等待着。 在 Looper 中 利用 `ThreadLocal` 进行存储数据，它可以保证各个线程中互不干扰的存储和提供数据。\n如果 使用 Handler 就必须为线程创建 Looper。我们能够在 Activity 只用它，主要是应为在 UI 线程( ActivityThread ) 创建是会初始化 looper。\n\nandroid 系统不允许 在子线程中访问UI ，主要是 很多控件时线程不安全的，如果多线程并发访问会出现不可预期的效果；同时由于 锁机制会让 UI 访问逻辑变复杂，并且会阻塞某些线程从而降低 UI 访问效率，并没有对 UI 线程进行加锁 操作。\n\n如下是 Handler 的 工作过程：\n\n![](/img/article_img/2016/Handler 消息机制.png)\n\n> 说明：首先 Handle 通过 `sendMessage()` 等方法发送一个消息，最终会调用 MessageQueue 的 **enqueueMessage** 方法 将消息添加到消息队列中；而 Looper 的 loop方法发现新消息后，从队列中取出消息，最后将其转发到 Handle 中，最终在 handleMessage 进行处理。而Looper 是运行在创建handler 的线程中，这样将Handler 中的业务逻辑切换到 穿件 Handler 的线程中去了。\n\n\n## 二、消息机制分析\n\n### 2.1 ThreadLocal 的工作原理\n\nThreadLocal 主要是线程内部的数据存储类，他可以在指定的线程中存储数据，然后只有指定的线程可以获取。，而其他线程则无法获取。这里使用它 可以方便的实现 Looper 在线程中的存取，此外，他还可以在复杂的逻辑下进行对象的传递，如监听器的传递。\n\n由于 api23 前后，ThreadLocal 的内部实现不同，这里不具体介绍。\n\n\n### 2.2  MessageQueue 的工作原理\n\n在消息队列 MessageQueue 中主要包括两个操作：插入和读取，在读取的同时伴随有删除。 插入和读取分别对应于 `enqueueMessage` 和 `next`。 enqueueMessage 是往队列中插入 一条数据，采用非的是单链表的插入操作，其内部采用了锁机制，而 next 是一个无限循环方法，若无消息，那么它将阻塞者，若有消息，则返回该消息并将其从消息队列中移除。\n\n### 2.3 Looper 的工作原理\n\nLooper 是消息循环的角色，不停的从 MessageQueue 中取消息，若存在则立即处理，否则阻塞。在 Looper 的构造方法中会创建一个MessageQueue对象。\nHandle  的工作需要 looper ，如果没有回报错，可以用 `prepare` 方法创建Looper：\n```\n// 创建looper\nLooper.prepare();\n//....\n//开启循环\nLooper.loop();\n```\n才外，还提供了 `prepareMainLooper` 方法为主线程创建Looper。对于退出循环，则提供了 `quit` 和 `quitSafely` 方法，前者是直接退出，后者则是设置个退出标记，等消息处理完后再退出。\n通常在子线程中创建的looper ,在执行完后应该退出，当执行退出后，次线程会立即终止，若handler 再次发送消息，则会返回 false。\n由于在 Looper 的 loop 方法中调用用了 MessageQueue 的 next方法，而next 方法是个阻塞的，导致loop阻塞。如下loop方法：\n\n```\npublic static void loop()\n{\n    final Looper me = myLooper();\n    if (me == null)\n    {\n        throw new RuntimeException (\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    final MessageQueue queue = me.mQueue;\n\n    // Make sure the identity of this thread is that of the local process,\n    // and keep track of what that identity token actually is.\n    Binder.clearCallingIdentity();\n    final long ident = Binder.clearCallingIdentity();\n\n    for (;;)\n    {\n        Message msg = queue.next(); // might block\n        if (msg == null)\n        {\n            // No message indicates that the message queue is quitting.\n            return;\n        }\n\n        // This must be in a local variable, in case a UI event sets the logger\n        final Printer logging = me.mLogging;\n        //...\n\n        final long traceTag = me.mTraceTag;\n        if (traceTag != 0 && Trace.isTagEnabled (traceTag) )\n        {\n            Trace.traceBegin (traceTag, msg.target.getTraceName (msg) );\n        }\n        try\n        {\n            msg.target.dispatchMessage (msg);\n        } finally\n        {\n            if (traceTag != 0)\n            {\n                Trace.traceEnd (traceTag);\n            }\n        }\n\n        //...\n        // Make sure that during the course of dispatching the\n        // identity of the thread wasn't corrupted.\n        final long newIdent = Binder.clearCallingIdentity();\n        //...\n\n        msg.recycleUnchecked();\n    }\n}\n```\n\n> 注意 `msg.target.dispatchMessage (msg);`一句，msg是一个从MessageQueue 中取出的Message对象，而 target 则是  Message 中的一个 Handler 类型的 成员变量，这样使得 loop方法将消息队列中的消息分发给 Handler 进行处理。\n\n### 2.4 Handler 的工作原理\n\nhandler 主要包括消息的发送和接受，主要包括一系列的post和send方法实现的,而post最终是通过 send实现的。如下各个方法：\n\n```\n public final boolean sendMessage(Message msg)\n{\n    return sendMessageDelayed(msg, 0);\n}\n public final boolean sendEmptyMessage(int what)\n{\n    return sendEmptyMessageDelayed(what, 0);\n}\n public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {\n    Message msg = Message.obtain();\n    msg.what = what;\n    return sendMessageDelayed(msg, delayMillis);\n}\n public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) {\n    Message msg = Message.obtain();\n    msg.what = what;\n    return sendMessageAtTime(msg, uptimeMillis);\n}\n public final boolean sendMessageDelayed(Message msg, long delayMillis)\n{\n    if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n      private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n        msg.target = this;\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n通过上面的各个方法，最终是往调用了 **enqueueMessage 方法 往 MessageQueue 中插入一条消息**。在Looper 中 调用了 MessageQueue 的next 方法，取出一条消息，通过 dispatchMessage 方法将消息分发给 Handler 处理,如下其具体实现：\n\n```\npublic void dispatchMessage(Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n```\n这里首先检查 callback 是否为null,不为空就调用 handleCallback 处理，它是一个 Runnable对象；其次检查 mCallback　是否为null ，mCallback　是一个Callback类型的接口，内部只有一个方法：\n```\npublic interface Callback {\n    public boolean handleMessage(Message msg);\n}\n```\n这里的 Callback 可以用来创建 Handle 对象，常见的创建 Handler 是重写 handleMessage 方法。\n如下 Handler 的消息处理流程：\n![](/img/article_img/2016/Handler消息处理流程.png)\n\n\n## 三、主线程消息循环\n\n主线程即ActivityThread ，其注入口方法为 main,在该方法中，通过 `Looper.prepareMainLooper();`  创建Looper，最后通过 `Looper.loop();`开启消息循环。\n\n\n```\npublic static void main (String[] args)\n{\n\n    //...\n   // 创建主线程的Looper\n    Looper.prepareMainLooper();\n\n    ActivityThread thread = new ActivityThread();\n    thread.attach (false);\n\n    if (sMainThreadHandler == null)\n    {\n        sMainThreadHandler = thread.getHandler();\n    }\n\n    if (false)\n    {\n        Looper.myLooper().setMessageLogging (new\n                                             LogPrinter (Log.DEBUG, \"ActivityThread\") );\n    }\n\n    // End of event ActivityThreadMain.\n    Trace.traceEnd (Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    //开启循环\n    Looper.loop();\n\n    throw new RuntimeException (\"Main thread loop unexpectedly exited\");\n}\n```\nActivityThread 的内部类 H 继承自 Handler ，其内部定义了一组消息类型，组要包括了四大组件的启动和停止。\n\n**主线程消息循环模型**：ActivityThread 内部通过 ApplicationThread 和 AMS 进行进程间通信，AMS 以进程间通信的方式完成 ActivityThread 的请求后回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 向 H 发送消息， H收到后将 ApplicationThread 中的逻辑切换到 ActivityThread 中去执行。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"android 消息机制及其原理","published":1,"updated":"2017-01-06T12:41:26.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucg50013g0g5fhtlka9i","content":"<blockquote>\n<p>读书笔记： 《Android 开发艺术探索》 ——第十章：android 消息机制</p>\n</blockquote>\n<p>对于 android 中的消息机制，主要是指 <strong>Handler</strong> 的运行机制。在我们平时的开发中 ，对它并不陌生。由于android 是 单线程（UI线程）机制，对于一些耗时操作会在子线程中进行，如文件读取等.<br><a id=\"more\"></a><br>往往在操作完成后会有 UI 的更新，由于 android 中不允许在子线程中更新ui,所以我们 常常用 Handler 来更新UI ，但它的功能不仅仅如此。</p>\n<h2 id=\"一、消息机制概述\"><a href=\"#一、消息机制概述\" class=\"headerlink\" title=\"一、消息机制概述\"></a>一、消息机制概述</h2><p><code>Handler</code> 的运行 需要底层的 <strong>MessageQueue</strong> 和 <strong>Looper</strong> 支撑。<code>MessageQueue</code> 是指消息队列，在他内部存储了一组消息，以队列的形式对外提供增删。虽名为队列，但是其内部的实现是采用 单链表。<code>Looper</code> 主要是用于消息循环，他内部通过无线循环的方式，查看是否有消息，如果有就处理，否则阻塞等待着。 在 Looper 中 利用 <code>ThreadLocal</code> 进行存储数据，它可以保证各个线程中互不干扰的存储和提供数据。<br>如果 使用 Handler 就必须为线程创建 Looper。我们能够在 Activity 只用它，主要是应为在 UI 线程( ActivityThread ) 创建是会初始化 looper。</p>\n<p>android 系统不允许 在子线程中访问UI ，主要是 很多控件时线程不安全的，如果多线程并发访问会出现不可预期的效果；同时由于 锁机制会让 UI 访问逻辑变复杂，并且会阻塞某些线程从而降低 UI 访问效率，并没有对 UI 线程进行加锁 操作。</p>\n<p>如下是 Handler 的 工作过程：</p>\n<p><img src=\"/img/article_img/2016/Handler 消息机制.png\" alt=\"\"></p>\n<blockquote>\n<p>说明：首先 Handle 通过 <code>sendMessage()</code> 等方法发送一个消息，最终会调用 MessageQueue 的 <strong>enqueueMessage</strong> 方法 将消息添加到消息队列中；而 Looper 的 loop方法发现新消息后，从队列中取出消息，最后将其转发到 Handle 中，最终在 handleMessage 进行处理。而Looper 是运行在创建handler 的线程中，这样将Handler 中的业务逻辑切换到 穿件 Handler 的线程中去了。</p>\n</blockquote>\n<h2 id=\"二、消息机制分析\"><a href=\"#二、消息机制分析\" class=\"headerlink\" title=\"二、消息机制分析\"></a>二、消息机制分析</h2><h3 id=\"2-1-ThreadLocal-的工作原理\"><a href=\"#2-1-ThreadLocal-的工作原理\" class=\"headerlink\" title=\"2.1 ThreadLocal 的工作原理\"></a>2.1 ThreadLocal 的工作原理</h3><p>ThreadLocal 主要是线程内部的数据存储类，他可以在指定的线程中存储数据，然后只有指定的线程可以获取。，而其他线程则无法获取。这里使用它 可以方便的实现 Looper 在线程中的存取，此外，他还可以在复杂的逻辑下进行对象的传递，如监听器的传递。</p>\n<p>由于 api23 前后，ThreadLocal 的内部实现不同，这里不具体介绍。</p>\n<h3 id=\"2-2-MessageQueue-的工作原理\"><a href=\"#2-2-MessageQueue-的工作原理\" class=\"headerlink\" title=\"2.2  MessageQueue 的工作原理\"></a>2.2  MessageQueue 的工作原理</h3><p>在消息队列 MessageQueue 中主要包括两个操作：插入和读取，在读取的同时伴随有删除。 插入和读取分别对应于 <code>enqueueMessage</code> 和 <code>next</code>。 enqueueMessage 是往队列中插入 一条数据，采用非的是单链表的插入操作，其内部采用了锁机制，而 next 是一个无限循环方法，若无消息，那么它将阻塞者，若有消息，则返回该消息并将其从消息队列中移除。</p>\n<h3 id=\"2-3-Looper-的工作原理\"><a href=\"#2-3-Looper-的工作原理\" class=\"headerlink\" title=\"2.3 Looper 的工作原理\"></a>2.3 Looper 的工作原理</h3><p>Looper 是消息循环的角色，不停的从 MessageQueue 中取消息，若存在则立即处理，否则阻塞。在 Looper 的构造方法中会创建一个MessageQueue对象。<br>Handle  的工作需要 looper ，如果没有回报错，可以用 <code>prepare</code> 方法创建Looper：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建looper</span><br><span class=\"line\">Looper.prepare();</span><br><span class=\"line\">//....</span><br><span class=\"line\">//开启循环</span><br><span class=\"line\">Looper.loop();</span><br></pre></td></tr></table></figure></p>\n<p>才外，还提供了 <code>prepareMainLooper</code> 方法为主线程创建Looper。对于退出循环，则提供了 <code>quit</code> 和 <code>quitSafely</code> 方法，前者是直接退出，后者则是设置个退出标记，等消息处理完后再退出。<br>通常在子线程中创建的looper ,在执行完后应该退出，当执行退出后，次线程会立即终止，若handler 再次发送消息，则会返回 false。<br>由于在 Looper 的 loop 方法中调用用了 MessageQueue 的 next方法，而next 方法是个阻塞的，导致loop阻塞。如下loop方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void loop()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    final Looper me = myLooper();</span><br><span class=\"line\">    if (me == null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        throw new RuntimeException (&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final MessageQueue queue = me.mQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Make sure the identity of this thread is that of the local process,</span><br><span class=\"line\">    // and keep track of what that identity token actually is.</span><br><span class=\"line\">    Binder.clearCallingIdentity();</span><br><span class=\"line\">    final long ident = Binder.clearCallingIdentity();</span><br><span class=\"line\"></span><br><span class=\"line\">    for (;;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Message msg = queue.next(); // might block</span><br><span class=\"line\">        if (msg == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // No message indicates that the message queue is quitting.</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This must be in a local variable, in case a UI event sets the logger</span><br><span class=\"line\">        final Printer logging = me.mLogging;</span><br><span class=\"line\">        //...</span><br><span class=\"line\"></span><br><span class=\"line\">        final long traceTag = me.mTraceTag;</span><br><span class=\"line\">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled (traceTag) )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Trace.traceBegin (traceTag, msg.target.getTraceName (msg) );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            msg.target.dispatchMessage (msg);</span><br><span class=\"line\">        &#125; finally</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (traceTag != 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Trace.traceEnd (traceTag);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //...</span><br><span class=\"line\">        // Make sure that during the course of dispatching the</span><br><span class=\"line\">        // identity of the thread wasn&apos;t corrupted.</span><br><span class=\"line\">        final long newIdent = Binder.clearCallingIdentity();</span><br><span class=\"line\">        //...</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.recycleUnchecked();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意 <code>msg.target.dispatchMessage (msg);</code>一句，msg是一个从MessageQueue 中取出的Message对象，而 target 则是  Message 中的一个 Handler 类型的 成员变量，这样使得 loop方法将消息队列中的消息分发给 Handler 进行处理。</p>\n</blockquote>\n<h3 id=\"2-4-Handler-的工作原理\"><a href=\"#2-4-Handler-的工作原理\" class=\"headerlink\" title=\"2.4 Handler 的工作原理\"></a>2.4 Handler 的工作原理</h3><p>handler 主要包括消息的发送和接受，主要包括一系列的post和send方法实现的,而post最终是通过 send实现的。如下各个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public final boolean sendMessage(Message msg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return sendMessageDelayed(msg, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> public final boolean sendEmptyMessage(int what)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return sendEmptyMessageDelayed(what, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123;</span><br><span class=\"line\">    Message msg = Message.obtain();</span><br><span class=\"line\">    msg.what = what;</span><br><span class=\"line\">    return sendMessageDelayed(msg, delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123;</span><br><span class=\"line\">    Message msg = Message.obtain();</span><br><span class=\"line\">    msg.what = what;</span><br><span class=\"line\">    return sendMessageAtTime(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (delayMillis &lt; 0) &#123;</span><br><span class=\"line\">        delayMillis = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class=\"line\">        MessageQueue queue = mQueue;</span><br><span class=\"line\">        if (queue == null) &#123;</span><br><span class=\"line\">            RuntimeException e = new RuntimeException(</span><br><span class=\"line\">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class=\"line\">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class=\"line\">        msg.target = this;</span><br><span class=\"line\">        if (mAsynchronous) &#123;</span><br><span class=\"line\">            msg.setAsynchronous(true);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面的各个方法，最终是往调用了 <strong>enqueueMessage 方法 往 MessageQueue 中插入一条消息</strong>。在Looper 中 调用了 MessageQueue 的next 方法，取出一条消息，通过 dispatchMessage 方法将消息分发给 Handler 处理,如下其具体实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void dispatchMessage(Message msg) &#123;</span><br><span class=\"line\">    if (msg.callback != null) &#123;</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        if (mCallback != null) &#123;</span><br><span class=\"line\">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里首先检查 callback 是否为null,不为空就调用 handleCallback 处理，它是一个 Runnable对象；其次检查 mCallback　是否为null ，mCallback　是一个Callback类型的接口，内部只有一个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Callback &#123;</span><br><span class=\"line\">    public boolean handleMessage(Message msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的 Callback 可以用来创建 Handle 对象，常见的创建 Handler 是重写 handleMessage 方法。<br>如下 Handler 的消息处理流程：<br><img src=\"/img/article_img/2016/Handler消息处理流程.png\" alt=\"\"></p>\n<h2 id=\"三、主线程消息循环\"><a href=\"#三、主线程消息循环\" class=\"headerlink\" title=\"三、主线程消息循环\"></a>三、主线程消息循环</h2><p>主线程即ActivityThread ，其注入口方法为 main,在该方法中，通过 <code>Looper.prepareMainLooper();</code>  创建Looper，最后通过 <code>Looper.loop();</code>开启消息循环。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main (String[] args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //...</span><br><span class=\"line\">   // 创建主线程的Looper</span><br><span class=\"line\">    Looper.prepareMainLooper();</span><br><span class=\"line\"></span><br><span class=\"line\">    ActivityThread thread = new ActivityThread();</span><br><span class=\"line\">    thread.attach (false);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (sMainThreadHandler == null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sMainThreadHandler = thread.getHandler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Looper.myLooper().setMessageLogging (new</span><br><span class=\"line\">                                             LogPrinter (Log.DEBUG, &quot;ActivityThread&quot;) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // End of event ActivityThreadMain.</span><br><span class=\"line\">    Trace.traceEnd (Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">    //开启循环</span><br><span class=\"line\">    Looper.loop();</span><br><span class=\"line\"></span><br><span class=\"line\">    throw new RuntimeException (&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActivityThread 的内部类 H 继承自 Handler ，其内部定义了一组消息类型，组要包括了四大组件的启动和停止。</p>\n<p><strong>主线程消息循环模型</strong>：ActivityThread 内部通过 ApplicationThread 和 AMS 进行进程间通信，AMS 以进程间通信的方式完成 ActivityThread 的请求后回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 向 H 发送消息， H收到后将 ApplicationThread 中的逻辑切换到 ActivityThread 中去执行。</p>\n","excerpt":"<blockquote>\n<p>读书笔记： 《Android 开发艺术探索》 ——第十章：android 消息机制</p>\n</blockquote>\n<p>对于 android 中的消息机制，主要是指 <strong>Handler</strong> 的运行机制。在我们平时的开发中 ，对它并不陌生。由于android 是 单线程（UI线程）机制，对于一些耗时操作会在子线程中进行，如文件读取等.<br>","more":"<br>往往在操作完成后会有 UI 的更新，由于 android 中不允许在子线程中更新ui,所以我们 常常用 Handler 来更新UI ，但它的功能不仅仅如此。</p>\n<h2 id=\"一、消息机制概述\"><a href=\"#一、消息机制概述\" class=\"headerlink\" title=\"一、消息机制概述\"></a>一、消息机制概述</h2><p><code>Handler</code> 的运行 需要底层的 <strong>MessageQueue</strong> 和 <strong>Looper</strong> 支撑。<code>MessageQueue</code> 是指消息队列，在他内部存储了一组消息，以队列的形式对外提供增删。虽名为队列，但是其内部的实现是采用 单链表。<code>Looper</code> 主要是用于消息循环，他内部通过无线循环的方式，查看是否有消息，如果有就处理，否则阻塞等待着。 在 Looper 中 利用 <code>ThreadLocal</code> 进行存储数据，它可以保证各个线程中互不干扰的存储和提供数据。<br>如果 使用 Handler 就必须为线程创建 Looper。我们能够在 Activity 只用它，主要是应为在 UI 线程( ActivityThread ) 创建是会初始化 looper。</p>\n<p>android 系统不允许 在子线程中访问UI ，主要是 很多控件时线程不安全的，如果多线程并发访问会出现不可预期的效果；同时由于 锁机制会让 UI 访问逻辑变复杂，并且会阻塞某些线程从而降低 UI 访问效率，并没有对 UI 线程进行加锁 操作。</p>\n<p>如下是 Handler 的 工作过程：</p>\n<p><img src=\"/img/article_img/2016/Handler 消息机制.png\" alt=\"\"></p>\n<blockquote>\n<p>说明：首先 Handle 通过 <code>sendMessage()</code> 等方法发送一个消息，最终会调用 MessageQueue 的 <strong>enqueueMessage</strong> 方法 将消息添加到消息队列中；而 Looper 的 loop方法发现新消息后，从队列中取出消息，最后将其转发到 Handle 中，最终在 handleMessage 进行处理。而Looper 是运行在创建handler 的线程中，这样将Handler 中的业务逻辑切换到 穿件 Handler 的线程中去了。</p>\n</blockquote>\n<h2 id=\"二、消息机制分析\"><a href=\"#二、消息机制分析\" class=\"headerlink\" title=\"二、消息机制分析\"></a>二、消息机制分析</h2><h3 id=\"2-1-ThreadLocal-的工作原理\"><a href=\"#2-1-ThreadLocal-的工作原理\" class=\"headerlink\" title=\"2.1 ThreadLocal 的工作原理\"></a>2.1 ThreadLocal 的工作原理</h3><p>ThreadLocal 主要是线程内部的数据存储类，他可以在指定的线程中存储数据，然后只有指定的线程可以获取。，而其他线程则无法获取。这里使用它 可以方便的实现 Looper 在线程中的存取，此外，他还可以在复杂的逻辑下进行对象的传递，如监听器的传递。</p>\n<p>由于 api23 前后，ThreadLocal 的内部实现不同，这里不具体介绍。</p>\n<h3 id=\"2-2-MessageQueue-的工作原理\"><a href=\"#2-2-MessageQueue-的工作原理\" class=\"headerlink\" title=\"2.2  MessageQueue 的工作原理\"></a>2.2  MessageQueue 的工作原理</h3><p>在消息队列 MessageQueue 中主要包括两个操作：插入和读取，在读取的同时伴随有删除。 插入和读取分别对应于 <code>enqueueMessage</code> 和 <code>next</code>。 enqueueMessage 是往队列中插入 一条数据，采用非的是单链表的插入操作，其内部采用了锁机制，而 next 是一个无限循环方法，若无消息，那么它将阻塞者，若有消息，则返回该消息并将其从消息队列中移除。</p>\n<h3 id=\"2-3-Looper-的工作原理\"><a href=\"#2-3-Looper-的工作原理\" class=\"headerlink\" title=\"2.3 Looper 的工作原理\"></a>2.3 Looper 的工作原理</h3><p>Looper 是消息循环的角色，不停的从 MessageQueue 中取消息，若存在则立即处理，否则阻塞。在 Looper 的构造方法中会创建一个MessageQueue对象。<br>Handle  的工作需要 looper ，如果没有回报错，可以用 <code>prepare</code> 方法创建Looper：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建looper</span><br><span class=\"line\">Looper.prepare();</span><br><span class=\"line\">//....</span><br><span class=\"line\">//开启循环</span><br><span class=\"line\">Looper.loop();</span><br></pre></td></tr></table></figure></p>\n<p>才外，还提供了 <code>prepareMainLooper</code> 方法为主线程创建Looper。对于退出循环，则提供了 <code>quit</code> 和 <code>quitSafely</code> 方法，前者是直接退出，后者则是设置个退出标记，等消息处理完后再退出。<br>通常在子线程中创建的looper ,在执行完后应该退出，当执行退出后，次线程会立即终止，若handler 再次发送消息，则会返回 false。<br>由于在 Looper 的 loop 方法中调用用了 MessageQueue 的 next方法，而next 方法是个阻塞的，导致loop阻塞。如下loop方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void loop()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    final Looper me = myLooper();</span><br><span class=\"line\">    if (me == null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        throw new RuntimeException (&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final MessageQueue queue = me.mQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Make sure the identity of this thread is that of the local process,</span><br><span class=\"line\">    // and keep track of what that identity token actually is.</span><br><span class=\"line\">    Binder.clearCallingIdentity();</span><br><span class=\"line\">    final long ident = Binder.clearCallingIdentity();</span><br><span class=\"line\"></span><br><span class=\"line\">    for (;;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Message msg = queue.next(); // might block</span><br><span class=\"line\">        if (msg == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // No message indicates that the message queue is quitting.</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This must be in a local variable, in case a UI event sets the logger</span><br><span class=\"line\">        final Printer logging = me.mLogging;</span><br><span class=\"line\">        //...</span><br><span class=\"line\"></span><br><span class=\"line\">        final long traceTag = me.mTraceTag;</span><br><span class=\"line\">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled (traceTag) )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Trace.traceBegin (traceTag, msg.target.getTraceName (msg) );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            msg.target.dispatchMessage (msg);</span><br><span class=\"line\">        &#125; finally</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (traceTag != 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Trace.traceEnd (traceTag);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //...</span><br><span class=\"line\">        // Make sure that during the course of dispatching the</span><br><span class=\"line\">        // identity of the thread wasn&apos;t corrupted.</span><br><span class=\"line\">        final long newIdent = Binder.clearCallingIdentity();</span><br><span class=\"line\">        //...</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.recycleUnchecked();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意 <code>msg.target.dispatchMessage (msg);</code>一句，msg是一个从MessageQueue 中取出的Message对象，而 target 则是  Message 中的一个 Handler 类型的 成员变量，这样使得 loop方法将消息队列中的消息分发给 Handler 进行处理。</p>\n</blockquote>\n<h3 id=\"2-4-Handler-的工作原理\"><a href=\"#2-4-Handler-的工作原理\" class=\"headerlink\" title=\"2.4 Handler 的工作原理\"></a>2.4 Handler 的工作原理</h3><p>handler 主要包括消息的发送和接受，主要包括一系列的post和send方法实现的,而post最终是通过 send实现的。如下各个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public final boolean sendMessage(Message msg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return sendMessageDelayed(msg, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> public final boolean sendEmptyMessage(int what)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return sendEmptyMessageDelayed(what, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123;</span><br><span class=\"line\">    Message msg = Message.obtain();</span><br><span class=\"line\">    msg.what = what;</span><br><span class=\"line\">    return sendMessageDelayed(msg, delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123;</span><br><span class=\"line\">    Message msg = Message.obtain();</span><br><span class=\"line\">    msg.what = what;</span><br><span class=\"line\">    return sendMessageAtTime(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (delayMillis &lt; 0) &#123;</span><br><span class=\"line\">        delayMillis = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class=\"line\">        MessageQueue queue = mQueue;</span><br><span class=\"line\">        if (queue == null) &#123;</span><br><span class=\"line\">            RuntimeException e = new RuntimeException(</span><br><span class=\"line\">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class=\"line\">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class=\"line\">        msg.target = this;</span><br><span class=\"line\">        if (mAsynchronous) &#123;</span><br><span class=\"line\">            msg.setAsynchronous(true);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面的各个方法，最终是往调用了 <strong>enqueueMessage 方法 往 MessageQueue 中插入一条消息</strong>。在Looper 中 调用了 MessageQueue 的next 方法，取出一条消息，通过 dispatchMessage 方法将消息分发给 Handler 处理,如下其具体实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void dispatchMessage(Message msg) &#123;</span><br><span class=\"line\">    if (msg.callback != null) &#123;</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        if (mCallback != null) &#123;</span><br><span class=\"line\">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里首先检查 callback 是否为null,不为空就调用 handleCallback 处理，它是一个 Runnable对象；其次检查 mCallback　是否为null ，mCallback　是一个Callback类型的接口，内部只有一个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Callback &#123;</span><br><span class=\"line\">    public boolean handleMessage(Message msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的 Callback 可以用来创建 Handle 对象，常见的创建 Handler 是重写 handleMessage 方法。<br>如下 Handler 的消息处理流程：<br><img src=\"/img/article_img/2016/Handler消息处理流程.png\" alt=\"\"></p>\n<h2 id=\"三、主线程消息循环\"><a href=\"#三、主线程消息循环\" class=\"headerlink\" title=\"三、主线程消息循环\"></a>三、主线程消息循环</h2><p>主线程即ActivityThread ，其注入口方法为 main,在该方法中，通过 <code>Looper.prepareMainLooper();</code>  创建Looper，最后通过 <code>Looper.loop();</code>开启消息循环。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main (String[] args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //...</span><br><span class=\"line\">   // 创建主线程的Looper</span><br><span class=\"line\">    Looper.prepareMainLooper();</span><br><span class=\"line\"></span><br><span class=\"line\">    ActivityThread thread = new ActivityThread();</span><br><span class=\"line\">    thread.attach (false);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (sMainThreadHandler == null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sMainThreadHandler = thread.getHandler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Looper.myLooper().setMessageLogging (new</span><br><span class=\"line\">                                             LogPrinter (Log.DEBUG, &quot;ActivityThread&quot;) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // End of event ActivityThreadMain.</span><br><span class=\"line\">    Trace.traceEnd (Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">    //开启循环</span><br><span class=\"line\">    Looper.loop();</span><br><span class=\"line\"></span><br><span class=\"line\">    throw new RuntimeException (&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ActivityThread 的内部类 H 继承自 Handler ，其内部定义了一组消息类型，组要包括了四大组件的启动和停止。</p>\n<p><strong>主线程消息循环模型</strong>：ActivityThread 内部通过 ApplicationThread 和 AMS 进行进程间通信，AMS 以进程间通信的方式完成 ActivityThread 的请求后回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 向 H 发送消息， H收到后将 ApplicationThread 中的逻辑切换到 ActivityThread 中去执行。</p>"},{"title":"android 自定义View 详解","date":"2016-12-19T08:06:25.000Z","_content":"> 读书笔记： 《Android 开发艺术探索》 ——第四章：View 的工作原理\n\n经过上一节 [Android View 的事件体系](http://imtianx.cn/2016/12/17/Android%20View%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/)的介绍，对 View 的架构及相关的事件分发有了解，本章主要介绍自定义 View 的相关知识。\n\n对于自定义 View ，主要有： 直接继承View 和 ViewGroup，或者继承现有控件，如 ListView 等。不管使用哪种方式，都要先了解View 的工作原理 ，才能更好的进行自定义 View。\n<!--more-->\n## 一、理解 MeasureSpec\n\nMeasureSpec 意思是 “度量规格”，它是View 的一个静态内部类，封装了父view传递给子View 的布局要求，\n在很大程度上确定了一个View 的尺寸。在测量过程中，系统会将 View 的LayoutParams 根据父容器所施加的规则转换成相应的 MeasureSpec，然后通过它测量 View 的宽高。\n\nMeasureSpec 是一个32 位的int值，高2位代表 `SpecModel`,低30位代表 `SpecSize`。 SpecModel 指测量模式，SpecSize指在某种测量模式下的规格大小。这种将来两个个值打包成一个int值，可以避免过多的对象内存分配。对于 `SpecModel` 主要有如下三种模式：\n\n- **UNSPECIFIED**\n  该模式下，父容器不对View 有任何限制，要多大给多大，一般用于系统内部。\n- **EXACTLY**\n该模式下，父容器已经检测出 View 所需的**精确**大小，此时 View  的最终大小就是 **SpecSize**，它对应 LayoutParams 中的 `match_parent` 和 `具体数值`。\n- **AT_MOST**\nView 的大小不能超过父容器指定的可用大小 (`SpecSize`) ,它对应 LayoutParams 中的 `wrap_parent`。\n\n上面提到了 View  的绘制还会和 `LayoutParams` 相关，对于 `DecorView` ,他的规则如下：\n\n- LayoutParams.MATCH_PARENT:精确模式，大小就是窗口大小；\n- LayoutParams.WARO_CONTENT:最大模式，大小不定，但不能超过窗口大小；\n- 固定大小：如100dp，精确模式，LayoutParams 中指定的大小。\n\n对于普通的 View 它的 MeasureSpec 创建规则如下：\n\n|parentSpecMode <br> childLayoutParamsl<br>|EXACTLY|AT_MOST<br>|UNSPECIFIED<br>|\n|:----:|:----:|:----:|:----:|\n|dp/px|EXACTLY<br>childSize|EXACTLY<br>childSize|EXACTLY <br>childSize|\n|match_parent|EXACTLY<br> parentSize|AT_MOST <br> parentSize|UNSPECIFIED <br> 0|\n|wrap_content|AT_MOST<br> parentSize|AT_MOST<br> parentSize|UNSPECIFIED <br> 0|\n\n> 说明：\n对于普通 View 的 MeasureSpec 是由它父容器的 MeasureSpec 和 其本身的 LayoutParams 决定的。\n\n> 当View 采用固定宽高时，其 MeasureSpec 是精确的，大小是 LayoutParams 指定的大小；\n当View 的宽高是 match_parent 时，若其父容器是 精确的，则它也是精确的，大小为父布局的剩余空间；若父容器是最大模式，则view也是最大模式且大小不会超过父容器的剩余空间；\n当 view 的宽高都是 wrap_content时，不管父容器是精确还是最大模式，他都是最大模式，大小不超过父容器的剩余空间。\n对于 UNSPECIFIED 模式，主要用于系统内部，一般情况下我们不用关注。\n\n## 二、View 的工作流程\n\n对于View 它的工作流程主要指**测量(measure)、布局(layout)、绘制(draw)**这三大流程，其中 `measure` 确定 view 的测量宽高， `layout` 确定view 的最终宽高和四个顶点的位置，  `draw` 将 view 绘制在屏幕上。\n\n### 2.1 measure 过程\n\n对于**View 的测量**，是由 `measure`方法完成的，而该方法是一个final 类型的，其中调用 了 `onMeasure` 方法，如下 View中 onMeasure方法源码：\n\n```\nprotected void onMeasure (int widthMeasureSpec, int heightMeasureSpec)\n{\n    //设置view 的测量值\n    setMeasuredDimension (getDefaultSize (getSuggestedMinimumWidth(), widthMeasureSpec),\n                          getDefaultSize (getSuggestedMinimumHeight(), heightMeasureSpec) );\n}\n```\n其中，setMeasuredDimension 方法是设置测量值，而 `getDefaultSize` 方法是获得测量尺寸，如下源码：\n\n```\npublic static int getDefaultSize (int size, int measureSpec)\n{\n    int result = size;\n    int specMode = MeasureSpec.getMode (measureSpec);\n    int specSize = MeasureSpec.getSize (measureSpec);\n\n    switch (specMode)\n    {\n    case MeasureSpec.UNSPECIFIED:\n        result = size;\n        break;\n    case MeasureSpec.AT_MOST:\n    case MeasureSpec.EXACTLY:\n        result = specSize;\n        break;\n    }\n    return result;\n}\n```\n\n注意 ` MeasureSpec.AT_MOST` 和 `MeasureSpec.EXACTLY` 两个分支语句返回相同结果，他们都是 MeasureSpec 中获取的测量结果。从这里可见 View 的宽高由 spaceSize 决定，所以**自定义控件时直接继承view 需要重写 `onMeasure` 方法，设置 `wrap_content` 时的大小，否则 使用 wrap_content 就相当于 match_parent了，都是精确模式。**\n\n在 onMeasure 中用到了 `getSuggestedMinimumWidth` 方法，如下源码：\n\n```\n/**\n * 如果无背景，返回mMinWidth（为 android:minWidth 指定的值）；\n * 否则，返回 minWidth 指定的值和背景最小宽度两者的最大值\n */\nprotected int getSuggestedMinimumWidth()\n{\n    return (mBackground == null) ? mMinWidth :\n           max (mMinWidth, mBackground.getMinimumWidth() );\n}\n//获取背景最小宽度,即 Drawable 的原始宽度，如果没有就返回0\npublic int getMinimumWidth()\n{\n    final int intrinsicWidth = getIntrinsicWidth();\n    return intrinsicWidth > 0 ? intrinsicWidth : 0;\n}\n```\n\n\n对于**ViewGroup 的测量过程**，它可以包含多个 View ，所以除了调用自己的测量法法外，还要遍历所有子元素的测量方法。它是一个抽象类，没有onMeasure 方法，但也提供了 `measureChildren` 方法，在该方法中调用 `measureChild` 方法，分别测量子view 的宽高。\n\n```\nprotected void measureChildren (int widthMeasureSpec, int heightMeasureSpec)\n{\n    final int size = mChildrenCount;\n    final View[] children = mChildren;\n    //遍历子view ，测量所有不是 GONE 状态的 view\n    for (int i = 0; i < size; ++i)\n    {\n        final View child = children[i];\n        if ( (child.mViewFlags & VISIBILITY_MASK) != GONE)\n        {\n            measureChild (child, widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n}\nprotected void measureChild (View child, int parentWidthMeasureSpec,\n                             int parentHeightMeasureSpec)\n{\n    final LayoutParams lp = child.getLayoutParams();\n\n    final int childWidthMeasureSpec = getChildMeasureSpec (parentWidthMeasureSpec,\n                                      mPaddingLeft + mPaddingRight, lp.width);\n    final int childHeightMeasureSpec = getChildMeasureSpec (parentHeightMeasureSpec,\n                                       mPaddingTop + mPaddingBottom, lp.height);\n\n    //调用 子view 的测量方法\n    child.measure (childWidthMeasureSpec, childHeightMeasureSpec);\n}\n```\n\n由于 ViewGroup 的子布局有不同的特性，这里通过调用子布局的 测量方法来测量每一个具体的View 的宽高，最终将他他们累加在一起，在计算具体的 View 时要考虑到 他的 padding 值。\n\n由于view 的测量和 activity 的生命周期不是同的，如果要在 activity 中获取 view 的宽高，不能在 `onCreate` `onResume` 等方法中获取，可通过下面几种方式获取：\n\n-  重写 onWindowFocusChanged(boolean hasFocus)  方法，在 hasFocus 为 true时获取\n-  使用view.post(Runnable runnable) 发送消息队列\n-  使用ViewTreeObserver ，添加 `addOnGlobalLayoutListener` 监听。\n\n到此，view的测量完成了，接下来就是对其进行布局。\n\n\n### 2.2 layout 过程\n\n`layout` 方法确定 view 本身的位置，而ViewGroup 的 `onLayout` 方法确定所有子view 的位置。对于View 的layout 方法，首先是 调用 `setFrame`方法设置四个点的坐标，然后调用父容器的 `onLayout` 方法，确定子view 的位置。在布局过程中 view的最终宽高被确定，通常和测量宽高相等，他们只是在赋值的过程中不同。\n\n### 2.3 draw 过程\n绘制过程，主要是将view 绘制到屏幕上显示。调用 `draw(Canvas canvas)`方法，如下源码：\n\n```\npublic void draw (Canvas canvas)\n{\n    final int privateFlags = mPrivateFlags;\n    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &&\n                                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);\n    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;\n\n    /*\n     * Draw traversal performs several drawing steps which must be executed\n     * in the appropriate order:\n     *\n     *      1. Draw the background\n     *      2. If necessary, save the canvas' layers to prepare for fading\n     *      3. Draw view's content\n     *      4. Draw children\n     *      5. If necessary, draw the fading edges and restore layers\n     *      6. Draw decorations (scrollbars for instance)\n     */\n\n    // Step 1, draw the background, if needed\n    int saveCount;\n\n    if (!dirtyOpaque)\n    {\n        drawBackground (canvas);\n    }\n\n    // skip step 2 & 5 if possible (common case)\n    final int viewFlags = mViewFlags;\n    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;\n    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;\n    if (!verticalEdges && !horizontalEdges)\n    {\n        // Step 3, draw the content\n        if (!dirtyOpaque)\n        {\n            onDraw (canvas);\n        }\n\n        // Step 4, draw the children\n        dispatchDraw (canvas);\n\n        // Overlay is part of the content and draws beneath Foreground\n        if (mOverlay != null && !mOverlay.isEmpty() )\n        {\n            mOverlay.getOverlayView().dispatchDraw (canvas);\n        }\n\n        // Step 6, draw decorations (foreground, scrollbars)\n        onDrawForeground (canvas);\n\n        // we're done...\n        return;\n    }\n\n```\n主要有四个步骤：\n\n- 绘制背景：drawBackground (canvas)；\n- 绘制自己 ：onDraw (canvas);\n- 绘制children：dispatchDraw (canvas);\n- 绘制装饰： onDrawForeground(canvas);\n\nview 通过 `dispatchDraw` 方法分发绘制的过程，而该方法会遍历所有子vied 的draw方法。如果View 是继承ViewGroup的并且自身不具备绘制功能时，可以调用 `setWillNotDraw` 设置标记位，使系统对其进行优化。\n\nview 的大致工作流程就是这样的，自定义view涉及到View 的层次结构、事件分发和相关工作原理，尽管挺复杂，掌握它对我们的开发有很大的帮助。\n\n## 三、自定义View\n\n### 3.1 View 的分类\n常见的自定义view的方式主要有如下几种：\n\n1. 继承view 重写 onDraw方法；\n这种方式主要用于实现不规则效果，需要自己支持 wrap_content 和 padding的处理\n2. 继承 ViewGroup 派生出特殊的Layout\n自定义布局，需要合适的处理ViewGroup 的测量和布局。\n3. 继承特定的View（如TextView）\n扩展现有控件，需要自己支持 wrap_content 和 padding的处理\n4. 继承特定的ViewGroup（如LinearLayout）\n这种方式和2类似，但不需要自己测量和布局过程。\n\n### 3.2 自定义view的注意事项\n\n1. 让View 支持 wrap_content\n在 onMeasure 中对其进行处理，否则控件不支持 wrap_content属性\n2.  让View 支持 padding\n在draw方法中处理 padding，如果是继承自ViewGroup，需要在 onMeasure 中处理 padding 和 margin\n3.  尽量不要使用 Handler ,View 本身提供的有 post方法\n4.  view中如果有线程和动画需要及时停止。\n5.  对于嵌套滑动，要处理好滑动冲突\n\n至此，View 的相关知识介绍完毕，接下来就是进行具体自定义操作了。\n\n\n","source":"_posts/android 自定义View 详解.md","raw":"---\ntitle: android 自定义View 详解\ndate: 2016-12-19 16:06:25\ncategories: [android,学习笔记]\ntags: [View,自定义,原理]\n---\n> 读书笔记： 《Android 开发艺术探索》 ——第四章：View 的工作原理\n\n经过上一节 [Android View 的事件体系](http://imtianx.cn/2016/12/17/Android%20View%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/)的介绍，对 View 的架构及相关的事件分发有了解，本章主要介绍自定义 View 的相关知识。\n\n对于自定义 View ，主要有： 直接继承View 和 ViewGroup，或者继承现有控件，如 ListView 等。不管使用哪种方式，都要先了解View 的工作原理 ，才能更好的进行自定义 View。\n<!--more-->\n## 一、理解 MeasureSpec\n\nMeasureSpec 意思是 “度量规格”，它是View 的一个静态内部类，封装了父view传递给子View 的布局要求，\n在很大程度上确定了一个View 的尺寸。在测量过程中，系统会将 View 的LayoutParams 根据父容器所施加的规则转换成相应的 MeasureSpec，然后通过它测量 View 的宽高。\n\nMeasureSpec 是一个32 位的int值，高2位代表 `SpecModel`,低30位代表 `SpecSize`。 SpecModel 指测量模式，SpecSize指在某种测量模式下的规格大小。这种将来两个个值打包成一个int值，可以避免过多的对象内存分配。对于 `SpecModel` 主要有如下三种模式：\n\n- **UNSPECIFIED**\n  该模式下，父容器不对View 有任何限制，要多大给多大，一般用于系统内部。\n- **EXACTLY**\n该模式下，父容器已经检测出 View 所需的**精确**大小，此时 View  的最终大小就是 **SpecSize**，它对应 LayoutParams 中的 `match_parent` 和 `具体数值`。\n- **AT_MOST**\nView 的大小不能超过父容器指定的可用大小 (`SpecSize`) ,它对应 LayoutParams 中的 `wrap_parent`。\n\n上面提到了 View  的绘制还会和 `LayoutParams` 相关，对于 `DecorView` ,他的规则如下：\n\n- LayoutParams.MATCH_PARENT:精确模式，大小就是窗口大小；\n- LayoutParams.WARO_CONTENT:最大模式，大小不定，但不能超过窗口大小；\n- 固定大小：如100dp，精确模式，LayoutParams 中指定的大小。\n\n对于普通的 View 它的 MeasureSpec 创建规则如下：\n\n|parentSpecMode <br> childLayoutParamsl<br>|EXACTLY|AT_MOST<br>|UNSPECIFIED<br>|\n|:----:|:----:|:----:|:----:|\n|dp/px|EXACTLY<br>childSize|EXACTLY<br>childSize|EXACTLY <br>childSize|\n|match_parent|EXACTLY<br> parentSize|AT_MOST <br> parentSize|UNSPECIFIED <br> 0|\n|wrap_content|AT_MOST<br> parentSize|AT_MOST<br> parentSize|UNSPECIFIED <br> 0|\n\n> 说明：\n对于普通 View 的 MeasureSpec 是由它父容器的 MeasureSpec 和 其本身的 LayoutParams 决定的。\n\n> 当View 采用固定宽高时，其 MeasureSpec 是精确的，大小是 LayoutParams 指定的大小；\n当View 的宽高是 match_parent 时，若其父容器是 精确的，则它也是精确的，大小为父布局的剩余空间；若父容器是最大模式，则view也是最大模式且大小不会超过父容器的剩余空间；\n当 view 的宽高都是 wrap_content时，不管父容器是精确还是最大模式，他都是最大模式，大小不超过父容器的剩余空间。\n对于 UNSPECIFIED 模式，主要用于系统内部，一般情况下我们不用关注。\n\n## 二、View 的工作流程\n\n对于View 它的工作流程主要指**测量(measure)、布局(layout)、绘制(draw)**这三大流程，其中 `measure` 确定 view 的测量宽高， `layout` 确定view 的最终宽高和四个顶点的位置，  `draw` 将 view 绘制在屏幕上。\n\n### 2.1 measure 过程\n\n对于**View 的测量**，是由 `measure`方法完成的，而该方法是一个final 类型的，其中调用 了 `onMeasure` 方法，如下 View中 onMeasure方法源码：\n\n```\nprotected void onMeasure (int widthMeasureSpec, int heightMeasureSpec)\n{\n    //设置view 的测量值\n    setMeasuredDimension (getDefaultSize (getSuggestedMinimumWidth(), widthMeasureSpec),\n                          getDefaultSize (getSuggestedMinimumHeight(), heightMeasureSpec) );\n}\n```\n其中，setMeasuredDimension 方法是设置测量值，而 `getDefaultSize` 方法是获得测量尺寸，如下源码：\n\n```\npublic static int getDefaultSize (int size, int measureSpec)\n{\n    int result = size;\n    int specMode = MeasureSpec.getMode (measureSpec);\n    int specSize = MeasureSpec.getSize (measureSpec);\n\n    switch (specMode)\n    {\n    case MeasureSpec.UNSPECIFIED:\n        result = size;\n        break;\n    case MeasureSpec.AT_MOST:\n    case MeasureSpec.EXACTLY:\n        result = specSize;\n        break;\n    }\n    return result;\n}\n```\n\n注意 ` MeasureSpec.AT_MOST` 和 `MeasureSpec.EXACTLY` 两个分支语句返回相同结果，他们都是 MeasureSpec 中获取的测量结果。从这里可见 View 的宽高由 spaceSize 决定，所以**自定义控件时直接继承view 需要重写 `onMeasure` 方法，设置 `wrap_content` 时的大小，否则 使用 wrap_content 就相当于 match_parent了，都是精确模式。**\n\n在 onMeasure 中用到了 `getSuggestedMinimumWidth` 方法，如下源码：\n\n```\n/**\n * 如果无背景，返回mMinWidth（为 android:minWidth 指定的值）；\n * 否则，返回 minWidth 指定的值和背景最小宽度两者的最大值\n */\nprotected int getSuggestedMinimumWidth()\n{\n    return (mBackground == null) ? mMinWidth :\n           max (mMinWidth, mBackground.getMinimumWidth() );\n}\n//获取背景最小宽度,即 Drawable 的原始宽度，如果没有就返回0\npublic int getMinimumWidth()\n{\n    final int intrinsicWidth = getIntrinsicWidth();\n    return intrinsicWidth > 0 ? intrinsicWidth : 0;\n}\n```\n\n\n对于**ViewGroup 的测量过程**，它可以包含多个 View ，所以除了调用自己的测量法法外，还要遍历所有子元素的测量方法。它是一个抽象类，没有onMeasure 方法，但也提供了 `measureChildren` 方法，在该方法中调用 `measureChild` 方法，分别测量子view 的宽高。\n\n```\nprotected void measureChildren (int widthMeasureSpec, int heightMeasureSpec)\n{\n    final int size = mChildrenCount;\n    final View[] children = mChildren;\n    //遍历子view ，测量所有不是 GONE 状态的 view\n    for (int i = 0; i < size; ++i)\n    {\n        final View child = children[i];\n        if ( (child.mViewFlags & VISIBILITY_MASK) != GONE)\n        {\n            measureChild (child, widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n}\nprotected void measureChild (View child, int parentWidthMeasureSpec,\n                             int parentHeightMeasureSpec)\n{\n    final LayoutParams lp = child.getLayoutParams();\n\n    final int childWidthMeasureSpec = getChildMeasureSpec (parentWidthMeasureSpec,\n                                      mPaddingLeft + mPaddingRight, lp.width);\n    final int childHeightMeasureSpec = getChildMeasureSpec (parentHeightMeasureSpec,\n                                       mPaddingTop + mPaddingBottom, lp.height);\n\n    //调用 子view 的测量方法\n    child.measure (childWidthMeasureSpec, childHeightMeasureSpec);\n}\n```\n\n由于 ViewGroup 的子布局有不同的特性，这里通过调用子布局的 测量方法来测量每一个具体的View 的宽高，最终将他他们累加在一起，在计算具体的 View 时要考虑到 他的 padding 值。\n\n由于view 的测量和 activity 的生命周期不是同的，如果要在 activity 中获取 view 的宽高，不能在 `onCreate` `onResume` 等方法中获取，可通过下面几种方式获取：\n\n-  重写 onWindowFocusChanged(boolean hasFocus)  方法，在 hasFocus 为 true时获取\n-  使用view.post(Runnable runnable) 发送消息队列\n-  使用ViewTreeObserver ，添加 `addOnGlobalLayoutListener` 监听。\n\n到此，view的测量完成了，接下来就是对其进行布局。\n\n\n### 2.2 layout 过程\n\n`layout` 方法确定 view 本身的位置，而ViewGroup 的 `onLayout` 方法确定所有子view 的位置。对于View 的layout 方法，首先是 调用 `setFrame`方法设置四个点的坐标，然后调用父容器的 `onLayout` 方法，确定子view 的位置。在布局过程中 view的最终宽高被确定，通常和测量宽高相等，他们只是在赋值的过程中不同。\n\n### 2.3 draw 过程\n绘制过程，主要是将view 绘制到屏幕上显示。调用 `draw(Canvas canvas)`方法，如下源码：\n\n```\npublic void draw (Canvas canvas)\n{\n    final int privateFlags = mPrivateFlags;\n    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &&\n                                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);\n    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;\n\n    /*\n     * Draw traversal performs several drawing steps which must be executed\n     * in the appropriate order:\n     *\n     *      1. Draw the background\n     *      2. If necessary, save the canvas' layers to prepare for fading\n     *      3. Draw view's content\n     *      4. Draw children\n     *      5. If necessary, draw the fading edges and restore layers\n     *      6. Draw decorations (scrollbars for instance)\n     */\n\n    // Step 1, draw the background, if needed\n    int saveCount;\n\n    if (!dirtyOpaque)\n    {\n        drawBackground (canvas);\n    }\n\n    // skip step 2 & 5 if possible (common case)\n    final int viewFlags = mViewFlags;\n    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;\n    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;\n    if (!verticalEdges && !horizontalEdges)\n    {\n        // Step 3, draw the content\n        if (!dirtyOpaque)\n        {\n            onDraw (canvas);\n        }\n\n        // Step 4, draw the children\n        dispatchDraw (canvas);\n\n        // Overlay is part of the content and draws beneath Foreground\n        if (mOverlay != null && !mOverlay.isEmpty() )\n        {\n            mOverlay.getOverlayView().dispatchDraw (canvas);\n        }\n\n        // Step 6, draw decorations (foreground, scrollbars)\n        onDrawForeground (canvas);\n\n        // we're done...\n        return;\n    }\n\n```\n主要有四个步骤：\n\n- 绘制背景：drawBackground (canvas)；\n- 绘制自己 ：onDraw (canvas);\n- 绘制children：dispatchDraw (canvas);\n- 绘制装饰： onDrawForeground(canvas);\n\nview 通过 `dispatchDraw` 方法分发绘制的过程，而该方法会遍历所有子vied 的draw方法。如果View 是继承ViewGroup的并且自身不具备绘制功能时，可以调用 `setWillNotDraw` 设置标记位，使系统对其进行优化。\n\nview 的大致工作流程就是这样的，自定义view涉及到View 的层次结构、事件分发和相关工作原理，尽管挺复杂，掌握它对我们的开发有很大的帮助。\n\n## 三、自定义View\n\n### 3.1 View 的分类\n常见的自定义view的方式主要有如下几种：\n\n1. 继承view 重写 onDraw方法；\n这种方式主要用于实现不规则效果，需要自己支持 wrap_content 和 padding的处理\n2. 继承 ViewGroup 派生出特殊的Layout\n自定义布局，需要合适的处理ViewGroup 的测量和布局。\n3. 继承特定的View（如TextView）\n扩展现有控件，需要自己支持 wrap_content 和 padding的处理\n4. 继承特定的ViewGroup（如LinearLayout）\n这种方式和2类似，但不需要自己测量和布局过程。\n\n### 3.2 自定义view的注意事项\n\n1. 让View 支持 wrap_content\n在 onMeasure 中对其进行处理，否则控件不支持 wrap_content属性\n2.  让View 支持 padding\n在draw方法中处理 padding，如果是继承自ViewGroup，需要在 onMeasure 中处理 padding 和 margin\n3.  尽量不要使用 Handler ,View 本身提供的有 post方法\n4.  view中如果有线程和动画需要及时停止。\n5.  对于嵌套滑动，要处理好滑动冲突\n\n至此，View 的相关知识介绍完毕，接下来就是进行具体自定义操作了。\n\n\n","slug":"android 自定义View 详解","published":1,"updated":"2016-12-19T06:21:17.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucg50016g0g5ri2d0c3i","content":"<blockquote>\n<p>读书笔记： 《Android 开发艺术探索》 ——第四章：View 的工作原理</p>\n</blockquote>\n<p>经过上一节 <a href=\"http://imtianx.cn/2016/12/17/Android%20View%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/\">Android View 的事件体系</a>的介绍，对 View 的架构及相关的事件分发有了解，本章主要介绍自定义 View 的相关知识。</p>\n<p>对于自定义 View ，主要有： 直接继承View 和 ViewGroup，或者继承现有控件，如 ListView 等。不管使用哪种方式，都要先了解View 的工作原理 ，才能更好的进行自定义 View。<br><a id=\"more\"></a></p>\n<h2 id=\"一、理解-MeasureSpec\"><a href=\"#一、理解-MeasureSpec\" class=\"headerlink\" title=\"一、理解 MeasureSpec\"></a>一、理解 MeasureSpec</h2><p>MeasureSpec 意思是 “度量规格”，它是View 的一个静态内部类，封装了父view传递给子View 的布局要求，<br>在很大程度上确定了一个View 的尺寸。在测量过程中，系统会将 View 的LayoutParams 根据父容器所施加的规则转换成相应的 MeasureSpec，然后通过它测量 View 的宽高。</p>\n<p>MeasureSpec 是一个32 位的int值，高2位代表 <code>SpecModel</code>,低30位代表 <code>SpecSize</code>。 SpecModel 指测量模式，SpecSize指在某种测量模式下的规格大小。这种将来两个个值打包成一个int值，可以避免过多的对象内存分配。对于 <code>SpecModel</code> 主要有如下三种模式：</p>\n<ul>\n<li><strong>UNSPECIFIED</strong><br>该模式下，父容器不对View 有任何限制，要多大给多大，一般用于系统内部。</li>\n<li><strong>EXACTLY</strong><br>该模式下，父容器已经检测出 View 所需的<strong>精确</strong>大小，此时 View  的最终大小就是 <strong>SpecSize</strong>，它对应 LayoutParams 中的 <code>match_parent</code> 和 <code>具体数值</code>。</li>\n<li><strong>AT_MOST</strong><br>View 的大小不能超过父容器指定的可用大小 (<code>SpecSize</code>) ,它对应 LayoutParams 中的 <code>wrap_parent</code>。</li>\n</ul>\n<p>上面提到了 View  的绘制还会和 <code>LayoutParams</code> 相关，对于 <code>DecorView</code> ,他的规则如下：</p>\n<ul>\n<li>LayoutParams.MATCH_PARENT:精确模式，大小就是窗口大小；</li>\n<li>LayoutParams.WARO_CONTENT:最大模式，大小不定，但不能超过窗口大小；</li>\n<li>固定大小：如100dp，精确模式，LayoutParams 中指定的大小。</li>\n</ul>\n<p>对于普通的 View 它的 MeasureSpec 创建规则如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">parentSpecMode <br> childLayoutParamsl<br></th>\n<th style=\"text-align:center\">EXACTLY</th>\n<th style=\"text-align:center\">AT_MOST<br></th>\n<th style=\"text-align:center\">UNSPECIFIED<br></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">dp/px</td>\n<td style=\"text-align:center\">EXACTLY<br>childSize</td>\n<td style=\"text-align:center\">EXACTLY<br>childSize</td>\n<td style=\"text-align:center\">EXACTLY <br>childSize</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">match_parent</td>\n<td style=\"text-align:center\">EXACTLY<br> parentSize</td>\n<td style=\"text-align:center\">AT_MOST <br> parentSize</td>\n<td style=\"text-align:center\">UNSPECIFIED <br> 0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wrap_content</td>\n<td style=\"text-align:center\">AT_MOST<br> parentSize</td>\n<td style=\"text-align:center\">AT_MOST<br> parentSize</td>\n<td style=\"text-align:center\">UNSPECIFIED <br> 0</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>说明：<br>对于普通 View 的 MeasureSpec 是由它父容器的 MeasureSpec 和 其本身的 LayoutParams 决定的。</p>\n<p>当View 采用固定宽高时，其 MeasureSpec 是精确的，大小是 LayoutParams 指定的大小；<br>当View 的宽高是 match_parent 时，若其父容器是 精确的，则它也是精确的，大小为父布局的剩余空间；若父容器是最大模式，则view也是最大模式且大小不会超过父容器的剩余空间；<br>当 view 的宽高都是 wrap_content时，不管父容器是精确还是最大模式，他都是最大模式，大小不超过父容器的剩余空间。<br>对于 UNSPECIFIED 模式，主要用于系统内部，一般情况下我们不用关注。</p>\n</blockquote>\n<h2 id=\"二、View-的工作流程\"><a href=\"#二、View-的工作流程\" class=\"headerlink\" title=\"二、View 的工作流程\"></a>二、View 的工作流程</h2><p>对于View 它的工作流程主要指<strong>测量(measure)、布局(layout)、绘制(draw)</strong>这三大流程，其中 <code>measure</code> 确定 view 的测量宽高， <code>layout</code> 确定view 的最终宽高和四个顶点的位置，  <code>draw</code> 将 view 绘制在屏幕上。</p>\n<h3 id=\"2-1-measure-过程\"><a href=\"#2-1-measure-过程\" class=\"headerlink\" title=\"2.1 measure 过程\"></a>2.1 measure 过程</h3><p>对于<strong>View 的测量</strong>，是由 <code>measure</code>方法完成的，而该方法是一个final 类型的，其中调用 了 <code>onMeasure</code> 方法，如下 View中 onMeasure方法源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //设置view 的测量值</span><br><span class=\"line\">    setMeasuredDimension (getDefaultSize (getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class=\"line\">                          getDefaultSize (getSuggestedMinimumHeight(), heightMeasureSpec) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，setMeasuredDimension 方法是设置测量值，而 <code>getDefaultSize</code> 方法是获得测量尺寸，如下源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int getDefaultSize (int size, int measureSpec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int result = size;</span><br><span class=\"line\">    int specMode = MeasureSpec.getMode (measureSpec);</span><br><span class=\"line\">    int specSize = MeasureSpec.getSize (measureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">    switch (specMode)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    case MeasureSpec.UNSPECIFIED:</span><br><span class=\"line\">        result = size;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case MeasureSpec.AT_MOST:</span><br><span class=\"line\">    case MeasureSpec.EXACTLY:</span><br><span class=\"line\">        result = specSize;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意 <code>MeasureSpec.AT_MOST</code> 和 <code>MeasureSpec.EXACTLY</code> 两个分支语句返回相同结果，他们都是 MeasureSpec 中获取的测量结果。从这里可见 View 的宽高由 spaceSize 决定，所以<strong>自定义控件时直接继承view 需要重写 <code>onMeasure</code> 方法，设置 <code>wrap_content</code> 时的大小，否则 使用 wrap_content 就相当于 match_parent了，都是精确模式。</strong></p>\n<p>在 onMeasure 中用到了 <code>getSuggestedMinimumWidth</code> 方法，如下源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 如果无背景，返回mMinWidth（为 android:minWidth 指定的值）；</span><br><span class=\"line\"> * 否则，返回 minWidth 指定的值和背景最小宽度两者的最大值</span><br><span class=\"line\"> */</span><br><span class=\"line\">protected int getSuggestedMinimumWidth()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return (mBackground == null) ? mMinWidth :</span><br><span class=\"line\">           max (mMinWidth, mBackground.getMinimumWidth() );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//获取背景最小宽度,即 Drawable 的原始宽度，如果没有就返回0</span><br><span class=\"line\">public int getMinimumWidth()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    final int intrinsicWidth = getIntrinsicWidth();</span><br><span class=\"line\">    return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于<strong>ViewGroup 的测量过程</strong>，它可以包含多个 View ，所以除了调用自己的测量法法外，还要遍历所有子元素的测量方法。它是一个抽象类，没有onMeasure 方法，但也提供了 <code>measureChildren</code> 方法，在该方法中调用 <code>measureChild</code> 方法，分别测量子view 的宽高。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void measureChildren (int widthMeasureSpec, int heightMeasureSpec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    final int size = mChildrenCount;</span><br><span class=\"line\">    final View[] children = mChildren;</span><br><span class=\"line\">    //遍历子view ，测量所有不是 GONE 状态的 view</span><br><span class=\"line\">    for (int i = 0; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        final View child = children[i];</span><br><span class=\"line\">        if ( (child.mViewFlags &amp; VISIBILITY_MASK) != GONE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            measureChild (child, widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">protected void measureChild (View child, int parentWidthMeasureSpec,</span><br><span class=\"line\">                             int parentHeightMeasureSpec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    final LayoutParams lp = child.getLayoutParams();</span><br><span class=\"line\"></span><br><span class=\"line\">    final int childWidthMeasureSpec = getChildMeasureSpec (parentWidthMeasureSpec,</span><br><span class=\"line\">                                      mPaddingLeft + mPaddingRight, lp.width);</span><br><span class=\"line\">    final int childHeightMeasureSpec = getChildMeasureSpec (parentHeightMeasureSpec,</span><br><span class=\"line\">                                       mPaddingTop + mPaddingBottom, lp.height);</span><br><span class=\"line\"></span><br><span class=\"line\">    //调用 子view 的测量方法</span><br><span class=\"line\">    child.measure (childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 ViewGroup 的子布局有不同的特性，这里通过调用子布局的 测量方法来测量每一个具体的View 的宽高，最终将他他们累加在一起，在计算具体的 View 时要考虑到 他的 padding 值。</p>\n<p>由于view 的测量和 activity 的生命周期不是同的，如果要在 activity 中获取 view 的宽高，不能在 <code>onCreate</code> <code>onResume</code> 等方法中获取，可通过下面几种方式获取：</p>\n<ul>\n<li>重写 onWindowFocusChanged(boolean hasFocus)  方法，在 hasFocus 为 true时获取</li>\n<li>使用view.post(Runnable runnable) 发送消息队列</li>\n<li>使用ViewTreeObserver ，添加 <code>addOnGlobalLayoutListener</code> 监听。</li>\n</ul>\n<p>到此，view的测量完成了，接下来就是对其进行布局。</p>\n<h3 id=\"2-2-layout-过程\"><a href=\"#2-2-layout-过程\" class=\"headerlink\" title=\"2.2 layout 过程\"></a>2.2 layout 过程</h3><p><code>layout</code> 方法确定 view 本身的位置，而ViewGroup 的 <code>onLayout</code> 方法确定所有子view 的位置。对于View 的layout 方法，首先是 调用 <code>setFrame</code>方法设置四个点的坐标，然后调用父容器的 <code>onLayout</code> 方法，确定子view 的位置。在布局过程中 view的最终宽高被确定，通常和测量宽高相等，他们只是在赋值的过程中不同。</p>\n<h3 id=\"2-3-draw-过程\"><a href=\"#2-3-draw-过程\" class=\"headerlink\" title=\"2.3 draw 过程\"></a>2.3 draw 过程</h3><p>绘制过程，主要是将view 绘制到屏幕上显示。调用 <code>draw(Canvas canvas)</code>方法，如下源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void draw (Canvas canvas)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    final int privateFlags = mPrivateFlags;</span><br><span class=\"line\">    final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class=\"line\">                                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class=\"line\">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * Draw traversal performs several drawing steps which must be executed</span><br><span class=\"line\">     * in the appropriate order:</span><br><span class=\"line\">     *</span><br><span class=\"line\">     *      1. Draw the background</span><br><span class=\"line\">     *      2. If necessary, save the canvas&apos; layers to prepare for fading</span><br><span class=\"line\">     *      3. Draw view&apos;s content</span><br><span class=\"line\">     *      4. Draw children</span><br><span class=\"line\">     *      5. If necessary, draw the fading edges and restore layers</span><br><span class=\"line\">     *      6. Draw decorations (scrollbars for instance)</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    // Step 1, draw the background, if needed</span><br><span class=\"line\">    int saveCount;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!dirtyOpaque)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        drawBackground (canvas);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // skip step 2 &amp; 5 if possible (common case)</span><br><span class=\"line\">    final int viewFlags = mViewFlags;</span><br><span class=\"line\">    boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</span><br><span class=\"line\">    boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</span><br><span class=\"line\">    if (!verticalEdges &amp;&amp; !horizontalEdges)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // Step 3, draw the content</span><br><span class=\"line\">        if (!dirtyOpaque)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            onDraw (canvas);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Step 4, draw the children</span><br><span class=\"line\">        dispatchDraw (canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Overlay is part of the content and draws beneath Foreground</span><br><span class=\"line\">        if (mOverlay != null &amp;&amp; !mOverlay.isEmpty() )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mOverlay.getOverlayView().dispatchDraw (canvas);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Step 6, draw decorations (foreground, scrollbars)</span><br><span class=\"line\">        onDrawForeground (canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">        // we&apos;re done...</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>主要有四个步骤：</p>\n<ul>\n<li>绘制背景：drawBackground (canvas)；</li>\n<li>绘制自己 ：onDraw (canvas);</li>\n<li>绘制children：dispatchDraw (canvas);</li>\n<li>绘制装饰： onDrawForeground(canvas);</li>\n</ul>\n<p>view 通过 <code>dispatchDraw</code> 方法分发绘制的过程，而该方法会遍历所有子vied 的draw方法。如果View 是继承ViewGroup的并且自身不具备绘制功能时，可以调用 <code>setWillNotDraw</code> 设置标记位，使系统对其进行优化。</p>\n<p>view 的大致工作流程就是这样的，自定义view涉及到View 的层次结构、事件分发和相关工作原理，尽管挺复杂，掌握它对我们的开发有很大的帮助。</p>\n<h2 id=\"三、自定义View\"><a href=\"#三、自定义View\" class=\"headerlink\" title=\"三、自定义View\"></a>三、自定义View</h2><h3 id=\"3-1-View-的分类\"><a href=\"#3-1-View-的分类\" class=\"headerlink\" title=\"3.1 View 的分类\"></a>3.1 View 的分类</h3><p>常见的自定义view的方式主要有如下几种：</p>\n<ol>\n<li>继承view 重写 onDraw方法；<br>这种方式主要用于实现不规则效果，需要自己支持 wrap_content 和 padding的处理</li>\n<li>继承 ViewGroup 派生出特殊的Layout<br>自定义布局，需要合适的处理ViewGroup 的测量和布局。</li>\n<li>继承特定的View（如TextView）<br>扩展现有控件，需要自己支持 wrap_content 和 padding的处理</li>\n<li>继承特定的ViewGroup（如LinearLayout）<br>这种方式和2类似，但不需要自己测量和布局过程。</li>\n</ol>\n<h3 id=\"3-2-自定义view的注意事项\"><a href=\"#3-2-自定义view的注意事项\" class=\"headerlink\" title=\"3.2 自定义view的注意事项\"></a>3.2 自定义view的注意事项</h3><ol>\n<li>让View 支持 wrap_content<br>在 onMeasure 中对其进行处理，否则控件不支持 wrap_content属性</li>\n<li>让View 支持 padding<br>在draw方法中处理 padding，如果是继承自ViewGroup，需要在 onMeasure 中处理 padding 和 margin</li>\n<li>尽量不要使用 Handler ,View 本身提供的有 post方法</li>\n<li>view中如果有线程和动画需要及时停止。</li>\n<li>对于嵌套滑动，要处理好滑动冲突</li>\n</ol>\n<p>至此，View 的相关知识介绍完毕，接下来就是进行具体自定义操作了。</p>\n","excerpt":"<blockquote>\n<p>读书笔记： 《Android 开发艺术探索》 ——第四章：View 的工作原理</p>\n</blockquote>\n<p>经过上一节 <a href=\"http://imtianx.cn/2016/12/17/Android%20View%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/\">Android View 的事件体系</a>的介绍，对 View 的架构及相关的事件分发有了解，本章主要介绍自定义 View 的相关知识。</p>\n<p>对于自定义 View ，主要有： 直接继承View 和 ViewGroup，或者继承现有控件，如 ListView 等。不管使用哪种方式，都要先了解View 的工作原理 ，才能更好的进行自定义 View。<br>","more":"</p>\n<h2 id=\"一、理解-MeasureSpec\"><a href=\"#一、理解-MeasureSpec\" class=\"headerlink\" title=\"一、理解 MeasureSpec\"></a>一、理解 MeasureSpec</h2><p>MeasureSpec 意思是 “度量规格”，它是View 的一个静态内部类，封装了父view传递给子View 的布局要求，<br>在很大程度上确定了一个View 的尺寸。在测量过程中，系统会将 View 的LayoutParams 根据父容器所施加的规则转换成相应的 MeasureSpec，然后通过它测量 View 的宽高。</p>\n<p>MeasureSpec 是一个32 位的int值，高2位代表 <code>SpecModel</code>,低30位代表 <code>SpecSize</code>。 SpecModel 指测量模式，SpecSize指在某种测量模式下的规格大小。这种将来两个个值打包成一个int值，可以避免过多的对象内存分配。对于 <code>SpecModel</code> 主要有如下三种模式：</p>\n<ul>\n<li><strong>UNSPECIFIED</strong><br>该模式下，父容器不对View 有任何限制，要多大给多大，一般用于系统内部。</li>\n<li><strong>EXACTLY</strong><br>该模式下，父容器已经检测出 View 所需的<strong>精确</strong>大小，此时 View  的最终大小就是 <strong>SpecSize</strong>，它对应 LayoutParams 中的 <code>match_parent</code> 和 <code>具体数值</code>。</li>\n<li><strong>AT_MOST</strong><br>View 的大小不能超过父容器指定的可用大小 (<code>SpecSize</code>) ,它对应 LayoutParams 中的 <code>wrap_parent</code>。</li>\n</ul>\n<p>上面提到了 View  的绘制还会和 <code>LayoutParams</code> 相关，对于 <code>DecorView</code> ,他的规则如下：</p>\n<ul>\n<li>LayoutParams.MATCH_PARENT:精确模式，大小就是窗口大小；</li>\n<li>LayoutParams.WARO_CONTENT:最大模式，大小不定，但不能超过窗口大小；</li>\n<li>固定大小：如100dp，精确模式，LayoutParams 中指定的大小。</li>\n</ul>\n<p>对于普通的 View 它的 MeasureSpec 创建规则如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">parentSpecMode <br> childLayoutParamsl<br></th>\n<th style=\"text-align:center\">EXACTLY</th>\n<th style=\"text-align:center\">AT_MOST<br></th>\n<th style=\"text-align:center\">UNSPECIFIED<br></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">dp/px</td>\n<td style=\"text-align:center\">EXACTLY<br>childSize</td>\n<td style=\"text-align:center\">EXACTLY<br>childSize</td>\n<td style=\"text-align:center\">EXACTLY <br>childSize</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">match_parent</td>\n<td style=\"text-align:center\">EXACTLY<br> parentSize</td>\n<td style=\"text-align:center\">AT_MOST <br> parentSize</td>\n<td style=\"text-align:center\">UNSPECIFIED <br> 0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wrap_content</td>\n<td style=\"text-align:center\">AT_MOST<br> parentSize</td>\n<td style=\"text-align:center\">AT_MOST<br> parentSize</td>\n<td style=\"text-align:center\">UNSPECIFIED <br> 0</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>说明：<br>对于普通 View 的 MeasureSpec 是由它父容器的 MeasureSpec 和 其本身的 LayoutParams 决定的。</p>\n<p>当View 采用固定宽高时，其 MeasureSpec 是精确的，大小是 LayoutParams 指定的大小；<br>当View 的宽高是 match_parent 时，若其父容器是 精确的，则它也是精确的，大小为父布局的剩余空间；若父容器是最大模式，则view也是最大模式且大小不会超过父容器的剩余空间；<br>当 view 的宽高都是 wrap_content时，不管父容器是精确还是最大模式，他都是最大模式，大小不超过父容器的剩余空间。<br>对于 UNSPECIFIED 模式，主要用于系统内部，一般情况下我们不用关注。</p>\n</blockquote>\n<h2 id=\"二、View-的工作流程\"><a href=\"#二、View-的工作流程\" class=\"headerlink\" title=\"二、View 的工作流程\"></a>二、View 的工作流程</h2><p>对于View 它的工作流程主要指<strong>测量(measure)、布局(layout)、绘制(draw)</strong>这三大流程，其中 <code>measure</code> 确定 view 的测量宽高， <code>layout</code> 确定view 的最终宽高和四个顶点的位置，  <code>draw</code> 将 view 绘制在屏幕上。</p>\n<h3 id=\"2-1-measure-过程\"><a href=\"#2-1-measure-过程\" class=\"headerlink\" title=\"2.1 measure 过程\"></a>2.1 measure 过程</h3><p>对于<strong>View 的测量</strong>，是由 <code>measure</code>方法完成的，而该方法是一个final 类型的，其中调用 了 <code>onMeasure</code> 方法，如下 View中 onMeasure方法源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //设置view 的测量值</span><br><span class=\"line\">    setMeasuredDimension (getDefaultSize (getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class=\"line\">                          getDefaultSize (getSuggestedMinimumHeight(), heightMeasureSpec) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，setMeasuredDimension 方法是设置测量值，而 <code>getDefaultSize</code> 方法是获得测量尺寸，如下源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int getDefaultSize (int size, int measureSpec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int result = size;</span><br><span class=\"line\">    int specMode = MeasureSpec.getMode (measureSpec);</span><br><span class=\"line\">    int specSize = MeasureSpec.getSize (measureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">    switch (specMode)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    case MeasureSpec.UNSPECIFIED:</span><br><span class=\"line\">        result = size;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case MeasureSpec.AT_MOST:</span><br><span class=\"line\">    case MeasureSpec.EXACTLY:</span><br><span class=\"line\">        result = specSize;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意 <code>MeasureSpec.AT_MOST</code> 和 <code>MeasureSpec.EXACTLY</code> 两个分支语句返回相同结果，他们都是 MeasureSpec 中获取的测量结果。从这里可见 View 的宽高由 spaceSize 决定，所以<strong>自定义控件时直接继承view 需要重写 <code>onMeasure</code> 方法，设置 <code>wrap_content</code> 时的大小，否则 使用 wrap_content 就相当于 match_parent了，都是精确模式。</strong></p>\n<p>在 onMeasure 中用到了 <code>getSuggestedMinimumWidth</code> 方法，如下源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 如果无背景，返回mMinWidth（为 android:minWidth 指定的值）；</span><br><span class=\"line\"> * 否则，返回 minWidth 指定的值和背景最小宽度两者的最大值</span><br><span class=\"line\"> */</span><br><span class=\"line\">protected int getSuggestedMinimumWidth()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return (mBackground == null) ? mMinWidth :</span><br><span class=\"line\">           max (mMinWidth, mBackground.getMinimumWidth() );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//获取背景最小宽度,即 Drawable 的原始宽度，如果没有就返回0</span><br><span class=\"line\">public int getMinimumWidth()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    final int intrinsicWidth = getIntrinsicWidth();</span><br><span class=\"line\">    return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于<strong>ViewGroup 的测量过程</strong>，它可以包含多个 View ，所以除了调用自己的测量法法外，还要遍历所有子元素的测量方法。它是一个抽象类，没有onMeasure 方法，但也提供了 <code>measureChildren</code> 方法，在该方法中调用 <code>measureChild</code> 方法，分别测量子view 的宽高。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void measureChildren (int widthMeasureSpec, int heightMeasureSpec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    final int size = mChildrenCount;</span><br><span class=\"line\">    final View[] children = mChildren;</span><br><span class=\"line\">    //遍历子view ，测量所有不是 GONE 状态的 view</span><br><span class=\"line\">    for (int i = 0; i &lt; size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        final View child = children[i];</span><br><span class=\"line\">        if ( (child.mViewFlags &amp; VISIBILITY_MASK) != GONE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            measureChild (child, widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">protected void measureChild (View child, int parentWidthMeasureSpec,</span><br><span class=\"line\">                             int parentHeightMeasureSpec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    final LayoutParams lp = child.getLayoutParams();</span><br><span class=\"line\"></span><br><span class=\"line\">    final int childWidthMeasureSpec = getChildMeasureSpec (parentWidthMeasureSpec,</span><br><span class=\"line\">                                      mPaddingLeft + mPaddingRight, lp.width);</span><br><span class=\"line\">    final int childHeightMeasureSpec = getChildMeasureSpec (parentHeightMeasureSpec,</span><br><span class=\"line\">                                       mPaddingTop + mPaddingBottom, lp.height);</span><br><span class=\"line\"></span><br><span class=\"line\">    //调用 子view 的测量方法</span><br><span class=\"line\">    child.measure (childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 ViewGroup 的子布局有不同的特性，这里通过调用子布局的 测量方法来测量每一个具体的View 的宽高，最终将他他们累加在一起，在计算具体的 View 时要考虑到 他的 padding 值。</p>\n<p>由于view 的测量和 activity 的生命周期不是同的，如果要在 activity 中获取 view 的宽高，不能在 <code>onCreate</code> <code>onResume</code> 等方法中获取，可通过下面几种方式获取：</p>\n<ul>\n<li>重写 onWindowFocusChanged(boolean hasFocus)  方法，在 hasFocus 为 true时获取</li>\n<li>使用view.post(Runnable runnable) 发送消息队列</li>\n<li>使用ViewTreeObserver ，添加 <code>addOnGlobalLayoutListener</code> 监听。</li>\n</ul>\n<p>到此，view的测量完成了，接下来就是对其进行布局。</p>\n<h3 id=\"2-2-layout-过程\"><a href=\"#2-2-layout-过程\" class=\"headerlink\" title=\"2.2 layout 过程\"></a>2.2 layout 过程</h3><p><code>layout</code> 方法确定 view 本身的位置，而ViewGroup 的 <code>onLayout</code> 方法确定所有子view 的位置。对于View 的layout 方法，首先是 调用 <code>setFrame</code>方法设置四个点的坐标，然后调用父容器的 <code>onLayout</code> 方法，确定子view 的位置。在布局过程中 view的最终宽高被确定，通常和测量宽高相等，他们只是在赋值的过程中不同。</p>\n<h3 id=\"2-3-draw-过程\"><a href=\"#2-3-draw-过程\" class=\"headerlink\" title=\"2.3 draw 过程\"></a>2.3 draw 过程</h3><p>绘制过程，主要是将view 绘制到屏幕上显示。调用 <code>draw(Canvas canvas)</code>方法，如下源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void draw (Canvas canvas)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    final int privateFlags = mPrivateFlags;</span><br><span class=\"line\">    final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class=\"line\">                                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class=\"line\">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * Draw traversal performs several drawing steps which must be executed</span><br><span class=\"line\">     * in the appropriate order:</span><br><span class=\"line\">     *</span><br><span class=\"line\">     *      1. Draw the background</span><br><span class=\"line\">     *      2. If necessary, save the canvas&apos; layers to prepare for fading</span><br><span class=\"line\">     *      3. Draw view&apos;s content</span><br><span class=\"line\">     *      4. Draw children</span><br><span class=\"line\">     *      5. If necessary, draw the fading edges and restore layers</span><br><span class=\"line\">     *      6. Draw decorations (scrollbars for instance)</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    // Step 1, draw the background, if needed</span><br><span class=\"line\">    int saveCount;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!dirtyOpaque)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        drawBackground (canvas);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // skip step 2 &amp; 5 if possible (common case)</span><br><span class=\"line\">    final int viewFlags = mViewFlags;</span><br><span class=\"line\">    boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</span><br><span class=\"line\">    boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</span><br><span class=\"line\">    if (!verticalEdges &amp;&amp; !horizontalEdges)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // Step 3, draw the content</span><br><span class=\"line\">        if (!dirtyOpaque)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            onDraw (canvas);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Step 4, draw the children</span><br><span class=\"line\">        dispatchDraw (canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Overlay is part of the content and draws beneath Foreground</span><br><span class=\"line\">        if (mOverlay != null &amp;&amp; !mOverlay.isEmpty() )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mOverlay.getOverlayView().dispatchDraw (canvas);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Step 6, draw decorations (foreground, scrollbars)</span><br><span class=\"line\">        onDrawForeground (canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">        // we&apos;re done...</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>主要有四个步骤：</p>\n<ul>\n<li>绘制背景：drawBackground (canvas)；</li>\n<li>绘制自己 ：onDraw (canvas);</li>\n<li>绘制children：dispatchDraw (canvas);</li>\n<li>绘制装饰： onDrawForeground(canvas);</li>\n</ul>\n<p>view 通过 <code>dispatchDraw</code> 方法分发绘制的过程，而该方法会遍历所有子vied 的draw方法。如果View 是继承ViewGroup的并且自身不具备绘制功能时，可以调用 <code>setWillNotDraw</code> 设置标记位，使系统对其进行优化。</p>\n<p>view 的大致工作流程就是这样的，自定义view涉及到View 的层次结构、事件分发和相关工作原理，尽管挺复杂，掌握它对我们的开发有很大的帮助。</p>\n<h2 id=\"三、自定义View\"><a href=\"#三、自定义View\" class=\"headerlink\" title=\"三、自定义View\"></a>三、自定义View</h2><h3 id=\"3-1-View-的分类\"><a href=\"#3-1-View-的分类\" class=\"headerlink\" title=\"3.1 View 的分类\"></a>3.1 View 的分类</h3><p>常见的自定义view的方式主要有如下几种：</p>\n<ol>\n<li>继承view 重写 onDraw方法；<br>这种方式主要用于实现不规则效果，需要自己支持 wrap_content 和 padding的处理</li>\n<li>继承 ViewGroup 派生出特殊的Layout<br>自定义布局，需要合适的处理ViewGroup 的测量和布局。</li>\n<li>继承特定的View（如TextView）<br>扩展现有控件，需要自己支持 wrap_content 和 padding的处理</li>\n<li>继承特定的ViewGroup（如LinearLayout）<br>这种方式和2类似，但不需要自己测量和布局过程。</li>\n</ol>\n<h3 id=\"3-2-自定义view的注意事项\"><a href=\"#3-2-自定义view的注意事项\" class=\"headerlink\" title=\"3.2 自定义view的注意事项\"></a>3.2 自定义view的注意事项</h3><ol>\n<li>让View 支持 wrap_content<br>在 onMeasure 中对其进行处理，否则控件不支持 wrap_content属性</li>\n<li>让View 支持 padding<br>在draw方法中处理 padding，如果是继承自ViewGroup，需要在 onMeasure 中处理 padding 和 margin</li>\n<li>尽量不要使用 Handler ,View 本身提供的有 post方法</li>\n<li>view中如果有线程和动画需要及时停止。</li>\n<li>对于嵌套滑动，要处理好滑动冲突</li>\n</ol>\n<p>至此，View 的相关知识介绍完毕，接下来就是进行具体自定义操作了。</p>"},{"title":"android 异常捕获-UncaughtExceptionHandler","date":"2016-07-10T08:06:25.000Z","_content":"\n在android开发中，异常信息的捕获有多种方式，比如第三方的友盟、蒲公英等，这里主要使用 android 原生的 Thread.UncaughtExceptionHandler 来捕获出现的异常信息<!--more-->,并给出友好的提示，避免出现停止运行，提高用户体验，下面是具体的实现过程。\n\n[转自： Android 全局异常捕获](http://blog.csdn.net/zly921112/article/details/51867079)\n## 1.定义自己的异常处理类\n  新建类 *CrashHandler* 实现 *Thread.UncaughtExceptionHandler*接口，如下代码：\n```\npublic class CrashHandler implements Thread.UncaughtExceptionHandler {\n\n    @Override\n    public void uncaughtException(Thread thread, Throwable ex) {\n    //回调函数，处理异常出现后的情况\n    }\n}\n```\n## 2.设置该异常类为系统默认的\n将上面定义的异常处理类设置为系统默认的异常处理类，当出现异常时，有该类处理。\n```\nThread.setDefaultUncaughtExceptionHandler(crashHandler);\n```\n## 3.具体的实现\n为了方便查看和修复异常，这里将出现异常的手机信息和异常信息保存在文件，以便传给服务器，具体实现如下：\n```\nimport android.content.Context;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.os.Build;\nimport android.os.Environment;\nimport android.os.Looper;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * 异常管理类\n * <p/>\n * Created by imtianx on 2016-7-10.\n */\npublic class CrashHandler implements Thread.UncaughtExceptionHandler {\n\n    /**\n     * 系统默认UncaughtExceptionHandler\n     */\n    private Thread.UncaughtExceptionHandler mDefaultHandler;\n\n    /**\n     * context\n     */\n    private Context mContext;\n\n    /**\n     * 存储异常和参数信息\n     */\n    private Map<String, String> paramsMap = new HashMap<>();\n\n    /**\n     * 格式化时间\n     */\n    private SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\n\n    private String TAG = this.getClass().getSimpleName();\n\n    private static CrashHandler mInstance;\n\n    private CrashHandler() {\n\n    }\n\n    /**\n     * 获取CrashHandler实例\n     */\n    public static synchronized CrashHandler getInstance() {\n        if (null == mInstance) {\n            mInstance = new CrashHandler();\n        }\n        return mInstance;\n    }\n\n    public void init(Context context) {\n        mContext = context;\n        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\n        //设置该CrashHandler为系统默认的\n        Thread.setDefaultUncaughtExceptionHandler(this);\n    }\n\n    /**\n     * uncaughtException 回调函数\n     */\n    @Override\n    public void uncaughtException(Thread thread, Throwable ex) {\n        if (!handleException(ex) && mDefaultHandler != null) {\n            //如果自己没处理交给系统处理\n            mDefaultHandler.uncaughtException(thread, ex);\n        } else {\n            //自己处理\n            try {//延迟3秒杀进程\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                Log.e(TAG, \"error : \", e);\n            }\n            //退出程序\n            AppManager.getAppManager().AppExit(mContext);\n        }\n\n    }\n\n    /**\n     * 收集错误信息.发送到服务器\n     *\n     * @return 处理了该异常返回true, 否则false\n     */\n    private boolean handleException(Throwable ex) {\n        if (ex == null) {\n            return false;\n        }\n        //收集设备参数信息\n        collectDeviceInfo(mContext);\n        //添加自定义信息\n        addCustomInfo();\n        //使用Toast来显示异常信息\n        new Thread() {\n            @Override\n            public void run() {\n                Looper.prepare();\n                //在此处处理出现异常的情况\n                Toast.makeText(mContext, \"程序开小差了呢..\", Toast.LENGTH_SHORT).show();\n                Looper.loop();\n            }\n        }.start();\n        //保存日志文件\n        saveCrashInfo2File(ex);\n        return true;\n    }\n\n\n    /**\n     * 收集设备参数信息\n     *\n     * @param ctx\n     */\n    public void collectDeviceInfo(Context ctx) {\n        //获取versionName,versionCode\n        try {\n            PackageManager pm = ctx.getPackageManager();\n            PackageInfo pi = pm.getPackageInfo(ctx.getPackageName(), PackageManager.GET_ACTIVITIES);\n            if (pi != null) {\n                String versionName = pi.versionName == null ? \"null\" : pi.versionName;\n                String versionCode = pi.versionCode + \"\";\n                paramsMap.put(\"versionName\", versionName);\n                paramsMap.put(\"versionCode\", versionCode);\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            Log.e(TAG, \"an error occured when collect package info\", e);\n        }\n        //获取所有系统信息\n        Field[] fields = Build.class.getDeclaredFields();\n        for (Field field : fields) {\n            try {\n                field.setAccessible(true);\n                paramsMap.put(field.getName(), field.get(null).toString());\n            } catch (Exception e) {\n                Log.e(TAG, \"an error occured when collect crash info\", e);\n            }\n        }\n    }\n\n    /**\n     * 添加自定义参数\n     */\n    private void addCustomInfo() {\n        Log.i(TAG, \"addCustomInfo: 程序出错了...\");\n    }\n\n    /**\n     * 保存错误信息到文件中\n     *\n     * @param ex\n     * @return 返回文件名称, 便于将文件传送到服务器\n     */\n    private String saveCrashInfo2File(Throwable ex) {\n\n        StringBuffer sb = new StringBuffer();\n        for (Map.Entry<String, String> entry : paramsMap.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            sb.append(key + \"=\" + value + \"\\n\");\n        }\n\n        Writer writer = new StringWriter();\n        PrintWriter printWriter = new PrintWriter(writer);\n        ex.printStackTrace(printWriter);\n        Throwable cause = ex.getCause();\n        while (cause != null) {\n            cause.printStackTrace(printWriter);\n            cause = cause.getCause();\n        }\n        printWriter.close();\n        String result = writer.toString();\n        sb.append(result);\n        try {\n            long timestamp = System.currentTimeMillis();\n            String time = format.format(new Date());\n            String fileName = \"crash-\" + time + \"-\" + timestamp + \".log\";\n            if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n                String path = Environment.getExternalStorageDirectory().getAbsolutePath() + \"/crash/\";\n                File dir = new File(path);\n                if (!dir.exists()) {\n                    dir.mkdirs();\n                }\n                FileOutputStream fos = new FileOutputStream(path + fileName);\n                fos.write(sb.toString().getBytes());\n                Log.i(TAG, \"saveCrashInfo2File: \"+sb.toString());\n                fos.close();\n            }\n            return fileName;\n        } catch (Exception e) {\n            Log.e(TAG, \"an error occured while writing file...\", e);\n        }\n        return null;\n    }\n}\n```\n注：在上述代码中使用了 AppManager类，是常用的activity 管理类 [点此查看](https://github.com/txadf/Android_Study_Notes/tree/master/android-tools/AppManager.md)\n## 4.实际使用\n在application中初始化，并在配置文件中添加读写权限。\n```\n CrashHandler.getInstance().init(this);\n```\n到此，全局异常捕获已全部完成。\n\n\n\n","source":"_posts/android-exception-catch-UncaughtExceptionHandler.md","raw":"---\ntitle: android 异常捕获-UncaughtExceptionHandler\ndate: 2016-07-10 16:06:25\ncategories: [android,学习笔记]\ntags: [android,异常捕获]\n---\n\n在android开发中，异常信息的捕获有多种方式，比如第三方的友盟、蒲公英等，这里主要使用 android 原生的 Thread.UncaughtExceptionHandler 来捕获出现的异常信息<!--more-->,并给出友好的提示，避免出现停止运行，提高用户体验，下面是具体的实现过程。\n\n[转自： Android 全局异常捕获](http://blog.csdn.net/zly921112/article/details/51867079)\n## 1.定义自己的异常处理类\n  新建类 *CrashHandler* 实现 *Thread.UncaughtExceptionHandler*接口，如下代码：\n```\npublic class CrashHandler implements Thread.UncaughtExceptionHandler {\n\n    @Override\n    public void uncaughtException(Thread thread, Throwable ex) {\n    //回调函数，处理异常出现后的情况\n    }\n}\n```\n## 2.设置该异常类为系统默认的\n将上面定义的异常处理类设置为系统默认的异常处理类，当出现异常时，有该类处理。\n```\nThread.setDefaultUncaughtExceptionHandler(crashHandler);\n```\n## 3.具体的实现\n为了方便查看和修复异常，这里将出现异常的手机信息和异常信息保存在文件，以便传给服务器，具体实现如下：\n```\nimport android.content.Context;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.os.Build;\nimport android.os.Environment;\nimport android.os.Looper;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * 异常管理类\n * <p/>\n * Created by imtianx on 2016-7-10.\n */\npublic class CrashHandler implements Thread.UncaughtExceptionHandler {\n\n    /**\n     * 系统默认UncaughtExceptionHandler\n     */\n    private Thread.UncaughtExceptionHandler mDefaultHandler;\n\n    /**\n     * context\n     */\n    private Context mContext;\n\n    /**\n     * 存储异常和参数信息\n     */\n    private Map<String, String> paramsMap = new HashMap<>();\n\n    /**\n     * 格式化时间\n     */\n    private SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\n\n    private String TAG = this.getClass().getSimpleName();\n\n    private static CrashHandler mInstance;\n\n    private CrashHandler() {\n\n    }\n\n    /**\n     * 获取CrashHandler实例\n     */\n    public static synchronized CrashHandler getInstance() {\n        if (null == mInstance) {\n            mInstance = new CrashHandler();\n        }\n        return mInstance;\n    }\n\n    public void init(Context context) {\n        mContext = context;\n        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\n        //设置该CrashHandler为系统默认的\n        Thread.setDefaultUncaughtExceptionHandler(this);\n    }\n\n    /**\n     * uncaughtException 回调函数\n     */\n    @Override\n    public void uncaughtException(Thread thread, Throwable ex) {\n        if (!handleException(ex) && mDefaultHandler != null) {\n            //如果自己没处理交给系统处理\n            mDefaultHandler.uncaughtException(thread, ex);\n        } else {\n            //自己处理\n            try {//延迟3秒杀进程\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                Log.e(TAG, \"error : \", e);\n            }\n            //退出程序\n            AppManager.getAppManager().AppExit(mContext);\n        }\n\n    }\n\n    /**\n     * 收集错误信息.发送到服务器\n     *\n     * @return 处理了该异常返回true, 否则false\n     */\n    private boolean handleException(Throwable ex) {\n        if (ex == null) {\n            return false;\n        }\n        //收集设备参数信息\n        collectDeviceInfo(mContext);\n        //添加自定义信息\n        addCustomInfo();\n        //使用Toast来显示异常信息\n        new Thread() {\n            @Override\n            public void run() {\n                Looper.prepare();\n                //在此处处理出现异常的情况\n                Toast.makeText(mContext, \"程序开小差了呢..\", Toast.LENGTH_SHORT).show();\n                Looper.loop();\n            }\n        }.start();\n        //保存日志文件\n        saveCrashInfo2File(ex);\n        return true;\n    }\n\n\n    /**\n     * 收集设备参数信息\n     *\n     * @param ctx\n     */\n    public void collectDeviceInfo(Context ctx) {\n        //获取versionName,versionCode\n        try {\n            PackageManager pm = ctx.getPackageManager();\n            PackageInfo pi = pm.getPackageInfo(ctx.getPackageName(), PackageManager.GET_ACTIVITIES);\n            if (pi != null) {\n                String versionName = pi.versionName == null ? \"null\" : pi.versionName;\n                String versionCode = pi.versionCode + \"\";\n                paramsMap.put(\"versionName\", versionName);\n                paramsMap.put(\"versionCode\", versionCode);\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            Log.e(TAG, \"an error occured when collect package info\", e);\n        }\n        //获取所有系统信息\n        Field[] fields = Build.class.getDeclaredFields();\n        for (Field field : fields) {\n            try {\n                field.setAccessible(true);\n                paramsMap.put(field.getName(), field.get(null).toString());\n            } catch (Exception e) {\n                Log.e(TAG, \"an error occured when collect crash info\", e);\n            }\n        }\n    }\n\n    /**\n     * 添加自定义参数\n     */\n    private void addCustomInfo() {\n        Log.i(TAG, \"addCustomInfo: 程序出错了...\");\n    }\n\n    /**\n     * 保存错误信息到文件中\n     *\n     * @param ex\n     * @return 返回文件名称, 便于将文件传送到服务器\n     */\n    private String saveCrashInfo2File(Throwable ex) {\n\n        StringBuffer sb = new StringBuffer();\n        for (Map.Entry<String, String> entry : paramsMap.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            sb.append(key + \"=\" + value + \"\\n\");\n        }\n\n        Writer writer = new StringWriter();\n        PrintWriter printWriter = new PrintWriter(writer);\n        ex.printStackTrace(printWriter);\n        Throwable cause = ex.getCause();\n        while (cause != null) {\n            cause.printStackTrace(printWriter);\n            cause = cause.getCause();\n        }\n        printWriter.close();\n        String result = writer.toString();\n        sb.append(result);\n        try {\n            long timestamp = System.currentTimeMillis();\n            String time = format.format(new Date());\n            String fileName = \"crash-\" + time + \"-\" + timestamp + \".log\";\n            if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n                String path = Environment.getExternalStorageDirectory().getAbsolutePath() + \"/crash/\";\n                File dir = new File(path);\n                if (!dir.exists()) {\n                    dir.mkdirs();\n                }\n                FileOutputStream fos = new FileOutputStream(path + fileName);\n                fos.write(sb.toString().getBytes());\n                Log.i(TAG, \"saveCrashInfo2File: \"+sb.toString());\n                fos.close();\n            }\n            return fileName;\n        } catch (Exception e) {\n            Log.e(TAG, \"an error occured while writing file...\", e);\n        }\n        return null;\n    }\n}\n```\n注：在上述代码中使用了 AppManager类，是常用的activity 管理类 [点此查看](https://github.com/txadf/Android_Study_Notes/tree/master/android-tools/AppManager.md)\n## 4.实际使用\n在application中初始化，并在配置文件中添加读写权限。\n```\n CrashHandler.getInstance().init(this);\n```\n到此，全局异常捕获已全部完成。\n\n\n\n","slug":"android-exception-catch-UncaughtExceptionHandler","published":1,"updated":"2016-07-10T11:23:00.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucg5001bg0g5mzr2w7rg","content":"<p>在android开发中，异常信息的捕获有多种方式，比如第三方的友盟、蒲公英等，这里主要使用 android 原生的 Thread.UncaughtExceptionHandler 来捕获出现的异常信息<a id=\"more\"></a>,并给出友好的提示，避免出现停止运行，提高用户体验，下面是具体的实现过程。</p>\n<p><a href=\"http://blog.csdn.net/zly921112/article/details/51867079\" target=\"_blank\" rel=\"external\">转自： Android 全局异常捕获</a></p>\n<h2 id=\"1-定义自己的异常处理类\"><a href=\"#1-定义自己的异常处理类\" class=\"headerlink\" title=\"1.定义自己的异常处理类\"></a>1.定义自己的异常处理类</h2><p>  新建类 <em>CrashHandler</em> 实现 <em>Thread.UncaughtExceptionHandler</em>接口，如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CrashHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void uncaughtException(Thread thread, Throwable ex) &#123;</span><br><span class=\"line\">    //回调函数，处理异常出现后的情况</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-设置该异常类为系统默认的\"><a href=\"#2-设置该异常类为系统默认的\" class=\"headerlink\" title=\"2.设置该异常类为系统默认的\"></a>2.设置该异常类为系统默认的</h2><p>将上面定义的异常处理类设置为系统默认的异常处理类，当出现异常时，有该类处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread.setDefaultUncaughtExceptionHandler(crashHandler);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-具体的实现\"><a href=\"#3-具体的实现\" class=\"headerlink\" title=\"3.具体的实现\"></a>3.具体的实现</h2><p>为了方便查看和修复异常，这里将出现异常的手机信息和异常信息保存在文件，以便传给服务器，具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.content.pm.PackageInfo;</span><br><span class=\"line\">import android.content.pm.PackageManager;</span><br><span class=\"line\">import android.os.Build;</span><br><span class=\"line\">import android.os.Environment;</span><br><span class=\"line\">import android.os.Looper;</span><br><span class=\"line\">import android.util.Log;</span><br><span class=\"line\">import android.widget.Toast;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.File;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.PrintWriter;</span><br><span class=\"line\">import java.io.StringWriter;</span><br><span class=\"line\">import java.io.Writer;</span><br><span class=\"line\">import java.lang.reflect.Field;</span><br><span class=\"line\">import java.text.SimpleDateFormat;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 异常管理类</span><br><span class=\"line\"> * &lt;p/&gt;</span><br><span class=\"line\"> * Created by imtianx on 2016-7-10.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CrashHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 系统默认UncaughtExceptionHandler</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Thread.UncaughtExceptionHandler mDefaultHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * context</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Context mContext;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 存储异常和参数信息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Map&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 格式化时间</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd-HH-mm-ss&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    private String TAG = this.getClass().getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    private static CrashHandler mInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    private CrashHandler() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取CrashHandler实例</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static synchronized CrashHandler getInstance() &#123;</span><br><span class=\"line\">        if (null == mInstance) &#123;</span><br><span class=\"line\">            mInstance = new CrashHandler();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return mInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void init(Context context) &#123;</span><br><span class=\"line\">        mContext = context;</span><br><span class=\"line\">        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();</span><br><span class=\"line\">        //设置该CrashHandler为系统默认的</span><br><span class=\"line\">        Thread.setDefaultUncaughtExceptionHandler(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * uncaughtException 回调函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void uncaughtException(Thread thread, Throwable ex) &#123;</span><br><span class=\"line\">        if (!handleException(ex) &amp;&amp; mDefaultHandler != null) &#123;</span><br><span class=\"line\">            //如果自己没处理交给系统处理</span><br><span class=\"line\">            mDefaultHandler.uncaughtException(thread, ex);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //自己处理</span><br><span class=\"line\">            try &#123;//延迟3秒杀进程</span><br><span class=\"line\">                Thread.sleep(2000);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                Log.e(TAG, &quot;error : &quot;, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //退出程序</span><br><span class=\"line\">            AppManager.getAppManager().AppExit(mContext);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 收集错误信息.发送到服务器</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return 处理了该异常返回true, 否则false</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private boolean handleException(Throwable ex) &#123;</span><br><span class=\"line\">        if (ex == null) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //收集设备参数信息</span><br><span class=\"line\">        collectDeviceInfo(mContext);</span><br><span class=\"line\">        //添加自定义信息</span><br><span class=\"line\">        addCustomInfo();</span><br><span class=\"line\">        //使用Toast来显示异常信息</span><br><span class=\"line\">        new Thread() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                Looper.prepare();</span><br><span class=\"line\">                //在此处处理出现异常的情况</span><br><span class=\"line\">                Toast.makeText(mContext, &quot;程序开小差了呢..&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">                Looper.loop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">        //保存日志文件</span><br><span class=\"line\">        saveCrashInfo2File(ex);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 收集设备参数信息</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param ctx</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void collectDeviceInfo(Context ctx) &#123;</span><br><span class=\"line\">        //获取versionName,versionCode</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            PackageManager pm = ctx.getPackageManager();</span><br><span class=\"line\">            PackageInfo pi = pm.getPackageInfo(ctx.getPackageName(), PackageManager.GET_ACTIVITIES);</span><br><span class=\"line\">            if (pi != null) &#123;</span><br><span class=\"line\">                String versionName = pi.versionName == null ? &quot;null&quot; : pi.versionName;</span><br><span class=\"line\">                String versionCode = pi.versionCode + &quot;&quot;;</span><br><span class=\"line\">                paramsMap.put(&quot;versionName&quot;, versionName);</span><br><span class=\"line\">                paramsMap.put(&quot;versionCode&quot;, versionCode);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class=\"line\">            Log.e(TAG, &quot;an error occured when collect package info&quot;, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //获取所有系统信息</span><br><span class=\"line\">        Field[] fields = Build.class.getDeclaredFields();</span><br><span class=\"line\">        for (Field field : fields) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                field.setAccessible(true);</span><br><span class=\"line\">                paramsMap.put(field.getName(), field.get(null).toString());</span><br><span class=\"line\">            &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                Log.e(TAG, &quot;an error occured when collect crash info&quot;, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 添加自定义参数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void addCustomInfo() &#123;</span><br><span class=\"line\">        Log.i(TAG, &quot;addCustomInfo: 程序出错了...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 保存错误信息到文件中</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param ex</span><br><span class=\"line\">     * @return 返回文件名称, 便于将文件传送到服务器</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String saveCrashInfo2File(Throwable ex) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        StringBuffer sb = new StringBuffer();</span><br><span class=\"line\">        for (Map.Entry&lt;String, String&gt; entry : paramsMap.entrySet()) &#123;</span><br><span class=\"line\">            String key = entry.getKey();</span><br><span class=\"line\">            String value = entry.getValue();</span><br><span class=\"line\">            sb.append(key + &quot;=&quot; + value + &quot;\\n&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Writer writer = new StringWriter();</span><br><span class=\"line\">        PrintWriter printWriter = new PrintWriter(writer);</span><br><span class=\"line\">        ex.printStackTrace(printWriter);</span><br><span class=\"line\">        Throwable cause = ex.getCause();</span><br><span class=\"line\">        while (cause != null) &#123;</span><br><span class=\"line\">            cause.printStackTrace(printWriter);</span><br><span class=\"line\">            cause = cause.getCause();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        printWriter.close();</span><br><span class=\"line\">        String result = writer.toString();</span><br><span class=\"line\">        sb.append(result);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            long timestamp = System.currentTimeMillis();</span><br><span class=\"line\">            String time = format.format(new Date());</span><br><span class=\"line\">            String fileName = &quot;crash-&quot; + time + &quot;-&quot; + timestamp + &quot;.log&quot;;</span><br><span class=\"line\">            if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class=\"line\">                String path = Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/crash/&quot;;</span><br><span class=\"line\">                File dir = new File(path);</span><br><span class=\"line\">                if (!dir.exists()) &#123;</span><br><span class=\"line\">                    dir.mkdirs();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                FileOutputStream fos = new FileOutputStream(path + fileName);</span><br><span class=\"line\">                fos.write(sb.toString().getBytes());</span><br><span class=\"line\">                Log.i(TAG, &quot;saveCrashInfo2File: &quot;+sb.toString());</span><br><span class=\"line\">                fos.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return fileName;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            Log.e(TAG, &quot;an error occured while writing file...&quot;, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注：在上述代码中使用了 AppManager类，是常用的activity 管理类 <a href=\"https://github.com/txadf/Android_Study_Notes/tree/master/android-tools/AppManager.md\" target=\"_blank\" rel=\"external\">点此查看</a></p>\n<h2 id=\"4-实际使用\"><a href=\"#4-实际使用\" class=\"headerlink\" title=\"4.实际使用\"></a>4.实际使用</h2><p>在application中初始化，并在配置文件中添加读写权限。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CrashHandler.getInstance().init(this);</span><br></pre></td></tr></table></figure></p>\n<p>到此，全局异常捕获已全部完成。</p>\n","excerpt":"<p>在android开发中，异常信息的捕获有多种方式，比如第三方的友盟、蒲公英等，这里主要使用 android 原生的 Thread.UncaughtExceptionHandler 来捕获出现的异常信息","more":",并给出友好的提示，避免出现停止运行，提高用户体验，下面是具体的实现过程。</p>\n<p><a href=\"http://blog.csdn.net/zly921112/article/details/51867079\">转自： Android 全局异常捕获</a></p>\n<h2 id=\"1-定义自己的异常处理类\"><a href=\"#1-定义自己的异常处理类\" class=\"headerlink\" title=\"1.定义自己的异常处理类\"></a>1.定义自己的异常处理类</h2><p>  新建类 <em>CrashHandler</em> 实现 <em>Thread.UncaughtExceptionHandler</em>接口，如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CrashHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void uncaughtException(Thread thread, Throwable ex) &#123;</span><br><span class=\"line\">    //回调函数，处理异常出现后的情况</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-设置该异常类为系统默认的\"><a href=\"#2-设置该异常类为系统默认的\" class=\"headerlink\" title=\"2.设置该异常类为系统默认的\"></a>2.设置该异常类为系统默认的</h2><p>将上面定义的异常处理类设置为系统默认的异常处理类，当出现异常时，有该类处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread.setDefaultUncaughtExceptionHandler(crashHandler);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-具体的实现\"><a href=\"#3-具体的实现\" class=\"headerlink\" title=\"3.具体的实现\"></a>3.具体的实现</h2><p>为了方便查看和修复异常，这里将出现异常的手机信息和异常信息保存在文件，以便传给服务器，具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.content.pm.PackageInfo;</span><br><span class=\"line\">import android.content.pm.PackageManager;</span><br><span class=\"line\">import android.os.Build;</span><br><span class=\"line\">import android.os.Environment;</span><br><span class=\"line\">import android.os.Looper;</span><br><span class=\"line\">import android.util.Log;</span><br><span class=\"line\">import android.widget.Toast;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.File;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.PrintWriter;</span><br><span class=\"line\">import java.io.StringWriter;</span><br><span class=\"line\">import java.io.Writer;</span><br><span class=\"line\">import java.lang.reflect.Field;</span><br><span class=\"line\">import java.text.SimpleDateFormat;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 异常管理类</span><br><span class=\"line\"> * &lt;p/&gt;</span><br><span class=\"line\"> * Created by imtianx on 2016-7-10.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CrashHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 系统默认UncaughtExceptionHandler</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Thread.UncaughtExceptionHandler mDefaultHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * context</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Context mContext;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 存储异常和参数信息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Map&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 格式化时间</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd-HH-mm-ss&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    private String TAG = this.getClass().getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    private static CrashHandler mInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    private CrashHandler() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取CrashHandler实例</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static synchronized CrashHandler getInstance() &#123;</span><br><span class=\"line\">        if (null == mInstance) &#123;</span><br><span class=\"line\">            mInstance = new CrashHandler();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return mInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void init(Context context) &#123;</span><br><span class=\"line\">        mContext = context;</span><br><span class=\"line\">        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();</span><br><span class=\"line\">        //设置该CrashHandler为系统默认的</span><br><span class=\"line\">        Thread.setDefaultUncaughtExceptionHandler(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * uncaughtException 回调函数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void uncaughtException(Thread thread, Throwable ex) &#123;</span><br><span class=\"line\">        if (!handleException(ex) &amp;&amp; mDefaultHandler != null) &#123;</span><br><span class=\"line\">            //如果自己没处理交给系统处理</span><br><span class=\"line\">            mDefaultHandler.uncaughtException(thread, ex);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //自己处理</span><br><span class=\"line\">            try &#123;//延迟3秒杀进程</span><br><span class=\"line\">                Thread.sleep(2000);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                Log.e(TAG, &quot;error : &quot;, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //退出程序</span><br><span class=\"line\">            AppManager.getAppManager().AppExit(mContext);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 收集错误信息.发送到服务器</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return 处理了该异常返回true, 否则false</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private boolean handleException(Throwable ex) &#123;</span><br><span class=\"line\">        if (ex == null) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //收集设备参数信息</span><br><span class=\"line\">        collectDeviceInfo(mContext);</span><br><span class=\"line\">        //添加自定义信息</span><br><span class=\"line\">        addCustomInfo();</span><br><span class=\"line\">        //使用Toast来显示异常信息</span><br><span class=\"line\">        new Thread() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                Looper.prepare();</span><br><span class=\"line\">                //在此处处理出现异常的情况</span><br><span class=\"line\">                Toast.makeText(mContext, &quot;程序开小差了呢..&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">                Looper.loop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">        //保存日志文件</span><br><span class=\"line\">        saveCrashInfo2File(ex);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 收集设备参数信息</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param ctx</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void collectDeviceInfo(Context ctx) &#123;</span><br><span class=\"line\">        //获取versionName,versionCode</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            PackageManager pm = ctx.getPackageManager();</span><br><span class=\"line\">            PackageInfo pi = pm.getPackageInfo(ctx.getPackageName(), PackageManager.GET_ACTIVITIES);</span><br><span class=\"line\">            if (pi != null) &#123;</span><br><span class=\"line\">                String versionName = pi.versionName == null ? &quot;null&quot; : pi.versionName;</span><br><span class=\"line\">                String versionCode = pi.versionCode + &quot;&quot;;</span><br><span class=\"line\">                paramsMap.put(&quot;versionName&quot;, versionName);</span><br><span class=\"line\">                paramsMap.put(&quot;versionCode&quot;, versionCode);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class=\"line\">            Log.e(TAG, &quot;an error occured when collect package info&quot;, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //获取所有系统信息</span><br><span class=\"line\">        Field[] fields = Build.class.getDeclaredFields();</span><br><span class=\"line\">        for (Field field : fields) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                field.setAccessible(true);</span><br><span class=\"line\">                paramsMap.put(field.getName(), field.get(null).toString());</span><br><span class=\"line\">            &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                Log.e(TAG, &quot;an error occured when collect crash info&quot;, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 添加自定义参数</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void addCustomInfo() &#123;</span><br><span class=\"line\">        Log.i(TAG, &quot;addCustomInfo: 程序出错了...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 保存错误信息到文件中</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param ex</span><br><span class=\"line\">     * @return 返回文件名称, 便于将文件传送到服务器</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String saveCrashInfo2File(Throwable ex) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        StringBuffer sb = new StringBuffer();</span><br><span class=\"line\">        for (Map.Entry&lt;String, String&gt; entry : paramsMap.entrySet()) &#123;</span><br><span class=\"line\">            String key = entry.getKey();</span><br><span class=\"line\">            String value = entry.getValue();</span><br><span class=\"line\">            sb.append(key + &quot;=&quot; + value + &quot;\\n&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Writer writer = new StringWriter();</span><br><span class=\"line\">        PrintWriter printWriter = new PrintWriter(writer);</span><br><span class=\"line\">        ex.printStackTrace(printWriter);</span><br><span class=\"line\">        Throwable cause = ex.getCause();</span><br><span class=\"line\">        while (cause != null) &#123;</span><br><span class=\"line\">            cause.printStackTrace(printWriter);</span><br><span class=\"line\">            cause = cause.getCause();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        printWriter.close();</span><br><span class=\"line\">        String result = writer.toString();</span><br><span class=\"line\">        sb.append(result);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            long timestamp = System.currentTimeMillis();</span><br><span class=\"line\">            String time = format.format(new Date());</span><br><span class=\"line\">            String fileName = &quot;crash-&quot; + time + &quot;-&quot; + timestamp + &quot;.log&quot;;</span><br><span class=\"line\">            if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class=\"line\">                String path = Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/crash/&quot;;</span><br><span class=\"line\">                File dir = new File(path);</span><br><span class=\"line\">                if (!dir.exists()) &#123;</span><br><span class=\"line\">                    dir.mkdirs();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                FileOutputStream fos = new FileOutputStream(path + fileName);</span><br><span class=\"line\">                fos.write(sb.toString().getBytes());</span><br><span class=\"line\">                Log.i(TAG, &quot;saveCrashInfo2File: &quot;+sb.toString());</span><br><span class=\"line\">                fos.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return fileName;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            Log.e(TAG, &quot;an error occured while writing file...&quot;, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注：在上述代码中使用了 AppManager类，是常用的activity 管理类 <a href=\"https://github.com/txadf/Android_Study_Notes/tree/master/android-tools/AppManager.md\">点此查看</a></p>\n<h2 id=\"4-实际使用\"><a href=\"#4-实际使用\" class=\"headerlink\" title=\"4.实际使用\"></a>4.实际使用</h2><p>在application中初始化，并在配置文件中添加读写权限。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CrashHandler.getInstance().init(this);</span><br></pre></td></tr></table></figure></p>\n<p>到此，全局异常捕获已全部完成。</p>"},{"title":"android 开源库（字体图标，MD控件等）","date":"2016-06-12T07:00:25.000Z","_content":"记录自己最近在开发中使用的开源库及部分使用方法，链接地址为个人fork后的地址，可以参见原作者仓库。本文将持续更新，大家有什么好用的可以留言，一起交流学习下。\n<!--more-->\n\n### 1. android 开发常用工具类\n地址：https://github.com/txadf/Lazy\n\n### 2. 字体图标\n地址：https://github.com/txadf/material-icon-lib\n用法：\n2.1.添加依赖\n```\ncompile 'net.steamcrafted:materialiconlib:1.0.9'\n```\n2.2.xml中使用\n注:需要添加命名空间\n```\n<net.steamcrafted.materialiconlib.MaterialIconView\n        xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n        android:id=\"@+id/icon\"\n        android:layout_width=\"24dp\"\n        android:layout_height=\"24dp\"\n        android:scaleType=\"center\"\n        app:materialIcon=\"account\"\n        app:materialIconColor=\"@color/mainColor\"\n        app:materialIconSize=\"24dp\"/>\n```\n示例效果：\n![](https://camo.githubusercontent.com/802f5408fb1caeae9647d6e72c5905225b24220d/687474703a2f2f692e696d6775722e636f6d2f4b584866586f382e676966)\n\n### 3. UI Model\n地址：http://genius.qiujuer.net/module/ui.html\n按原作者网上站上的配置。\n具体使用，按钮的使用：\n```\n<net.qiujuer.genius.ui.widget.Button\n            xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n            android:id=\"@+id/gbtn_login\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_marginTop=\"25dp\"\n            android:background=\"@color/mainColor\"\n            android:onClick=\"LoginClickEvent\"\n            android:text=\"@string/login_btn\"\n            android:textColor=\"@color/white\"\n            app:gFont=\"roboto.ttf\"\n            app:gTouchColor=\"@color/black_alpha_32\"\n            app:gTouchDurationRate=\"0.7\"\n            app:gTouchEffect=\"ripple\"/>\n```\n同样需要注意添加命名空间。\n### 4. xutils3\n地址：https://github.com/txadf/xUtils3\n### 5.进度条\n地址：https://github.com/txadf/spots-dialog\n效果：\n![](https://camo.githubusercontent.com/d8108413298d70047f52cff9ac05603a5fd51988/687474703a2f2f332e62702e626c6f6773706f742e636f6d2f2d6c3155765657694d5341672f564c61355a6657346444492f41414141414141414e54632f7273576f755f71623042632f733332302f593648615453772e676966)\n\n### 6.对话框\n地址:https://github.com/txadf/sweet-alert-dialog\n示例效果：\n![](https://github.com/pedant/sweet-alert-dialog/raw/master/change_type.gif)\n\n### 7. EventBus\n地址：https://github.com/txadf/EventBus\n注意：在使用，进行注册订阅时，使用下面的方式，其中“XXX”表示需要订阅的Activity或者Fragment名，避免直接使用“this”：\n```\nEventBus.getDefault().register(XXX.this);\n```\n","source":"_posts/android-open-source-connected.md","raw":"---\ntitle: android 开源库（字体图标，MD控件等）\ndate: 2016-06-12 15:00:25\ncategories: [android,开源库]\ntags: [android,开源框架]\n---\n记录自己最近在开发中使用的开源库及部分使用方法，链接地址为个人fork后的地址，可以参见原作者仓库。本文将持续更新，大家有什么好用的可以留言，一起交流学习下。\n<!--more-->\n\n### 1. android 开发常用工具类\n地址：https://github.com/txadf/Lazy\n\n### 2. 字体图标\n地址：https://github.com/txadf/material-icon-lib\n用法：\n2.1.添加依赖\n```\ncompile 'net.steamcrafted:materialiconlib:1.0.9'\n```\n2.2.xml中使用\n注:需要添加命名空间\n```\n<net.steamcrafted.materialiconlib.MaterialIconView\n        xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n        android:id=\"@+id/icon\"\n        android:layout_width=\"24dp\"\n        android:layout_height=\"24dp\"\n        android:scaleType=\"center\"\n        app:materialIcon=\"account\"\n        app:materialIconColor=\"@color/mainColor\"\n        app:materialIconSize=\"24dp\"/>\n```\n示例效果：\n![](https://camo.githubusercontent.com/802f5408fb1caeae9647d6e72c5905225b24220d/687474703a2f2f692e696d6775722e636f6d2f4b584866586f382e676966)\n\n### 3. UI Model\n地址：http://genius.qiujuer.net/module/ui.html\n按原作者网上站上的配置。\n具体使用，按钮的使用：\n```\n<net.qiujuer.genius.ui.widget.Button\n            xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n            android:id=\"@+id/gbtn_login\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_marginTop=\"25dp\"\n            android:background=\"@color/mainColor\"\n            android:onClick=\"LoginClickEvent\"\n            android:text=\"@string/login_btn\"\n            android:textColor=\"@color/white\"\n            app:gFont=\"roboto.ttf\"\n            app:gTouchColor=\"@color/black_alpha_32\"\n            app:gTouchDurationRate=\"0.7\"\n            app:gTouchEffect=\"ripple\"/>\n```\n同样需要注意添加命名空间。\n### 4. xutils3\n地址：https://github.com/txadf/xUtils3\n### 5.进度条\n地址：https://github.com/txadf/spots-dialog\n效果：\n![](https://camo.githubusercontent.com/d8108413298d70047f52cff9ac05603a5fd51988/687474703a2f2f332e62702e626c6f6773706f742e636f6d2f2d6c3155765657694d5341672f564c61355a6657346444492f41414141414141414e54632f7273576f755f71623042632f733332302f593648615453772e676966)\n\n### 6.对话框\n地址:https://github.com/txadf/sweet-alert-dialog\n示例效果：\n![](https://github.com/pedant/sweet-alert-dialog/raw/master/change_type.gif)\n\n### 7. EventBus\n地址：https://github.com/txadf/EventBus\n注意：在使用，进行注册订阅时，使用下面的方式，其中“XXX”表示需要订阅的Activity或者Fragment名，避免直接使用“this”：\n```\nEventBus.getDefault().register(XXX.this);\n```\n","slug":"android-open-source-connected","published":1,"updated":"2016-07-15T02:55:56.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucgl001eg0g5k4yq5q7i","content":"<p>记录自己最近在开发中使用的开源库及部分使用方法，链接地址为个人fork后的地址，可以参见原作者仓库。本文将持续更新，大家有什么好用的可以留言，一起交流学习下。<br><a id=\"more\"></a></p>\n<h3 id=\"1-android-开发常用工具类\"><a href=\"#1-android-开发常用工具类\" class=\"headerlink\" title=\"1. android 开发常用工具类\"></a>1. android 开发常用工具类</h3><p>地址：<a href=\"https://github.com/txadf/Lazy\" target=\"_blank\" rel=\"external\">https://github.com/txadf/Lazy</a></p>\n<h3 id=\"2-字体图标\"><a href=\"#2-字体图标\" class=\"headerlink\" title=\"2. 字体图标\"></a>2. 字体图标</h3><p>地址：<a href=\"https://github.com/txadf/material-icon-lib\" target=\"_blank\" rel=\"external\">https://github.com/txadf/material-icon-lib</a><br>用法：<br>2.1.添加依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &apos;net.steamcrafted:materialiconlib:1.0.9&apos;</span><br></pre></td></tr></table></figure></p>\n<p>2.2.xml中使用<br>注:需要添加命名空间<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;net.steamcrafted.materialiconlib.MaterialIconView</span><br><span class=\"line\">        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class=\"line\">        android:id=&quot;@+id/icon&quot;</span><br><span class=\"line\">        android:layout_width=&quot;24dp&quot;</span><br><span class=\"line\">        android:layout_height=&quot;24dp&quot;</span><br><span class=\"line\">        android:scaleType=&quot;center&quot;</span><br><span class=\"line\">        app:materialIcon=&quot;account&quot;</span><br><span class=\"line\">        app:materialIconColor=&quot;@color/mainColor&quot;</span><br><span class=\"line\">        app:materialIconSize=&quot;24dp&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>示例效果：<br><img src=\"https://camo.githubusercontent.com/802f5408fb1caeae9647d6e72c5905225b24220d/687474703a2f2f692e696d6775722e636f6d2f4b584866586f382e676966\" alt=\"\"></p>\n<h3 id=\"3-UI-Model\"><a href=\"#3-UI-Model\" class=\"headerlink\" title=\"3. UI Model\"></a>3. UI Model</h3><p>地址：<a href=\"http://genius.qiujuer.net/module/ui.html\" target=\"_blank\" rel=\"external\">http://genius.qiujuer.net/module/ui.html</a><br>按原作者网上站上的配置。<br>具体使用，按钮的使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;net.qiujuer.genius.ui.widget.Button</span><br><span class=\"line\">            xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class=\"line\">            android:id=&quot;@+id/gbtn_login&quot;</span><br><span class=\"line\">            android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">            android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:layout_marginTop=&quot;25dp&quot;</span><br><span class=\"line\">            android:background=&quot;@color/mainColor&quot;</span><br><span class=\"line\">            android:onClick=&quot;LoginClickEvent&quot;</span><br><span class=\"line\">            android:text=&quot;@string/login_btn&quot;</span><br><span class=\"line\">            android:textColor=&quot;@color/white&quot;</span><br><span class=\"line\">            app:gFont=&quot;roboto.ttf&quot;</span><br><span class=\"line\">            app:gTouchColor=&quot;@color/black_alpha_32&quot;</span><br><span class=\"line\">            app:gTouchDurationRate=&quot;0.7&quot;</span><br><span class=\"line\">            app:gTouchEffect=&quot;ripple&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>同样需要注意添加命名空间。</p>\n<h3 id=\"4-xutils3\"><a href=\"#4-xutils3\" class=\"headerlink\" title=\"4. xutils3\"></a>4. xutils3</h3><p>地址：<a href=\"https://github.com/txadf/xUtils3\" target=\"_blank\" rel=\"external\">https://github.com/txadf/xUtils3</a></p>\n<h3 id=\"5-进度条\"><a href=\"#5-进度条\" class=\"headerlink\" title=\"5.进度条\"></a>5.进度条</h3><p>地址：<a href=\"https://github.com/txadf/spots-dialog\" target=\"_blank\" rel=\"external\">https://github.com/txadf/spots-dialog</a><br>效果：<br><img src=\"https://camo.githubusercontent.com/d8108413298d70047f52cff9ac05603a5fd51988/687474703a2f2f332e62702e626c6f6773706f742e636f6d2f2d6c3155765657694d5341672f564c61355a6657346444492f41414141414141414e54632f7273576f755f71623042632f733332302f593648615453772e676966\" alt=\"\"></p>\n<h3 id=\"6-对话框\"><a href=\"#6-对话框\" class=\"headerlink\" title=\"6.对话框\"></a>6.对话框</h3><p>地址:<a href=\"https://github.com/txadf/sweet-alert-dialog\" target=\"_blank\" rel=\"external\">https://github.com/txadf/sweet-alert-dialog</a><br>示例效果：<br><img src=\"https://github.com/pedant/sweet-alert-dialog/raw/master/change_type.gif\" alt=\"\"></p>\n<h3 id=\"7-EventBus\"><a href=\"#7-EventBus\" class=\"headerlink\" title=\"7. EventBus\"></a>7. EventBus</h3><p>地址：<a href=\"https://github.com/txadf/EventBus\" target=\"_blank\" rel=\"external\">https://github.com/txadf/EventBus</a><br>注意：在使用，进行注册订阅时，使用下面的方式，其中“XXX”表示需要订阅的Activity或者Fragment名，避免直接使用“this”：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().register(XXX.this);</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<p>记录自己最近在开发中使用的开源库及部分使用方法，链接地址为个人fork后的地址，可以参见原作者仓库。本文将持续更新，大家有什么好用的可以留言，一起交流学习下。<br>","more":"</p>\n<h3 id=\"1-android-开发常用工具类\"><a href=\"#1-android-开发常用工具类\" class=\"headerlink\" title=\"1. android 开发常用工具类\"></a>1. android 开发常用工具类</h3><p>地址：<a href=\"https://github.com/txadf/Lazy\">https://github.com/txadf/Lazy</a></p>\n<h3 id=\"2-字体图标\"><a href=\"#2-字体图标\" class=\"headerlink\" title=\"2. 字体图标\"></a>2. 字体图标</h3><p>地址：<a href=\"https://github.com/txadf/material-icon-lib\">https://github.com/txadf/material-icon-lib</a><br>用法：<br>2.1.添加依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile &apos;net.steamcrafted:materialiconlib:1.0.9&apos;</span><br></pre></td></tr></table></figure></p>\n<p>2.2.xml中使用<br>注:需要添加命名空间<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;net.steamcrafted.materialiconlib.MaterialIconView</span><br><span class=\"line\">        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class=\"line\">        android:id=&quot;@+id/icon&quot;</span><br><span class=\"line\">        android:layout_width=&quot;24dp&quot;</span><br><span class=\"line\">        android:layout_height=&quot;24dp&quot;</span><br><span class=\"line\">        android:scaleType=&quot;center&quot;</span><br><span class=\"line\">        app:materialIcon=&quot;account&quot;</span><br><span class=\"line\">        app:materialIconColor=&quot;@color/mainColor&quot;</span><br><span class=\"line\">        app:materialIconSize=&quot;24dp&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>示例效果：<br><img src=\"https://camo.githubusercontent.com/802f5408fb1caeae9647d6e72c5905225b24220d/687474703a2f2f692e696d6775722e636f6d2f4b584866586f382e676966\" alt=\"\"></p>\n<h3 id=\"3-UI-Model\"><a href=\"#3-UI-Model\" class=\"headerlink\" title=\"3. UI Model\"></a>3. UI Model</h3><p>地址：<a href=\"http://genius.qiujuer.net/module/ui.html\">http://genius.qiujuer.net/module/ui.html</a><br>按原作者网上站上的配置。<br>具体使用，按钮的使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;net.qiujuer.genius.ui.widget.Button</span><br><span class=\"line\">            xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class=\"line\">            android:id=&quot;@+id/gbtn_login&quot;</span><br><span class=\"line\">            android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">            android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:layout_marginTop=&quot;25dp&quot;</span><br><span class=\"line\">            android:background=&quot;@color/mainColor&quot;</span><br><span class=\"line\">            android:onClick=&quot;LoginClickEvent&quot;</span><br><span class=\"line\">            android:text=&quot;@string/login_btn&quot;</span><br><span class=\"line\">            android:textColor=&quot;@color/white&quot;</span><br><span class=\"line\">            app:gFont=&quot;roboto.ttf&quot;</span><br><span class=\"line\">            app:gTouchColor=&quot;@color/black_alpha_32&quot;</span><br><span class=\"line\">            app:gTouchDurationRate=&quot;0.7&quot;</span><br><span class=\"line\">            app:gTouchEffect=&quot;ripple&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>同样需要注意添加命名空间。</p>\n<h3 id=\"4-xutils3\"><a href=\"#4-xutils3\" class=\"headerlink\" title=\"4. xutils3\"></a>4. xutils3</h3><p>地址：<a href=\"https://github.com/txadf/xUtils3\">https://github.com/txadf/xUtils3</a></p>\n<h3 id=\"5-进度条\"><a href=\"#5-进度条\" class=\"headerlink\" title=\"5.进度条\"></a>5.进度条</h3><p>地址：<a href=\"https://github.com/txadf/spots-dialog\">https://github.com/txadf/spots-dialog</a><br>效果：<br><img src=\"https://camo.githubusercontent.com/d8108413298d70047f52cff9ac05603a5fd51988/687474703a2f2f332e62702e626c6f6773706f742e636f6d2f2d6c3155765657694d5341672f564c61355a6657346444492f41414141414141414e54632f7273576f755f71623042632f733332302f593648615453772e676966\" alt=\"\"></p>\n<h3 id=\"6-对话框\"><a href=\"#6-对话框\" class=\"headerlink\" title=\"6.对话框\"></a>6.对话框</h3><p>地址:<a href=\"https://github.com/txadf/sweet-alert-dialog\">https://github.com/txadf/sweet-alert-dialog</a><br>示例效果：<br><img src=\"https://github.com/pedant/sweet-alert-dialog/raw/master/change_type.gif\" alt=\"\"></p>\n<h3 id=\"7-EventBus\"><a href=\"#7-EventBus\" class=\"headerlink\" title=\"7. EventBus\"></a>7. EventBus</h3><p>地址：<a href=\"https://github.com/txadf/EventBus\">https://github.com/txadf/EventBus</a><br>注意：在使用，进行注册订阅时，使用下面的方式，其中“XXX”表示需要订阅的Activity或者Fragment名，避免直接使用“this”：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus.getDefault().register(XXX.this);</span><br></pre></td></tr></table></figure></p>"},{"title":"android SQLite学习手册","date":"2016-04-23T08:06:25.000Z","_content":" 在实际的应用中，SQLite作为目前最为流行的开源嵌入式关系型数据库，在系统的架构设计中正在扮演着越来越为重要的角色。和很多其它嵌入式NoSQL数据库不同的是，SQLite支持很多关系型数据库的基本特征，这在数据移植、程序演示等应用中有着不可替代的优势。<!--more-->从官方文档中我们可以获悉到，SQLite支持的数据量和运行效率都是非常骄人的，因此在海量数据的解决方案中，SQLite可以作为数据预计算的桥头堡，从而显著减少存储在关系型数据库服务器中的数据数量，最终提高系统的查询效率和运行期效率，同时也可以显著的降低数据备份的磁盘开销\n#### SQLite学习手册(开篇)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/09/2317603.html\n一、简介\n二、SQLite的主要优点\n三、和RDBMS相比SQLite的一些劣势\n四、个性化特征\n\n#### SQLite学习手册(C/C++接口简介)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321386.html\n一、概述\n二、核心对象和接口\n三、参数绑定\n\n#### SQLite学习手册(数据表和视图)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321668.html\n一、创建数据表\n二、表的修改\n三、表的删除\n四、创建视图\n五、删除视图\n\n#### SQLite学习手册(内置函数)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2322027.html\n一、聚合函数\n二、核心函数\n三、日期和时间函数\n\n#### SQLite学习手册(索引和数据分析/清理)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322335.html\n一、创建索引\n二、删除索引\n三、重建索引\n四、数据分析\n五、数据清理\n\n#### SQLite学习手册(数据库和事物)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322575.html\n一、Attach数据库\n二、Detach数据库\n三、事物\n\n#### SQLite学习手册(表达式)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/16/2323907.html\n一、常用表达式\n二、条件表达式\n三、转换表达式\n\n#### SQLite学习手册(数据类型)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325258.html\n一、存储种类和数据类型\n二、类型亲缘性\n三、比较表达式\n四、操作符\n\n#### SQLite学习手册(命令行工具)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325981.html\n\n#### SQLite学习手册(在线备份)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/19/2326309.html\n一、常用备份\n二、在线备份APIs简介\n三、高级应用技巧\n\n#### SQLite学习手册(内存数据库)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/20/2328348.html\n一、内存数据库\n二、临时数据库\n\n#### SQLite学习手册(临时文件)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/21/2328483.html\n一、简介\n二、具体说明\n三、相关的编译时参数和指令\n四、其它优化策略\n\n#### SQLite学习手册(锁和并发控制)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/22/2328753.html\n一、概述\n二、文件锁\n三、回滚日志\n四、数据写入\n五、SQL级别的事物控制\n\n#### SQLite学习手册(实例代码<一>)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2340780.html\n一、获取表的Schema信息\n二、常规数据插入\n\n#### SQLite学习手册(实例代码<二>)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2341480.html\n三、高效的批量数据插入\n四、数据查询","source":"_posts/android-sqlite-notebook.md","raw":"---\ntitle: android SQLite学习手册\ndate: 2016-04-23 16:06:25\ncategories: [android,SQLit]\ntags: [android,SQLit]\n---\n 在实际的应用中，SQLite作为目前最为流行的开源嵌入式关系型数据库，在系统的架构设计中正在扮演着越来越为重要的角色。和很多其它嵌入式NoSQL数据库不同的是，SQLite支持很多关系型数据库的基本特征，这在数据移植、程序演示等应用中有着不可替代的优势。<!--more-->从官方文档中我们可以获悉到，SQLite支持的数据量和运行效率都是非常骄人的，因此在海量数据的解决方案中，SQLite可以作为数据预计算的桥头堡，从而显著减少存储在关系型数据库服务器中的数据数量，最终提高系统的查询效率和运行期效率，同时也可以显著的降低数据备份的磁盘开销\n#### SQLite学习手册(开篇)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/09/2317603.html\n一、简介\n二、SQLite的主要优点\n三、和RDBMS相比SQLite的一些劣势\n四、个性化特征\n\n#### SQLite学习手册(C/C++接口简介)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321386.html\n一、概述\n二、核心对象和接口\n三、参数绑定\n\n#### SQLite学习手册(数据表和视图)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321668.html\n一、创建数据表\n二、表的修改\n三、表的删除\n四、创建视图\n五、删除视图\n\n#### SQLite学习手册(内置函数)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2322027.html\n一、聚合函数\n二、核心函数\n三、日期和时间函数\n\n#### SQLite学习手册(索引和数据分析/清理)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322335.html\n一、创建索引\n二、删除索引\n三、重建索引\n四、数据分析\n五、数据清理\n\n#### SQLite学习手册(数据库和事物)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322575.html\n一、Attach数据库\n二、Detach数据库\n三、事物\n\n#### SQLite学习手册(表达式)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/16/2323907.html\n一、常用表达式\n二、条件表达式\n三、转换表达式\n\n#### SQLite学习手册(数据类型)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325258.html\n一、存储种类和数据类型\n二、类型亲缘性\n三、比较表达式\n四、操作符\n\n#### SQLite学习手册(命令行工具)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325981.html\n\n#### SQLite学习手册(在线备份)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/19/2326309.html\n一、常用备份\n二、在线备份APIs简介\n三、高级应用技巧\n\n#### SQLite学习手册(内存数据库)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/20/2328348.html\n一、内存数据库\n二、临时数据库\n\n#### SQLite学习手册(临时文件)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/21/2328483.html\n一、简介\n二、具体说明\n三、相关的编译时参数和指令\n四、其它优化策略\n\n#### SQLite学习手册(锁和并发控制)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/01/22/2328753.html\n一、概述\n二、文件锁\n三、回滚日志\n四、数据写入\n五、SQL级别的事物控制\n\n#### SQLite学习手册(实例代码<一>)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2340780.html\n一、获取表的Schema信息\n二、常规数据插入\n\n#### SQLite学习手册(实例代码<二>)\nhttp://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2341480.html\n三、高效的批量数据插入\n四、数据查询","slug":"android-sqlite-notebook","published":1,"updated":"2016-04-23T08:42:43.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucgl001hg0g5dh5gksg6","content":"<p> 在实际的应用中，SQLite作为目前最为流行的开源嵌入式关系型数据库，在系统的架构设计中正在扮演着越来越为重要的角色。和很多其它嵌入式NoSQL数据库不同的是，SQLite支持很多关系型数据库的基本特征，这在数据移植、程序演示等应用中有着不可替代的优势。<a id=\"more\"></a>从官方文档中我们可以获悉到，SQLite支持的数据量和运行效率都是非常骄人的，因此在海量数据的解决方案中，SQLite可以作为数据预计算的桥头堡，从而显著减少存储在关系型数据库服务器中的数据数量，最终提高系统的查询效率和运行期效率，同时也可以显著的降低数据备份的磁盘开销</p>\n<h4 id=\"SQLite学习手册-开篇\"><a href=\"#SQLite学习手册-开篇\" class=\"headerlink\" title=\"SQLite学习手册(开篇)\"></a>SQLite学习手册(开篇)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/09/2317603.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/09/2317603.html</a><br>一、简介<br>二、SQLite的主要优点<br>三、和RDBMS相比SQLite的一些劣势<br>四、个性化特征</p>\n<h4 id=\"SQLite学习手册-C-C-接口简介\"><a href=\"#SQLite学习手册-C-C-接口简介\" class=\"headerlink\" title=\"SQLite学习手册(C/C++接口简介)\"></a>SQLite学习手册(C/C++接口简介)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321386.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321386.html</a><br>一、概述<br>二、核心对象和接口<br>三、参数绑定</p>\n<h4 id=\"SQLite学习手册-数据表和视图\"><a href=\"#SQLite学习手册-数据表和视图\" class=\"headerlink\" title=\"SQLite学习手册(数据表和视图)\"></a>SQLite学习手册(数据表和视图)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321668.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321668.html</a><br>一、创建数据表<br>二、表的修改<br>三、表的删除<br>四、创建视图<br>五、删除视图</p>\n<h4 id=\"SQLite学习手册-内置函数\"><a href=\"#SQLite学习手册-内置函数\" class=\"headerlink\" title=\"SQLite学习手册(内置函数)\"></a>SQLite学习手册(内置函数)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2322027.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2322027.html</a><br>一、聚合函数<br>二、核心函数<br>三、日期和时间函数</p>\n<h4 id=\"SQLite学习手册-索引和数据分析-清理\"><a href=\"#SQLite学习手册-索引和数据分析-清理\" class=\"headerlink\" title=\"SQLite学习手册(索引和数据分析/清理)\"></a>SQLite学习手册(索引和数据分析/清理)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322335.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322335.html</a><br>一、创建索引<br>二、删除索引<br>三、重建索引<br>四、数据分析<br>五、数据清理</p>\n<h4 id=\"SQLite学习手册-数据库和事物\"><a href=\"#SQLite学习手册-数据库和事物\" class=\"headerlink\" title=\"SQLite学习手册(数据库和事物)\"></a>SQLite学习手册(数据库和事物)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322575.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322575.html</a><br>一、Attach数据库<br>二、Detach数据库<br>三、事物</p>\n<h4 id=\"SQLite学习手册-表达式\"><a href=\"#SQLite学习手册-表达式\" class=\"headerlink\" title=\"SQLite学习手册(表达式)\"></a>SQLite学习手册(表达式)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/16/2323907.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/16/2323907.html</a><br>一、常用表达式<br>二、条件表达式<br>三、转换表达式</p>\n<h4 id=\"SQLite学习手册-数据类型\"><a href=\"#SQLite学习手册-数据类型\" class=\"headerlink\" title=\"SQLite学习手册(数据类型)\"></a>SQLite学习手册(数据类型)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325258.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325258.html</a><br>一、存储种类和数据类型<br>二、类型亲缘性<br>三、比较表达式<br>四、操作符</p>\n<h4 id=\"SQLite学习手册-命令行工具\"><a href=\"#SQLite学习手册-命令行工具\" class=\"headerlink\" title=\"SQLite学习手册(命令行工具)\"></a>SQLite学习手册(命令行工具)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325981.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325981.html</a></p>\n<h4 id=\"SQLite学习手册-在线备份\"><a href=\"#SQLite学习手册-在线备份\" class=\"headerlink\" title=\"SQLite学习手册(在线备份)\"></a>SQLite学习手册(在线备份)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/19/2326309.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/19/2326309.html</a><br>一、常用备份<br>二、在线备份APIs简介<br>三、高级应用技巧</p>\n<h4 id=\"SQLite学习手册-内存数据库\"><a href=\"#SQLite学习手册-内存数据库\" class=\"headerlink\" title=\"SQLite学习手册(内存数据库)\"></a>SQLite学习手册(内存数据库)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/20/2328348.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/20/2328348.html</a><br>一、内存数据库<br>二、临时数据库</p>\n<h4 id=\"SQLite学习手册-临时文件\"><a href=\"#SQLite学习手册-临时文件\" class=\"headerlink\" title=\"SQLite学习手册(临时文件)\"></a>SQLite学习手册(临时文件)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/21/2328483.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/21/2328483.html</a><br>一、简介<br>二、具体说明<br>三、相关的编译时参数和指令<br>四、其它优化策略</p>\n<h4 id=\"SQLite学习手册-锁和并发控制\"><a href=\"#SQLite学习手册-锁和并发控制\" class=\"headerlink\" title=\"SQLite学习手册(锁和并发控制)\"></a>SQLite学习手册(锁和并发控制)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/22/2328753.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/22/2328753.html</a><br>一、概述<br>二、文件锁<br>三、回滚日志<br>四、数据写入<br>五、SQL级别的事物控制</p>\n<h4 id=\"SQLite学习手册-实例代码-lt-一-gt\"><a href=\"#SQLite学习手册-实例代码-lt-一-gt\" class=\"headerlink\" title=\"SQLite学习手册(实例代码&lt;一&gt;)\"></a>SQLite学习手册(实例代码&lt;一&gt;)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2340780.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2340780.html</a><br>一、获取表的Schema信息<br>二、常规数据插入</p>\n<h4 id=\"SQLite学习手册-实例代码-lt-二-gt\"><a href=\"#SQLite学习手册-实例代码-lt-二-gt\" class=\"headerlink\" title=\"SQLite学习手册(实例代码&lt;二&gt;)\"></a>SQLite学习手册(实例代码&lt;二&gt;)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2341480.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2341480.html</a><br>三、高效的批量数据插入<br>四、数据查询</p>\n","excerpt":"<p> 在实际的应用中，SQLite作为目前最为流行的开源嵌入式关系型数据库，在系统的架构设计中正在扮演着越来越为重要的角色。和很多其它嵌入式NoSQL数据库不同的是，SQLite支持很多关系型数据库的基本特征，这在数据移植、程序演示等应用中有着不可替代的优势。","more":"从官方文档中我们可以获悉到，SQLite支持的数据量和运行效率都是非常骄人的，因此在海量数据的解决方案中，SQLite可以作为数据预计算的桥头堡，从而显著减少存储在关系型数据库服务器中的数据数量，最终提高系统的查询效率和运行期效率，同时也可以显著的降低数据备份的磁盘开销</p>\n<h4 id=\"SQLite学习手册-开篇\"><a href=\"#SQLite学习手册-开篇\" class=\"headerlink\" title=\"SQLite学习手册(开篇)\"></a>SQLite学习手册(开篇)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/09/2317603.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/09/2317603.html</a><br>一、简介<br>二、SQLite的主要优点<br>三、和RDBMS相比SQLite的一些劣势<br>四、个性化特征</p>\n<h4 id=\"SQLite学习手册-C-C-接口简介\"><a href=\"#SQLite学习手册-C-C-接口简介\" class=\"headerlink\" title=\"SQLite学习手册(C/C++接口简介)\"></a>SQLite学习手册(C/C++接口简介)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321386.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321386.html</a><br>一、概述<br>二、核心对象和接口<br>三、参数绑定</p>\n<h4 id=\"SQLite学习手册-数据表和视图\"><a href=\"#SQLite学习手册-数据表和视图\" class=\"headerlink\" title=\"SQLite学习手册(数据表和视图)\"></a>SQLite学习手册(数据表和视图)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321668.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2321668.html</a><br>一、创建数据表<br>二、表的修改<br>三、表的删除<br>四、创建视图<br>五、删除视图</p>\n<h4 id=\"SQLite学习手册-内置函数\"><a href=\"#SQLite学习手册-内置函数\" class=\"headerlink\" title=\"SQLite学习手册(内置函数)\"></a>SQLite学习手册(内置函数)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2322027.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/13/2322027.html</a><br>一、聚合函数<br>二、核心函数<br>三、日期和时间函数</p>\n<h4 id=\"SQLite学习手册-索引和数据分析-清理\"><a href=\"#SQLite学习手册-索引和数据分析-清理\" class=\"headerlink\" title=\"SQLite学习手册(索引和数据分析/清理)\"></a>SQLite学习手册(索引和数据分析/清理)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322335.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322335.html</a><br>一、创建索引<br>二、删除索引<br>三、重建索引<br>四、数据分析<br>五、数据清理</p>\n<h4 id=\"SQLite学习手册-数据库和事物\"><a href=\"#SQLite学习手册-数据库和事物\" class=\"headerlink\" title=\"SQLite学习手册(数据库和事物)\"></a>SQLite学习手册(数据库和事物)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322575.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/14/2322575.html</a><br>一、Attach数据库<br>二、Detach数据库<br>三、事物</p>\n<h4 id=\"SQLite学习手册-表达式\"><a href=\"#SQLite学习手册-表达式\" class=\"headerlink\" title=\"SQLite学习手册(表达式)\"></a>SQLite学习手册(表达式)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/16/2323907.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/16/2323907.html</a><br>一、常用表达式<br>二、条件表达式<br>三、转换表达式</p>\n<h4 id=\"SQLite学习手册-数据类型\"><a href=\"#SQLite学习手册-数据类型\" class=\"headerlink\" title=\"SQLite学习手册(数据类型)\"></a>SQLite学习手册(数据类型)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325258.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325258.html</a><br>一、存储种类和数据类型<br>二、类型亲缘性<br>三、比较表达式<br>四、操作符</p>\n<h4 id=\"SQLite学习手册-命令行工具\"><a href=\"#SQLite学习手册-命令行工具\" class=\"headerlink\" title=\"SQLite学习手册(命令行工具)\"></a>SQLite学习手册(命令行工具)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325981.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/18/2325981.html</a></p>\n<h4 id=\"SQLite学习手册-在线备份\"><a href=\"#SQLite学习手册-在线备份\" class=\"headerlink\" title=\"SQLite学习手册(在线备份)\"></a>SQLite学习手册(在线备份)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/19/2326309.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/19/2326309.html</a><br>一、常用备份<br>二、在线备份APIs简介<br>三、高级应用技巧</p>\n<h4 id=\"SQLite学习手册-内存数据库\"><a href=\"#SQLite学习手册-内存数据库\" class=\"headerlink\" title=\"SQLite学习手册(内存数据库)\"></a>SQLite学习手册(内存数据库)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/20/2328348.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/20/2328348.html</a><br>一、内存数据库<br>二、临时数据库</p>\n<h4 id=\"SQLite学习手册-临时文件\"><a href=\"#SQLite学习手册-临时文件\" class=\"headerlink\" title=\"SQLite学习手册(临时文件)\"></a>SQLite学习手册(临时文件)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/21/2328483.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/21/2328483.html</a><br>一、简介<br>二、具体说明<br>三、相关的编译时参数和指令<br>四、其它优化策略</p>\n<h4 id=\"SQLite学习手册-锁和并发控制\"><a href=\"#SQLite学习手册-锁和并发控制\" class=\"headerlink\" title=\"SQLite学习手册(锁和并发控制)\"></a>SQLite学习手册(锁和并发控制)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/01/22/2328753.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/01/22/2328753.html</a><br>一、概述<br>二、文件锁<br>三、回滚日志<br>四、数据写入<br>五、SQL级别的事物控制</p>\n<h4 id=\"SQLite学习手册-实例代码-lt-一-gt\"><a href=\"#SQLite学习手册-实例代码-lt-一-gt\" class=\"headerlink\" title=\"SQLite学习手册(实例代码&lt;一&gt;)\"></a>SQLite学习手册(实例代码&lt;一&gt;)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2340780.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2340780.html</a><br>一、获取表的Schema信息<br>二、常规数据插入</p>\n<h4 id=\"SQLite学习手册-实例代码-lt-二-gt\"><a href=\"#SQLite学习手册-实例代码-lt-二-gt\" class=\"headerlink\" title=\"SQLite学习手册(实例代码&lt;二&gt;)\"></a>SQLite学习手册(实例代码&lt;二&gt;)</h4><p><a href=\"http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2341480.html\">http://www.cnblogs.com/stephen-liu74/archive/2012/02/07/2341480.html</a><br>三、高效的批量数据插入<br>四、数据查询</p>"},{"title":"SQLit相关类的介绍及使用","date":"2016-04-23T08:04:25.000Z","_content":"本文主要介绍了SQLit中相关的几个类（SQLiteDatabase、ContentValues、SQLiteOpenHelper）中的常用的方法及其作用。\n<!--more-->\n## **1. SQLiteDatabase类**\n（对 SQLite数据库增、删、改、查的操作）\n 常用方法\n```\nexecSQL(String  sql);\nexecSQL(String sql, String[] args);\n```\n示例：删除 person表中personId＝1的记录：\n```\nSQLiteDatabase db=this.getWritableDatabase();\ndb.execSQL(“delete from  person where personId=?”,new\nString[]{“1”});\ndb.execSQL(“delete from  person where personId=1”);\n```\n提示：this是 SQLiteOpenHelper类的实例，该类稍后介绍。\n#### 打开数据库\n``` \nContext.openOrCreateDatabase(Stringdbname,int mode);\n```\n作用：打开数据库，若数据库未创建则创建数据库。\n参数－dbname：数据库文件名。\n参数－mode：访问权限，有以下常量选择：\n1、MODE_PRIVATE：不允许其它应用程序访问本数据库。\n2、MODE_WORLD_READABLE：允许其它应用程序读本数据库。\n3、MODE_WORLD_WRITEABLE：允许其它应用程序写本数据库。\n4、MODE_APPEND：若数据库已存在，则允向数据库中许添加数据。\n\n\n#### 添加\n```\nlong insert(TABLE_NAME, String nullColumnHack, ContentValues   contentValues);\n```\n作用：添加记录。\n参数－TABLE_NAME：表名。\n参数－nullColumnHack：若插入的数据是空行，则本参数必须设置为 null。\n参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据\n\n#### 删除 \n```\nint delete(TABLE_NAME, String  where, String[]  whereValue);\n```\n作用：删除记录。\n参数－TABLE_NAME：表名。\n参数－where：删除的条件，相当于 SQL语句中的where部分的 SQL命令。\n参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。\n示例：删除当前数据库中表peson中，字段 personId值为1的行，代码如下：\n```\ndelete(“person”,”personId=?”,newString[]{“1”});\n```\n#### 更新\n```\nint update(TABLE_NAME, contentValues,String  where, String[] whereValue) ;\n```\n作用：更新记录。\n参数－TABLE_NAME：表名。\n参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据。可\n存放多个键－值对数据，代表需要更新的数据。\n参数－where：更新的条件，相当于 SQL语句中的where部分的 SQL命令。\n参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。\n示例：更新当前数据库的person表中,personId＝1的记录，代码如下：\n```\nContentValues  values=new ContentValues();//创建可存操作的键－值对的对象\nvalues.put(“name”,”李四”);//存放姓名数据\nvalues.put(“phone”,”13315577889”);//存放电话数据\n//实例化SQLiteDatabase对象\nSQLiteDatabase db=this.getWritableDatabase();\ndb.update(“person” ,values,”personId=?”，new String[]{“1”);//更新数据\n```\n#### 查询\n```\nCursor rawQuery(String sql,String[]selectionArgs);\n```\n作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。\n参数－sql：查询的 SQL命令。\n参数－selectionArgs：查询的条件数据。\n提示：\n(1)Cursor类稍后介绍。\n(2)若 sql中没有占位符，则第二个参数设置为 null。\n(3)对数据表进行变更操作时，使用execSQL，对数据表进行查询时，使用rawQuery\n方法。\n```\nCursorquery(table,projection,selection,selectionArgs,groupby,having,orderby);\n```\n作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。\ncursor :返回值类型，返回查询结果游标对象。\n  table : String ,要查询的表名。\n  projection : String[]，要查询的列名，如果为 null，则查询所有列。\n  selection : String,查询条件。\n  selectionArgs:String[]为selection中的？补值的数组。\n  groupby : String,分组列的列名。\n  having:String,分组在查询的条件。\n  orderby:String排序列的列名。\n\n\n\n## 2、ContentValues类\n####  概述\nContentValues类包装了HashMap类，该类用于存取键－值对的数据，每个键－值对数\n据表示一列的列名和该列的数据。\n####  常用方法\n```\nContentValues();\n```\n\n作用：无参构造方法，创建一个内部成员变量为 HashMap<String,Object>的对象。\n```\nvoid put(String key,Object value);\n```\n作用：向成员变量 mValues中存放一个键－值对数据。\n提示：value可以是 Java的所有基本数据类型、数组、对象的类型。\n```\nObject** get(String key);\n```\n作用：获取键名 key对应的值。\n```\nXXX getAsXXX(String key);\n```\n作用：返回 XXX类型的值。\n提示：XXX可以是所有基本类型的包装类，如 Integer，还有AsByteArray（字节数组类型）。\n\n\n## 3 、SQLiteOpenHelper类\n#### 概述\nSQLiteOpenHelper类是Android提供的用于操作 SQLite数据库的工具类，该工具类能\n方便地创建数据库、表，以及管理数据库版本。\n#### 常用方法\n```\nsynchronized SQLiteDatabasegetReadableDatabase();\n```\n作用：以读写的方式打开数据库对应的 SQLiteDatabase类的对象。\n提示：synchronized关键字定义该方法为线程同步。\n```\nsynchronized SQLiteDatabasegetWriteableDatabase();\n```\n作用：以写的方式创建或打开数据库对应的 SQLiteDatabase类的对象。\n```\n abstract onCreate(SQLiteDatabase db);\n```\n作用：首次创建数据库时，回调本方法。","source":"_posts/android-sqlite-use.md","raw":"---\ntitle: SQLit相关类的介绍及使用\ndate: 2016-04-23 16:04:25\ncategories: [android,SQLit]\ntags: [android,SQLit]\n---\n本文主要介绍了SQLit中相关的几个类（SQLiteDatabase、ContentValues、SQLiteOpenHelper）中的常用的方法及其作用。\n<!--more-->\n## **1. SQLiteDatabase类**\n（对 SQLite数据库增、删、改、查的操作）\n 常用方法\n```\nexecSQL(String  sql);\nexecSQL(String sql, String[] args);\n```\n示例：删除 person表中personId＝1的记录：\n```\nSQLiteDatabase db=this.getWritableDatabase();\ndb.execSQL(“delete from  person where personId=?”,new\nString[]{“1”});\ndb.execSQL(“delete from  person where personId=1”);\n```\n提示：this是 SQLiteOpenHelper类的实例，该类稍后介绍。\n#### 打开数据库\n``` \nContext.openOrCreateDatabase(Stringdbname,int mode);\n```\n作用：打开数据库，若数据库未创建则创建数据库。\n参数－dbname：数据库文件名。\n参数－mode：访问权限，有以下常量选择：\n1、MODE_PRIVATE：不允许其它应用程序访问本数据库。\n2、MODE_WORLD_READABLE：允许其它应用程序读本数据库。\n3、MODE_WORLD_WRITEABLE：允许其它应用程序写本数据库。\n4、MODE_APPEND：若数据库已存在，则允向数据库中许添加数据。\n\n\n#### 添加\n```\nlong insert(TABLE_NAME, String nullColumnHack, ContentValues   contentValues);\n```\n作用：添加记录。\n参数－TABLE_NAME：表名。\n参数－nullColumnHack：若插入的数据是空行，则本参数必须设置为 null。\n参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据\n\n#### 删除 \n```\nint delete(TABLE_NAME, String  where, String[]  whereValue);\n```\n作用：删除记录。\n参数－TABLE_NAME：表名。\n参数－where：删除的条件，相当于 SQL语句中的where部分的 SQL命令。\n参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。\n示例：删除当前数据库中表peson中，字段 personId值为1的行，代码如下：\n```\ndelete(“person”,”personId=?”,newString[]{“1”});\n```\n#### 更新\n```\nint update(TABLE_NAME, contentValues,String  where, String[] whereValue) ;\n```\n作用：更新记录。\n参数－TABLE_NAME：表名。\n参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据。可\n存放多个键－值对数据，代表需要更新的数据。\n参数－where：更新的条件，相当于 SQL语句中的where部分的 SQL命令。\n参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。\n示例：更新当前数据库的person表中,personId＝1的记录，代码如下：\n```\nContentValues  values=new ContentValues();//创建可存操作的键－值对的对象\nvalues.put(“name”,”李四”);//存放姓名数据\nvalues.put(“phone”,”13315577889”);//存放电话数据\n//实例化SQLiteDatabase对象\nSQLiteDatabase db=this.getWritableDatabase();\ndb.update(“person” ,values,”personId=?”，new String[]{“1”);//更新数据\n```\n#### 查询\n```\nCursor rawQuery(String sql,String[]selectionArgs);\n```\n作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。\n参数－sql：查询的 SQL命令。\n参数－selectionArgs：查询的条件数据。\n提示：\n(1)Cursor类稍后介绍。\n(2)若 sql中没有占位符，则第二个参数设置为 null。\n(3)对数据表进行变更操作时，使用execSQL，对数据表进行查询时，使用rawQuery\n方法。\n```\nCursorquery(table,projection,selection,selectionArgs,groupby,having,orderby);\n```\n作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。\ncursor :返回值类型，返回查询结果游标对象。\n  table : String ,要查询的表名。\n  projection : String[]，要查询的列名，如果为 null，则查询所有列。\n  selection : String,查询条件。\n  selectionArgs:String[]为selection中的？补值的数组。\n  groupby : String,分组列的列名。\n  having:String,分组在查询的条件。\n  orderby:String排序列的列名。\n\n\n\n## 2、ContentValues类\n####  概述\nContentValues类包装了HashMap类，该类用于存取键－值对的数据，每个键－值对数\n据表示一列的列名和该列的数据。\n####  常用方法\n```\nContentValues();\n```\n\n作用：无参构造方法，创建一个内部成员变量为 HashMap<String,Object>的对象。\n```\nvoid put(String key,Object value);\n```\n作用：向成员变量 mValues中存放一个键－值对数据。\n提示：value可以是 Java的所有基本数据类型、数组、对象的类型。\n```\nObject** get(String key);\n```\n作用：获取键名 key对应的值。\n```\nXXX getAsXXX(String key);\n```\n作用：返回 XXX类型的值。\n提示：XXX可以是所有基本类型的包装类，如 Integer，还有AsByteArray（字节数组类型）。\n\n\n## 3 、SQLiteOpenHelper类\n#### 概述\nSQLiteOpenHelper类是Android提供的用于操作 SQLite数据库的工具类，该工具类能\n方便地创建数据库、表，以及管理数据库版本。\n#### 常用方法\n```\nsynchronized SQLiteDatabasegetReadableDatabase();\n```\n作用：以读写的方式打开数据库对应的 SQLiteDatabase类的对象。\n提示：synchronized关键字定义该方法为线程同步。\n```\nsynchronized SQLiteDatabasegetWriteableDatabase();\n```\n作用：以写的方式创建或打开数据库对应的 SQLiteDatabase类的对象。\n```\n abstract onCreate(SQLiteDatabase db);\n```\n作用：首次创建数据库时，回调本方法。","slug":"android-sqlite-use","published":1,"updated":"2016-04-23T08:40:43.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuch0001kg0g59lgv0aeb","content":"<p>本文主要介绍了SQLit中相关的几个类（SQLiteDatabase、ContentValues、SQLiteOpenHelper）中的常用的方法及其作用。<br><a id=\"more\"></a></p>\n<h2 id=\"1-SQLiteDatabase类\"><a href=\"#1-SQLiteDatabase类\" class=\"headerlink\" title=\"1. SQLiteDatabase类\"></a><strong>1. SQLiteDatabase类</strong></h2><p>（对 SQLite数据库增、删、改、查的操作）<br> 常用方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execSQL(String  sql);</span><br><span class=\"line\">execSQL(String sql, String[] args);</span><br></pre></td></tr></table></figure></p>\n<p>示例：删除 person表中personId＝1的记录：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db=this.getWritableDatabase();</span><br><span class=\"line\">db.execSQL(“delete from  person where personId=?”,new</span><br><span class=\"line\">String[]&#123;“1”&#125;);</span><br><span class=\"line\">db.execSQL(“delete from  person where personId=1”);</span><br></pre></td></tr></table></figure></p>\n<p>提示：this是 SQLiteOpenHelper类的实例，该类稍后介绍。</p>\n<h4 id=\"打开数据库\"><a href=\"#打开数据库\" class=\"headerlink\" title=\"打开数据库\"></a>打开数据库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Context.openOrCreateDatabase(Stringdbname,int mode);</span><br></pre></td></tr></table></figure>\n<p>作用：打开数据库，若数据库未创建则创建数据库。<br>参数－dbname：数据库文件名。<br>参数－mode：访问权限，有以下常量选择：<br>1、MODE_PRIVATE：不允许其它应用程序访问本数据库。<br>2、MODE_WORLD_READABLE：允许其它应用程序读本数据库。<br>3、MODE_WORLD_WRITEABLE：允许其它应用程序写本数据库。<br>4、MODE_APPEND：若数据库已存在，则允向数据库中许添加数据。</p>\n<h4 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long insert(TABLE_NAME, String nullColumnHack, ContentValues   contentValues);</span><br></pre></td></tr></table></figure>\n<p>作用：添加记录。<br>参数－TABLE_NAME：表名。<br>参数－nullColumnHack：若插入的数据是空行，则本参数必须设置为 null。<br>参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据</p>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int delete(TABLE_NAME, String  where, String[]  whereValue);</span><br></pre></td></tr></table></figure>\n<p>作用：删除记录。<br>参数－TABLE_NAME：表名。<br>参数－where：删除的条件，相当于 SQL语句中的where部分的 SQL命令。<br>参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。<br>示例：删除当前数据库中表peson中，字段 personId值为1的行，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete(“person”,”personId=?”,newString[]&#123;“1”&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int update(TABLE_NAME, contentValues,String  where, String[] whereValue) ;</span><br></pre></td></tr></table></figure>\n<p>作用：更新记录。<br>参数－TABLE_NAME：表名。<br>参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据。可<br>存放多个键－值对数据，代表需要更新的数据。<br>参数－where：更新的条件，相当于 SQL语句中的where部分的 SQL命令。<br>参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。<br>示例：更新当前数据库的person表中,personId＝1的记录，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContentValues  values=new ContentValues();//创建可存操作的键－值对的对象</span><br><span class=\"line\">values.put(“name”,”李四”);//存放姓名数据</span><br><span class=\"line\">values.put(“phone”,”13315577889”);//存放电话数据</span><br><span class=\"line\">//实例化SQLiteDatabase对象</span><br><span class=\"line\">SQLiteDatabase db=this.getWritableDatabase();</span><br><span class=\"line\">db.update(“person” ,values,”personId=?”，new String[]&#123;“1”);//更新数据</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cursor rawQuery(String sql,String[]selectionArgs);</span><br></pre></td></tr></table></figure>\n<p>作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。<br>参数－sql：查询的 SQL命令。<br>参数－selectionArgs：查询的条件数据。<br>提示：<br>(1)Cursor类稍后介绍。<br>(2)若 sql中没有占位符，则第二个参数设置为 null。<br>(3)对数据表进行变更操作时，使用execSQL，对数据表进行查询时，使用rawQuery<br>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cursorquery(table,projection,selection,selectionArgs,groupby,having,orderby);</span><br></pre></td></tr></table></figure></p>\n<p>作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。<br>cursor :返回值类型，返回查询结果游标对象。<br>  table : String ,要查询的表名。<br>  projection : String[]，要查询的列名，如果为 null，则查询所有列。<br>  selection : String,查询条件。<br>  selectionArgs:String[]为selection中的？补值的数组。<br>  groupby : String,分组列的列名。<br>  having:String,分组在查询的条件。<br>  orderby:String排序列的列名。</p>\n<h2 id=\"2、ContentValues类\"><a href=\"#2、ContentValues类\" class=\"headerlink\" title=\"2、ContentValues类\"></a>2、ContentValues类</h2><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>ContentValues类包装了HashMap类，该类用于存取键－值对的数据，每个键－值对数<br>据表示一列的列名和该列的数据。</p>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContentValues();</span><br></pre></td></tr></table></figure>\n<p>作用：无参构造方法，创建一个内部成员变量为 HashMap<string,object>的对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void put(String key,Object value);</span><br></pre></td></tr></table></figure></string,object></p>\n<p>作用：向成员变量 mValues中存放一个键－值对数据。<br>提示：value可以是 Java的所有基本数据类型、数组、对象的类型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object** get(String key);</span><br></pre></td></tr></table></figure></p>\n<p>作用：获取键名 key对应的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XXX getAsXXX(String key);</span><br></pre></td></tr></table></figure></p>\n<p>作用：返回 XXX类型的值。<br>提示：XXX可以是所有基本类型的包装类，如 Integer，还有AsByteArray（字节数组类型）。</p>\n<h2 id=\"3-、SQLiteOpenHelper类\"><a href=\"#3-、SQLiteOpenHelper类\" class=\"headerlink\" title=\"3 、SQLiteOpenHelper类\"></a>3 、SQLiteOpenHelper类</h2><h4 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>SQLiteOpenHelper类是Android提供的用于操作 SQLite数据库的工具类，该工具类能<br>方便地创建数据库、表，以及管理数据库版本。</p>\n<h4 id=\"常用方法-1\"><a href=\"#常用方法-1\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized SQLiteDatabasegetReadableDatabase();</span><br></pre></td></tr></table></figure>\n<p>作用：以读写的方式打开数据库对应的 SQLiteDatabase类的对象。<br>提示：synchronized关键字定义该方法为线程同步。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized SQLiteDatabasegetWriteableDatabase();</span><br></pre></td></tr></table></figure></p>\n<p>作用：以写的方式创建或打开数据库对应的 SQLiteDatabase类的对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract onCreate(SQLiteDatabase db);</span><br></pre></td></tr></table></figure></p>\n<p>作用：首次创建数据库时，回调本方法。</p>\n","excerpt":"<p>本文主要介绍了SQLit中相关的几个类（SQLiteDatabase、ContentValues、SQLiteOpenHelper）中的常用的方法及其作用。<br>","more":"</p>\n<h2 id=\"1-SQLiteDatabase类\"><a href=\"#1-SQLiteDatabase类\" class=\"headerlink\" title=\"1. SQLiteDatabase类\"></a><strong>1. SQLiteDatabase类</strong></h2><p>（对 SQLite数据库增、删、改、查的操作）<br> 常用方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execSQL(String  sql);</span><br><span class=\"line\">execSQL(String sql, String[] args);</span><br></pre></td></tr></table></figure></p>\n<p>示例：删除 person表中personId＝1的记录：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SQLiteDatabase db=this.getWritableDatabase();</span><br><span class=\"line\">db.execSQL(“delete from  person where personId=?”,new</span><br><span class=\"line\">String[]&#123;“1”&#125;);</span><br><span class=\"line\">db.execSQL(“delete from  person where personId=1”);</span><br></pre></td></tr></table></figure></p>\n<p>提示：this是 SQLiteOpenHelper类的实例，该类稍后介绍。</p>\n<h4 id=\"打开数据库\"><a href=\"#打开数据库\" class=\"headerlink\" title=\"打开数据库\"></a>打开数据库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Context.openOrCreateDatabase(Stringdbname,int mode);</span><br></pre></td></tr></table></figure>\n<p>作用：打开数据库，若数据库未创建则创建数据库。<br>参数－dbname：数据库文件名。<br>参数－mode：访问权限，有以下常量选择：<br>1、MODE_PRIVATE：不允许其它应用程序访问本数据库。<br>2、MODE_WORLD_READABLE：允许其它应用程序读本数据库。<br>3、MODE_WORLD_WRITEABLE：允许其它应用程序写本数据库。<br>4、MODE_APPEND：若数据库已存在，则允向数据库中许添加数据。</p>\n<h4 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long insert(TABLE_NAME, String nullColumnHack, ContentValues   contentValues);</span><br></pre></td></tr></table></figure>\n<p>作用：添加记录。<br>参数－TABLE_NAME：表名。<br>参数－nullColumnHack：若插入的数据是空行，则本参数必须设置为 null。<br>参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据</p>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int delete(TABLE_NAME, String  where, String[]  whereValue);</span><br></pre></td></tr></table></figure>\n<p>作用：删除记录。<br>参数－TABLE_NAME：表名。<br>参数－where：删除的条件，相当于 SQL语句中的where部分的 SQL命令。<br>参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。<br>示例：删除当前数据库中表peson中，字段 personId值为1的行，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete(“person”,”personId=?”,newString[]&#123;“1”&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int update(TABLE_NAME, contentValues,String  where, String[] whereValue) ;</span><br></pre></td></tr></table></figure>\n<p>作用：更新记录。<br>参数－TABLE_NAME：表名。<br>参数－contentValues：Map类型的数据，每组键－值对代表一列及其该列的数据。可<br>存放多个键－值对数据，代表需要更新的数据。<br>参数－where：更新的条件，相当于 SQL语句中的where部分的 SQL命令。<br>参数－whereValue：符合参数 where的数据。该值是 String[]类型的数组。<br>示例：更新当前数据库的person表中,personId＝1的记录，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContentValues  values=new ContentValues();//创建可存操作的键－值对的对象</span><br><span class=\"line\">values.put(“name”,”李四”);//存放姓名数据</span><br><span class=\"line\">values.put(“phone”,”13315577889”);//存放电话数据</span><br><span class=\"line\">//实例化SQLiteDatabase对象</span><br><span class=\"line\">SQLiteDatabase db=this.getWritableDatabase();</span><br><span class=\"line\">db.update(“person” ,values,”personId=?”，new String[]&#123;“1”);//更新数据</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cursor rawQuery(String sql,String[]selectionArgs);</span><br></pre></td></tr></table></figure>\n<p>作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。<br>参数－sql：查询的 SQL命令。<br>参数－selectionArgs：查询的条件数据。<br>提示：<br>(1)Cursor类稍后介绍。<br>(2)若 sql中没有占位符，则第二个参数设置为 null。<br>(3)对数据表进行变更操作时，使用execSQL，对数据表进行查询时，使用rawQuery<br>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cursorquery(table,projection,selection,selectionArgs,groupby,having,orderby);</span><br></pre></td></tr></table></figure></p>\n<p>作用：执行带占位符的 SQL查询，返回的结果集存放在 Cursor对象中。<br>cursor :返回值类型，返回查询结果游标对象。<br>  table : String ,要查询的表名。<br>  projection : String[]，要查询的列名，如果为 null，则查询所有列。<br>  selection : String,查询条件。<br>  selectionArgs:String[]为selection中的？补值的数组。<br>  groupby : String,分组列的列名。<br>  having:String,分组在查询的条件。<br>  orderby:String排序列的列名。</p>\n<h2 id=\"2、ContentValues类\"><a href=\"#2、ContentValues类\" class=\"headerlink\" title=\"2、ContentValues类\"></a>2、ContentValues类</h2><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>ContentValues类包装了HashMap类，该类用于存取键－值对的数据，每个键－值对数<br>据表示一列的列名和该列的数据。</p>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ContentValues();</span><br></pre></td></tr></table></figure>\n<p>作用：无参构造方法，创建一个内部成员变量为 HashMap<String,Object>的对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void put(String key,Object value);</span><br></pre></td></tr></table></figure></p>\n<p>作用：向成员变量 mValues中存放一个键－值对数据。<br>提示：value可以是 Java的所有基本数据类型、数组、对象的类型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object** get(String key);</span><br></pre></td></tr></table></figure></p>\n<p>作用：获取键名 key对应的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XXX getAsXXX(String key);</span><br></pre></td></tr></table></figure></p>\n<p>作用：返回 XXX类型的值。<br>提示：XXX可以是所有基本类型的包装类，如 Integer，还有AsByteArray（字节数组类型）。</p>\n<h2 id=\"3-、SQLiteOpenHelper类\"><a href=\"#3-、SQLiteOpenHelper类\" class=\"headerlink\" title=\"3 、SQLiteOpenHelper类\"></a>3 、SQLiteOpenHelper类</h2><h4 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>SQLiteOpenHelper类是Android提供的用于操作 SQLite数据库的工具类，该工具类能<br>方便地创建数据库、表，以及管理数据库版本。</p>\n<h4 id=\"常用方法-1\"><a href=\"#常用方法-1\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized SQLiteDatabasegetReadableDatabase();</span><br></pre></td></tr></table></figure>\n<p>作用：以读写的方式打开数据库对应的 SQLiteDatabase类的对象。<br>提示：synchronized关键字定义该方法为线程同步。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized SQLiteDatabasegetWriteableDatabase();</span><br></pre></td></tr></table></figure></p>\n<p>作用：以写的方式创建或打开数据库对应的 SQLiteDatabase类的对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract onCreate(SQLiteDatabase db);</span><br></pre></td></tr></table></figure></p>\n<p>作用：首次创建数据库时，回调本方法。</p>"},{"title":"Android Studio 快捷键","date":"2016-04-23T08:25:25.000Z","_content":"原官方快捷键：https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf\nAlt+回车 导入包,自动修正\nCtrl+N   查找类\nCtrl+Shift+N 查找文件\nCtrl+Alt+L  格式化代码\nCtrl+Alt+O 优化导入的类和包\nAlt+Insert 生成代码(如get,set方法,构造函数等<!--more-->\nCtrl+E或者Alt+Shift+C  最近更改的代码\nCtrl+R 替换文本\nCtrl+F 查找文本\nCtrl+Shift+Space 自动补全代码\nCtrl+空格 代码提示\nCtrl+Alt+Space 类名或接口名提示\nCtrl+P 方法参数提示\nCtrl+Shift+Alt+N 查找类中的方法或变量\nAlt+Shift+C 对比最近修改的代码\n\nShift+F6  重构-重命名\nCtrl+Shift+先上键\nCtrl+Y 删除行（ctrl+x不是删除行，是剪切。如果不选中，则为剪切当行。ths for 貌似掉线）\nCtrl+D 复制行\nCtrl+/ 或 Ctrl+Shift+/  注释（// 或者/*...*/ ）\nCtrl+J  自动代码\nCtrl+E 最近打开的文件\nCtrl+H 显示类结构图\nCtrl+Q 显示注释文档\nAlt+F1 查找代码所在位置\nAlt+1 快速打开或隐藏工程面板\nCtrl+Alt+ left/right 返回至上次浏览的位置\nAlt+ left/right 切换代码视图\nAlt+ Up/Down 在方法间快速移动定位\nCtrl+Shift+Up/Down 代码向上/下移动。\nF2 或Shift+F2 高亮错误或警告快速定位\n\n代码标签输入完成后，按Tab，生成代码。\n选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。\nCtrl+W 选中代码，连续按会有其他效果\n选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。\nCtrl+Up/Down 光标跳转到第一行或最后一行下\nCtrl+B 快速打开光标处的类或方法 \n最常用快捷键\n1.Ctrl＋E，可以显示最近编辑的文件列表\n2.Shift＋Click可以关闭文件\n3.Ctrl＋[或]可以跳到大括号的开头结尾\n4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方\n5.Ctrl＋F12，可以显示当前文件的结构\n6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择\n7.Ctrl＋N，可以快速打开类\n8.Ctrl＋Shift＋N，可以快速打开文件\n9.Alt＋Q可以看到当前方法的声明\n10.Ctrl＋W可以选择单词继而语句继而行继而函数\n11.Alt＋F1可以将正在编辑的元素在各个面板中定位\n12.Ctrl＋P，可以显示参数信息\n13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入\n14.Alt＋Insert可以生成构造器/Getter/Setter等\n15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量\n16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch\n17.Alt＋Up and Alt＋Down可在方法间快速移动\n下面的不是很有用\n18.在一些地方按Alt＋Enter可以得到一些Intention Action，例如将”==”改为”equals()”\n19.Ctrl＋Shift＋Alt＋N可以快速打开符号\n20.Ctrl＋Shift＋Space在很多时候都能够给出Smart提示\n21.Alt＋F3可以快速寻找\n22.Ctrl＋/和Ctrl＋Shift＋/可以注释代码\n23.Ctrl＋Alt＋B可以跳转到抽象方法的实现\n24.Ctrl＋O可以选择父类的方法进行重写\n25.Ctrl＋Q可以看JavaDoc\n26.Ctrl＋Alt＋Space是类名自动完成\n27.快速打开类/文件/符号时，可以使用通配符，也可以使用缩写\n28.Live Templates! Ctrl＋J\n29.Ctrl＋Shift＋F7可以高亮当前元素在当前文件中的使用\n30.Ctrl＋Alt＋Up /Ctrl＋Alt＋Down可以快速跳转搜索结果\n31.Ctrl＋Shift＋J可以整合两行\n32.Alt＋F8是计算变量值\n\nIntelliJ IDEA使用技巧一览表 \n在使用 InelliJ IDEA 的过程中，通过查找资料以及一些自己的摸索，发现这个众多 Java 程序员喜欢的 IDE 里有许多值得一提的小窍门，如果能熟练的将它们应用于实际开发过程中，相信它会大大节省你的开发时间，而且随之而来的还会有那么一点点成就感：） Try it ！ \n\n1 、写代码时用 Alt-Insert （ Code|Generate… ）可以创建类里面任何字段的 getter 与 setter 方法。 \n<?xml:namespace prefix = v ns = \"urn:schemas-microsoft-com:vml\" /> \n\n2 、右键点击断点标记（在文本的左边栏里）激活速查菜单，你可以快速设置 enable/disable 断点或者条件它的属性。\n\n3 、 CodeCompletion （代码完成）属性里的一个特殊的变量是，激活 Ctrl-Alt-Space 可以完成在或不在当前文件里的类名。如果类没有引入则 import 标志会自动创建。\n\n4 、使用 Ctrl-Shift-V 快捷键可以将最近使用的剪贴板内容选择插入到文本。使用时系统会弹出一个含有剪贴内容的对话框，从中你可以选择你要粘贴的部分。 \n\n5 、利用 CodeCompletion （代码完成）属性可以快速地在代码中完成各种不同地语句，方法是先键入一个类名地前几个字母然后再用 Ctrl-Space 完成全称。如果有多个选项，它们会列在速查列表里。 \n\n6 、用 Ctrl-/ 与 Ctrl-Shift-/ 来注释 / 反注释代码行与代码块。 \n\n-/ 用单行注释标记（“ //… ”）来注释 / 反注释当前行或者选择地代码块。而 Ctrl-Shift-/ 则可以用块注释标记（“ /*…*/ ”）把所选块包围起来。要反注释一个代码块就在块中任何一个地方按 Ctrl-Shift-/ 即可。\n\n\n\n7 、按 Alt-Q （ View|Context Info ）可以不需要移动代码就能查看当前方法地声明。连续按两次会显示当前所编辑的类名。 \n\n8 、使用 Refactor|Copy Class… 可以创建一个所选择的类的“副本”。这一点很有用，比如，在你想要创建一个大部分内容都和已存在类相同的类时。 \n\n\n9 、在编辑器里 Ctrl-D 可以复制选择的块或者没有所选块是的当前行。 \n\n\n10 、 Ctrl-W （选择字）在编辑器里的功能是先选择脱字符处的单词，然后选择源代码的扩展区域。举例来说，先选择一个方法名，然后是调用这个方法的表达式，然后是整个语句，然后包容块，等等。\n\n\n11 、如果你不想让指示事件细节的“亮球”图标在编辑器上显示，通过按 Alt-Enter 组合键打开所有事件列表然后用鼠标点击它就可以把这个事件文本附件的亮球置成非活动状态。 \n\n这样以后就不会有指示特殊事件的亮球出现了，但是你仍然可以用 Alt-Enter 快捷键使用它。\n\n\n12 、在使用 CodeCompletion 时，可以用逗点（ . ）字符，逗号（，）分号（；），空格和其它字符输入弹出列表里的当前高亮部分。选择的名字会随着输入的字符自动输入到编辑器里。 \n\n\n13 、在任何工具窗口里使用 Escape 键都可以把焦点移到编辑器上。 \n\nShift-Escape 不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口。 \n\nF12 键把焦点从编辑器移到最近使用的工具窗口。 \n\n\n14 、在调试程序时查看任何表达式值的一个容易的方法就是在编辑器中选择文本（可以按几次 Ctrl-W 组合键更有效地执行这个操作）然后按 Alt-F8 。 \n\n\n\n15 、要打开编辑器脱字符处使用的类或者方法 Java 文档的浏览器，就按 Shift-F1 （右键菜单的 External JavaDoc ）。 \n\n要使用这个功能须要把加入浏览器的路径，在“ General ”选项中设置（ Options | IDE Settings ），另外还要把创建的 Java 文档加入到工程中（ File | Project Properties ）。 \n\n\n16 、用 Ctrl-F12 （ View | File Structure Popup ）键你可以在当前编辑的文件中快速导航。 \n\n这时它会显示当前类的成员列表。选中一个要导航的元素然后按 Enter 键或 F4 键。要轻松地定位到列表中的一个条目，只需键入它的名字即可。 \n\n\n17 、在代码中把光标置于标记符或者它的检查点上再按 Alt-F7 （右键菜单中的 Find Usages… ）会很快地查找到在整个工程中使用地某一个类、方法或者变量的位置。\n\n\n18 、按 Ctrl-N （ Go to | Class… ）再键入类的名字可以快速地在编辑器里打开任何一个类。从显示出来的下拉列表里选择类。 \n同样的方法你可以通过使用 Ctrl-Shift-N （ Go to | File… ）打开工程中的非 Java 文件。\n\n19 、要导航代码中一些地方使用到的类、方法或者变量的声明，把光标放在查看项上再按 Ctrl-B 即可。也可以通过按 Ctrl 键的同时在查看点上单击鼠标键调转到声明处。 \n\n20 、把光标放到查看点上再按 Ctrl-Alt-B 可以导航到一个抽象方法的实现代码。\n\n\n21 、要看一个所选择的类的继承层次，按 Ctrl-H （ Browse Type Hierarchy ）即可。也可以激活编辑器中的继承关系视图查看当前编辑类的继承关系。22 、使用 Ctrl-Shift-F7 （ Search | Highlight Usages in File ）可以快速高亮显示当前文件中某一变量的使用地方。按 Escape 清除高亮显示。 \n\n\n23 、用 Alt-F3 （ Search | Incremental Search ）在编辑器中实现快速查查找功能。 \n\n在“ Search for: ”提示工具里输入字符，使用箭头键朝前和朝后搜索。按 Escape 退出。\n\n\n24 、按 Ctrl-J 组合键来执行一些你记不起来的 Live Template 缩写。比如，键“ it ”然后按 Ctrl-J 看看有什么发生。\n\n\n25 、 Introduce Variable 整合帮助你简化代码中复杂的声明。举个例子，在下面的代码片断里，在代码中选择一个表达式：然后按 Ctrl-Alt-V 。\n\n\n26 、 Ctrl-Shift-J 快捷键把两行合成一行并把不必要的空格去掉以匹配你的代码格式。\n\n\n27 、 Ctrl-Shift-Backspace （ Go to | Last Edit Location ）让你调转到代码中所做改变的最后一个地方。 \n\n多按几次 Ctrl-Shift-Backspace 查看更深的修改历史。 \n\n\n28 、用 Tools | Reformat Code… 根据你的代码样式参考（查看 Options | IDE Setting | Code Style ）格式化代码。 \n\n使用 Tools | Optimize Imports… 可以根据设置（查看 Options | IDE Setting | Code Style | Imports ）自动“优化” imports （清除无用的 imports 等）。\n\n\n29 、使用 IDEA 的 Live Templates | Live Templates 让你在眨眼间创建许多典型代码。比如，在一个方法里键入 \n\n再按 Tab 键看有什么事情发生了。 \n用 Tab 键在不同的模板域内移动。查看 Options | Live Templates 获取更多的细节。\n\n\n30 、要查看一个文件中修改的本地历史，激活右键菜单里的 Local VCS | Show History… 。也许你可以导航不同的文件版本，看看它们的不同之处再回滚到以前的任何一个版本吧。 \n\n使用同样的右键菜单条目还可以看到一个目录里修改的历史。有了这个特性你就不会丢失任何代码了。\n\n\n31 、如果要了解主菜单里每一个条目的用途，把鼠标指针移到菜单条目上再应用程序框架的底部的状态栏里就会显示它们的一些简短描述，也许会对你有帮助。 \n\n\n32 、要在编辑器里显示方法间的分隔线，打开 Options | IDE Settings | Editor ，选中“ Show method separators ”检查盒（ checkbox ）。 \n\n\n33 、用 Alt-Up 和 Alt-Down 键可以在编辑器里不同的方法之间快速移动。 \n\n\n34 、用 F2/Shift-F2 键在高亮显示的语法错误间跳转。 \n\n用 Ctrl-Alt-Down/Ctrl-Alt-Up 快捷键则可以在编译器错误信息或者查找操作结果间跳转。\n\n\n35 、通过按 Ctrl-O （ Code | Override Methods… ）可以很容易地重载基本类地方法。 \n\n要完成当前类 implements 的（或者抽象基本类的）接口的方法，就使用 Ctrl-I （ Code | Implement Methods… ）。 \n\n36 、如果光标置于一个方法调用的括号间，按 Ctrl-P 会显示一个可用参数的列表。\n\n37 、要快速查看编辑器脱字符处使用的类或方法的 Java 文档，按 Ctrl-Q （在弹出菜单的 Show Quick JavaDoc 里）即可。 \n\n38 、像 Ctrl-Q （ Show Quick JavaDoc 显示简洁 Java 文档）， Ctrl-P （ Show Parameter Info 显示参数信息）， Ctrl-B （ Go to Declaration 跳转到声明）， Shift-F1 （ External JavaDoc 外部 Java 文档）以及其它一些快捷键不仅可以在编辑器里使用，也可以应用在代码完成右键列表里。 \n\n39 、 Ctrl-E （ View | Recent Files ）弹出最近访问的文件右键列表。选中文件按 Enter 键打开。 \n\n40 、在 IDEA 中可以很容易地对你的类，方法以及变量进行重命名并在所有使用到它们的地方自动更正。 \n\n试一下，把编辑器脱字符置于任何一个变量名字上然后按 Shift-F6 （ Refactor | Rename… ）。在对话框里键入要显示地新名字再按 Enter 。你会浏览到使用这个变量地所有地方然后按“ Do Refactor ”按钮结束重命名操作。 \n\n41 、要在任何视图（ Project View 工程视图， Structure View 结构视图或者其它视图）里快速 \n\n选择当前编辑地部分（类，文件，方法或者字段），按 Alt-F1 （ View | Select in… ）。 \n\n42 、在“ new ”字符后实例化一个已知类型对象时也许你会用到 SmartType 代码完成这个特性。比如，键入 \n\n再按 Ctrl-Shift-Space ：\n\n43 、通过使用 SmartType 代码完成，在 IDEA 中创建接口的整个匿名 implementation 也是非常容易的，比如，对于一些 listener （监听器），可以键入 \n\nComponent component; \n\ncomponent.addMouseListener( \n\n  new <caret is here>   \n\n); \n\n然后再按 Ctrl-Shift-Space 看看有什么发生了。 \n\n\n44 、在你需要设置一个已知类型的表达式的值时用 SmartType 代码完成也很有帮助。比如，键入 \n\nString s = ( <caret is here>   \n\n再按 Ctrl-Shift-Space 看看会有什么出现。 \n\n\n45 、在所有视图里都提供了速查功能：在树里只需键入字符就可以快速定位到一个条目。 \n\n\n\n46 、当你想用代码片断捕捉异常时，在编辑器里选中这个片断，按 Ctrl-Alt-T （ Code | Surround with… ）然后选择“ try/catch ”。它会自动产生代码片断中抛出的所有异常的捕捉块。在 Options | File Templates | Code tab 中你还可以自己定制产生捕捉块的模板。 \n\n用列表中的其它项可以包围别的一些结构。 \n\n47 、在使用代码完成时，用 Tab 键可以输入弹出列表里的高亮显示部分。 \n\n不像用 Enter 键接受输入，这个选中的名字会覆盖掉脱字符右边名字的其它部分。这一点在用一个方法或者变量名替换另一个时特别有用。 \n\n\n48 、在声明一个变量时代码完成特性会给你显示一个建议名。比如，开始键入“ private FileOutputStream ”然后按 Ctrl-Space \n\n在 Options | IDE Setting | Code Style 中还可以为本地变量，参数，实例及静态字段定制名字。","source":"_posts/androidstudio-keaymap.md","raw":"---\ntitle: Android Studio 快捷键\ndate: 2016-04-23 16:25:25\ncategories: [android,学习笔记]\ntags: [androidstudio,快捷键]\n---\n原官方快捷键：https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf\nAlt+回车 导入包,自动修正\nCtrl+N   查找类\nCtrl+Shift+N 查找文件\nCtrl+Alt+L  格式化代码\nCtrl+Alt+O 优化导入的类和包\nAlt+Insert 生成代码(如get,set方法,构造函数等<!--more-->\nCtrl+E或者Alt+Shift+C  最近更改的代码\nCtrl+R 替换文本\nCtrl+F 查找文本\nCtrl+Shift+Space 自动补全代码\nCtrl+空格 代码提示\nCtrl+Alt+Space 类名或接口名提示\nCtrl+P 方法参数提示\nCtrl+Shift+Alt+N 查找类中的方法或变量\nAlt+Shift+C 对比最近修改的代码\n\nShift+F6  重构-重命名\nCtrl+Shift+先上键\nCtrl+Y 删除行（ctrl+x不是删除行，是剪切。如果不选中，则为剪切当行。ths for 貌似掉线）\nCtrl+D 复制行\nCtrl+/ 或 Ctrl+Shift+/  注释（// 或者/*...*/ ）\nCtrl+J  自动代码\nCtrl+E 最近打开的文件\nCtrl+H 显示类结构图\nCtrl+Q 显示注释文档\nAlt+F1 查找代码所在位置\nAlt+1 快速打开或隐藏工程面板\nCtrl+Alt+ left/right 返回至上次浏览的位置\nAlt+ left/right 切换代码视图\nAlt+ Up/Down 在方法间快速移动定位\nCtrl+Shift+Up/Down 代码向上/下移动。\nF2 或Shift+F2 高亮错误或警告快速定位\n\n代码标签输入完成后，按Tab，生成代码。\n选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。\nCtrl+W 选中代码，连续按会有其他效果\n选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。\nCtrl+Up/Down 光标跳转到第一行或最后一行下\nCtrl+B 快速打开光标处的类或方法 \n最常用快捷键\n1.Ctrl＋E，可以显示最近编辑的文件列表\n2.Shift＋Click可以关闭文件\n3.Ctrl＋[或]可以跳到大括号的开头结尾\n4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方\n5.Ctrl＋F12，可以显示当前文件的结构\n6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择\n7.Ctrl＋N，可以快速打开类\n8.Ctrl＋Shift＋N，可以快速打开文件\n9.Alt＋Q可以看到当前方法的声明\n10.Ctrl＋W可以选择单词继而语句继而行继而函数\n11.Alt＋F1可以将正在编辑的元素在各个面板中定位\n12.Ctrl＋P，可以显示参数信息\n13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入\n14.Alt＋Insert可以生成构造器/Getter/Setter等\n15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量\n16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch\n17.Alt＋Up and Alt＋Down可在方法间快速移动\n下面的不是很有用\n18.在一些地方按Alt＋Enter可以得到一些Intention Action，例如将”==”改为”equals()”\n19.Ctrl＋Shift＋Alt＋N可以快速打开符号\n20.Ctrl＋Shift＋Space在很多时候都能够给出Smart提示\n21.Alt＋F3可以快速寻找\n22.Ctrl＋/和Ctrl＋Shift＋/可以注释代码\n23.Ctrl＋Alt＋B可以跳转到抽象方法的实现\n24.Ctrl＋O可以选择父类的方法进行重写\n25.Ctrl＋Q可以看JavaDoc\n26.Ctrl＋Alt＋Space是类名自动完成\n27.快速打开类/文件/符号时，可以使用通配符，也可以使用缩写\n28.Live Templates! Ctrl＋J\n29.Ctrl＋Shift＋F7可以高亮当前元素在当前文件中的使用\n30.Ctrl＋Alt＋Up /Ctrl＋Alt＋Down可以快速跳转搜索结果\n31.Ctrl＋Shift＋J可以整合两行\n32.Alt＋F8是计算变量值\n\nIntelliJ IDEA使用技巧一览表 \n在使用 InelliJ IDEA 的过程中，通过查找资料以及一些自己的摸索，发现这个众多 Java 程序员喜欢的 IDE 里有许多值得一提的小窍门，如果能熟练的将它们应用于实际开发过程中，相信它会大大节省你的开发时间，而且随之而来的还会有那么一点点成就感：） Try it ！ \n\n1 、写代码时用 Alt-Insert （ Code|Generate… ）可以创建类里面任何字段的 getter 与 setter 方法。 \n<?xml:namespace prefix = v ns = \"urn:schemas-microsoft-com:vml\" /> \n\n2 、右键点击断点标记（在文本的左边栏里）激活速查菜单，你可以快速设置 enable/disable 断点或者条件它的属性。\n\n3 、 CodeCompletion （代码完成）属性里的一个特殊的变量是，激活 Ctrl-Alt-Space 可以完成在或不在当前文件里的类名。如果类没有引入则 import 标志会自动创建。\n\n4 、使用 Ctrl-Shift-V 快捷键可以将最近使用的剪贴板内容选择插入到文本。使用时系统会弹出一个含有剪贴内容的对话框，从中你可以选择你要粘贴的部分。 \n\n5 、利用 CodeCompletion （代码完成）属性可以快速地在代码中完成各种不同地语句，方法是先键入一个类名地前几个字母然后再用 Ctrl-Space 完成全称。如果有多个选项，它们会列在速查列表里。 \n\n6 、用 Ctrl-/ 与 Ctrl-Shift-/ 来注释 / 反注释代码行与代码块。 \n\n-/ 用单行注释标记（“ //… ”）来注释 / 反注释当前行或者选择地代码块。而 Ctrl-Shift-/ 则可以用块注释标记（“ /*…*/ ”）把所选块包围起来。要反注释一个代码块就在块中任何一个地方按 Ctrl-Shift-/ 即可。\n\n\n\n7 、按 Alt-Q （ View|Context Info ）可以不需要移动代码就能查看当前方法地声明。连续按两次会显示当前所编辑的类名。 \n\n8 、使用 Refactor|Copy Class… 可以创建一个所选择的类的“副本”。这一点很有用，比如，在你想要创建一个大部分内容都和已存在类相同的类时。 \n\n\n9 、在编辑器里 Ctrl-D 可以复制选择的块或者没有所选块是的当前行。 \n\n\n10 、 Ctrl-W （选择字）在编辑器里的功能是先选择脱字符处的单词，然后选择源代码的扩展区域。举例来说，先选择一个方法名，然后是调用这个方法的表达式，然后是整个语句，然后包容块，等等。\n\n\n11 、如果你不想让指示事件细节的“亮球”图标在编辑器上显示，通过按 Alt-Enter 组合键打开所有事件列表然后用鼠标点击它就可以把这个事件文本附件的亮球置成非活动状态。 \n\n这样以后就不会有指示特殊事件的亮球出现了，但是你仍然可以用 Alt-Enter 快捷键使用它。\n\n\n12 、在使用 CodeCompletion 时，可以用逗点（ . ）字符，逗号（，）分号（；），空格和其它字符输入弹出列表里的当前高亮部分。选择的名字会随着输入的字符自动输入到编辑器里。 \n\n\n13 、在任何工具窗口里使用 Escape 键都可以把焦点移到编辑器上。 \n\nShift-Escape 不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口。 \n\nF12 键把焦点从编辑器移到最近使用的工具窗口。 \n\n\n14 、在调试程序时查看任何表达式值的一个容易的方法就是在编辑器中选择文本（可以按几次 Ctrl-W 组合键更有效地执行这个操作）然后按 Alt-F8 。 \n\n\n\n15 、要打开编辑器脱字符处使用的类或者方法 Java 文档的浏览器，就按 Shift-F1 （右键菜单的 External JavaDoc ）。 \n\n要使用这个功能须要把加入浏览器的路径，在“ General ”选项中设置（ Options | IDE Settings ），另外还要把创建的 Java 文档加入到工程中（ File | Project Properties ）。 \n\n\n16 、用 Ctrl-F12 （ View | File Structure Popup ）键你可以在当前编辑的文件中快速导航。 \n\n这时它会显示当前类的成员列表。选中一个要导航的元素然后按 Enter 键或 F4 键。要轻松地定位到列表中的一个条目，只需键入它的名字即可。 \n\n\n17 、在代码中把光标置于标记符或者它的检查点上再按 Alt-F7 （右键菜单中的 Find Usages… ）会很快地查找到在整个工程中使用地某一个类、方法或者变量的位置。\n\n\n18 、按 Ctrl-N （ Go to | Class… ）再键入类的名字可以快速地在编辑器里打开任何一个类。从显示出来的下拉列表里选择类。 \n同样的方法你可以通过使用 Ctrl-Shift-N （ Go to | File… ）打开工程中的非 Java 文件。\n\n19 、要导航代码中一些地方使用到的类、方法或者变量的声明，把光标放在查看项上再按 Ctrl-B 即可。也可以通过按 Ctrl 键的同时在查看点上单击鼠标键调转到声明处。 \n\n20 、把光标放到查看点上再按 Ctrl-Alt-B 可以导航到一个抽象方法的实现代码。\n\n\n21 、要看一个所选择的类的继承层次，按 Ctrl-H （ Browse Type Hierarchy ）即可。也可以激活编辑器中的继承关系视图查看当前编辑类的继承关系。22 、使用 Ctrl-Shift-F7 （ Search | Highlight Usages in File ）可以快速高亮显示当前文件中某一变量的使用地方。按 Escape 清除高亮显示。 \n\n\n23 、用 Alt-F3 （ Search | Incremental Search ）在编辑器中实现快速查查找功能。 \n\n在“ Search for: ”提示工具里输入字符，使用箭头键朝前和朝后搜索。按 Escape 退出。\n\n\n24 、按 Ctrl-J 组合键来执行一些你记不起来的 Live Template 缩写。比如，键“ it ”然后按 Ctrl-J 看看有什么发生。\n\n\n25 、 Introduce Variable 整合帮助你简化代码中复杂的声明。举个例子，在下面的代码片断里，在代码中选择一个表达式：然后按 Ctrl-Alt-V 。\n\n\n26 、 Ctrl-Shift-J 快捷键把两行合成一行并把不必要的空格去掉以匹配你的代码格式。\n\n\n27 、 Ctrl-Shift-Backspace （ Go to | Last Edit Location ）让你调转到代码中所做改变的最后一个地方。 \n\n多按几次 Ctrl-Shift-Backspace 查看更深的修改历史。 \n\n\n28 、用 Tools | Reformat Code… 根据你的代码样式参考（查看 Options | IDE Setting | Code Style ）格式化代码。 \n\n使用 Tools | Optimize Imports… 可以根据设置（查看 Options | IDE Setting | Code Style | Imports ）自动“优化” imports （清除无用的 imports 等）。\n\n\n29 、使用 IDEA 的 Live Templates | Live Templates 让你在眨眼间创建许多典型代码。比如，在一个方法里键入 \n\n再按 Tab 键看有什么事情发生了。 \n用 Tab 键在不同的模板域内移动。查看 Options | Live Templates 获取更多的细节。\n\n\n30 、要查看一个文件中修改的本地历史，激活右键菜单里的 Local VCS | Show History… 。也许你可以导航不同的文件版本，看看它们的不同之处再回滚到以前的任何一个版本吧。 \n\n使用同样的右键菜单条目还可以看到一个目录里修改的历史。有了这个特性你就不会丢失任何代码了。\n\n\n31 、如果要了解主菜单里每一个条目的用途，把鼠标指针移到菜单条目上再应用程序框架的底部的状态栏里就会显示它们的一些简短描述，也许会对你有帮助。 \n\n\n32 、要在编辑器里显示方法间的分隔线，打开 Options | IDE Settings | Editor ，选中“ Show method separators ”检查盒（ checkbox ）。 \n\n\n33 、用 Alt-Up 和 Alt-Down 键可以在编辑器里不同的方法之间快速移动。 \n\n\n34 、用 F2/Shift-F2 键在高亮显示的语法错误间跳转。 \n\n用 Ctrl-Alt-Down/Ctrl-Alt-Up 快捷键则可以在编译器错误信息或者查找操作结果间跳转。\n\n\n35 、通过按 Ctrl-O （ Code | Override Methods… ）可以很容易地重载基本类地方法。 \n\n要完成当前类 implements 的（或者抽象基本类的）接口的方法，就使用 Ctrl-I （ Code | Implement Methods… ）。 \n\n36 、如果光标置于一个方法调用的括号间，按 Ctrl-P 会显示一个可用参数的列表。\n\n37 、要快速查看编辑器脱字符处使用的类或方法的 Java 文档，按 Ctrl-Q （在弹出菜单的 Show Quick JavaDoc 里）即可。 \n\n38 、像 Ctrl-Q （ Show Quick JavaDoc 显示简洁 Java 文档）， Ctrl-P （ Show Parameter Info 显示参数信息）， Ctrl-B （ Go to Declaration 跳转到声明）， Shift-F1 （ External JavaDoc 外部 Java 文档）以及其它一些快捷键不仅可以在编辑器里使用，也可以应用在代码完成右键列表里。 \n\n39 、 Ctrl-E （ View | Recent Files ）弹出最近访问的文件右键列表。选中文件按 Enter 键打开。 \n\n40 、在 IDEA 中可以很容易地对你的类，方法以及变量进行重命名并在所有使用到它们的地方自动更正。 \n\n试一下，把编辑器脱字符置于任何一个变量名字上然后按 Shift-F6 （ Refactor | Rename… ）。在对话框里键入要显示地新名字再按 Enter 。你会浏览到使用这个变量地所有地方然后按“ Do Refactor ”按钮结束重命名操作。 \n\n41 、要在任何视图（ Project View 工程视图， Structure View 结构视图或者其它视图）里快速 \n\n选择当前编辑地部分（类，文件，方法或者字段），按 Alt-F1 （ View | Select in… ）。 \n\n42 、在“ new ”字符后实例化一个已知类型对象时也许你会用到 SmartType 代码完成这个特性。比如，键入 \n\n再按 Ctrl-Shift-Space ：\n\n43 、通过使用 SmartType 代码完成，在 IDEA 中创建接口的整个匿名 implementation 也是非常容易的，比如，对于一些 listener （监听器），可以键入 \n\nComponent component; \n\ncomponent.addMouseListener( \n\n  new <caret is here>   \n\n); \n\n然后再按 Ctrl-Shift-Space 看看有什么发生了。 \n\n\n44 、在你需要设置一个已知类型的表达式的值时用 SmartType 代码完成也很有帮助。比如，键入 \n\nString s = ( <caret is here>   \n\n再按 Ctrl-Shift-Space 看看会有什么出现。 \n\n\n45 、在所有视图里都提供了速查功能：在树里只需键入字符就可以快速定位到一个条目。 \n\n\n\n46 、当你想用代码片断捕捉异常时，在编辑器里选中这个片断，按 Ctrl-Alt-T （ Code | Surround with… ）然后选择“ try/catch ”。它会自动产生代码片断中抛出的所有异常的捕捉块。在 Options | File Templates | Code tab 中你还可以自己定制产生捕捉块的模板。 \n\n用列表中的其它项可以包围别的一些结构。 \n\n47 、在使用代码完成时，用 Tab 键可以输入弹出列表里的高亮显示部分。 \n\n不像用 Enter 键接受输入，这个选中的名字会覆盖掉脱字符右边名字的其它部分。这一点在用一个方法或者变量名替换另一个时特别有用。 \n\n\n48 、在声明一个变量时代码完成特性会给你显示一个建议名。比如，开始键入“ private FileOutputStream ”然后按 Ctrl-Space \n\n在 Options | IDE Setting | Code Style 中还可以为本地变量，参数，实例及静态字段定制名字。","slug":"androidstudio-keaymap","published":1,"updated":"2016-04-23T09:59:26.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuch0001ng0g50v9q1cnh","content":"<p>原官方快捷键：<a href=\"https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf\" target=\"_blank\" rel=\"external\">https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf</a><br>Alt+回车 导入包,自动修正<br>Ctrl+N   查找类<br>Ctrl+Shift+N 查找文件<br>Ctrl+Alt+L  格式化代码<br>Ctrl+Alt+O 优化导入的类和包<br>Alt+Insert 生成代码(如get,set方法,构造函数等<a id=\"more\"></a><br>Ctrl+E或者Alt+Shift+C  最近更改的代码<br>Ctrl+R 替换文本<br>Ctrl+F 查找文本<br>Ctrl+Shift+Space 自动补全代码<br>Ctrl+空格 代码提示<br>Ctrl+Alt+Space 类名或接口名提示<br>Ctrl+P 方法参数提示<br>Ctrl+Shift+Alt+N 查找类中的方法或变量<br>Alt+Shift+C 对比最近修改的代码</p>\n<p>Shift+F6  重构-重命名<br>Ctrl+Shift+先上键<br>Ctrl+Y 删除行（ctrl+x不是删除行，是剪切。如果不选中，则为剪切当行。ths for 貌似掉线）<br>Ctrl+D 复制行<br>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）<br>Ctrl+J  自动代码<br>Ctrl+E 最近打开的文件<br>Ctrl+H 显示类结构图<br>Ctrl+Q 显示注释文档<br>Alt+F1 查找代码所在位置<br>Alt+1 快速打开或隐藏工程面板<br>Ctrl+Alt+ left/right 返回至上次浏览的位置<br>Alt+ left/right 切换代码视图<br>Alt+ Up/Down 在方法间快速移动定位<br>Ctrl+Shift+Up/Down 代码向上/下移动。<br>F2 或Shift+F2 高亮错误或警告快速定位</p>\n<p>代码标签输入完成后，按Tab，生成代码。<br>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。<br>Ctrl+W 选中代码，连续按会有其他效果<br>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。<br>Ctrl+Up/Down 光标跳转到第一行或最后一行下<br>Ctrl+B 快速打开光标处的类或方法<br>最常用快捷键<br>1.Ctrl＋E，可以显示最近编辑的文件列表<br>2.Shift＋Click可以关闭文件<br>3.Ctrl＋[或]可以跳到大括号的开头结尾<br>4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方<br>5.Ctrl＋F12，可以显示当前文件的结构<br>6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择<br>7.Ctrl＋N，可以快速打开类<br>8.Ctrl＋Shift＋N，可以快速打开文件<br>9.Alt＋Q可以看到当前方法的声明<br>10.Ctrl＋W可以选择单词继而语句继而行继而函数<br>11.Alt＋F1可以将正在编辑的元素在各个面板中定位<br>12.Ctrl＋P，可以显示参数信息<br>13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入<br>14.Alt＋Insert可以生成构造器/Getter/Setter等<br>15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量<br>16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch<br>17.Alt＋Up and Alt＋Down可在方法间快速移动<br>下面的不是很有用<br>18.在一些地方按Alt＋Enter可以得到一些Intention Action，例如将”==”改为”equals()”<br>19.Ctrl＋Shift＋Alt＋N可以快速打开符号<br>20.Ctrl＋Shift＋Space在很多时候都能够给出Smart提示<br>21.Alt＋F3可以快速寻找<br>22.Ctrl＋/和Ctrl＋Shift＋/可以注释代码<br>23.Ctrl＋Alt＋B可以跳转到抽象方法的实现<br>24.Ctrl＋O可以选择父类的方法进行重写<br>25.Ctrl＋Q可以看JavaDoc<br>26.Ctrl＋Alt＋Space是类名自动完成<br>27.快速打开类/文件/符号时，可以使用通配符，也可以使用缩写<br>28.Live Templates! Ctrl＋J<br>29.Ctrl＋Shift＋F7可以高亮当前元素在当前文件中的使用<br>30.Ctrl＋Alt＋Up /Ctrl＋Alt＋Down可以快速跳转搜索结果<br>31.Ctrl＋Shift＋J可以整合两行<br>32.Alt＋F8是计算变量值</p>\n<p>IntelliJ IDEA使用技巧一览表<br>在使用 InelliJ IDEA 的过程中，通过查找资料以及一些自己的摸索，发现这个众多 Java 程序员喜欢的 IDE 里有许多值得一提的小窍门，如果能熟练的将它们应用于实际开发过程中，相信它会大大节省你的开发时间，而且随之而来的还会有那么一点点成就感：） Try it ！ </p>\n<p>1 、写代码时用 Alt-Insert （ Code|Generate… ）可以创建类里面任何字段的 getter 与 setter 方法。<br>&lt;?xml:namespace prefix = v ns = “urn:schemas-microsoft-com:vml” /&gt; </p>\n<p>2 、右键点击断点标记（在文本的左边栏里）激活速查菜单，你可以快速设置 enable/disable 断点或者条件它的属性。</p>\n<p>3 、 CodeCompletion （代码完成）属性里的一个特殊的变量是，激活 Ctrl-Alt-Space 可以完成在或不在当前文件里的类名。如果类没有引入则 import 标志会自动创建。</p>\n<p>4 、使用 Ctrl-Shift-V 快捷键可以将最近使用的剪贴板内容选择插入到文本。使用时系统会弹出一个含有剪贴内容的对话框，从中你可以选择你要粘贴的部分。 </p>\n<p>5 、利用 CodeCompletion （代码完成）属性可以快速地在代码中完成各种不同地语句，方法是先键入一个类名地前几个字母然后再用 Ctrl-Space 完成全称。如果有多个选项，它们会列在速查列表里。 </p>\n<p>6 、用 Ctrl-/ 与 Ctrl-Shift-/ 来注释 / 反注释代码行与代码块。 </p>\n<p>-/ 用单行注释标记（“ //… ”）来注释 / 反注释当前行或者选择地代码块。而 Ctrl-Shift-/ 则可以用块注释标记（“ /<em>…</em>/ ”）把所选块包围起来。要反注释一个代码块就在块中任何一个地方按 Ctrl-Shift-/ 即可。</p>\n<p>7 、按 Alt-Q （ View|Context Info ）可以不需要移动代码就能查看当前方法地声明。连续按两次会显示当前所编辑的类名。 </p>\n<p>8 、使用 Refactor|Copy Class… 可以创建一个所选择的类的“副本”。这一点很有用，比如，在你想要创建一个大部分内容都和已存在类相同的类时。 </p>\n<p>9 、在编辑器里 Ctrl-D 可以复制选择的块或者没有所选块是的当前行。 </p>\n<p>10 、 Ctrl-W （选择字）在编辑器里的功能是先选择脱字符处的单词，然后选择源代码的扩展区域。举例来说，先选择一个方法名，然后是调用这个方法的表达式，然后是整个语句，然后包容块，等等。</p>\n<p>11 、如果你不想让指示事件细节的“亮球”图标在编辑器上显示，通过按 Alt-Enter 组合键打开所有事件列表然后用鼠标点击它就可以把这个事件文本附件的亮球置成非活动状态。 </p>\n<p>这样以后就不会有指示特殊事件的亮球出现了，但是你仍然可以用 Alt-Enter 快捷键使用它。</p>\n<p>12 、在使用 CodeCompletion 时，可以用逗点（ . ）字符，逗号（，）分号（；），空格和其它字符输入弹出列表里的当前高亮部分。选择的名字会随着输入的字符自动输入到编辑器里。 </p>\n<p>13 、在任何工具窗口里使用 Escape 键都可以把焦点移到编辑器上。 </p>\n<p>Shift-Escape 不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口。 </p>\n<p>F12 键把焦点从编辑器移到最近使用的工具窗口。 </p>\n<p>14 、在调试程序时查看任何表达式值的一个容易的方法就是在编辑器中选择文本（可以按几次 Ctrl-W 组合键更有效地执行这个操作）然后按 Alt-F8 。 </p>\n<p>15 、要打开编辑器脱字符处使用的类或者方法 Java 文档的浏览器，就按 Shift-F1 （右键菜单的 External JavaDoc ）。 </p>\n<p>要使用这个功能须要把加入浏览器的路径，在“ General ”选项中设置（ Options | IDE Settings ），另外还要把创建的 Java 文档加入到工程中（ File | Project Properties ）。 </p>\n<p>16 、用 Ctrl-F12 （ View | File Structure Popup ）键你可以在当前编辑的文件中快速导航。 </p>\n<p>这时它会显示当前类的成员列表。选中一个要导航的元素然后按 Enter 键或 F4 键。要轻松地定位到列表中的一个条目，只需键入它的名字即可。 </p>\n<p>17 、在代码中把光标置于标记符或者它的检查点上再按 Alt-F7 （右键菜单中的 Find Usages… ）会很快地查找到在整个工程中使用地某一个类、方法或者变量的位置。</p>\n<p>18 、按 Ctrl-N （ Go to | Class… ）再键入类的名字可以快速地在编辑器里打开任何一个类。从显示出来的下拉列表里选择类。<br>同样的方法你可以通过使用 Ctrl-Shift-N （ Go to | File… ）打开工程中的非 Java 文件。</p>\n<p>19 、要导航代码中一些地方使用到的类、方法或者变量的声明，把光标放在查看项上再按 Ctrl-B 即可。也可以通过按 Ctrl 键的同时在查看点上单击鼠标键调转到声明处。 </p>\n<p>20 、把光标放到查看点上再按 Ctrl-Alt-B 可以导航到一个抽象方法的实现代码。</p>\n<p>21 、要看一个所选择的类的继承层次，按 Ctrl-H （ Browse Type Hierarchy ）即可。也可以激活编辑器中的继承关系视图查看当前编辑类的继承关系。22 、使用 Ctrl-Shift-F7 （ Search | Highlight Usages in File ）可以快速高亮显示当前文件中某一变量的使用地方。按 Escape 清除高亮显示。 </p>\n<p>23 、用 Alt-F3 （ Search | Incremental Search ）在编辑器中实现快速查查找功能。 </p>\n<p>在“ Search for: ”提示工具里输入字符，使用箭头键朝前和朝后搜索。按 Escape 退出。</p>\n<p>24 、按 Ctrl-J 组合键来执行一些你记不起来的 Live Template 缩写。比如，键“ it ”然后按 Ctrl-J 看看有什么发生。</p>\n<p>25 、 Introduce Variable 整合帮助你简化代码中复杂的声明。举个例子，在下面的代码片断里，在代码中选择一个表达式：然后按 Ctrl-Alt-V 。</p>\n<p>26 、 Ctrl-Shift-J 快捷键把两行合成一行并把不必要的空格去掉以匹配你的代码格式。</p>\n<p>27 、 Ctrl-Shift-Backspace （ Go to | Last Edit Location ）让你调转到代码中所做改变的最后一个地方。 </p>\n<p>多按几次 Ctrl-Shift-Backspace 查看更深的修改历史。 </p>\n<p>28 、用 Tools | Reformat Code… 根据你的代码样式参考（查看 Options | IDE Setting | Code Style ）格式化代码。 </p>\n<p>使用 Tools | Optimize Imports… 可以根据设置（查看 Options | IDE Setting | Code Style | Imports ）自动“优化” imports （清除无用的 imports 等）。</p>\n<p>29 、使用 IDEA 的 Live Templates | Live Templates 让你在眨眼间创建许多典型代码。比如，在一个方法里键入 </p>\n<p>再按 Tab 键看有什么事情发生了。<br>用 Tab 键在不同的模板域内移动。查看 Options | Live Templates 获取更多的细节。</p>\n<p>30 、要查看一个文件中修改的本地历史，激活右键菜单里的 Local VCS | Show History… 。也许你可以导航不同的文件版本，看看它们的不同之处再回滚到以前的任何一个版本吧。 </p>\n<p>使用同样的右键菜单条目还可以看到一个目录里修改的历史。有了这个特性你就不会丢失任何代码了。</p>\n<p>31 、如果要了解主菜单里每一个条目的用途，把鼠标指针移到菜单条目上再应用程序框架的底部的状态栏里就会显示它们的一些简短描述，也许会对你有帮助。 </p>\n<p>32 、要在编辑器里显示方法间的分隔线，打开 Options | IDE Settings | Editor ，选中“ Show method separators ”检查盒（ checkbox ）。 </p>\n<p>33 、用 Alt-Up 和 Alt-Down 键可以在编辑器里不同的方法之间快速移动。 </p>\n<p>34 、用 F2/Shift-F2 键在高亮显示的语法错误间跳转。 </p>\n<p>用 Ctrl-Alt-Down/Ctrl-Alt-Up 快捷键则可以在编译器错误信息或者查找操作结果间跳转。</p>\n<p>35 、通过按 Ctrl-O （ Code | Override Methods… ）可以很容易地重载基本类地方法。 </p>\n<p>要完成当前类 implements 的（或者抽象基本类的）接口的方法，就使用 Ctrl-I （ Code | Implement Methods… ）。 </p>\n<p>36 、如果光标置于一个方法调用的括号间，按 Ctrl-P 会显示一个可用参数的列表。</p>\n<p>37 、要快速查看编辑器脱字符处使用的类或方法的 Java 文档，按 Ctrl-Q （在弹出菜单的 Show Quick JavaDoc 里）即可。 </p>\n<p>38 、像 Ctrl-Q （ Show Quick JavaDoc 显示简洁 Java 文档）， Ctrl-P （ Show Parameter Info 显示参数信息）， Ctrl-B （ Go to Declaration 跳转到声明）， Shift-F1 （ External JavaDoc 外部 Java 文档）以及其它一些快捷键不仅可以在编辑器里使用，也可以应用在代码完成右键列表里。 </p>\n<p>39 、 Ctrl-E （ View | Recent Files ）弹出最近访问的文件右键列表。选中文件按 Enter 键打开。 </p>\n<p>40 、在 IDEA 中可以很容易地对你的类，方法以及变量进行重命名并在所有使用到它们的地方自动更正。 </p>\n<p>试一下，把编辑器脱字符置于任何一个变量名字上然后按 Shift-F6 （ Refactor | Rename… ）。在对话框里键入要显示地新名字再按 Enter 。你会浏览到使用这个变量地所有地方然后按“ Do Refactor ”按钮结束重命名操作。 </p>\n<p>41 、要在任何视图（ Project View 工程视图， Structure View 结构视图或者其它视图）里快速 </p>\n<p>选择当前编辑地部分（类，文件，方法或者字段），按 Alt-F1 （ View | Select in… ）。 </p>\n<p>42 、在“ new ”字符后实例化一个已知类型对象时也许你会用到 SmartType 代码完成这个特性。比如，键入 </p>\n<p>再按 Ctrl-Shift-Space ：</p>\n<p>43 、通过使用 SmartType 代码完成，在 IDEA 中创建接口的整个匿名 implementation 也是非常容易的，比如，对于一些 listener （监听器），可以键入 </p>\n<p>Component component; </p>\n<p>component.addMouseListener( </p>\n<p>  new <caret is=\"\" here=\"\">   </caret></p>\n<p>); </p>\n<p>然后再按 Ctrl-Shift-Space 看看有什么发生了。 </p>\n<p>44 、在你需要设置一个已知类型的表达式的值时用 SmartType 代码完成也很有帮助。比如，键入 </p>\n<p>String s = ( <caret is=\"\" here=\"\">   </caret></p>\n<p>再按 Ctrl-Shift-Space 看看会有什么出现。 </p>\n<p>45 、在所有视图里都提供了速查功能：在树里只需键入字符就可以快速定位到一个条目。 </p>\n<p>46 、当你想用代码片断捕捉异常时，在编辑器里选中这个片断，按 Ctrl-Alt-T （ Code | Surround with… ）然后选择“ try/catch ”。它会自动产生代码片断中抛出的所有异常的捕捉块。在 Options | File Templates | Code tab 中你还可以自己定制产生捕捉块的模板。 </p>\n<p>用列表中的其它项可以包围别的一些结构。 </p>\n<p>47 、在使用代码完成时，用 Tab 键可以输入弹出列表里的高亮显示部分。 </p>\n<p>不像用 Enter 键接受输入，这个选中的名字会覆盖掉脱字符右边名字的其它部分。这一点在用一个方法或者变量名替换另一个时特别有用。 </p>\n<p>48 、在声明一个变量时代码完成特性会给你显示一个建议名。比如，开始键入“ private FileOutputStream ”然后按 Ctrl-Space </p>\n<p>在 Options | IDE Setting | Code Style 中还可以为本地变量，参数，实例及静态字段定制名字。</p>\n","excerpt":"<p>原官方快捷键：<a href=\"https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf\">https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf</a><br>Alt+回车 导入包,自动修正<br>Ctrl+N   查找类<br>Ctrl+Shift+N 查找文件<br>Ctrl+Alt+L  格式化代码<br>Ctrl+Alt+O 优化导入的类和包<br>Alt+Insert 生成代码(如get,set方法,构造函数等","more":"<br>Ctrl+E或者Alt+Shift+C  最近更改的代码<br>Ctrl+R 替换文本<br>Ctrl+F 查找文本<br>Ctrl+Shift+Space 自动补全代码<br>Ctrl+空格 代码提示<br>Ctrl+Alt+Space 类名或接口名提示<br>Ctrl+P 方法参数提示<br>Ctrl+Shift+Alt+N 查找类中的方法或变量<br>Alt+Shift+C 对比最近修改的代码</p>\n<p>Shift+F6  重构-重命名<br>Ctrl+Shift+先上键<br>Ctrl+Y 删除行（ctrl+x不是删除行，是剪切。如果不选中，则为剪切当行。ths for 貌似掉线）<br>Ctrl+D 复制行<br>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）<br>Ctrl+J  自动代码<br>Ctrl+E 最近打开的文件<br>Ctrl+H 显示类结构图<br>Ctrl+Q 显示注释文档<br>Alt+F1 查找代码所在位置<br>Alt+1 快速打开或隐藏工程面板<br>Ctrl+Alt+ left/right 返回至上次浏览的位置<br>Alt+ left/right 切换代码视图<br>Alt+ Up/Down 在方法间快速移动定位<br>Ctrl+Shift+Up/Down 代码向上/下移动。<br>F2 或Shift+F2 高亮错误或警告快速定位</p>\n<p>代码标签输入完成后，按Tab，生成代码。<br>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。<br>Ctrl+W 选中代码，连续按会有其他效果<br>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。<br>Ctrl+Up/Down 光标跳转到第一行或最后一行下<br>Ctrl+B 快速打开光标处的类或方法<br>最常用快捷键<br>1.Ctrl＋E，可以显示最近编辑的文件列表<br>2.Shift＋Click可以关闭文件<br>3.Ctrl＋[或]可以跳到大括号的开头结尾<br>4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方<br>5.Ctrl＋F12，可以显示当前文件的结构<br>6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择<br>7.Ctrl＋N，可以快速打开类<br>8.Ctrl＋Shift＋N，可以快速打开文件<br>9.Alt＋Q可以看到当前方法的声明<br>10.Ctrl＋W可以选择单词继而语句继而行继而函数<br>11.Alt＋F1可以将正在编辑的元素在各个面板中定位<br>12.Ctrl＋P，可以显示参数信息<br>13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入<br>14.Alt＋Insert可以生成构造器/Getter/Setter等<br>15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量<br>16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch<br>17.Alt＋Up and Alt＋Down可在方法间快速移动<br>下面的不是很有用<br>18.在一些地方按Alt＋Enter可以得到一些Intention Action，例如将”==”改为”equals()”<br>19.Ctrl＋Shift＋Alt＋N可以快速打开符号<br>20.Ctrl＋Shift＋Space在很多时候都能够给出Smart提示<br>21.Alt＋F3可以快速寻找<br>22.Ctrl＋/和Ctrl＋Shift＋/可以注释代码<br>23.Ctrl＋Alt＋B可以跳转到抽象方法的实现<br>24.Ctrl＋O可以选择父类的方法进行重写<br>25.Ctrl＋Q可以看JavaDoc<br>26.Ctrl＋Alt＋Space是类名自动完成<br>27.快速打开类/文件/符号时，可以使用通配符，也可以使用缩写<br>28.Live Templates! Ctrl＋J<br>29.Ctrl＋Shift＋F7可以高亮当前元素在当前文件中的使用<br>30.Ctrl＋Alt＋Up /Ctrl＋Alt＋Down可以快速跳转搜索结果<br>31.Ctrl＋Shift＋J可以整合两行<br>32.Alt＋F8是计算变量值</p>\n<p>IntelliJ IDEA使用技巧一览表<br>在使用 InelliJ IDEA 的过程中，通过查找资料以及一些自己的摸索，发现这个众多 Java 程序员喜欢的 IDE 里有许多值得一提的小窍门，如果能熟练的将它们应用于实际开发过程中，相信它会大大节省你的开发时间，而且随之而来的还会有那么一点点成就感：） Try it ！ </p>\n<p>1 、写代码时用 Alt-Insert （ Code|Generate… ）可以创建类里面任何字段的 getter 与 setter 方法。<br>&lt;?xml:namespace prefix = v ns = “urn:schemas-microsoft-com:vml” /&gt; </p>\n<p>2 、右键点击断点标记（在文本的左边栏里）激活速查菜单，你可以快速设置 enable/disable 断点或者条件它的属性。</p>\n<p>3 、 CodeCompletion （代码完成）属性里的一个特殊的变量是，激活 Ctrl-Alt-Space 可以完成在或不在当前文件里的类名。如果类没有引入则 import 标志会自动创建。</p>\n<p>4 、使用 Ctrl-Shift-V 快捷键可以将最近使用的剪贴板内容选择插入到文本。使用时系统会弹出一个含有剪贴内容的对话框，从中你可以选择你要粘贴的部分。 </p>\n<p>5 、利用 CodeCompletion （代码完成）属性可以快速地在代码中完成各种不同地语句，方法是先键入一个类名地前几个字母然后再用 Ctrl-Space 完成全称。如果有多个选项，它们会列在速查列表里。 </p>\n<p>6 、用 Ctrl-/ 与 Ctrl-Shift-/ 来注释 / 反注释代码行与代码块。 </p>\n<p>-/ 用单行注释标记（“ //… ”）来注释 / 反注释当前行或者选择地代码块。而 Ctrl-Shift-/ 则可以用块注释标记（“ /<em>…</em>/ ”）把所选块包围起来。要反注释一个代码块就在块中任何一个地方按 Ctrl-Shift-/ 即可。</p>\n<p>7 、按 Alt-Q （ View|Context Info ）可以不需要移动代码就能查看当前方法地声明。连续按两次会显示当前所编辑的类名。 </p>\n<p>8 、使用 Refactor|Copy Class… 可以创建一个所选择的类的“副本”。这一点很有用，比如，在你想要创建一个大部分内容都和已存在类相同的类时。 </p>\n<p>9 、在编辑器里 Ctrl-D 可以复制选择的块或者没有所选块是的当前行。 </p>\n<p>10 、 Ctrl-W （选择字）在编辑器里的功能是先选择脱字符处的单词，然后选择源代码的扩展区域。举例来说，先选择一个方法名，然后是调用这个方法的表达式，然后是整个语句，然后包容块，等等。</p>\n<p>11 、如果你不想让指示事件细节的“亮球”图标在编辑器上显示，通过按 Alt-Enter 组合键打开所有事件列表然后用鼠标点击它就可以把这个事件文本附件的亮球置成非活动状态。 </p>\n<p>这样以后就不会有指示特殊事件的亮球出现了，但是你仍然可以用 Alt-Enter 快捷键使用它。</p>\n<p>12 、在使用 CodeCompletion 时，可以用逗点（ . ）字符，逗号（，）分号（；），空格和其它字符输入弹出列表里的当前高亮部分。选择的名字会随着输入的字符自动输入到编辑器里。 </p>\n<p>13 、在任何工具窗口里使用 Escape 键都可以把焦点移到编辑器上。 </p>\n<p>Shift-Escape 不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口。 </p>\n<p>F12 键把焦点从编辑器移到最近使用的工具窗口。 </p>\n<p>14 、在调试程序时查看任何表达式值的一个容易的方法就是在编辑器中选择文本（可以按几次 Ctrl-W 组合键更有效地执行这个操作）然后按 Alt-F8 。 </p>\n<p>15 、要打开编辑器脱字符处使用的类或者方法 Java 文档的浏览器，就按 Shift-F1 （右键菜单的 External JavaDoc ）。 </p>\n<p>要使用这个功能须要把加入浏览器的路径，在“ General ”选项中设置（ Options | IDE Settings ），另外还要把创建的 Java 文档加入到工程中（ File | Project Properties ）。 </p>\n<p>16 、用 Ctrl-F12 （ View | File Structure Popup ）键你可以在当前编辑的文件中快速导航。 </p>\n<p>这时它会显示当前类的成员列表。选中一个要导航的元素然后按 Enter 键或 F4 键。要轻松地定位到列表中的一个条目，只需键入它的名字即可。 </p>\n<p>17 、在代码中把光标置于标记符或者它的检查点上再按 Alt-F7 （右键菜单中的 Find Usages… ）会很快地查找到在整个工程中使用地某一个类、方法或者变量的位置。</p>\n<p>18 、按 Ctrl-N （ Go to | Class… ）再键入类的名字可以快速地在编辑器里打开任何一个类。从显示出来的下拉列表里选择类。<br>同样的方法你可以通过使用 Ctrl-Shift-N （ Go to | File… ）打开工程中的非 Java 文件。</p>\n<p>19 、要导航代码中一些地方使用到的类、方法或者变量的声明，把光标放在查看项上再按 Ctrl-B 即可。也可以通过按 Ctrl 键的同时在查看点上单击鼠标键调转到声明处。 </p>\n<p>20 、把光标放到查看点上再按 Ctrl-Alt-B 可以导航到一个抽象方法的实现代码。</p>\n<p>21 、要看一个所选择的类的继承层次，按 Ctrl-H （ Browse Type Hierarchy ）即可。也可以激活编辑器中的继承关系视图查看当前编辑类的继承关系。22 、使用 Ctrl-Shift-F7 （ Search | Highlight Usages in File ）可以快速高亮显示当前文件中某一变量的使用地方。按 Escape 清除高亮显示。 </p>\n<p>23 、用 Alt-F3 （ Search | Incremental Search ）在编辑器中实现快速查查找功能。 </p>\n<p>在“ Search for: ”提示工具里输入字符，使用箭头键朝前和朝后搜索。按 Escape 退出。</p>\n<p>24 、按 Ctrl-J 组合键来执行一些你记不起来的 Live Template 缩写。比如，键“ it ”然后按 Ctrl-J 看看有什么发生。</p>\n<p>25 、 Introduce Variable 整合帮助你简化代码中复杂的声明。举个例子，在下面的代码片断里，在代码中选择一个表达式：然后按 Ctrl-Alt-V 。</p>\n<p>26 、 Ctrl-Shift-J 快捷键把两行合成一行并把不必要的空格去掉以匹配你的代码格式。</p>\n<p>27 、 Ctrl-Shift-Backspace （ Go to | Last Edit Location ）让你调转到代码中所做改变的最后一个地方。 </p>\n<p>多按几次 Ctrl-Shift-Backspace 查看更深的修改历史。 </p>\n<p>28 、用 Tools | Reformat Code… 根据你的代码样式参考（查看 Options | IDE Setting | Code Style ）格式化代码。 </p>\n<p>使用 Tools | Optimize Imports… 可以根据设置（查看 Options | IDE Setting | Code Style | Imports ）自动“优化” imports （清除无用的 imports 等）。</p>\n<p>29 、使用 IDEA 的 Live Templates | Live Templates 让你在眨眼间创建许多典型代码。比如，在一个方法里键入 </p>\n<p>再按 Tab 键看有什么事情发生了。<br>用 Tab 键在不同的模板域内移动。查看 Options | Live Templates 获取更多的细节。</p>\n<p>30 、要查看一个文件中修改的本地历史，激活右键菜单里的 Local VCS | Show History… 。也许你可以导航不同的文件版本，看看它们的不同之处再回滚到以前的任何一个版本吧。 </p>\n<p>使用同样的右键菜单条目还可以看到一个目录里修改的历史。有了这个特性你就不会丢失任何代码了。</p>\n<p>31 、如果要了解主菜单里每一个条目的用途，把鼠标指针移到菜单条目上再应用程序框架的底部的状态栏里就会显示它们的一些简短描述，也许会对你有帮助。 </p>\n<p>32 、要在编辑器里显示方法间的分隔线，打开 Options | IDE Settings | Editor ，选中“ Show method separators ”检查盒（ checkbox ）。 </p>\n<p>33 、用 Alt-Up 和 Alt-Down 键可以在编辑器里不同的方法之间快速移动。 </p>\n<p>34 、用 F2/Shift-F2 键在高亮显示的语法错误间跳转。 </p>\n<p>用 Ctrl-Alt-Down/Ctrl-Alt-Up 快捷键则可以在编译器错误信息或者查找操作结果间跳转。</p>\n<p>35 、通过按 Ctrl-O （ Code | Override Methods… ）可以很容易地重载基本类地方法。 </p>\n<p>要完成当前类 implements 的（或者抽象基本类的）接口的方法，就使用 Ctrl-I （ Code | Implement Methods… ）。 </p>\n<p>36 、如果光标置于一个方法调用的括号间，按 Ctrl-P 会显示一个可用参数的列表。</p>\n<p>37 、要快速查看编辑器脱字符处使用的类或方法的 Java 文档，按 Ctrl-Q （在弹出菜单的 Show Quick JavaDoc 里）即可。 </p>\n<p>38 、像 Ctrl-Q （ Show Quick JavaDoc 显示简洁 Java 文档）， Ctrl-P （ Show Parameter Info 显示参数信息）， Ctrl-B （ Go to Declaration 跳转到声明）， Shift-F1 （ External JavaDoc 外部 Java 文档）以及其它一些快捷键不仅可以在编辑器里使用，也可以应用在代码完成右键列表里。 </p>\n<p>39 、 Ctrl-E （ View | Recent Files ）弹出最近访问的文件右键列表。选中文件按 Enter 键打开。 </p>\n<p>40 、在 IDEA 中可以很容易地对你的类，方法以及变量进行重命名并在所有使用到它们的地方自动更正。 </p>\n<p>试一下，把编辑器脱字符置于任何一个变量名字上然后按 Shift-F6 （ Refactor | Rename… ）。在对话框里键入要显示地新名字再按 Enter 。你会浏览到使用这个变量地所有地方然后按“ Do Refactor ”按钮结束重命名操作。 </p>\n<p>41 、要在任何视图（ Project View 工程视图， Structure View 结构视图或者其它视图）里快速 </p>\n<p>选择当前编辑地部分（类，文件，方法或者字段），按 Alt-F1 （ View | Select in… ）。 </p>\n<p>42 、在“ new ”字符后实例化一个已知类型对象时也许你会用到 SmartType 代码完成这个特性。比如，键入 </p>\n<p>再按 Ctrl-Shift-Space ：</p>\n<p>43 、通过使用 SmartType 代码完成，在 IDEA 中创建接口的整个匿名 implementation 也是非常容易的，比如，对于一些 listener （监听器），可以键入 </p>\n<p>Component component; </p>\n<p>component.addMouseListener( </p>\n<p>  new <caret is here>   </p>\n<p>); </p>\n<p>然后再按 Ctrl-Shift-Space 看看有什么发生了。 </p>\n<p>44 、在你需要设置一个已知类型的表达式的值时用 SmartType 代码完成也很有帮助。比如，键入 </p>\n<p>String s = ( <caret is here>   </p>\n<p>再按 Ctrl-Shift-Space 看看会有什么出现。 </p>\n<p>45 、在所有视图里都提供了速查功能：在树里只需键入字符就可以快速定位到一个条目。 </p>\n<p>46 、当你想用代码片断捕捉异常时，在编辑器里选中这个片断，按 Ctrl-Alt-T （ Code | Surround with… ）然后选择“ try/catch ”。它会自动产生代码片断中抛出的所有异常的捕捉块。在 Options | File Templates | Code tab 中你还可以自己定制产生捕捉块的模板。 </p>\n<p>用列表中的其它项可以包围别的一些结构。 </p>\n<p>47 、在使用代码完成时，用 Tab 键可以输入弹出列表里的高亮显示部分。 </p>\n<p>不像用 Enter 键接受输入，这个选中的名字会覆盖掉脱字符右边名字的其它部分。这一点在用一个方法或者变量名替换另一个时特别有用。 </p>\n<p>48 、在声明一个变量时代码完成特性会给你显示一个建议名。比如，开始键入“ private FileOutputStream ”然后按 Ctrl-Space </p>\n<p>在 Options | IDE Setting | Code Style 中还可以为本地变量，参数，实例及静态字段定制名字。</p>"},{"title":"android自动获取短信验证码","date":"2016-04-23T08:08:25.000Z","_content":"这里主要使用了**ContentObserver**类（观察者模式类）来监听短信的变化，然后通过**正则表达式**，提取出短信，然后在子线程中更新UI，显示验证码。<!--more-->\n所谓的观察者模式，它是软件设计模式的一种，在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。观察者模式（Observer）完美的将观察者和被观察的对象分离开，在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。观察者设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。\nContentObserver,内容观察者，目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当 ContentObserver 所观察的Uri发生变化时，便会触发它。\n观察特定Uri的步骤如下：\n\n 1. 、创建我们特定的 ContentObserver 派生类，必须重载父类构造方法，必须重载 onChange() 方法去处理回调后的功能实现。\n 2. 利用 context.getContentResolover() 获得 ContentResolove 对象，接着调用 registerContentObserver() 方法去注册内容观察者。\n 3. 由于 ContentObserver 的生命周期不同步于 Activity 和 Service 等，因此，在不需要时，需要手动的调用 unregisterContentObserver() 去取消注册。\n\n*具体使用：*\n### 1、继承ContentObserver，重写onChange方法\n```\npackage com.tx.testsms;\n/**\n * 自动读取短信验证码\n */\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport android.content.Context;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.util.Log;\n\npublic class SmsObserver extends ContentObserver {\n\n\tprivate Context mContext;\n\tprivate Handler mHandler;\n\tprivate String tel_phone = \"\";\n\n\tprivate String code;\n\n\tpublic void setTel_phone(String tel_phone) {\n\t\tthis.tel_phone = tel_phone;\n\t}\n\n\tpublic SmsObserver(Context mContext, Handler handler) {\n\t\tsuper(handler);\n\t\tthis.mContext = mContext;\n\t\tthis.mHandler = handler;\n\t}\n\n\t@Override\n\tpublic void onChange(boolean selfChange, Uri uri) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onChange(selfChange, uri);\n\n\t\tif(uri.toString().equals(\"content:://sms//raw\")){\n\t\t\treturn;\n\t\t}\n\n\t\tUri inboxUri = Uri.parse(\"content://sms//inbox\");\n\n\t\tCursor cursor = mContext.getContentResolver().\n\t\t\t\tquery(inboxUri, null, null, null, \"date desc\");\n\n\t\tif(cursor!=null){\n\t\t\tif(cursor.moveToFirst()){\n\t\t\t\tString address = cursor.getString(cursor.getColumnIndex(\"address\"));\n\t\t\t\tLog.i(\"test\", \"短信验证码为：--------\"+address);\n\n\t\t\t\tString body = cursor.getString(cursor.getColumnIndex(\"body\"));\n\t\t\t\tLog.i(\"test\", \"uri---------\"+inboxUri);\n\n\t\t\t\tif(address.equals(tel_phone)){\n\n\t\t\t\t\tPattern pattern = Pattern.compile(\"(\\\\d{4})\");\n\t\t\t\t\tMatcher matcher = pattern.matcher(body);\n\n\t\t\t\t\tif(matcher.find()){\n\t\t\t\t\t\tcode = matcher.group(0);\n\t\t\t\t\t\tLog.i(\"test\", \"短信验证码为：--------\"+code);\n\t\t\t\t\t\tmHandler.obtainMessage(\n\t\t\t\t\t\t\t\tMainActivity.MSG_RECEIVED_CODE,code).sendToTarget();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tcursor.close();\n\t\t}\n\t}\n}\n```\n\n### 2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册\n```\npackage com.tx.testsms;\n\nimport android.app.Activity;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.Window;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\npublic class MainActivity extends Activity {\n\n\tpublic static final int MSG_RECEIVED_CODE = 1;\n\n\tprivate SmsObserver mSmsObserver;\n\tprivate Handler mHandler;\n\n\tprivate EditText metPhone;\n\tprivate TextView mtvCode;\n\tprivate Button mbtnButton;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\tsetContentView(R.layout.activity_main);\n\n\t\tmetPhone = (EditText) findViewById(R.id.phone);\n\t\tmbtnButton = (Button) findViewById(R.id.btn);\n\t\tmtvCode = (TextView) findViewById(R.id.code);\n\n\t\t/**\n\t\t * 设置手机号，拦截固定的手机号\n\t\t */\n\n\t\tmbtnButton.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View arg0) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tmSmsObserver.setTel_phone(metPhone.getText().toString());\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * 在子线程中更新UI\n\t\t */\n\t\tmHandler = new Handler(){\n\t\t\t@Override\n\t\t\tpublic void handleMessage(Message msg) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tsuper.handleMessage(msg);\n\t\t\t\tif(msg.what == MSG_RECEIVED_CODE){\n\t\t\t\t\tmtvCode.setText(\"四位短信验证码为：\"+msg.obj.toString());\n\t\t\t\t\tToast.makeText(getApplicationContext(), msg.obj.toString(), Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t<span style=\"color:#ff0000;\">/**\n\t\t * 实例化ContentObserver,注册短信监听\n\t\t */\n\t\tmSmsObserver = new SmsObserver(getApplicationContext(), mHandler);\n\t\tUri  uri = Uri.parse(\"content://sms\");\n\t\tgetContentResolver().registerContentObserver(uri, true, mSmsObserver);</span>\n\n\t}\n\n\t/**\n\t * 由于 ContentObserver 的生命周期不同步于 Activity 和 Service ，\n\t * 因此需要手动取消注册\n\t * \n\t */\n\n\t@Override\n\tprotected void onDestroy() {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onDestroy();\n\t\t<span style=\"color:#ff0000;\">getContentResolver().unregisterContentObserver(mSmsObserver);</span>\n\t}\n}\n```\n### 3、注意在配置文件中添加读取短信的权限：\n```\n <uses-permission android:name=\"android.permission.READ_SMS\" />\n ```\n**注意：最小sdk为16.**\n###  4、如下运行截图：\n![](http://img.blog.csdn.net/20151017130345615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n控制台打印出的Log：\n![](http://img.blog.csdn.net/20151017130527628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n例子源代码：http://download.csdn.net/detail/txadf/9188791\n","source":"_posts/auto-filin-smscode.md","raw":"---\ntitle: android自动获取短信验证码\ndate: 2016-04-23 16:08:25\ncategories: [android,学习笔记]\ntags: [android,验证码]\n---\n这里主要使用了**ContentObserver**类（观察者模式类）来监听短信的变化，然后通过**正则表达式**，提取出短信，然后在子线程中更新UI，显示验证码。<!--more-->\n所谓的观察者模式，它是软件设计模式的一种，在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。观察者模式（Observer）完美的将观察者和被观察的对象分离开，在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。观察者设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。\nContentObserver,内容观察者，目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当 ContentObserver 所观察的Uri发生变化时，便会触发它。\n观察特定Uri的步骤如下：\n\n 1. 、创建我们特定的 ContentObserver 派生类，必须重载父类构造方法，必须重载 onChange() 方法去处理回调后的功能实现。\n 2. 利用 context.getContentResolover() 获得 ContentResolove 对象，接着调用 registerContentObserver() 方法去注册内容观察者。\n 3. 由于 ContentObserver 的生命周期不同步于 Activity 和 Service 等，因此，在不需要时，需要手动的调用 unregisterContentObserver() 去取消注册。\n\n*具体使用：*\n### 1、继承ContentObserver，重写onChange方法\n```\npackage com.tx.testsms;\n/**\n * 自动读取短信验证码\n */\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport android.content.Context;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.util.Log;\n\npublic class SmsObserver extends ContentObserver {\n\n\tprivate Context mContext;\n\tprivate Handler mHandler;\n\tprivate String tel_phone = \"\";\n\n\tprivate String code;\n\n\tpublic void setTel_phone(String tel_phone) {\n\t\tthis.tel_phone = tel_phone;\n\t}\n\n\tpublic SmsObserver(Context mContext, Handler handler) {\n\t\tsuper(handler);\n\t\tthis.mContext = mContext;\n\t\tthis.mHandler = handler;\n\t}\n\n\t@Override\n\tpublic void onChange(boolean selfChange, Uri uri) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onChange(selfChange, uri);\n\n\t\tif(uri.toString().equals(\"content:://sms//raw\")){\n\t\t\treturn;\n\t\t}\n\n\t\tUri inboxUri = Uri.parse(\"content://sms//inbox\");\n\n\t\tCursor cursor = mContext.getContentResolver().\n\t\t\t\tquery(inboxUri, null, null, null, \"date desc\");\n\n\t\tif(cursor!=null){\n\t\t\tif(cursor.moveToFirst()){\n\t\t\t\tString address = cursor.getString(cursor.getColumnIndex(\"address\"));\n\t\t\t\tLog.i(\"test\", \"短信验证码为：--------\"+address);\n\n\t\t\t\tString body = cursor.getString(cursor.getColumnIndex(\"body\"));\n\t\t\t\tLog.i(\"test\", \"uri---------\"+inboxUri);\n\n\t\t\t\tif(address.equals(tel_phone)){\n\n\t\t\t\t\tPattern pattern = Pattern.compile(\"(\\\\d{4})\");\n\t\t\t\t\tMatcher matcher = pattern.matcher(body);\n\n\t\t\t\t\tif(matcher.find()){\n\t\t\t\t\t\tcode = matcher.group(0);\n\t\t\t\t\t\tLog.i(\"test\", \"短信验证码为：--------\"+code);\n\t\t\t\t\t\tmHandler.obtainMessage(\n\t\t\t\t\t\t\t\tMainActivity.MSG_RECEIVED_CODE,code).sendToTarget();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tcursor.close();\n\t\t}\n\t}\n}\n```\n\n### 2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册\n```\npackage com.tx.testsms;\n\nimport android.app.Activity;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.Window;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\npublic class MainActivity extends Activity {\n\n\tpublic static final int MSG_RECEIVED_CODE = 1;\n\n\tprivate SmsObserver mSmsObserver;\n\tprivate Handler mHandler;\n\n\tprivate EditText metPhone;\n\tprivate TextView mtvCode;\n\tprivate Button mbtnButton;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\tsetContentView(R.layout.activity_main);\n\n\t\tmetPhone = (EditText) findViewById(R.id.phone);\n\t\tmbtnButton = (Button) findViewById(R.id.btn);\n\t\tmtvCode = (TextView) findViewById(R.id.code);\n\n\t\t/**\n\t\t * 设置手机号，拦截固定的手机号\n\t\t */\n\n\t\tmbtnButton.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View arg0) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tmSmsObserver.setTel_phone(metPhone.getText().toString());\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * 在子线程中更新UI\n\t\t */\n\t\tmHandler = new Handler(){\n\t\t\t@Override\n\t\t\tpublic void handleMessage(Message msg) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tsuper.handleMessage(msg);\n\t\t\t\tif(msg.what == MSG_RECEIVED_CODE){\n\t\t\t\t\tmtvCode.setText(\"四位短信验证码为：\"+msg.obj.toString());\n\t\t\t\t\tToast.makeText(getApplicationContext(), msg.obj.toString(), Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t<span style=\"color:#ff0000;\">/**\n\t\t * 实例化ContentObserver,注册短信监听\n\t\t */\n\t\tmSmsObserver = new SmsObserver(getApplicationContext(), mHandler);\n\t\tUri  uri = Uri.parse(\"content://sms\");\n\t\tgetContentResolver().registerContentObserver(uri, true, mSmsObserver);</span>\n\n\t}\n\n\t/**\n\t * 由于 ContentObserver 的生命周期不同步于 Activity 和 Service ，\n\t * 因此需要手动取消注册\n\t * \n\t */\n\n\t@Override\n\tprotected void onDestroy() {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onDestroy();\n\t\t<span style=\"color:#ff0000;\">getContentResolver().unregisterContentObserver(mSmsObserver);</span>\n\t}\n}\n```\n### 3、注意在配置文件中添加读取短信的权限：\n```\n <uses-permission android:name=\"android.permission.READ_SMS\" />\n ```\n**注意：最小sdk为16.**\n###  4、如下运行截图：\n![](http://img.blog.csdn.net/20151017130345615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n控制台打印出的Log：\n![](http://img.blog.csdn.net/20151017130527628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n例子源代码：http://download.csdn.net/detail/txadf/9188791\n","slug":"auto-filin-smscode","published":1,"updated":"2016-04-23T09:12:14.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuchg001qg0g53ckqz67f","content":"<p>这里主要使用了<strong>ContentObserver</strong>类（观察者模式类）来监听短信的变化，然后通过<strong>正则表达式</strong>，提取出短信，然后在子线程中更新UI，显示验证码。<a id=\"more\"></a><br>所谓的观察者模式，它是软件设计模式的一种，在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。观察者模式（Observer）完美的将观察者和被观察的对象分离开，在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。观察者设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。<br>ContentObserver,内容观察者，目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当 ContentObserver 所观察的Uri发生变化时，便会触发它。<br>观察特定Uri的步骤如下：</p>\n<ol>\n<li>、创建我们特定的 ContentObserver 派生类，必须重载父类构造方法，必须重载 onChange() 方法去处理回调后的功能实现。</li>\n<li>利用 context.getContentResolover() 获得 ContentResolove 对象，接着调用 registerContentObserver() 方法去注册内容观察者。</li>\n<li>由于 ContentObserver 的生命周期不同步于 Activity 和 Service 等，因此，在不需要时，需要手动的调用 unregisterContentObserver() 去取消注册。</li>\n</ol>\n<p><em>具体使用：</em></p>\n<h3 id=\"1、继承ContentObserver，重写onChange方法\"><a href=\"#1、继承ContentObserver，重写onChange方法\" class=\"headerlink\" title=\"1、继承ContentObserver，重写onChange方法\"></a>1、继承ContentObserver，重写onChange方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tx.testsms;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 自动读取短信验证码</span><br><span class=\"line\"> */</span><br><span class=\"line\">import java.util.regex.Matcher;</span><br><span class=\"line\">import java.util.regex.Pattern;</span><br><span class=\"line\"></span><br><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.database.ContentObserver;</span><br><span class=\"line\">import android.database.Cursor;</span><br><span class=\"line\">import android.net.Uri;</span><br><span class=\"line\">import android.os.Handler;</span><br><span class=\"line\">import android.util.Log;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SmsObserver extends ContentObserver &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Context mContext;</span><br><span class=\"line\">\tprivate Handler mHandler;</span><br><span class=\"line\">\tprivate String tel_phone = &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String code;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setTel_phone(String tel_phone) &#123;</span><br><span class=\"line\">\t\tthis.tel_phone = tel_phone;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic SmsObserver(Context mContext, Handler handler) &#123;</span><br><span class=\"line\">\t\tsuper(handler);</span><br><span class=\"line\">\t\tthis.mContext = mContext;</span><br><span class=\"line\">\t\tthis.mHandler = handler;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onChange(boolean selfChange, Uri uri) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onChange(selfChange, uri);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif(uri.toString().equals(&quot;content:://sms//raw&quot;))&#123;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUri inboxUri = Uri.parse(&quot;content://sms//inbox&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tCursor cursor = mContext.getContentResolver().</span><br><span class=\"line\">\t\t\t\tquery(inboxUri, null, null, null, &quot;date desc&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif(cursor!=null)&#123;</span><br><span class=\"line\">\t\t\tif(cursor.moveToFirst())&#123;</span><br><span class=\"line\">\t\t\t\tString address = cursor.getString(cursor.getColumnIndex(&quot;address&quot;));</span><br><span class=\"line\">\t\t\t\tLog.i(&quot;test&quot;, &quot;短信验证码为：--------&quot;+address);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tString body = cursor.getString(cursor.getColumnIndex(&quot;body&quot;));</span><br><span class=\"line\">\t\t\t\tLog.i(&quot;test&quot;, &quot;uri---------&quot;+inboxUri);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tif(address.equals(tel_phone))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tPattern pattern = Pattern.compile(&quot;(\\\\d&#123;4&#125;)&quot;);</span><br><span class=\"line\">\t\t\t\t\tMatcher matcher = pattern.matcher(body);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tif(matcher.find())&#123;</span><br><span class=\"line\">\t\t\t\t\t\tcode = matcher.group(0);</span><br><span class=\"line\">\t\t\t\t\t\tLog.i(&quot;test&quot;, &quot;短信验证码为：--------&quot;+code);</span><br><span class=\"line\">\t\t\t\t\t\tmHandler.obtainMessage(</span><br><span class=\"line\">\t\t\t\t\t\t\t\tMainActivity.MSG_RECEIVED_CODE,code).sendToTarget();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcursor.close();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册\"><a href=\"#2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册\" class=\"headerlink\" title=\"2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册\"></a>2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tx.testsms;</span><br><span class=\"line\"></span><br><span class=\"line\">import android.app.Activity;</span><br><span class=\"line\">import android.net.Uri;</span><br><span class=\"line\">import android.os.Bundle;</span><br><span class=\"line\">import android.os.Handler;</span><br><span class=\"line\">import android.os.Message;</span><br><span class=\"line\">import android.view.View;</span><br><span class=\"line\">import android.view.View.OnClickListener;</span><br><span class=\"line\">import android.view.Window;</span><br><span class=\"line\">import android.widget.Button;</span><br><span class=\"line\">import android.widget.EditText;</span><br><span class=\"line\">import android.widget.TextView;</span><br><span class=\"line\">import android.widget.Toast;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MainActivity extends Activity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static final int MSG_RECEIVED_CODE = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate SmsObserver mSmsObserver;</span><br><span class=\"line\">\tprivate Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate EditText metPhone;</span><br><span class=\"line\">\tprivate TextView mtvCode;</span><br><span class=\"line\">\tprivate Button mbtnButton;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\t\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class=\"line\">\t\tsetContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmetPhone = (EditText) findViewById(R.id.phone);</span><br><span class=\"line\">\t\tmbtnButton = (Button) findViewById(R.id.btn);</span><br><span class=\"line\">\t\tmtvCode = (TextView) findViewById(R.id.code);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 设置手机号，拦截固定的手机号</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmbtnButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic void onClick(View arg0) &#123;</span><br><span class=\"line\">\t\t\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\t\t\tmSmsObserver.setTel_phone(metPhone.getText().toString());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 在子线程中更新UI</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tmHandler = new Handler()&#123;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic void handleMessage(Message msg) &#123;</span><br><span class=\"line\">\t\t\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\t\t\tsuper.handleMessage(msg);</span><br><span class=\"line\">\t\t\t\tif(msg.what == MSG_RECEIVED_CODE)&#123;</span><br><span class=\"line\">\t\t\t\t\tmtvCode.setText(&quot;四位短信验证码为：&quot;+msg.obj.toString());</span><br><span class=\"line\">\t\t\t\t\tToast.makeText(getApplicationContext(), msg.obj.toString(), Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;span style=&quot;color:#ff0000;&quot;&gt;/**</span><br><span class=\"line\">\t\t * 实例化ContentObserver,注册短信监听</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tmSmsObserver = new SmsObserver(getApplicationContext(), mHandler);</span><br><span class=\"line\">\t\tUri  uri = Uri.parse(&quot;content://sms&quot;);</span><br><span class=\"line\">\t\tgetContentResolver().registerContentObserver(uri, true, mSmsObserver);&lt;/span&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 由于 ContentObserver 的生命周期不同步于 Activity 和 Service ，</span><br><span class=\"line\">\t * 因此需要手动取消注册</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t */</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onDestroy() &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onDestroy();</span><br><span class=\"line\">\t\t&lt;span style=&quot;color:#ff0000;&quot;&gt;getContentResolver().unregisterContentObserver(mSmsObserver);&lt;/span&gt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、注意在配置文件中添加读取短信的权限：\"><a href=\"#3、注意在配置文件中添加读取短信的权限：\" class=\"headerlink\" title=\"3、注意在配置文件中添加读取短信的权限：\"></a>3、注意在配置文件中添加读取短信的权限：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：最小sdk为16.</strong></p>\n<h3 id=\"4、如下运行截图：\"><a href=\"#4、如下运行截图：\" class=\"headerlink\" title=\"4、如下运行截图：\"></a>4、如下运行截图：</h3><p><img src=\"http://img.blog.csdn.net/20151017130345615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>控制台打印出的Log：<br><img src=\"http://img.blog.csdn.net/20151017130527628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>例子源代码：<a href=\"http://download.csdn.net/detail/txadf/9188791\" target=\"_blank\" rel=\"external\">http://download.csdn.net/detail/txadf/9188791</a></p>\n","excerpt":"<p>这里主要使用了<strong>ContentObserver</strong>类（观察者模式类）来监听短信的变化，然后通过<strong>正则表达式</strong>，提取出短信，然后在子线程中更新UI，显示验证码。","more":"<br>所谓的观察者模式，它是软件设计模式的一种，在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。观察者模式（Observer）完美的将观察者和被观察的对象分离开，在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。观察者设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。<br>ContentObserver,内容观察者，目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当 ContentObserver 所观察的Uri发生变化时，便会触发它。<br>观察特定Uri的步骤如下：</p>\n<ol>\n<li>、创建我们特定的 ContentObserver 派生类，必须重载父类构造方法，必须重载 onChange() 方法去处理回调后的功能实现。</li>\n<li>利用 context.getContentResolover() 获得 ContentResolove 对象，接着调用 registerContentObserver() 方法去注册内容观察者。</li>\n<li>由于 ContentObserver 的生命周期不同步于 Activity 和 Service 等，因此，在不需要时，需要手动的调用 unregisterContentObserver() 去取消注册。</li>\n</ol>\n<p><em>具体使用：</em></p>\n<h3 id=\"1、继承ContentObserver，重写onChange方法\"><a href=\"#1、继承ContentObserver，重写onChange方法\" class=\"headerlink\" title=\"1、继承ContentObserver，重写onChange方法\"></a>1、继承ContentObserver，重写onChange方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tx.testsms;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 自动读取短信验证码</span><br><span class=\"line\"> */</span><br><span class=\"line\">import java.util.regex.Matcher;</span><br><span class=\"line\">import java.util.regex.Pattern;</span><br><span class=\"line\"></span><br><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.database.ContentObserver;</span><br><span class=\"line\">import android.database.Cursor;</span><br><span class=\"line\">import android.net.Uri;</span><br><span class=\"line\">import android.os.Handler;</span><br><span class=\"line\">import android.util.Log;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SmsObserver extends ContentObserver &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Context mContext;</span><br><span class=\"line\">\tprivate Handler mHandler;</span><br><span class=\"line\">\tprivate String tel_phone = &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String code;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setTel_phone(String tel_phone) &#123;</span><br><span class=\"line\">\t\tthis.tel_phone = tel_phone;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic SmsObserver(Context mContext, Handler handler) &#123;</span><br><span class=\"line\">\t\tsuper(handler);</span><br><span class=\"line\">\t\tthis.mContext = mContext;</span><br><span class=\"line\">\t\tthis.mHandler = handler;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onChange(boolean selfChange, Uri uri) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onChange(selfChange, uri);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif(uri.toString().equals(&quot;content:://sms//raw&quot;))&#123;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUri inboxUri = Uri.parse(&quot;content://sms//inbox&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tCursor cursor = mContext.getContentResolver().</span><br><span class=\"line\">\t\t\t\tquery(inboxUri, null, null, null, &quot;date desc&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif(cursor!=null)&#123;</span><br><span class=\"line\">\t\t\tif(cursor.moveToFirst())&#123;</span><br><span class=\"line\">\t\t\t\tString address = cursor.getString(cursor.getColumnIndex(&quot;address&quot;));</span><br><span class=\"line\">\t\t\t\tLog.i(&quot;test&quot;, &quot;短信验证码为：--------&quot;+address);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tString body = cursor.getString(cursor.getColumnIndex(&quot;body&quot;));</span><br><span class=\"line\">\t\t\t\tLog.i(&quot;test&quot;, &quot;uri---------&quot;+inboxUri);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tif(address.equals(tel_phone))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tPattern pattern = Pattern.compile(&quot;(\\\\d&#123;4&#125;)&quot;);</span><br><span class=\"line\">\t\t\t\t\tMatcher matcher = pattern.matcher(body);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tif(matcher.find())&#123;</span><br><span class=\"line\">\t\t\t\t\t\tcode = matcher.group(0);</span><br><span class=\"line\">\t\t\t\t\t\tLog.i(&quot;test&quot;, &quot;短信验证码为：--------&quot;+code);</span><br><span class=\"line\">\t\t\t\t\t\tmHandler.obtainMessage(</span><br><span class=\"line\">\t\t\t\t\t\t\t\tMainActivity.MSG_RECEIVED_CODE,code).sendToTarget();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcursor.close();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册\"><a href=\"#2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册\" class=\"headerlink\" title=\"2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册\"></a>2、在MainActivity中注册监听，在子线程中更更新显示UI，并复写onDestroy，取消注册</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tx.testsms;</span><br><span class=\"line\"></span><br><span class=\"line\">import android.app.Activity;</span><br><span class=\"line\">import android.net.Uri;</span><br><span class=\"line\">import android.os.Bundle;</span><br><span class=\"line\">import android.os.Handler;</span><br><span class=\"line\">import android.os.Message;</span><br><span class=\"line\">import android.view.View;</span><br><span class=\"line\">import android.view.View.OnClickListener;</span><br><span class=\"line\">import android.view.Window;</span><br><span class=\"line\">import android.widget.Button;</span><br><span class=\"line\">import android.widget.EditText;</span><br><span class=\"line\">import android.widget.TextView;</span><br><span class=\"line\">import android.widget.Toast;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MainActivity extends Activity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static final int MSG_RECEIVED_CODE = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate SmsObserver mSmsObserver;</span><br><span class=\"line\">\tprivate Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate EditText metPhone;</span><br><span class=\"line\">\tprivate TextView mtvCode;</span><br><span class=\"line\">\tprivate Button mbtnButton;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\t\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class=\"line\">\t\tsetContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmetPhone = (EditText) findViewById(R.id.phone);</span><br><span class=\"line\">\t\tmbtnButton = (Button) findViewById(R.id.btn);</span><br><span class=\"line\">\t\tmtvCode = (TextView) findViewById(R.id.code);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 设置手机号，拦截固定的手机号</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmbtnButton.setOnClickListener(new OnClickListener() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic void onClick(View arg0) &#123;</span><br><span class=\"line\">\t\t\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\t\t\tmSmsObserver.setTel_phone(metPhone.getText().toString());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * 在子线程中更新UI</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tmHandler = new Handler()&#123;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic void handleMessage(Message msg) &#123;</span><br><span class=\"line\">\t\t\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\t\t\tsuper.handleMessage(msg);</span><br><span class=\"line\">\t\t\t\tif(msg.what == MSG_RECEIVED_CODE)&#123;</span><br><span class=\"line\">\t\t\t\t\tmtvCode.setText(&quot;四位短信验证码为：&quot;+msg.obj.toString());</span><br><span class=\"line\">\t\t\t\t\tToast.makeText(getApplicationContext(), msg.obj.toString(), Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;span style=&quot;color:#ff0000;&quot;&gt;/**</span><br><span class=\"line\">\t\t * 实例化ContentObserver,注册短信监听</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tmSmsObserver = new SmsObserver(getApplicationContext(), mHandler);</span><br><span class=\"line\">\t\tUri  uri = Uri.parse(&quot;content://sms&quot;);</span><br><span class=\"line\">\t\tgetContentResolver().registerContentObserver(uri, true, mSmsObserver);&lt;/span&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 由于 ContentObserver 的生命周期不同步于 Activity 和 Service ，</span><br><span class=\"line\">\t * 因此需要手动取消注册</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t */</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onDestroy() &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onDestroy();</span><br><span class=\"line\">\t\t&lt;span style=&quot;color:#ff0000;&quot;&gt;getContentResolver().unregisterContentObserver(mSmsObserver);&lt;/span&gt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、注意在配置文件中添加读取短信的权限：\"><a href=\"#3、注意在配置文件中添加读取短信的权限：\" class=\"headerlink\" title=\"3、注意在配置文件中添加读取短信的权限：\"></a>3、注意在配置文件中添加读取短信的权限：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：最小sdk为16.</strong></p>\n<h3 id=\"4、如下运行截图：\"><a href=\"#4、如下运行截图：\" class=\"headerlink\" title=\"4、如下运行截图：\"></a>4、如下运行截图：</h3><p><img src=\"http://img.blog.csdn.net/20151017130345615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>控制台打印出的Log：<br><img src=\"http://img.blog.csdn.net/20151017130527628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>例子源代码：<a href=\"http://download.csdn.net/detail/txadf/9188791\">http://download.csdn.net/detail/txadf/9188791</a></p>"},{"title":"android开发较好的blog","date":"2016-04-23T08:12:25.000Z","_content":"作为初学者，跟着大神的脚步才能成为大神，少走弯路。以下是个人收藏的一些blog。<!--more-->\nCSDN博客：\n    郭霖:http://blog.csdn.net/guolin_blog\n    鸿洋：http://blog.csdn.net/lmj623565791 \n    IT_xiao小巫：http://blog.csdn.net/wwj_748 \n    Mr.Simple：http://blog.csdn.net/bboyfeiyu \n    爱哥：http://blog.csdn.net/aigestudio\n   老罗：http://blog.csdn.net/luoshengyang \n    任玉刚：http://blog.csdn.net/singwhatiwanna \n    夏安明：http://blog.csdn.net/xiaanming \n    徐医生：http://blog.csdn.net/eclipsexys \n    郭神：http://blog.csdn.net/sinyu890807/ \n    张兴业：http://blog.csdn.net/xyz_lmn/ \n    咪当系欧巴：http://blog.csdn.net/hellogv\n个人Blog\n    张涛：http://www.kymjs.com/   \n    码农明明桑：http://blog.isming.me/\n     张明云：http://zmywly8866.github.io/pages/archive.html\n    郝锡强：http://www.haoxiqiang.info/static/timing.html \n    胡凯：http://hukai.me/blog/archives/ \n    农民伯伯：http://www.cnblogs.com/over140/ \n    Trinea：http://www.trinea.cn/ \n    daimajia：http://blog.daimajia.com/ \n    stay4it：http://www.cnblogs.com/stay/\n    stormzhang：http://stormzhang.com/posts.html \n    Coder Robin：http://coderrobin.com/ \n\n\t\n更多资料：\n[Android学习资源网站大全](http://blog.csdn.net/txadf/article/details/49965053)\n   \n","source":"_posts/excellent-blog-author-of-android.md","raw":"---\ntitle: android开发较好的blog\ndate: 2016-04-23 16:12:25\ncategories: [android,学习笔记]\ntags: [android,blog]\n---\n作为初学者，跟着大神的脚步才能成为大神，少走弯路。以下是个人收藏的一些blog。<!--more-->\nCSDN博客：\n    郭霖:http://blog.csdn.net/guolin_blog\n    鸿洋：http://blog.csdn.net/lmj623565791 \n    IT_xiao小巫：http://blog.csdn.net/wwj_748 \n    Mr.Simple：http://blog.csdn.net/bboyfeiyu \n    爱哥：http://blog.csdn.net/aigestudio\n   老罗：http://blog.csdn.net/luoshengyang \n    任玉刚：http://blog.csdn.net/singwhatiwanna \n    夏安明：http://blog.csdn.net/xiaanming \n    徐医生：http://blog.csdn.net/eclipsexys \n    郭神：http://blog.csdn.net/sinyu890807/ \n    张兴业：http://blog.csdn.net/xyz_lmn/ \n    咪当系欧巴：http://blog.csdn.net/hellogv\n个人Blog\n    张涛：http://www.kymjs.com/   \n    码农明明桑：http://blog.isming.me/\n     张明云：http://zmywly8866.github.io/pages/archive.html\n    郝锡强：http://www.haoxiqiang.info/static/timing.html \n    胡凯：http://hukai.me/blog/archives/ \n    农民伯伯：http://www.cnblogs.com/over140/ \n    Trinea：http://www.trinea.cn/ \n    daimajia：http://blog.daimajia.com/ \n    stay4it：http://www.cnblogs.com/stay/\n    stormzhang：http://stormzhang.com/posts.html \n    Coder Robin：http://coderrobin.com/ \n\n\t\n更多资料：\n[Android学习资源网站大全](http://blog.csdn.net/txadf/article/details/49965053)\n   \n","slug":"excellent-blog-author-of-android","published":1,"updated":"2016-04-23T09:53:31.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuchg001ug0g57rl2ywe4","content":"<p>作为初学者，跟着大神的脚步才能成为大神，少走弯路。以下是个人收藏的一些blog。<a id=\"more\"></a><br>CSDN博客：<br>    郭霖:<a href=\"http://blog.csdn.net/guolin_blog\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/guolin_blog</a><br>    鸿洋：<a href=\"http://blog.csdn.net/lmj623565791\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lmj623565791</a><br>    IT_xiao小巫：<a href=\"http://blog.csdn.net/wwj_748\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/wwj_748</a><br>    Mr.Simple：<a href=\"http://blog.csdn.net/bboyfeiyu\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/bboyfeiyu</a><br>    爱哥：<a href=\"http://blog.csdn.net/aigestudio\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/aigestudio</a><br>   老罗：<a href=\"http://blog.csdn.net/luoshengyang\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/luoshengyang</a><br>    任玉刚：<a href=\"http://blog.csdn.net/singwhatiwanna\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/singwhatiwanna</a><br>    夏安明：<a href=\"http://blog.csdn.net/xiaanming\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/xiaanming</a><br>    徐医生：<a href=\"http://blog.csdn.net/eclipsexys\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/eclipsexys</a><br>    郭神：<a href=\"http://blog.csdn.net/sinyu890807/\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/sinyu890807/</a><br>    张兴业：<a href=\"http://blog.csdn.net/xyz_lmn/\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/xyz_lmn/</a><br>    咪当系欧巴：<a href=\"http://blog.csdn.net/hellogv\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/hellogv</a><br>个人Blog<br>    张涛：<a href=\"http://www.kymjs.com/\" target=\"_blank\" rel=\"external\">http://www.kymjs.com/</a><br>    码农明明桑：<a href=\"http://blog.isming.me/\" target=\"_blank\" rel=\"external\">http://blog.isming.me/</a><br>     张明云：<a href=\"http://zmywly8866.github.io/pages/archive.html\" target=\"_blank\" rel=\"external\">http://zmywly8866.github.io/pages/archive.html</a><br>    郝锡强：<a href=\"http://www.haoxiqiang.info/static/timing.html\" target=\"_blank\" rel=\"external\">http://www.haoxiqiang.info/static/timing.html</a><br>    胡凯：<a href=\"http://hukai.me/blog/archives/\" target=\"_blank\" rel=\"external\">http://hukai.me/blog/archives/</a><br>    农民伯伯：<a href=\"http://www.cnblogs.com/over140/\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/over140/</a><br>    Trinea：<a href=\"http://www.trinea.cn/\" target=\"_blank\" rel=\"external\">http://www.trinea.cn/</a><br>    daimajia：<a href=\"http://blog.daimajia.com/\" target=\"_blank\" rel=\"external\">http://blog.daimajia.com/</a><br>    stay4it：<a href=\"http://www.cnblogs.com/stay/\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/stay/</a><br>    stormzhang：<a href=\"http://stormzhang.com/posts.html\" target=\"_blank\" rel=\"external\">http://stormzhang.com/posts.html</a><br>    Coder Robin：<a href=\"http://coderrobin.com/\" target=\"_blank\" rel=\"external\">http://coderrobin.com/</a> </p>\n<p>更多资料：<br><a href=\"http://blog.csdn.net/txadf/article/details/49965053\" target=\"_blank\" rel=\"external\">Android学习资源网站大全</a></p>\n","excerpt":"<p>作为初学者，跟着大神的脚步才能成为大神，少走弯路。以下是个人收藏的一些blog。","more":"<br>CSDN博客：<br>    郭霖:<a href=\"http://blog.csdn.net/guolin_blog\">http://blog.csdn.net/guolin_blog</a><br>    鸿洋：<a href=\"http://blog.csdn.net/lmj623565791\">http://blog.csdn.net/lmj623565791</a><br>    IT_xiao小巫：<a href=\"http://blog.csdn.net/wwj_748\">http://blog.csdn.net/wwj_748</a><br>    Mr.Simple：<a href=\"http://blog.csdn.net/bboyfeiyu\">http://blog.csdn.net/bboyfeiyu</a><br>    爱哥：<a href=\"http://blog.csdn.net/aigestudio\">http://blog.csdn.net/aigestudio</a><br>   老罗：<a href=\"http://blog.csdn.net/luoshengyang\">http://blog.csdn.net/luoshengyang</a><br>    任玉刚：<a href=\"http://blog.csdn.net/singwhatiwanna\">http://blog.csdn.net/singwhatiwanna</a><br>    夏安明：<a href=\"http://blog.csdn.net/xiaanming\">http://blog.csdn.net/xiaanming</a><br>    徐医生：<a href=\"http://blog.csdn.net/eclipsexys\">http://blog.csdn.net/eclipsexys</a><br>    郭神：<a href=\"http://blog.csdn.net/sinyu890807/\">http://blog.csdn.net/sinyu890807/</a><br>    张兴业：<a href=\"http://blog.csdn.net/xyz_lmn/\">http://blog.csdn.net/xyz_lmn/</a><br>    咪当系欧巴：<a href=\"http://blog.csdn.net/hellogv\">http://blog.csdn.net/hellogv</a><br>个人Blog<br>    张涛：<a href=\"http://www.kymjs.com/\">http://www.kymjs.com/</a><br>    码农明明桑：<a href=\"http://blog.isming.me/\">http://blog.isming.me/</a><br>     张明云：<a href=\"http://zmywly8866.github.io/pages/archive.html\">http://zmywly8866.github.io/pages/archive.html</a><br>    郝锡强：<a href=\"http://www.haoxiqiang.info/static/timing.html\">http://www.haoxiqiang.info/static/timing.html</a><br>    胡凯：<a href=\"http://hukai.me/blog/archives/\">http://hukai.me/blog/archives/</a><br>    农民伯伯：<a href=\"http://www.cnblogs.com/over140/\">http://www.cnblogs.com/over140/</a><br>    Trinea：<a href=\"http://www.trinea.cn/\">http://www.trinea.cn/</a><br>    daimajia：<a href=\"http://blog.daimajia.com/\">http://blog.daimajia.com/</a><br>    stay4it：<a href=\"http://www.cnblogs.com/stay/\">http://www.cnblogs.com/stay/</a><br>    stormzhang：<a href=\"http://stormzhang.com/posts.html\">http://stormzhang.com/posts.html</a><br>    Coder Robin：<a href=\"http://coderrobin.com/\">http://coderrobin.com/</a> </p>\n<p>更多资料：<br><a href=\"http://blog.csdn.net/txadf/article/details/49965053\">Android学习资源网站大全</a></p>"},{"title":"android真机测试之offline或unauthorized错误","date":"2016-04-23T08:30:25.000Z","_content":"在开发中，使用真机测试较为方便，然而在ide连接手机时，adb device 提示 **offline** 或者 **unauthorized**(中文：未授权的)会令大家非常困扰。<!--more-->我也同样为此而浪费了很多时间。这里，介绍一种较为方便的解决方法（亲测有效）：\n先删除.android 文件夹下的adbkey文件夹,再连接数据线，让其重新授权。\n对于.android 文件夹，一般在电脑c盘的用户/用户名 下，它是用于存放android虚拟机的。如果将sdk配置到了环境变量中，则.android文件夹在相应的sdk目录下。\n此外，网上还有其他的方法，不过都没有解决：\n\n 1. 用数据线连接手机，在设备管理器中把手机的驱动卸载了，然后重启，重新连接数据线；\n 2. 打开手机设置，进入 开发人员选项，关闭 usb调试 ，撤销usb授权，最后重新打开；\n 3. 重启adb：①在编辑器中重启或者关掉编辑器，同时在任务管理器中结束adb.exe;\n ②使用命令行：windows下，（win+R）-->cmd 进入命令行，输入一次以下命令：\n                            \n```\nadb kill-server;\nadb start-server;\n```\n4. 使用第三方的软件，如豌豆荚（曾经用过，可用）\n总之，不同的人有不同的方法，选择一种自己可以接受的，能够有效解决问题就行。\n\n\n\n\n","source":"_posts/erroe-of-offline-or-unauthorized.md","raw":"---\ntitle: android真机测试之offline或unauthorized错误\ndate: 2016-04-23 16:30:25\ncategories: [android,学习笔记]\ntags: [真机调试,offline]\n---\n在开发中，使用真机测试较为方便，然而在ide连接手机时，adb device 提示 **offline** 或者 **unauthorized**(中文：未授权的)会令大家非常困扰。<!--more-->我也同样为此而浪费了很多时间。这里，介绍一种较为方便的解决方法（亲测有效）：\n先删除.android 文件夹下的adbkey文件夹,再连接数据线，让其重新授权。\n对于.android 文件夹，一般在电脑c盘的用户/用户名 下，它是用于存放android虚拟机的。如果将sdk配置到了环境变量中，则.android文件夹在相应的sdk目录下。\n此外，网上还有其他的方法，不过都没有解决：\n\n 1. 用数据线连接手机，在设备管理器中把手机的驱动卸载了，然后重启，重新连接数据线；\n 2. 打开手机设置，进入 开发人员选项，关闭 usb调试 ，撤销usb授权，最后重新打开；\n 3. 重启adb：①在编辑器中重启或者关掉编辑器，同时在任务管理器中结束adb.exe;\n ②使用命令行：windows下，（win+R）-->cmd 进入命令行，输入一次以下命令：\n                            \n```\nadb kill-server;\nadb start-server;\n```\n4. 使用第三方的软件，如豌豆荚（曾经用过，可用）\n总之，不同的人有不同的方法，选择一种自己可以接受的，能够有效解决问题就行。\n\n\n\n\n","slug":"erroe-of-offline-or-unauthorized","published":1,"updated":"2016-04-23T10:27:04.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuchg001yg0g5tr23q13a","content":"<p>在开发中，使用真机测试较为方便，然而在ide连接手机时，adb device 提示 <strong>offline</strong> 或者 <strong>unauthorized</strong>(中文：未授权的)会令大家非常困扰。<a id=\"more\"></a>我也同样为此而浪费了很多时间。这里，介绍一种较为方便的解决方法（亲测有效）：<br>先删除.android 文件夹下的adbkey文件夹,再连接数据线，让其重新授权。<br>对于.android 文件夹，一般在电脑c盘的用户/用户名 下，它是用于存放android虚拟机的。如果将sdk配置到了环境变量中，则.android文件夹在相应的sdk目录下。<br>此外，网上还有其他的方法，不过都没有解决：</p>\n<ol>\n<li>用数据线连接手机，在设备管理器中把手机的驱动卸载了，然后重启，重新连接数据线；</li>\n<li>打开手机设置，进入 开发人员选项，关闭 usb调试 ，撤销usb授权，最后重新打开；</li>\n<li>重启adb：①在编辑器中重启或者关掉编辑器，同时在任务管理器中结束adb.exe;<br>②使用命令行：windows下，（win+R）–&gt;cmd 进入命令行，输入一次以下命令：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb kill-server;</span><br><span class=\"line\">adb start-server;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>使用第三方的软件，如豌豆荚（曾经用过，可用）<br>总之，不同的人有不同的方法，选择一种自己可以接受的，能够有效解决问题就行。</li>\n</ol>\n","excerpt":"<p>在开发中，使用真机测试较为方便，然而在ide连接手机时，adb device 提示 <strong>offline</strong> 或者 <strong>unauthorized</strong>(中文：未授权的)会令大家非常困扰。","more":"我也同样为此而浪费了很多时间。这里，介绍一种较为方便的解决方法（亲测有效）：<br>先删除.android 文件夹下的adbkey文件夹,再连接数据线，让其重新授权。<br>对于.android 文件夹，一般在电脑c盘的用户/用户名 下，它是用于存放android虚拟机的。如果将sdk配置到了环境变量中，则.android文件夹在相应的sdk目录下。<br>此外，网上还有其他的方法，不过都没有解决：</p>\n<ol>\n<li>用数据线连接手机，在设备管理器中把手机的驱动卸载了，然后重启，重新连接数据线；</li>\n<li>打开手机设置，进入 开发人员选项，关闭 usb调试 ，撤销usb授权，最后重新打开；</li>\n<li>重启adb：①在编辑器中重启或者关掉编辑器，同时在任务管理器中结束adb.exe;<br>②使用命令行：windows下，（win+R）–&gt;cmd 进入命令行，输入一次以下命令：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb kill-server;</span><br><span class=\"line\">adb start-server;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>使用第三方的软件，如豌豆荚（曾经用过，可用）<br>总之，不同的人有不同的方法，选择一种自己可以接受的，能够有效解决问题就行。</li>\n</ol>"},{"title":"初识widget桌面小组件","date":"2016-04-23T08:20:25.000Z","_content":"学习android widget的使用，使用高德地图的定位功能中的天气api来获取天气，做了个简单的demo。<!--more-->widget的开发步骤如下：\n\n 1. 编写widget布局和配置文件；\n 2. 编写自己的provider继承自AppWidgetProvider；\n 3. 使用服务来更新widget；\n 4. 修改配置文件。\n\n开发之前先导入高德定位jar包，修改配置文件添加自己的appkey和相关的权限。（详情请参照：http://lbs.amap.com/api/android-location-sdk/guide/weather/）\n\n### 一、编写widget布局文件和配置文件\n这里就添加了一个TextView来显示天气信息；\nwidget配置文件： src/xml/widgetconfig \n```\n<span style=\"font-size:18px;\"><?xml version=\"1.0\" encoding=\"utf-8\"?>\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:initialLayout=\"@layout/widget\"\n    android:minHeight=\"100dp\"\n    android:minWidth=\"200dp\"\n    android:updatePeriodMillis=\"860000\" >\n\n</appwidget-provider></span>\n```\n### 二、AppWidgetProvider的编写，启动与停止服务。\n在AppWidgetProvider中的主要方法有：\nonEnabled(Context context)--第一个widget添加时调用\nonDeleted(Context context, int[] appWidgetIds)--widget被从屏幕移除时调用\nonDisabled(Context context) --widget 最后一个被从屏幕移除\nonUpdate(Context context, \nAppWidgetManager appWidgetManager,\nint[] appWidgetIds)---刷新widget\n\n代码：\n```\npackage com.tx.weatherwidget;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetProvider;\nimport android.content.Context;\nimport android.content.Intent;\npublic class WeatherProvider extends AppWidgetProvider {\n\t/**\n\t * widget第一个添加到桌面执行\n\t */\n\t@Override\n\tpublic void onEnabled(Context context) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onEnabled(context);\n\t\tIntent intent = new Intent(context, WeatherService.class);\n\t\tcontext.startService(intent);\n\t}\n\t/**\n\t * 最后一个widget移除桌面执行\n\t */\n\t@Override\n\tpublic void onDisabled(Context context) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onDisabled(context);\n\t\tIntent intent = new Intent(context, WeatherService.class);\n\t\tcontext.stopService(intent);\n\t}\n\t/**\n\t * 更新数据\n\t */\n\t@Override\n\tpublic void onUpdate(Context context, AppWidgetManager appWidgetManager,\n\t\t\tint[] appWidgetIds) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onUpdate(context, appWidgetManager, appWidgetIds);\n\t}\n}\n```\n### 三、service的编写，获取天气，widget更新。\n主要代码在updateView中，这里使用RemoteViews，AppWidgetManager的updateAppWidget来通知widget更新。\n代码：\n```\npackage com.tx.weatherwidget;\n/**\n * 调用高德地图的天气api获取天气\n * \n */\nimport android.app.Service;\nimport android.appwidget.AppWidgetManager;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.os.IBinder;\nimport android.widget.RemoteViews;\nimport android.widget.Toast;\n\nimport com.amap.api.location.AMapLocalWeatherForecast;\nimport com.amap.api.location.AMapLocalWeatherListener;\nimport com.amap.api.location.AMapLocalWeatherLive;\nimport com.amap.api.location.LocationManagerProxy;\nimport com.tx.weatherwidget.R;\n\npublic class WeatherService extends Service implements\nAMapLocalWeatherListener{\n\tprivate LocationManagerProxy mLocationManagerProxy;\n\t@Override\n\tpublic IBinder onBind(Intent arg0) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\t@Override\n\tpublic void onCreate() {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onCreate();\n\t\tinit();\n\t}\n\t/**\n\t * 注册天气监听\n\t */\n\tprivate void init() {\n\t\tmLocationManagerProxy = LocationManagerProxy.getInstance(this);\n\t\tmLocationManagerProxy.requestWeatherUpdates(\n\t\t\t\tLocationManagerProxy.WEATHER_TYPE_LIVE, this);\n\t}\n\t@Override\n\tpublic void onWeatherForecaseSearched(AMapLocalWeatherForecast arg0) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\t@Override\n\tpublic void onWeatherLiveSearched(AMapLocalWeatherLive aMapLocalWeatherLive) {\n\t\t// TODO Auto-generated method stub\n\t\tif(aMapLocalWeatherLive!=null && aMapLocalWeatherLive.getAMapException().getErrorCode() == 0){\n\t\t\tString city = aMapLocalWeatherLive.getCity();//城市\n\t\t\tString weather = aMapLocalWeatherLive.getWeather();//天气情况\n\t\t\tString windDir = aMapLocalWeatherLive.getWindDir();//风向\n\t\t\tString windPower = aMapLocalWeatherLive.getWindPower();//风力\n\t\t\tString humidity = aMapLocalWeatherLive.getHumidity();//空气湿度\n\t\t\tString reportTime = aMapLocalWeatherLive.getReportTime();//数据发布时间\n\t\t\tupdateView(\"城市： \"+city+'\\n'+\n\t\t\t\t\t\"风向： \"+windDir+'\\n'+\n\t\t\t\t\t\"风力： \"+windPower+'\\n'+\n\t\t\t\t\t\"天气情况： \"+weather+'\\n'+\n\t\t\t\t\t\"空气湿度： \"+humidity+'\\n'+\n\t\t\t\t\t\"数据发布时间： \"+reportTime+'\\n');\n\n\t\t}else{\n\t\t\t// 获取天气预报失败\n\t\t\tToast.makeText(this,\"获取天气预报失败:\"+ aMapLocalWeatherLive.getAMapException().getErrorMessage(), Toast.LENGTH_SHORT).show();\n\t\t}\n\t}\n\tprivate void updateView(String info){\n\t\tRemoteViews remoteViews = new RemoteViews(getPackageName(),\n\t\t\t\tR.layout.widget);\n\t\tremoteViews.setTextViewText(R.id.weather, info);\n\t\tAppWidgetManager manager = AppWidgetManager.\n\t\t\t\tgetInstance(getApplicationContext());\n\t\tComponentName provider = new ComponentName(\n\t\t\t\tgetApplicationContext(), WeatherProvider.class);\n\t\tmanager.updateAppWidget(provider, remoteViews);\n\t}\n}\n```\n### 四、修改配置文件，注册服务。\n代码：\n```\n<receiver android:name=\"com.tx.weatherwidget.WeatherProvider\" >\n            <intent-filter>\n                <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.appwidget.provider\"\n                android:resource=\"@xml/widgetconfig\" />\n        </receiver>\n\n        <service android:name=\"com.tx.weatherwidget.WeatherService\" >\n        </service>\n```\n源代码下载：[weatherWidget](http://download.csdn.net/detail/txadf/9267497)\n\n\n\n\n\n\n\n","source":"_posts/first-use-widget.md","raw":"---\ntitle: 初识widget桌面小组件\ndate: 2016-04-23 16:20:25\ncategories: [android,学习笔记]\ntags: [android,widget]\n---\n学习android widget的使用，使用高德地图的定位功能中的天气api来获取天气，做了个简单的demo。<!--more-->widget的开发步骤如下：\n\n 1. 编写widget布局和配置文件；\n 2. 编写自己的provider继承自AppWidgetProvider；\n 3. 使用服务来更新widget；\n 4. 修改配置文件。\n\n开发之前先导入高德定位jar包，修改配置文件添加自己的appkey和相关的权限。（详情请参照：http://lbs.amap.com/api/android-location-sdk/guide/weather/）\n\n### 一、编写widget布局文件和配置文件\n这里就添加了一个TextView来显示天气信息；\nwidget配置文件： src/xml/widgetconfig \n```\n<span style=\"font-size:18px;\"><?xml version=\"1.0\" encoding=\"utf-8\"?>\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:initialLayout=\"@layout/widget\"\n    android:minHeight=\"100dp\"\n    android:minWidth=\"200dp\"\n    android:updatePeriodMillis=\"860000\" >\n\n</appwidget-provider></span>\n```\n### 二、AppWidgetProvider的编写，启动与停止服务。\n在AppWidgetProvider中的主要方法有：\nonEnabled(Context context)--第一个widget添加时调用\nonDeleted(Context context, int[] appWidgetIds)--widget被从屏幕移除时调用\nonDisabled(Context context) --widget 最后一个被从屏幕移除\nonUpdate(Context context, \nAppWidgetManager appWidgetManager,\nint[] appWidgetIds)---刷新widget\n\n代码：\n```\npackage com.tx.weatherwidget;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetProvider;\nimport android.content.Context;\nimport android.content.Intent;\npublic class WeatherProvider extends AppWidgetProvider {\n\t/**\n\t * widget第一个添加到桌面执行\n\t */\n\t@Override\n\tpublic void onEnabled(Context context) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onEnabled(context);\n\t\tIntent intent = new Intent(context, WeatherService.class);\n\t\tcontext.startService(intent);\n\t}\n\t/**\n\t * 最后一个widget移除桌面执行\n\t */\n\t@Override\n\tpublic void onDisabled(Context context) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onDisabled(context);\n\t\tIntent intent = new Intent(context, WeatherService.class);\n\t\tcontext.stopService(intent);\n\t}\n\t/**\n\t * 更新数据\n\t */\n\t@Override\n\tpublic void onUpdate(Context context, AppWidgetManager appWidgetManager,\n\t\t\tint[] appWidgetIds) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onUpdate(context, appWidgetManager, appWidgetIds);\n\t}\n}\n```\n### 三、service的编写，获取天气，widget更新。\n主要代码在updateView中，这里使用RemoteViews，AppWidgetManager的updateAppWidget来通知widget更新。\n代码：\n```\npackage com.tx.weatherwidget;\n/**\n * 调用高德地图的天气api获取天气\n * \n */\nimport android.app.Service;\nimport android.appwidget.AppWidgetManager;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.os.IBinder;\nimport android.widget.RemoteViews;\nimport android.widget.Toast;\n\nimport com.amap.api.location.AMapLocalWeatherForecast;\nimport com.amap.api.location.AMapLocalWeatherListener;\nimport com.amap.api.location.AMapLocalWeatherLive;\nimport com.amap.api.location.LocationManagerProxy;\nimport com.tx.weatherwidget.R;\n\npublic class WeatherService extends Service implements\nAMapLocalWeatherListener{\n\tprivate LocationManagerProxy mLocationManagerProxy;\n\t@Override\n\tpublic IBinder onBind(Intent arg0) {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\t@Override\n\tpublic void onCreate() {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onCreate();\n\t\tinit();\n\t}\n\t/**\n\t * 注册天气监听\n\t */\n\tprivate void init() {\n\t\tmLocationManagerProxy = LocationManagerProxy.getInstance(this);\n\t\tmLocationManagerProxy.requestWeatherUpdates(\n\t\t\t\tLocationManagerProxy.WEATHER_TYPE_LIVE, this);\n\t}\n\t@Override\n\tpublic void onWeatherForecaseSearched(AMapLocalWeatherForecast arg0) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\t@Override\n\tpublic void onWeatherLiveSearched(AMapLocalWeatherLive aMapLocalWeatherLive) {\n\t\t// TODO Auto-generated method stub\n\t\tif(aMapLocalWeatherLive!=null && aMapLocalWeatherLive.getAMapException().getErrorCode() == 0){\n\t\t\tString city = aMapLocalWeatherLive.getCity();//城市\n\t\t\tString weather = aMapLocalWeatherLive.getWeather();//天气情况\n\t\t\tString windDir = aMapLocalWeatherLive.getWindDir();//风向\n\t\t\tString windPower = aMapLocalWeatherLive.getWindPower();//风力\n\t\t\tString humidity = aMapLocalWeatherLive.getHumidity();//空气湿度\n\t\t\tString reportTime = aMapLocalWeatherLive.getReportTime();//数据发布时间\n\t\t\tupdateView(\"城市： \"+city+'\\n'+\n\t\t\t\t\t\"风向： \"+windDir+'\\n'+\n\t\t\t\t\t\"风力： \"+windPower+'\\n'+\n\t\t\t\t\t\"天气情况： \"+weather+'\\n'+\n\t\t\t\t\t\"空气湿度： \"+humidity+'\\n'+\n\t\t\t\t\t\"数据发布时间： \"+reportTime+'\\n');\n\n\t\t}else{\n\t\t\t// 获取天气预报失败\n\t\t\tToast.makeText(this,\"获取天气预报失败:\"+ aMapLocalWeatherLive.getAMapException().getErrorMessage(), Toast.LENGTH_SHORT).show();\n\t\t}\n\t}\n\tprivate void updateView(String info){\n\t\tRemoteViews remoteViews = new RemoteViews(getPackageName(),\n\t\t\t\tR.layout.widget);\n\t\tremoteViews.setTextViewText(R.id.weather, info);\n\t\tAppWidgetManager manager = AppWidgetManager.\n\t\t\t\tgetInstance(getApplicationContext());\n\t\tComponentName provider = new ComponentName(\n\t\t\t\tgetApplicationContext(), WeatherProvider.class);\n\t\tmanager.updateAppWidget(provider, remoteViews);\n\t}\n}\n```\n### 四、修改配置文件，注册服务。\n代码：\n```\n<receiver android:name=\"com.tx.weatherwidget.WeatherProvider\" >\n            <intent-filter>\n                <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.appwidget.provider\"\n                android:resource=\"@xml/widgetconfig\" />\n        </receiver>\n\n        <service android:name=\"com.tx.weatherwidget.WeatherService\" >\n        </service>\n```\n源代码下载：[weatherWidget](http://download.csdn.net/detail/txadf/9267497)\n\n\n\n\n\n\n\n","slug":"first-use-widget","published":1,"updated":"2016-04-23T09:48:41.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuchw0022g0g51f4qizuw","content":"<p>学习android widget的使用，使用高德地图的定位功能中的天气api来获取天气，做了个简单的demo。<a id=\"more\"></a>widget的开发步骤如下：</p>\n<ol>\n<li>编写widget布局和配置文件；</li>\n<li>编写自己的provider继承自AppWidgetProvider；</li>\n<li>使用服务来更新widget；</li>\n<li>修改配置文件。</li>\n</ol>\n<p>开发之前先导入高德定位jar包，修改配置文件添加自己的appkey和相关的权限。（详情请参照：<a href=\"http://lbs.amap.com/api/android-location-sdk/guide/weather/）\" target=\"_blank\" rel=\"external\">http://lbs.amap.com/api/android-location-sdk/guide/weather/）</a></p>\n<h3 id=\"一、编写widget布局文件和配置文件\"><a href=\"#一、编写widget布局文件和配置文件\" class=\"headerlink\" title=\"一、编写widget布局文件和配置文件\"></a>一、编写widget布局文件和配置文件</h3><p>这里就添加了一个TextView来显示天气信息；<br>widget配置文件： src/xml/widgetconfig<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:initialLayout=&quot;@layout/widget&quot;</span><br><span class=\"line\">    android:minHeight=&quot;100dp&quot;</span><br><span class=\"line\">    android:minWidth=&quot;200dp&quot;</span><br><span class=\"line\">    android:updatePeriodMillis=&quot;860000&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/appwidget-provider&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二、AppWidgetProvider的编写，启动与停止服务。\"><a href=\"#二、AppWidgetProvider的编写，启动与停止服务。\" class=\"headerlink\" title=\"二、AppWidgetProvider的编写，启动与停止服务。\"></a>二、AppWidgetProvider的编写，启动与停止服务。</h3><p>在AppWidgetProvider中的主要方法有：<br>onEnabled(Context context)–第一个widget添加时调用<br>onDeleted(Context context, int[] appWidgetIds)–widget被从屏幕移除时调用<br>onDisabled(Context context) –widget 最后一个被从屏幕移除<br>onUpdate(Context context,<br>AppWidgetManager appWidgetManager,<br>int[] appWidgetIds)—刷新widget</p>\n<p>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tx.weatherwidget;</span><br><span class=\"line\">import android.appwidget.AppWidgetManager;</span><br><span class=\"line\">import android.appwidget.AppWidgetProvider;</span><br><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.content.Intent;</span><br><span class=\"line\">public class WeatherProvider extends AppWidgetProvider &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * widget第一个添加到桌面执行</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onEnabled(Context context) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onEnabled(context);</span><br><span class=\"line\">\t\tIntent intent = new Intent(context, WeatherService.class);</span><br><span class=\"line\">\t\tcontext.startService(intent);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 最后一个widget移除桌面执行</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onDisabled(Context context) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onDisabled(context);</span><br><span class=\"line\">\t\tIntent intent = new Intent(context, WeatherService.class);</span><br><span class=\"line\">\t\tcontext.stopService(intent);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 更新数据</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onUpdate(Context context, AppWidgetManager appWidgetManager,</span><br><span class=\"line\">\t\t\tint[] appWidgetIds) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onUpdate(context, appWidgetManager, appWidgetIds);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"三、service的编写，获取天气，widget更新。\"><a href=\"#三、service的编写，获取天气，widget更新。\" class=\"headerlink\" title=\"三、service的编写，获取天气，widget更新。\"></a>三、service的编写，获取天气，widget更新。</h3><p>主要代码在updateView中，这里使用RemoteViews，AppWidgetManager的updateAppWidget来通知widget更新。<br>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tx.weatherwidget;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 调用高德地图的天气api获取天气</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">import android.app.Service;</span><br><span class=\"line\">import android.appwidget.AppWidgetManager;</span><br><span class=\"line\">import android.content.ComponentName;</span><br><span class=\"line\">import android.content.Intent;</span><br><span class=\"line\">import android.os.IBinder;</span><br><span class=\"line\">import android.widget.RemoteViews;</span><br><span class=\"line\">import android.widget.Toast;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.amap.api.location.AMapLocalWeatherForecast;</span><br><span class=\"line\">import com.amap.api.location.AMapLocalWeatherListener;</span><br><span class=\"line\">import com.amap.api.location.AMapLocalWeatherLive;</span><br><span class=\"line\">import com.amap.api.location.LocationManagerProxy;</span><br><span class=\"line\">import com.tx.weatherwidget.R;</span><br><span class=\"line\"></span><br><span class=\"line\">public class WeatherService extends Service implements</span><br><span class=\"line\">AMapLocalWeatherListener&#123;</span><br><span class=\"line\">\tprivate LocationManagerProxy mLocationManagerProxy;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic IBinder onBind(Intent arg0) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\treturn null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onCreate() &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onCreate();</span><br><span class=\"line\">\t\tinit();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 注册天气监听</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tprivate void init() &#123;</span><br><span class=\"line\">\t\tmLocationManagerProxy = LocationManagerProxy.getInstance(this);</span><br><span class=\"line\">\t\tmLocationManagerProxy.requestWeatherUpdates(</span><br><span class=\"line\">\t\t\t\tLocationManagerProxy.WEATHER_TYPE_LIVE, this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onWeatherForecaseSearched(AMapLocalWeatherForecast arg0) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onWeatherLiveSearched(AMapLocalWeatherLive aMapLocalWeatherLive) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tif(aMapLocalWeatherLive!=null &amp;&amp; aMapLocalWeatherLive.getAMapException().getErrorCode() == 0)&#123;</span><br><span class=\"line\">\t\t\tString city = aMapLocalWeatherLive.getCity();//城市</span><br><span class=\"line\">\t\t\tString weather = aMapLocalWeatherLive.getWeather();//天气情况</span><br><span class=\"line\">\t\t\tString windDir = aMapLocalWeatherLive.getWindDir();//风向</span><br><span class=\"line\">\t\t\tString windPower = aMapLocalWeatherLive.getWindPower();//风力</span><br><span class=\"line\">\t\t\tString humidity = aMapLocalWeatherLive.getHumidity();//空气湿度</span><br><span class=\"line\">\t\t\tString reportTime = aMapLocalWeatherLive.getReportTime();//数据发布时间</span><br><span class=\"line\">\t\t\tupdateView(&quot;城市： &quot;+city+&apos;\\n&apos;+</span><br><span class=\"line\">\t\t\t\t\t&quot;风向： &quot;+windDir+&apos;\\n&apos;+</span><br><span class=\"line\">\t\t\t\t\t&quot;风力： &quot;+windPower+&apos;\\n&apos;+</span><br><span class=\"line\">\t\t\t\t\t&quot;天气情况： &quot;+weather+&apos;\\n&apos;+</span><br><span class=\"line\">\t\t\t\t\t&quot;空气湿度： &quot;+humidity+&apos;\\n&apos;+</span><br><span class=\"line\">\t\t\t\t\t&quot;数据发布时间： &quot;+reportTime+&apos;\\n&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t// 获取天气预报失败</span><br><span class=\"line\">\t\t\tToast.makeText(this,&quot;获取天气预报失败:&quot;+ aMapLocalWeatherLive.getAMapException().getErrorMessage(), Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate void updateView(String info)&#123;</span><br><span class=\"line\">\t\tRemoteViews remoteViews = new RemoteViews(getPackageName(),</span><br><span class=\"line\">\t\t\t\tR.layout.widget);</span><br><span class=\"line\">\t\tremoteViews.setTextViewText(R.id.weather, info);</span><br><span class=\"line\">\t\tAppWidgetManager manager = AppWidgetManager.</span><br><span class=\"line\">\t\t\t\tgetInstance(getApplicationContext());</span><br><span class=\"line\">\t\tComponentName provider = new ComponentName(</span><br><span class=\"line\">\t\t\t\tgetApplicationContext(), WeatherProvider.class);</span><br><span class=\"line\">\t\tmanager.updateAppWidget(provider, remoteViews);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"四、修改配置文件，注册服务。\"><a href=\"#四、修改配置文件，注册服务。\" class=\"headerlink\" title=\"四、修改配置文件，注册服务。\"></a>四、修改配置文件，注册服务。</h3><p>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;receiver android:name=&quot;com.tx.weatherwidget.WeatherProvider&quot; &gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;meta-data</span><br><span class=\"line\">                android:name=&quot;android.appwidget.provider&quot;</span><br><span class=\"line\">                android:resource=&quot;@xml/widgetconfig&quot; /&gt;</span><br><span class=\"line\">        &lt;/receiver&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;service android:name=&quot;com.tx.weatherwidget.WeatherService&quot; &gt;</span><br><span class=\"line\">        &lt;/service&gt;</span><br></pre></td></tr></table></figure></p>\n<p>源代码下载：<a href=\"http://download.csdn.net/detail/txadf/9267497\" target=\"_blank\" rel=\"external\">weatherWidget</a></p>\n","excerpt":"<p>学习android widget的使用，使用高德地图的定位功能中的天气api来获取天气，做了个简单的demo。","more":"widget的开发步骤如下：</p>\n<ol>\n<li>编写widget布局和配置文件；</li>\n<li>编写自己的provider继承自AppWidgetProvider；</li>\n<li>使用服务来更新widget；</li>\n<li>修改配置文件。</li>\n</ol>\n<p>开发之前先导入高德定位jar包，修改配置文件添加自己的appkey和相关的权限。（详情请参照：<a href=\"http://lbs.amap.com/api/android-location-sdk/guide/weather/）\">http://lbs.amap.com/api/android-location-sdk/guide/weather/）</a></p>\n<h3 id=\"一、编写widget布局文件和配置文件\"><a href=\"#一、编写widget布局文件和配置文件\" class=\"headerlink\" title=\"一、编写widget布局文件和配置文件\"></a>一、编写widget布局文件和配置文件</h3><p>这里就添加了一个TextView来显示天气信息；<br>widget配置文件： src/xml/widgetconfig<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:initialLayout=&quot;@layout/widget&quot;</span><br><span class=\"line\">    android:minHeight=&quot;100dp&quot;</span><br><span class=\"line\">    android:minWidth=&quot;200dp&quot;</span><br><span class=\"line\">    android:updatePeriodMillis=&quot;860000&quot; &gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/appwidget-provider&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二、AppWidgetProvider的编写，启动与停止服务。\"><a href=\"#二、AppWidgetProvider的编写，启动与停止服务。\" class=\"headerlink\" title=\"二、AppWidgetProvider的编写，启动与停止服务。\"></a>二、AppWidgetProvider的编写，启动与停止服务。</h3><p>在AppWidgetProvider中的主要方法有：<br>onEnabled(Context context)–第一个widget添加时调用<br>onDeleted(Context context, int[] appWidgetIds)–widget被从屏幕移除时调用<br>onDisabled(Context context) –widget 最后一个被从屏幕移除<br>onUpdate(Context context,<br>AppWidgetManager appWidgetManager,<br>int[] appWidgetIds)—刷新widget</p>\n<p>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tx.weatherwidget;</span><br><span class=\"line\">import android.appwidget.AppWidgetManager;</span><br><span class=\"line\">import android.appwidget.AppWidgetProvider;</span><br><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.content.Intent;</span><br><span class=\"line\">public class WeatherProvider extends AppWidgetProvider &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * widget第一个添加到桌面执行</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onEnabled(Context context) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onEnabled(context);</span><br><span class=\"line\">\t\tIntent intent = new Intent(context, WeatherService.class);</span><br><span class=\"line\">\t\tcontext.startService(intent);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 最后一个widget移除桌面执行</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onDisabled(Context context) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onDisabled(context);</span><br><span class=\"line\">\t\tIntent intent = new Intent(context, WeatherService.class);</span><br><span class=\"line\">\t\tcontext.stopService(intent);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 更新数据</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onUpdate(Context context, AppWidgetManager appWidgetManager,</span><br><span class=\"line\">\t\t\tint[] appWidgetIds) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onUpdate(context, appWidgetManager, appWidgetIds);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"三、service的编写，获取天气，widget更新。\"><a href=\"#三、service的编写，获取天气，widget更新。\" class=\"headerlink\" title=\"三、service的编写，获取天气，widget更新。\"></a>三、service的编写，获取天气，widget更新。</h3><p>主要代码在updateView中，这里使用RemoteViews，AppWidgetManager的updateAppWidget来通知widget更新。<br>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tx.weatherwidget;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 调用高德地图的天气api获取天气</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">import android.app.Service;</span><br><span class=\"line\">import android.appwidget.AppWidgetManager;</span><br><span class=\"line\">import android.content.ComponentName;</span><br><span class=\"line\">import android.content.Intent;</span><br><span class=\"line\">import android.os.IBinder;</span><br><span class=\"line\">import android.widget.RemoteViews;</span><br><span class=\"line\">import android.widget.Toast;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.amap.api.location.AMapLocalWeatherForecast;</span><br><span class=\"line\">import com.amap.api.location.AMapLocalWeatherListener;</span><br><span class=\"line\">import com.amap.api.location.AMapLocalWeatherLive;</span><br><span class=\"line\">import com.amap.api.location.LocationManagerProxy;</span><br><span class=\"line\">import com.tx.weatherwidget.R;</span><br><span class=\"line\"></span><br><span class=\"line\">public class WeatherService extends Service implements</span><br><span class=\"line\">AMapLocalWeatherListener&#123;</span><br><span class=\"line\">\tprivate LocationManagerProxy mLocationManagerProxy;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic IBinder onBind(Intent arg0) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\treturn null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onCreate() &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tsuper.onCreate();</span><br><span class=\"line\">\t\tinit();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 注册天气监听</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tprivate void init() &#123;</span><br><span class=\"line\">\t\tmLocationManagerProxy = LocationManagerProxy.getInstance(this);</span><br><span class=\"line\">\t\tmLocationManagerProxy.requestWeatherUpdates(</span><br><span class=\"line\">\t\t\t\tLocationManagerProxy.WEATHER_TYPE_LIVE, this);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onWeatherForecaseSearched(AMapLocalWeatherForecast arg0) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void onWeatherLiveSearched(AMapLocalWeatherLive aMapLocalWeatherLive) &#123;</span><br><span class=\"line\">\t\t// TODO Auto-generated method stub</span><br><span class=\"line\">\t\tif(aMapLocalWeatherLive!=null &amp;&amp; aMapLocalWeatherLive.getAMapException().getErrorCode() == 0)&#123;</span><br><span class=\"line\">\t\t\tString city = aMapLocalWeatherLive.getCity();//城市</span><br><span class=\"line\">\t\t\tString weather = aMapLocalWeatherLive.getWeather();//天气情况</span><br><span class=\"line\">\t\t\tString windDir = aMapLocalWeatherLive.getWindDir();//风向</span><br><span class=\"line\">\t\t\tString windPower = aMapLocalWeatherLive.getWindPower();//风力</span><br><span class=\"line\">\t\t\tString humidity = aMapLocalWeatherLive.getHumidity();//空气湿度</span><br><span class=\"line\">\t\t\tString reportTime = aMapLocalWeatherLive.getReportTime();//数据发布时间</span><br><span class=\"line\">\t\t\tupdateView(&quot;城市： &quot;+city+&apos;\\n&apos;+</span><br><span class=\"line\">\t\t\t\t\t&quot;风向： &quot;+windDir+&apos;\\n&apos;+</span><br><span class=\"line\">\t\t\t\t\t&quot;风力： &quot;+windPower+&apos;\\n&apos;+</span><br><span class=\"line\">\t\t\t\t\t&quot;天气情况： &quot;+weather+&apos;\\n&apos;+</span><br><span class=\"line\">\t\t\t\t\t&quot;空气湿度： &quot;+humidity+&apos;\\n&apos;+</span><br><span class=\"line\">\t\t\t\t\t&quot;数据发布时间： &quot;+reportTime+&apos;\\n&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t// 获取天气预报失败</span><br><span class=\"line\">\t\t\tToast.makeText(this,&quot;获取天气预报失败:&quot;+ aMapLocalWeatherLive.getAMapException().getErrorMessage(), Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate void updateView(String info)&#123;</span><br><span class=\"line\">\t\tRemoteViews remoteViews = new RemoteViews(getPackageName(),</span><br><span class=\"line\">\t\t\t\tR.layout.widget);</span><br><span class=\"line\">\t\tremoteViews.setTextViewText(R.id.weather, info);</span><br><span class=\"line\">\t\tAppWidgetManager manager = AppWidgetManager.</span><br><span class=\"line\">\t\t\t\tgetInstance(getApplicationContext());</span><br><span class=\"line\">\t\tComponentName provider = new ComponentName(</span><br><span class=\"line\">\t\t\t\tgetApplicationContext(), WeatherProvider.class);</span><br><span class=\"line\">\t\tmanager.updateAppWidget(provider, remoteViews);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"四、修改配置文件，注册服务。\"><a href=\"#四、修改配置文件，注册服务。\" class=\"headerlink\" title=\"四、修改配置文件，注册服务。\"></a>四、修改配置文件，注册服务。</h3><p>代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;receiver android:name=&quot;com.tx.weatherwidget.WeatherProvider&quot; &gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;meta-data</span><br><span class=\"line\">                android:name=&quot;android.appwidget.provider&quot;</span><br><span class=\"line\">                android:resource=&quot;@xml/widgetconfig&quot; /&gt;</span><br><span class=\"line\">        &lt;/receiver&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;service android:name=&quot;com.tx.weatherwidget.WeatherService&quot; &gt;</span><br><span class=\"line\">        &lt;/service&gt;</span><br></pre></td></tr></table></figure></p>\n<p>源代码下载：<a href=\"http://download.csdn.net/detail/txadf/9267497\">weatherWidget</a></p>"},{"title":"Hexo+github 搭建个人博客","_content":"最近，看见很多人在使用hexo+github搭建自己的博客，为了方便记录平时的学习内容。在此，我也学习搭建一个个人博客，记下自己的搭建过程，方便自己，也方便他人。\n<!--more-->\n## 1、安装前准备\n\n>- 安装 **Node.js** ，(可以去 [官网][1] 下载相应的版本，并安装。\n>- 安装Git (或者安装github客户端)\n\n---\n## 2、安装hexo\nwindows下进入命令行，执行如下命令：\n\n        npm install-g hexo\n然后启动 git shell 初始化hexo。这里，我打算把hexo放在自己新建的 “myblog” 文件夹下，则需要先进入该文件夹下，然后进行初始化，如下命令：\n        \n        \n        E:\\GitHub> cd myblog            //进入目录\n        E:\\GitHub\\myblog> hexo init    //进行初始化\n\n注：我的git shell 的根目录为 E:\\Github ,myblog 文件夹在它下面。\n然后就是静静的等待它下载完成，可能需要几分钟。\n最后就可以生成静态界面：\n        \n        hexo g\n启动服务：\n        \n        hexo s\n打开浏览器，输入 http://localhost:4000/ 即可成功打开。\n到此，你已经成功的弄好博客页面了。\n\n---\n## 3、配置到github\n上面生成的 博客页面仅限本机使用，别人无法访问。有服务器的可以把它配置到服务器上。但这里采用的是提交到github，由它托管，就可以方便的访问了。\n在github 上建立  ***用户名.github.io*** 的仓库。如我的github用户名为：txadf,仓库为：**txadf.github.io**  地址为 ：https://github.com/txadf/txadf.github.io.git\n然后打开blog 文件夹下的 _config.yml 文件，在最后修改为如下代码：\n\n        deploy:\n          type: git\n          repo: https://github.com/txadf/txadf.github.io.git\n          branch: master\n\n\n最后，提交博客文件到gtihub,执行如下命令：\n        \n        hexo d\n如果不出错，那么就可以在浏览器用 txadf.github.进行访问了。\n\n---\n## 4、hexo 相关命令\n        cls             清屏\n        hexo clean      清理项目\n        hexo g          生成静态界面\n        hexo s          启动服务器\n        hexo d          提交到github\n        hexo help       全部的命令\n新建文章：\n    \n    hexo new \"blogname\"\n博客支持markdown语法，可以用相关的编辑器写好后放在**_posts**文件下。对于markdown语法，如有不懂课自行百度。\n\n---\n## 5、主题推荐\n对于主题的修改，只需要修改 blog 文件夹下的 **_config.yml** 中的**theme**属性为指定的主题名，并将主题放到theme文件夹下。\n然后 进行部署（hexo g） 和提交 （hexo d）\n注：对于其他的属性，修改 方法类似，如网站标题，作者等。\n\n这里推荐几个个人比较喜欢的主题：\n 1. [我的博客主题][2]  \n 2.  [hexo-theme-spfk][3]\n \n更多主题，请访问[这里][4]\n \n \n\n\n  [1]: https://nodejs.org/en/\n  [2]: https://github.com/raytaylorlin/hexo-theme-raytaylorism\n  [3]: https://github.com/txadf/hexo-theme-spfk\n  [4]: https://github.com/hexojs/hexo/wiki/Themes","source":"_posts/hexo+github -build-my-blog.md","raw":"---\ntitle: Hexo+github 搭建个人博客\ncategories: [工具软件,hexo]\ntags: [软件,gihub]\n---\n最近，看见很多人在使用hexo+github搭建自己的博客，为了方便记录平时的学习内容。在此，我也学习搭建一个个人博客，记下自己的搭建过程，方便自己，也方便他人。\n<!--more-->\n## 1、安装前准备\n\n>- 安装 **Node.js** ，(可以去 [官网][1] 下载相应的版本，并安装。\n>- 安装Git (或者安装github客户端)\n\n---\n## 2、安装hexo\nwindows下进入命令行，执行如下命令：\n\n        npm install-g hexo\n然后启动 git shell 初始化hexo。这里，我打算把hexo放在自己新建的 “myblog” 文件夹下，则需要先进入该文件夹下，然后进行初始化，如下命令：\n        \n        \n        E:\\GitHub> cd myblog            //进入目录\n        E:\\GitHub\\myblog> hexo init    //进行初始化\n\n注：我的git shell 的根目录为 E:\\Github ,myblog 文件夹在它下面。\n然后就是静静的等待它下载完成，可能需要几分钟。\n最后就可以生成静态界面：\n        \n        hexo g\n启动服务：\n        \n        hexo s\n打开浏览器，输入 http://localhost:4000/ 即可成功打开。\n到此，你已经成功的弄好博客页面了。\n\n---\n## 3、配置到github\n上面生成的 博客页面仅限本机使用，别人无法访问。有服务器的可以把它配置到服务器上。但这里采用的是提交到github，由它托管，就可以方便的访问了。\n在github 上建立  ***用户名.github.io*** 的仓库。如我的github用户名为：txadf,仓库为：**txadf.github.io**  地址为 ：https://github.com/txadf/txadf.github.io.git\n然后打开blog 文件夹下的 _config.yml 文件，在最后修改为如下代码：\n\n        deploy:\n          type: git\n          repo: https://github.com/txadf/txadf.github.io.git\n          branch: master\n\n\n最后，提交博客文件到gtihub,执行如下命令：\n        \n        hexo d\n如果不出错，那么就可以在浏览器用 txadf.github.进行访问了。\n\n---\n## 4、hexo 相关命令\n        cls             清屏\n        hexo clean      清理项目\n        hexo g          生成静态界面\n        hexo s          启动服务器\n        hexo d          提交到github\n        hexo help       全部的命令\n新建文章：\n    \n    hexo new \"blogname\"\n博客支持markdown语法，可以用相关的编辑器写好后放在**_posts**文件下。对于markdown语法，如有不懂课自行百度。\n\n---\n## 5、主题推荐\n对于主题的修改，只需要修改 blog 文件夹下的 **_config.yml** 中的**theme**属性为指定的主题名，并将主题放到theme文件夹下。\n然后 进行部署（hexo g） 和提交 （hexo d）\n注：对于其他的属性，修改 方法类似，如网站标题，作者等。\n\n这里推荐几个个人比较喜欢的主题：\n 1. [我的博客主题][2]  \n 2.  [hexo-theme-spfk][3]\n \n更多主题，请访问[这里][4]\n \n \n\n\n  [1]: https://nodejs.org/en/\n  [2]: https://github.com/raytaylorlin/hexo-theme-raytaylorism\n  [3]: https://github.com/txadf/hexo-theme-spfk\n  [4]: https://github.com/hexojs/hexo/wiki/Themes","slug":"hexo+github -build-my-blog","published":1,"date":"2016-04-20T08:45:08.620Z","updated":"2016-04-22T13:43:27.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuchw0025g0g5imsdrmv8","content":"<p>最近，看见很多人在使用hexo+github搭建自己的博客，为了方便记录平时的学习内容。在此，我也学习搭建一个个人博客，记下自己的搭建过程，方便自己，也方便他人。<br><a id=\"more\"></a></p>\n<h2 id=\"1、安装前准备\"><a href=\"#1、安装前准备\" class=\"headerlink\" title=\"1、安装前准备\"></a>1、安装前准备</h2><blockquote>\n<ul>\n<li>安装 <strong>Node.js</strong> ，(可以去 <a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">官网</a> 下载相应的版本，并安装。</li>\n<li>安装Git (或者安装github客户端)</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"2、安装hexo\"><a href=\"#2、安装hexo\" class=\"headerlink\" title=\"2、安装hexo\"></a>2、安装hexo</h2><p>windows下进入命令行，执行如下命令：</p>\n<pre><code>npm install-g hexo\n</code></pre><p>然后启动 git shell 初始化hexo。这里，我打算把hexo放在自己新建的 “myblog” 文件夹下，则需要先进入该文件夹下，然后进行初始化，如下命令：</p>\n<pre><code>E:\\GitHub&gt; cd myblog            //进入目录\nE:\\GitHub\\myblog&gt; hexo init    //进行初始化\n</code></pre><p>注：我的git shell 的根目录为 E:\\Github ,myblog 文件夹在它下面。<br>然后就是静静的等待它下载完成，可能需要几分钟。<br>最后就可以生成静态界面：</p>\n<pre><code>hexo g\n</code></pre><p>启动服务：</p>\n<pre><code>hexo s\n</code></pre><p>打开浏览器，输入 <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a> 即可成功打开。<br>到此，你已经成功的弄好博客页面了。</p>\n<hr>\n<h2 id=\"3、配置到github\"><a href=\"#3、配置到github\" class=\"headerlink\" title=\"3、配置到github\"></a>3、配置到github</h2><p>上面生成的 博客页面仅限本机使用，别人无法访问。有服务器的可以把它配置到服务器上。但这里采用的是提交到github，由它托管，就可以方便的访问了。<br>在github 上建立  <strong><em>用户名.github.io</em></strong> 的仓库。如我的github用户名为：txadf,仓库为：<strong>txadf.github.io</strong>  地址为 ：<a href=\"https://github.com/txadf/txadf.github.io.git\" target=\"_blank\" rel=\"external\">https://github.com/txadf/txadf.github.io.git</a><br>然后打开blog 文件夹下的 _config.yml 文件，在最后修改为如下代码：</p>\n<pre><code>deploy:\n  type: git\n  repo: https://github.com/txadf/txadf.github.io.git\n  branch: master\n</code></pre><p>最后，提交博客文件到gtihub,执行如下命令：</p>\n<pre><code>hexo d\n</code></pre><p>如果不出错，那么就可以在浏览器用 txadf.github.进行访问了。</p>\n<hr>\n<h2 id=\"4、hexo-相关命令\"><a href=\"#4、hexo-相关命令\" class=\"headerlink\" title=\"4、hexo 相关命令\"></a>4、hexo 相关命令</h2><pre><code>cls             清屏\nhexo clean      清理项目\nhexo g          生成静态界面\nhexo s          启动服务器\nhexo d          提交到github\nhexo help       全部的命令\n</code></pre><p>新建文章：</p>\n<pre><code>hexo new &quot;blogname&quot;\n</code></pre><p>博客支持markdown语法，可以用相关的编辑器写好后放在<strong>_posts</strong>文件下。对于markdown语法，如有不懂课自行百度。</p>\n<hr>\n<h2 id=\"5、主题推荐\"><a href=\"#5、主题推荐\" class=\"headerlink\" title=\"5、主题推荐\"></a>5、主题推荐</h2><p>对于主题的修改，只需要修改 blog 文件夹下的 <strong>_config.yml</strong> 中的<strong>theme</strong>属性为指定的主题名，并将主题放到theme文件夹下。<br>然后 进行部署（hexo g） 和提交 （hexo d）<br>注：对于其他的属性，修改 方法类似，如网站标题，作者等。</p>\n<p>这里推荐几个个人比较喜欢的主题：</p>\n<ol>\n<li><a href=\"https://github.com/raytaylorlin/hexo-theme-raytaylorism\" target=\"_blank\" rel=\"external\">我的博客主题</a>  </li>\n<li><a href=\"https://github.com/txadf/hexo-theme-spfk\" target=\"_blank\" rel=\"external\">hexo-theme-spfk</a></li>\n</ol>\n<p>更多主题，请访问<a href=\"https://github.com/hexojs/hexo/wiki/Themes\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<p>最近，看见很多人在使用hexo+github搭建自己的博客，为了方便记录平时的学习内容。在此，我也学习搭建一个个人博客，记下自己的搭建过程，方便自己，也方便他人。<br>","more":"</p>\n<h2 id=\"1、安装前准备\"><a href=\"#1、安装前准备\" class=\"headerlink\" title=\"1、安装前准备\"></a>1、安装前准备</h2><blockquote>\n<ul>\n<li>安装 <strong>Node.js</strong> ，(可以去 <a href=\"https://nodejs.org/en/\">官网</a> 下载相应的版本，并安装。</li>\n<li>安装Git (或者安装github客户端)</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"2、安装hexo\"><a href=\"#2、安装hexo\" class=\"headerlink\" title=\"2、安装hexo\"></a>2、安装hexo</h2><p>windows下进入命令行，执行如下命令：</p>\n<pre><code>npm install-g hexo\n</code></pre><p>然后启动 git shell 初始化hexo。这里，我打算把hexo放在自己新建的 “myblog” 文件夹下，则需要先进入该文件夹下，然后进行初始化，如下命令：</p>\n<pre><code>E:\\GitHub&gt; cd myblog            //进入目录\nE:\\GitHub\\myblog&gt; hexo init    //进行初始化\n</code></pre><p>注：我的git shell 的根目录为 E:\\Github ,myblog 文件夹在它下面。<br>然后就是静静的等待它下载完成，可能需要几分钟。<br>最后就可以生成静态界面：</p>\n<pre><code>hexo g\n</code></pre><p>启动服务：</p>\n<pre><code>hexo s\n</code></pre><p>打开浏览器，输入 <a href=\"http://localhost:4000/\">http://localhost:4000/</a> 即可成功打开。<br>到此，你已经成功的弄好博客页面了。</p>\n<hr>\n<h2 id=\"3、配置到github\"><a href=\"#3、配置到github\" class=\"headerlink\" title=\"3、配置到github\"></a>3、配置到github</h2><p>上面生成的 博客页面仅限本机使用，别人无法访问。有服务器的可以把它配置到服务器上。但这里采用的是提交到github，由它托管，就可以方便的访问了。<br>在github 上建立  <strong><em>用户名.github.io</em></strong> 的仓库。如我的github用户名为：txadf,仓库为：<strong>txadf.github.io</strong>  地址为 ：<a href=\"https://github.com/txadf/txadf.github.io.git\">https://github.com/txadf/txadf.github.io.git</a><br>然后打开blog 文件夹下的 _config.yml 文件，在最后修改为如下代码：</p>\n<pre><code>deploy:\n  type: git\n  repo: https://github.com/txadf/txadf.github.io.git\n  branch: master\n</code></pre><p>最后，提交博客文件到gtihub,执行如下命令：</p>\n<pre><code>hexo d\n</code></pre><p>如果不出错，那么就可以在浏览器用 txadf.github.进行访问了。</p>\n<hr>\n<h2 id=\"4、hexo-相关命令\"><a href=\"#4、hexo-相关命令\" class=\"headerlink\" title=\"4、hexo 相关命令\"></a>4、hexo 相关命令</h2><pre><code>cls             清屏\nhexo clean      清理项目\nhexo g          生成静态界面\nhexo s          启动服务器\nhexo d          提交到github\nhexo help       全部的命令\n</code></pre><p>新建文章：</p>\n<pre><code>hexo new &quot;blogname&quot;\n</code></pre><p>博客支持markdown语法，可以用相关的编辑器写好后放在<strong>_posts</strong>文件下。对于markdown语法，如有不懂课自行百度。</p>\n<hr>\n<h2 id=\"5、主题推荐\"><a href=\"#5、主题推荐\" class=\"headerlink\" title=\"5、主题推荐\"></a>5、主题推荐</h2><p>对于主题的修改，只需要修改 blog 文件夹下的 <strong>_config.yml</strong> 中的<strong>theme</strong>属性为指定的主题名，并将主题放到theme文件夹下。<br>然后 进行部署（hexo g） 和提交 （hexo d）<br>注：对于其他的属性，修改 方法类似，如网站标题，作者等。</p>\n<p>这里推荐几个个人比较喜欢的主题：</p>\n<ol>\n<li><a href=\"https://github.com/raytaylorlin/hexo-theme-raytaylorism\">我的博客主题</a>  </li>\n<li><a href=\"https://github.com/txadf/hexo-theme-spfk\">hexo-theme-spfk</a></li>\n</ol>\n<p>更多主题，请访问<a href=\"https://github.com/hexojs/hexo/wiki/Themes\">这里</a></p>"},{"title":"hexo 编写发布博客","date":"2016-04-23T01:27:03.000Z","_content":"\n上一篇 :[Hexo+github搭建个人博客][1]\n我们介绍了博客的搭建过程，这里说明如何编写博客及发布.\n<!--more-->\n## 1、编写博客\n\n\n- ##### a、使用hexo 命令\n    ```\n    hexo new [layout] blogName\n    ```\n    这里layout默认的是 **post**,可以为文章指定标题，日期，分类，标签等，方便博客的管理。其中分类和标签若有多个，可放在“**[ ]**”中，用“**，**”。隔开具体如下：\n\t```\n\t---\n\t\ttitle: {{ title }}\n\t\tdate: {{ date }}\n\t\tcategories: [分类1,子分类]\n\t\ttags: [标签1,标签2,]\n\t---\n\t```\n 需要注意的是是：“**title：**”标签**冒号**后有**空格**，其他的同样。\n此外，为了界面美观，可以添加 显示\"**read more**\",如：只显示第一段，则在第一段后添加：\n\t```   \n\t<!--more-->\n\t```\n- ##### b、直接用编辑器编写\n\n    博客的编写支持markdown 语法，个人使用的是**作业部落**的Cmd Markdown 编辑器，非常好用，语法简单，方便，具体用法参见[这里][2]。\n    这种方式需要在写好的文件开头添加**post**文件，方法同上。然后吧写好的文件放到“**_posts**” 文件夹下，如果没有准备发布，作为草稿可以放在“**_data**”文件夹下。\n\n\t\n## 2、发布博客\n打开gitshell 进入博客根目录，生成静态页面：\n\t```\n\t\thexo g\n\t```\n然后起动服务就可以在网页上预览了。\n\n最后就是将页面提交github。\n\n  [1]: http://imtianx.cn/2016/04/20/Hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\n  [2]: https://www.zybuluo.com/mdeditor#345522","source":"_posts/hexo- write-blog.md","raw":"---\ntitle: hexo 编写发布博客\ndate: 2016-04-23 09:27:03\ncategories: [工具软件,hexo]\ntags: [hexo,写博客]\n---\n\n上一篇 :[Hexo+github搭建个人博客][1]\n我们介绍了博客的搭建过程，这里说明如何编写博客及发布.\n<!--more-->\n## 1、编写博客\n\n\n- ##### a、使用hexo 命令\n    ```\n    hexo new [layout] blogName\n    ```\n    这里layout默认的是 **post**,可以为文章指定标题，日期，分类，标签等，方便博客的管理。其中分类和标签若有多个，可放在“**[ ]**”中，用“**，**”。隔开具体如下：\n\t```\n\t---\n\t\ttitle: {{ title }}\n\t\tdate: {{ date }}\n\t\tcategories: [分类1,子分类]\n\t\ttags: [标签1,标签2,]\n\t---\n\t```\n 需要注意的是是：“**title：**”标签**冒号**后有**空格**，其他的同样。\n此外，为了界面美观，可以添加 显示\"**read more**\",如：只显示第一段，则在第一段后添加：\n\t```   \n\t<!--more-->\n\t```\n- ##### b、直接用编辑器编写\n\n    博客的编写支持markdown 语法，个人使用的是**作业部落**的Cmd Markdown 编辑器，非常好用，语法简单，方便，具体用法参见[这里][2]。\n    这种方式需要在写好的文件开头添加**post**文件，方法同上。然后吧写好的文件放到“**_posts**” 文件夹下，如果没有准备发布，作为草稿可以放在“**_data**”文件夹下。\n\n\t\n## 2、发布博客\n打开gitshell 进入博客根目录，生成静态页面：\n\t```\n\t\thexo g\n\t```\n然后起动服务就可以在网页上预览了。\n\n最后就是将页面提交github。\n\n  [1]: http://imtianx.cn/2016/04/20/Hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\n  [2]: https://www.zybuluo.com/mdeditor#345522","slug":"hexo- write-blog","published":1,"updated":"2016-04-23T02:51:43.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuchw0029g0g5dy1wl9f4","content":"<p>上一篇 :<a href=\"http://imtianx.cn/2016/04/20/Hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\">Hexo+github搭建个人博客</a><br>我们介绍了博客的搭建过程，这里说明如何编写博客及发布.<br><a id=\"more\"></a></p>\n<h2 id=\"1、编写博客\"><a href=\"#1、编写博客\" class=\"headerlink\" title=\"1、编写博客\"></a>1、编写博客</h2><ul>\n<li><h5 id=\"a、使用hexo-命令\"><a href=\"#a、使用hexo-命令\" class=\"headerlink\" title=\"a、使用hexo 命令\"></a>a、使用hexo 命令</h5>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new [layout] blogName</span><br></pre></td></tr></table></figure>\n<p>  这里layout默认的是 <strong>post</strong>,可以为文章指定标题，日期，分类，标签等，方便博客的管理。其中分类和标签若有多个，可放在“<strong>[ ]</strong>”中，用“<strong>，</strong>”。隔开具体如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">\ttitle: &#123;&#123; title &#125;&#125;</span><br><span class=\"line\">\tdate: &#123;&#123; date &#125;&#125;</span><br><span class=\"line\">\tcategories: [分类1,子分类]</span><br><span class=\"line\">\ttags: [标签1,标签2,]</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>需要注意的是是：“<strong>title：</strong>”标签<strong>冒号</strong>后有<strong>空格</strong>，其他的同样。<br>此外，为了界面美观，可以添加 显示”<strong>read more</strong>“,如：只显示第一段，则在第一段后添加：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"b、直接用编辑器编写\"><a href=\"#b、直接用编辑器编写\" class=\"headerlink\" title=\"b、直接用编辑器编写\"></a>b、直接用编辑器编写</h5><p>  博客的编写支持markdown 语法，个人使用的是<strong>作业部落</strong>的Cmd Markdown 编辑器，非常好用，语法简单，方便，具体用法参见<a href=\"https://www.zybuluo.com/mdeditor#345522\" target=\"_blank\" rel=\"external\">这里</a>。<br>  这种方式需要在写好的文件开头添加<strong>post</strong>文件，方法同上。然后吧写好的文件放到“<strong>_posts</strong>” 文件夹下，如果没有准备发布，作为草稿可以放在“<strong>_data</strong>”文件夹下。</p>\n</li>\n</ul>\n<h2 id=\"2、发布博客\"><a href=\"#2、发布博客\" class=\"headerlink\" title=\"2、发布博客\"></a>2、发布博客</h2><p>打开gitshell 进入博客根目录，生成静态页面：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure></p>\n<p>然后起动服务就可以在网页上预览了。</p>\n<p>最后就是将页面提交github。</p>\n","excerpt":"<p>上一篇 :<a href=\"http://imtianx.cn/2016/04/20/Hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\">Hexo+github搭建个人博客</a><br>我们介绍了博客的搭建过程，这里说明如何编写博客及发布.<br>","more":"</p>\n<h2 id=\"1、编写博客\"><a href=\"#1、编写博客\" class=\"headerlink\" title=\"1、编写博客\"></a>1、编写博客</h2><ul>\n<li><h5 id=\"a、使用hexo-命令\"><a href=\"#a、使用hexo-命令\" class=\"headerlink\" title=\"a、使用hexo 命令\"></a>a、使用hexo 命令</h5>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new [layout] blogName</span><br></pre></td></tr></table></figure>\n<p>  这里layout默认的是 <strong>post</strong>,可以为文章指定标题，日期，分类，标签等，方便博客的管理。其中分类和标签若有多个，可放在“<strong>[ ]</strong>”中，用“<strong>，</strong>”。隔开具体如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">\ttitle: &#123;&#123; title &#125;&#125;</span><br><span class=\"line\">\tdate: &#123;&#123; date &#125;&#125;</span><br><span class=\"line\">\tcategories: [分类1,子分类]</span><br><span class=\"line\">\ttags: [标签1,标签2,]</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>需要注意的是是：“<strong>title：</strong>”标签<strong>冒号</strong>后有<strong>空格</strong>，其他的同样。<br>此外，为了界面美观，可以添加 显示”<strong>read more</strong>“,如：只显示第一段，则在第一段后添加：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"b、直接用编辑器编写\"><a href=\"#b、直接用编辑器编写\" class=\"headerlink\" title=\"b、直接用编辑器编写\"></a>b、直接用编辑器编写</h5><p>  博客的编写支持markdown 语法，个人使用的是<strong>作业部落</strong>的Cmd Markdown 编辑器，非常好用，语法简单，方便，具体用法参见<a href=\"https://www.zybuluo.com/mdeditor#345522\">这里</a>。<br>  这种方式需要在写好的文件开头添加<strong>post</strong>文件，方法同上。然后吧写好的文件放到“<strong>_posts</strong>” 文件夹下，如果没有准备发布，作为草稿可以放在“<strong>_data</strong>”文件夹下。</p>\n</li>\n</ul>\n<h2 id=\"2、发布博客\"><a href=\"#2、发布博客\" class=\"headerlink\" title=\"2、发布博客\"></a>2、发布博客</h2><p>打开gitshell 进入博客根目录，生成静态页面：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure></p>\n<p>然后起动服务就可以在网页上预览了。</p>\n<p>最后就是将页面提交github。</p>"},{"title":"java 三大特性：封装、继承和多态","date":"2016-10-15T08:06:25.000Z","_content":"\n最近项目上线，暂时稍微闲一点，来回顾下java的一些基础。回想下，也是大二上学的java，已经过去两年了，老师教的基本都是那些最基础的，如数据类型、运算符之类的，加上自己又没有好好学，基本算没学，也就后来转向android 的时候，用啥学啥，如集合、多线程和网络通信等等。下面整理下java面向对象的三大特性。\n### 一、封装\n**封装**是把过程和数据包围起来，对数据的访问只能通过已定义的界面。<!--more-->\n一般是把属性私有，对其的访问只提供`getter` 和 `setter` 方法。\n### 二、继承\n**继承**可以理解为一个对象从另一个对象获取方法和属性的过程。常用的两个关键字为：`extends` 和 `implements`,他们决定了一个对象和另一个对象间是否是**IS-A**(是一个)的关系。\n在Java中，类的继承是**单一继承**，也就是说，一个子类只能拥有一个父类。\n注：java的类均是由 `java.lang.Object` 类继承而来的，上面说的一个父类并不包含Object,它并不需要显示的声明。\n**extends**关键字是用于 类直接的继承而** implements**是针对接口的。\n类只能是单继承的，但是接口可以同时实现多个，也可以同时使用。如：\n```\npublic class A extends B implements  C,D {\n}\n```\n注：在Java中，类的多重继承是不合法，但接口允许多重继承。\n\n### 三、多态\n**多态**：同一个行为具有多个不同表现形式或形态的能力。它的必要条件：继承、重写、父类引用指向子类对象。\n多态性具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。\n\n### 四、重写(Override)与重载(Overload)\n**重写** ：是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。他的好处在于子类可以根据需要，定义特定于自己的行为。\n\n**方法的重写规则**\n 1. 参数列表必须完全与被重写方法的相同；\n 2. 返回类型必须完全与被重写方法的返回类型相同；\n 3. 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。\n 4. 父类的成员方法只能被它的子类重写。\n 5. 声明为final的方法不能被重写。\n 6. 声明为static的方法不能被重写，但是能够被再次声明。\n 7. 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。\n 8. 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。\n 9. 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n 10. 构造方法不能被重写。\n 11. 如果不能继承一个方法，则不能重写这个方法。\n\n**Super**：当需要在子类中调用父类的被重写方法时，要使用super关键字。\n\n**重载**：是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n\n**重载的重写规则**\n\n 1. 被重载的方法必须改变参数列表；\n 2. 被重载的方法可以改变返回类型；\n 3. 被重载的方法可以改变访问修饰符；\n 4. 被重载的方法可以声明新的或更广的检查异常；\n 5. 方法能够在同一个类中或者在一个子类中被重载。\n \n**重写与重载之间的区别**\n| 区别点        | 方法重载   |  方法重写  |\n| --------   | :-----:  | :----:  |\n| 参数列表     | \t必须修改 |   不能修改     |\n| 返回类型        |   可以修改   |   不能修改   |\n| 异常        |    可以修改    |  可减少或删除，不能抛出新的或者更广的异常  |\n| 访问 | 可以修改|可以降低访问限制|\n\n### 五、接口（interface）\n**接口：**是抽象方法的集合。它并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n**接口的特性：**\n 1. 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。\n 2. 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。\n 3. 接口中的方法都是公有的。\n\n一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键，与类不同的是他可以多重继承其他接口\n```\npublic  interface A  extends InterfaceB,InterfaceC{\n}\n```\n\n**标记接口**:没有任何方法和属性。起作用如下：\n \n- 建立一个公共的父接口；\n- 向一个类添加数据类型。\n","source":"_posts/java 三大特性：封装、继承和多态.md","raw":"\n---\ntitle: java 三大特性：封装、继承和多态\ndate: 2016-10-15 16:06:25\ncategories: [java,基础知识]\ntags: [java,继承,多态]\n---\n\n最近项目上线，暂时稍微闲一点，来回顾下java的一些基础。回想下，也是大二上学的java，已经过去两年了，老师教的基本都是那些最基础的，如数据类型、运算符之类的，加上自己又没有好好学，基本算没学，也就后来转向android 的时候，用啥学啥，如集合、多线程和网络通信等等。下面整理下java面向对象的三大特性。\n### 一、封装\n**封装**是把过程和数据包围起来，对数据的访问只能通过已定义的界面。<!--more-->\n一般是把属性私有，对其的访问只提供`getter` 和 `setter` 方法。\n### 二、继承\n**继承**可以理解为一个对象从另一个对象获取方法和属性的过程。常用的两个关键字为：`extends` 和 `implements`,他们决定了一个对象和另一个对象间是否是**IS-A**(是一个)的关系。\n在Java中，类的继承是**单一继承**，也就是说，一个子类只能拥有一个父类。\n注：java的类均是由 `java.lang.Object` 类继承而来的，上面说的一个父类并不包含Object,它并不需要显示的声明。\n**extends**关键字是用于 类直接的继承而** implements**是针对接口的。\n类只能是单继承的，但是接口可以同时实现多个，也可以同时使用。如：\n```\npublic class A extends B implements  C,D {\n}\n```\n注：在Java中，类的多重继承是不合法，但接口允许多重继承。\n\n### 三、多态\n**多态**：同一个行为具有多个不同表现形式或形态的能力。它的必要条件：继承、重写、父类引用指向子类对象。\n多态性具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。\n\n### 四、重写(Override)与重载(Overload)\n**重写** ：是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。他的好处在于子类可以根据需要，定义特定于自己的行为。\n\n**方法的重写规则**\n 1. 参数列表必须完全与被重写方法的相同；\n 2. 返回类型必须完全与被重写方法的返回类型相同；\n 3. 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。\n 4. 父类的成员方法只能被它的子类重写。\n 5. 声明为final的方法不能被重写。\n 6. 声明为static的方法不能被重写，但是能够被再次声明。\n 7. 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。\n 8. 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。\n 9. 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n 10. 构造方法不能被重写。\n 11. 如果不能继承一个方法，则不能重写这个方法。\n\n**Super**：当需要在子类中调用父类的被重写方法时，要使用super关键字。\n\n**重载**：是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n\n**重载的重写规则**\n\n 1. 被重载的方法必须改变参数列表；\n 2. 被重载的方法可以改变返回类型；\n 3. 被重载的方法可以改变访问修饰符；\n 4. 被重载的方法可以声明新的或更广的检查异常；\n 5. 方法能够在同一个类中或者在一个子类中被重载。\n \n**重写与重载之间的区别**\n| 区别点        | 方法重载   |  方法重写  |\n| --------   | :-----:  | :----:  |\n| 参数列表     | \t必须修改 |   不能修改     |\n| 返回类型        |   可以修改   |   不能修改   |\n| 异常        |    可以修改    |  可减少或删除，不能抛出新的或者更广的异常  |\n| 访问 | 可以修改|可以降低访问限制|\n\n### 五、接口（interface）\n**接口：**是抽象方法的集合。它并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n**接口的特性：**\n 1. 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。\n 2. 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。\n 3. 接口中的方法都是公有的。\n\n一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键，与类不同的是他可以多重继承其他接口\n```\npublic  interface A  extends InterfaceB,InterfaceC{\n}\n```\n\n**标记接口**:没有任何方法和属性。起作用如下：\n \n- 建立一个公共的父接口；\n- 向一个类添加数据类型。\n","slug":"java 三大特性：封装、继承和多态","published":1,"updated":"2016-11-19T04:50:38.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucib002cg0g5zg1oxwc0","content":"<p>最近项目上线，暂时稍微闲一点，来回顾下java的一些基础。回想下，也是大二上学的java，已经过去两年了，老师教的基本都是那些最基础的，如数据类型、运算符之类的，加上自己又没有好好学，基本算没学，也就后来转向android 的时候，用啥学啥，如集合、多线程和网络通信等等。下面整理下java面向对象的三大特性。</p>\n<h3 id=\"一、封装\"><a href=\"#一、封装\" class=\"headerlink\" title=\"一、封装\"></a>一、封装</h3><p><strong>封装</strong>是把过程和数据包围起来，对数据的访问只能通过已定义的界面。<a id=\"more\"></a><br>一般是把属性私有，对其的访问只提供<code>getter</code> 和 <code>setter</code> 方法。</p>\n<h3 id=\"二、继承\"><a href=\"#二、继承\" class=\"headerlink\" title=\"二、继承\"></a>二、继承</h3><p><strong>继承</strong>可以理解为一个对象从另一个对象获取方法和属性的过程。常用的两个关键字为：<code>extends</code> 和 <code>implements</code>,他们决定了一个对象和另一个对象间是否是<strong>IS-A</strong>(是一个)的关系。<br>在Java中，类的继承是<strong>单一继承</strong>，也就是说，一个子类只能拥有一个父类。<br>注：java的类均是由 <code>java.lang.Object</code> 类继承而来的，上面说的一个父类并不包含Object,它并不需要显示的声明。<br><strong>extends</strong>关键字是用于 类直接的继承而<strong> implements</strong>是针对接口的。<br>类只能是单继承的，但是接口可以同时实现多个，也可以同时使用。如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class A extends B implements  C,D &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注：在Java中，类的多重继承是不合法，但接口允许多重继承。</p>\n<h3 id=\"三、多态\"><a href=\"#三、多态\" class=\"headerlink\" title=\"三、多态\"></a>三、多态</h3><p><strong>多态</strong>：同一个行为具有多个不同表现形式或形态的能力。它的必要条件：继承、重写、父类引用指向子类对象。<br>多态性具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p>\n<h3 id=\"四、重写-Override-与重载-Overload\"><a href=\"#四、重写-Override-与重载-Overload\" class=\"headerlink\" title=\"四、重写(Override)与重载(Overload)\"></a>四、重写(Override)与重载(Overload)</h3><p><strong>重写</strong> ：是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。他的好处在于子类可以根据需要，定义特定于自己的行为。</p>\n<p><strong>方法的重写规则</strong></p>\n<ol>\n<li>参数列表必须完全与被重写方法的相同；</li>\n<li>返回类型必须完全与被重写方法的返回类型相同；</li>\n<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li>\n<li>父类的成员方法只能被它的子类重写。</li>\n<li>声明为final的方法不能被重写。</li>\n<li>声明为static的方法不能被重写，但是能够被再次声明。</li>\n<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li>\n<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li>\n<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>\n<li>构造方法不能被重写。</li>\n<li>如果不能继承一个方法，则不能重写这个方法。</li>\n</ol>\n<p><strong>Super</strong>：当需要在子类中调用父类的被重写方法时，要使用super关键字。</p>\n<p><strong>重载</strong>：是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<br>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>\n<p><strong>重载的重写规则</strong></p>\n<ol>\n<li>被重载的方法必须改变参数列表；</li>\n<li>被重载的方法可以改变返回类型；</li>\n<li>被重载的方法可以改变访问修饰符；</li>\n<li>被重载的方法可以声明新的或更广的检查异常；</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n</ol>\n<p><strong>重写与重载之间的区别</strong><br>| 区别点        | 方法重载   |  方法重写  |<br>| ——–   | :—–:  | :—-:  |<br>| 参数列表     |     必须修改 |   不能修改     |<br>| 返回类型        |   可以修改   |   不能修改   |<br>| 异常        |    可以修改    |  可减少或删除，不能抛出新的或者更广的异常  |<br>| 访问 | 可以修改|可以降低访问限制|</p>\n<h3 id=\"五、接口（interface）\"><a href=\"#五、接口（interface）\" class=\"headerlink\" title=\"五、接口（interface）\"></a>五、接口（interface）</h3><p><strong>接口：</strong>是抽象方法的集合。它并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。<br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>\n<p><strong>接口的特性：</strong></p>\n<ol>\n<li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li>\n<li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。</li>\n<li>接口中的方法都是公有的。</li>\n</ol>\n<p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键，与类不同的是他可以多重继承其他接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public  interface A  extends InterfaceB,InterfaceC&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>标记接口</strong>:没有任何方法和属性。起作用如下：</p>\n<ul>\n<li>建立一个公共的父接口；</li>\n<li>向一个类添加数据类型。</li>\n</ul>\n","excerpt":"<p>最近项目上线，暂时稍微闲一点，来回顾下java的一些基础。回想下，也是大二上学的java，已经过去两年了，老师教的基本都是那些最基础的，如数据类型、运算符之类的，加上自己又没有好好学，基本算没学，也就后来转向android 的时候，用啥学啥，如集合、多线程和网络通信等等。下面整理下java面向对象的三大特性。</p>\n<h3 id=\"一、封装\"><a href=\"#一、封装\" class=\"headerlink\" title=\"一、封装\"></a>一、封装</h3><p><strong>封装</strong>是把过程和数据包围起来，对数据的访问只能通过已定义的界面。","more":"<br>一般是把属性私有，对其的访问只提供<code>getter</code> 和 <code>setter</code> 方法。</p>\n<h3 id=\"二、继承\"><a href=\"#二、继承\" class=\"headerlink\" title=\"二、继承\"></a>二、继承</h3><p><strong>继承</strong>可以理解为一个对象从另一个对象获取方法和属性的过程。常用的两个关键字为：<code>extends</code> 和 <code>implements</code>,他们决定了一个对象和另一个对象间是否是<strong>IS-A</strong>(是一个)的关系。<br>在Java中，类的继承是<strong>单一继承</strong>，也就是说，一个子类只能拥有一个父类。<br>注：java的类均是由 <code>java.lang.Object</code> 类继承而来的，上面说的一个父类并不包含Object,它并不需要显示的声明。<br><strong>extends</strong>关键字是用于 类直接的继承而<strong> implements</strong>是针对接口的。<br>类只能是单继承的，但是接口可以同时实现多个，也可以同时使用。如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class A extends B implements  C,D &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注：在Java中，类的多重继承是不合法，但接口允许多重继承。</p>\n<h3 id=\"三、多态\"><a href=\"#三、多态\" class=\"headerlink\" title=\"三、多态\"></a>三、多态</h3><p><strong>多态</strong>：同一个行为具有多个不同表现形式或形态的能力。它的必要条件：继承、重写、父类引用指向子类对象。<br>多态性具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p>\n<h3 id=\"四、重写-Override-与重载-Overload\"><a href=\"#四、重写-Override-与重载-Overload\" class=\"headerlink\" title=\"四、重写(Override)与重载(Overload)\"></a>四、重写(Override)与重载(Overload)</h3><p><strong>重写</strong> ：是子类对父类的允许访问的方法的实现过程进行重新编写。返回值和形参都不能改变。他的好处在于子类可以根据需要，定义特定于自己的行为。</p>\n<p><strong>方法的重写规则</strong></p>\n<ol>\n<li>参数列表必须完全与被重写方法的相同；</li>\n<li>返回类型必须完全与被重写方法的返回类型相同；</li>\n<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li>\n<li>父类的成员方法只能被它的子类重写。</li>\n<li>声明为final的方法不能被重写。</li>\n<li>声明为static的方法不能被重写，但是能够被再次声明。</li>\n<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li>\n<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li>\n<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>\n<li>构造方法不能被重写。</li>\n<li>如果不能继承一个方法，则不能重写这个方法。</li>\n</ol>\n<p><strong>Super</strong>：当需要在子类中调用父类的被重写方法时，要使用super关键字。</p>\n<p><strong>重载</strong>：是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<br>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>\n<p><strong>重载的重写规则</strong></p>\n<ol>\n<li>被重载的方法必须改变参数列表；</li>\n<li>被重载的方法可以改变返回类型；</li>\n<li>被重载的方法可以改变访问修饰符；</li>\n<li>被重载的方法可以声明新的或更广的检查异常；</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n</ol>\n<p><strong>重写与重载之间的区别</strong><br>| 区别点        | 方法重载   |  方法重写  |<br>| ——–   | :—–:  | :—-:  |<br>| 参数列表     |     必须修改 |   不能修改     |<br>| 返回类型        |   可以修改   |   不能修改   |<br>| 异常        |    可以修改    |  可减少或删除，不能抛出新的或者更广的异常  |<br>| 访问 | 可以修改|可以降低访问限制|</p>\n<h3 id=\"五、接口（interface）\"><a href=\"#五、接口（interface）\" class=\"headerlink\" title=\"五、接口（interface）\"></a>五、接口（interface）</h3><p><strong>接口：</strong>是抽象方法的集合。它并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。<br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>\n<p><strong>接口的特性：</strong></p>\n<ol>\n<li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li>\n<li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。</li>\n<li>接口中的方法都是公有的。</li>\n</ol>\n<p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键，与类不同的是他可以多重继承其他接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public  interface A  extends InterfaceB,InterfaceC&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>标记接口</strong>:没有任何方法和属性。起作用如下：</p>\n<ul>\n<li>建立一个公共的父接口；</li>\n<li>向一个类添加数据类型。</li>\n</ul>"},{"title":"java 知识 之 内存管理","date":"2016-11-24T08:06:25.000Z","_content":"> 读书笔记：《疯狂java 程序员的基本修养》第四章——java内存管理\n\n\n\njava 中的内存管理包括内存分配和内存回收，这些都是由 JVM 帮我们完成的。当创建对象时为其分配内存空间；当失去引用时，GC会自动清除并回收他们所占用的空间。\n<!--more-->\n\n## 一、java 引用的种类\n\n当java对象创建完后，垃圾回收机制会实时的监测每个对象的状态，包括对象的申请、引用、被引用。赋值等。当它不存在引用时，对其进行回收。\n\n当一个对象在堆内存中运行时，根据它对应的有向图的状态，有如下三种状态：\n\n- 可达状态\n 当一个对象被创建后，有一个以上的引用变量引用他，在有向图中可以从起点导航到该点，此时可以通过引用变量调用它的属性和方法。\n- 可恢复状态\n  程序中不再有任何对象引用变量引用它，此时不能从有向图的起点到达它。系统准备回收，再回收之前系统会调用该对象的`finalize()`方法进行资源清理，如果在finalize 中重新让一个及以上的引用变量引用该对象，则它会再次变为可达状态，否则，进入不可达状态。\n- 不可达状态\n  所有的关联都被切断，永久性的失去引用，只有在该状态下系统才会真正的回收对象所占用的资源。\n\n三张状态转换图如下：\n\n![](/img/article_img/2016/object_state.png)\n\n\n\n### **a. 强引用**\n\n在java  中，创建一个对象，并把它赋值给一个引用变量，就是强引用。**被强引用所引用的对象时绝对不会被垃圾回收机制回收的，即使系统非常紧张**，因此它是造成内存泄露的主要原因之一。\n\n### **b. 软引用**\n软引用需要用`SoftReference`类来实现，当一个对象只有软引用时，它有可能被回收。对于软引用，**当系统内存空间足够时，不会被回收，否则会被系统回收，该对象不可再被使用**。\n软引用是强引用很好的替代，他能避免系统内存不足的异常。具体的使用如下（其中Person类有两个属性和一个tostring方法）：\n```\npublic class SoftReferenceTest {\n    public static void main(String[] args)\n            throws Exception {\n        SoftReference<Person>[] people =\n                new SoftReference[100000];\n        for (int i = 0; i < people.length; i++) {\n            people[i] = new SoftReference<Person>(new Person(\n                    \"名字\" + i, (i + 1) * 4 % 100));\n        }\n        System.out.println(people[2].get());\n        System.out.println(people[4].get());\n        // 通知系统进行垃圾回收\n        System.gc();\n        System.runFinalization();\n        // 垃圾回收机制运行之后，SoftReference数组里的元素保持不变\n        System.out.println(people[2].get());\n        System.out.println(people[4].get());\n    }\n}\n```\n运行结果：\n```\nPerson[name=名字2, age=12]\nPerson[name=名字4, age=20]\nPerson[name=名字2, age=12]\nPerson[name=名字4, age=20]\n```\n系统内存足够，在垃圾回收前后结果一样，和强引用并无区别。若指定jvm的内存大小，则软引用所引用的对象会被系统回收，可使用如下命令指定堆内存只有2M，则创建长度为100000的数组可使内存紧张，则会被回收，最终输出均为\nnull：\n```\njava -Xmx2m -Xms2m SoftReferenceTest\n```\n> Xmx：设置java虚拟机堆内存最大容量；\nXms：设置java虚拟机初始容量。 \n\n如果将前面初始化people的方式改为下面的强引用方式，依然指定2M内存，则会抛出`java.lang.OutOfMemoryError`的内存溢出异常,因而终止程序,此处也体现了前面所说的强引用对象不会回收其所占用的内存，尽管内存不足。\n```\nPerson[] people = new Person[100000];\n```\n### **c. 弱引用**\n弱引用于软引用类似，但他的生存期更短，通过`WeakReference`类实现。对于只有弱引用的对象，当垃圾机制运行时，**不管内存是否足够，总会回收该对象占用的内存**。\n如下示例代码：\n```\npublic class WeakReferenceTest {\n    public static void main(String[] args) throws Exception {\n        // 创建一个字符串对象\n        String str = new String(\"疯狂Java讲义\");\n        // 创建一个弱引用，让此弱引用引用到\"疯狂Java讲义\"字符串\n        WeakReference<String> wr = new WeakReference<String>(str);\n        // 切断str引用和\"疯狂Java讲义\"字符串之间的引用\n        str = null;      //②\n        // 取出弱引用所引用的对象\n        System.out.println(wr.get()); //输出：疯狂Java讲义\n        // 强制垃圾回收\n        System.gc();\n        System.runFinalization();\n        // 再次取出弱引用所引用的对象\n        System.out.println(wr.get());  //输出：null\n    }\n}\n\n```\n\n> 注：上面代码中创建字符串对象不可采用 “String str = \"疯狂Java讲义\";” 这种方式,因为这样的定义系统会把它缓存为常量，使用强引用来引用它，则不会被回收。\n\n上述代码中的内存分配示意图：\n\n![](/img/article_img/2016/weakreference.png)\n\n在实际使用时，可以使用`WeakHashMap`来保存弱引用对象。\n\n### **d. 虚引用**\n\n虚引用主要是跟踪对象被垃圾回收的状态，可以通过检查与虚引用关联的队列中是否包含指定的引用，了解对象是否被回收。\n与软引用和弱引用不同，虚引用不能单独使用。\n虚引用对象在被释放前会将它添加到他关联的引用队列中。通过`PhantomReference`类实现，结合引用队列`ReferenceQuence`使用。如下使用示例：\n```\npublic class PhantomReferenceTest {\n    public static void main(String[] args)\n            throws Exception {\n        // 创建一个字符串对象\n        String str = new String(\"疯狂Java讲义\");\n        // 创建一个引用队列\n        ReferenceQueue<String> rq = new ReferenceQueue<String>();\n        // 创建一个虚引用，让此虚引用引用到\"疯狂Java讲义\"字符串\n        PhantomReference<String> pr =\n                new PhantomReference<String>(str, rq);\n        // 切断str引用和\"Struts2权威指南\"字符串之间的引用\n        str = null;\n        // 试图取出虚引用所引用的对象，\n        // 程序并不能通过虚引用访问被引用的对象\n        System.out.println(pr.get());  //输出null\n        // 强制垃圾回收\n        System.gc();\n        System.runFinalization();\n        // 取出引用队列中最先进入队列中引用与pr进行比较\n        System.out.println(rq.poll() == pr);  //输出：true\n    }\n}\n```\n\n## 二、java 的内存泄露\n\n与C++程序员不同，java 程序员无需关注内存释放的问题，这些由JVM帮我们完成。然而如果使用不当，一样会出现内存泄露。如果是可达状态的对象，但程序不访问，他们做占用的空间不会被回收，就会产生内存泄露。\nyi ArrayList中的remove方法为例，每当删除一个元素时，就会让最后一个元素的引用置为null:\n\n```\nelementData[--size] = null;\n```\n在ArrayList中采用数组来保存每个元素的。由于集合中每个元素实际上存的是引用，如果不使用上述的代码，则ArrayList中被删除的元素一直被引用着，处于可达状态，导致无法被回收，因而会产生内存泄露。\n\n\n\n## 三、垃圾回收机制\n\n垃圾回收主要完成两件事：\n\n- 跟踪监控java对象，当它处于不可达时，回收他所占用的内存；\n- 清理内存分配和回收过程中产生的内存是碎片。\n\n垃圾回收的基本算法有：\n\n- 串行回收和并行回收\n- 并发执行和应用程序停止\n- 压缩/不压缩和复制\n\n现在的垃圾回收机制用分代的方式采用不同的回收机制，根据**对象生存时间的长短**，把堆内存分为三代：**Yong(新生代)、Old(老年代)、Permanent(永生代)**。\n\n在java中，绝大多数对象不会被长时间引用，他们在Yong期间被回收，很老的对象和很新的对象之间很少存在相互引用的情况。\n\n当Yong代的内存快要用完时，垃圾回收机制会对其进行回收，此时回收的系统性能开销小。为次要回收；当Old代快要用完时，垃圾回收机制会进行全面的回收，包括Yong和Old，此时回收成本大，为主要回收。\n\nPermanent时代主要用于装在Class、方法等信息，默认是64MB，通常不会被回收。\n\n\n## 四、内存管理技巧\n\n只有很好的掌握了垃圾回收及其机制，才能更好的管理java虚拟机，使我们写出更高性能的java代码。避免内存泄露的主要技巧如下：\n\n- 使用直接量\n  如使用 `String str = \"hello;\"` 代替 `String str = new String(\"hello\");`，前者会在缓存池缓存这个常量\n- 使用StringBuilder和StringBuffer进行字符串的连接\n 使用String时会生成大量的临时字符串存在内存中。\n- 及时释放无用对象的引用\n- 减少静态变量\n- 避免在经常调用的方法、循环中创建java对象\n- 缓存经常使用的对象\n  缓存技术是牺牲空间换时间的，主要使用容器保存已使用的对象，其关键在于如何控制缓存容器的空间使其不至于过大并且能够保留大部分已用过的对象。\n- 尽量不要使用finalize方法\n- 考虑使用SoftReference\n 当创建长度很大的对象时，可以使用软引用包装数组，便于在内存不足的情况下被回收释放。\n \n \n \n \n \n \n\n\n\n\n\n","source":"_posts/java 知识 之 内存管理.md","raw":"---\ntitle: java 知识 之 内存管理\ndate: 2016-11-24 16:06:25\ncategories: [java,高级知识]\ntags: [java,内存回收]\n---\n> 读书笔记：《疯狂java 程序员的基本修养》第四章——java内存管理\n\n\n\njava 中的内存管理包括内存分配和内存回收，这些都是由 JVM 帮我们完成的。当创建对象时为其分配内存空间；当失去引用时，GC会自动清除并回收他们所占用的空间。\n<!--more-->\n\n## 一、java 引用的种类\n\n当java对象创建完后，垃圾回收机制会实时的监测每个对象的状态，包括对象的申请、引用、被引用。赋值等。当它不存在引用时，对其进行回收。\n\n当一个对象在堆内存中运行时，根据它对应的有向图的状态，有如下三种状态：\n\n- 可达状态\n 当一个对象被创建后，有一个以上的引用变量引用他，在有向图中可以从起点导航到该点，此时可以通过引用变量调用它的属性和方法。\n- 可恢复状态\n  程序中不再有任何对象引用变量引用它，此时不能从有向图的起点到达它。系统准备回收，再回收之前系统会调用该对象的`finalize()`方法进行资源清理，如果在finalize 中重新让一个及以上的引用变量引用该对象，则它会再次变为可达状态，否则，进入不可达状态。\n- 不可达状态\n  所有的关联都被切断，永久性的失去引用，只有在该状态下系统才会真正的回收对象所占用的资源。\n\n三张状态转换图如下：\n\n![](/img/article_img/2016/object_state.png)\n\n\n\n### **a. 强引用**\n\n在java  中，创建一个对象，并把它赋值给一个引用变量，就是强引用。**被强引用所引用的对象时绝对不会被垃圾回收机制回收的，即使系统非常紧张**，因此它是造成内存泄露的主要原因之一。\n\n### **b. 软引用**\n软引用需要用`SoftReference`类来实现，当一个对象只有软引用时，它有可能被回收。对于软引用，**当系统内存空间足够时，不会被回收，否则会被系统回收，该对象不可再被使用**。\n软引用是强引用很好的替代，他能避免系统内存不足的异常。具体的使用如下（其中Person类有两个属性和一个tostring方法）：\n```\npublic class SoftReferenceTest {\n    public static void main(String[] args)\n            throws Exception {\n        SoftReference<Person>[] people =\n                new SoftReference[100000];\n        for (int i = 0; i < people.length; i++) {\n            people[i] = new SoftReference<Person>(new Person(\n                    \"名字\" + i, (i + 1) * 4 % 100));\n        }\n        System.out.println(people[2].get());\n        System.out.println(people[4].get());\n        // 通知系统进行垃圾回收\n        System.gc();\n        System.runFinalization();\n        // 垃圾回收机制运行之后，SoftReference数组里的元素保持不变\n        System.out.println(people[2].get());\n        System.out.println(people[4].get());\n    }\n}\n```\n运行结果：\n```\nPerson[name=名字2, age=12]\nPerson[name=名字4, age=20]\nPerson[name=名字2, age=12]\nPerson[name=名字4, age=20]\n```\n系统内存足够，在垃圾回收前后结果一样，和强引用并无区别。若指定jvm的内存大小，则软引用所引用的对象会被系统回收，可使用如下命令指定堆内存只有2M，则创建长度为100000的数组可使内存紧张，则会被回收，最终输出均为\nnull：\n```\njava -Xmx2m -Xms2m SoftReferenceTest\n```\n> Xmx：设置java虚拟机堆内存最大容量；\nXms：设置java虚拟机初始容量。 \n\n如果将前面初始化people的方式改为下面的强引用方式，依然指定2M内存，则会抛出`java.lang.OutOfMemoryError`的内存溢出异常,因而终止程序,此处也体现了前面所说的强引用对象不会回收其所占用的内存，尽管内存不足。\n```\nPerson[] people = new Person[100000];\n```\n### **c. 弱引用**\n弱引用于软引用类似，但他的生存期更短，通过`WeakReference`类实现。对于只有弱引用的对象，当垃圾机制运行时，**不管内存是否足够，总会回收该对象占用的内存**。\n如下示例代码：\n```\npublic class WeakReferenceTest {\n    public static void main(String[] args) throws Exception {\n        // 创建一个字符串对象\n        String str = new String(\"疯狂Java讲义\");\n        // 创建一个弱引用，让此弱引用引用到\"疯狂Java讲义\"字符串\n        WeakReference<String> wr = new WeakReference<String>(str);\n        // 切断str引用和\"疯狂Java讲义\"字符串之间的引用\n        str = null;      //②\n        // 取出弱引用所引用的对象\n        System.out.println(wr.get()); //输出：疯狂Java讲义\n        // 强制垃圾回收\n        System.gc();\n        System.runFinalization();\n        // 再次取出弱引用所引用的对象\n        System.out.println(wr.get());  //输出：null\n    }\n}\n\n```\n\n> 注：上面代码中创建字符串对象不可采用 “String str = \"疯狂Java讲义\";” 这种方式,因为这样的定义系统会把它缓存为常量，使用强引用来引用它，则不会被回收。\n\n上述代码中的内存分配示意图：\n\n![](/img/article_img/2016/weakreference.png)\n\n在实际使用时，可以使用`WeakHashMap`来保存弱引用对象。\n\n### **d. 虚引用**\n\n虚引用主要是跟踪对象被垃圾回收的状态，可以通过检查与虚引用关联的队列中是否包含指定的引用，了解对象是否被回收。\n与软引用和弱引用不同，虚引用不能单独使用。\n虚引用对象在被释放前会将它添加到他关联的引用队列中。通过`PhantomReference`类实现，结合引用队列`ReferenceQuence`使用。如下使用示例：\n```\npublic class PhantomReferenceTest {\n    public static void main(String[] args)\n            throws Exception {\n        // 创建一个字符串对象\n        String str = new String(\"疯狂Java讲义\");\n        // 创建一个引用队列\n        ReferenceQueue<String> rq = new ReferenceQueue<String>();\n        // 创建一个虚引用，让此虚引用引用到\"疯狂Java讲义\"字符串\n        PhantomReference<String> pr =\n                new PhantomReference<String>(str, rq);\n        // 切断str引用和\"Struts2权威指南\"字符串之间的引用\n        str = null;\n        // 试图取出虚引用所引用的对象，\n        // 程序并不能通过虚引用访问被引用的对象\n        System.out.println(pr.get());  //输出null\n        // 强制垃圾回收\n        System.gc();\n        System.runFinalization();\n        // 取出引用队列中最先进入队列中引用与pr进行比较\n        System.out.println(rq.poll() == pr);  //输出：true\n    }\n}\n```\n\n## 二、java 的内存泄露\n\n与C++程序员不同，java 程序员无需关注内存释放的问题，这些由JVM帮我们完成。然而如果使用不当，一样会出现内存泄露。如果是可达状态的对象，但程序不访问，他们做占用的空间不会被回收，就会产生内存泄露。\nyi ArrayList中的remove方法为例，每当删除一个元素时，就会让最后一个元素的引用置为null:\n\n```\nelementData[--size] = null;\n```\n在ArrayList中采用数组来保存每个元素的。由于集合中每个元素实际上存的是引用，如果不使用上述的代码，则ArrayList中被删除的元素一直被引用着，处于可达状态，导致无法被回收，因而会产生内存泄露。\n\n\n\n## 三、垃圾回收机制\n\n垃圾回收主要完成两件事：\n\n- 跟踪监控java对象，当它处于不可达时，回收他所占用的内存；\n- 清理内存分配和回收过程中产生的内存是碎片。\n\n垃圾回收的基本算法有：\n\n- 串行回收和并行回收\n- 并发执行和应用程序停止\n- 压缩/不压缩和复制\n\n现在的垃圾回收机制用分代的方式采用不同的回收机制，根据**对象生存时间的长短**，把堆内存分为三代：**Yong(新生代)、Old(老年代)、Permanent(永生代)**。\n\n在java中，绝大多数对象不会被长时间引用，他们在Yong期间被回收，很老的对象和很新的对象之间很少存在相互引用的情况。\n\n当Yong代的内存快要用完时，垃圾回收机制会对其进行回收，此时回收的系统性能开销小。为次要回收；当Old代快要用完时，垃圾回收机制会进行全面的回收，包括Yong和Old，此时回收成本大，为主要回收。\n\nPermanent时代主要用于装在Class、方法等信息，默认是64MB，通常不会被回收。\n\n\n## 四、内存管理技巧\n\n只有很好的掌握了垃圾回收及其机制，才能更好的管理java虚拟机，使我们写出更高性能的java代码。避免内存泄露的主要技巧如下：\n\n- 使用直接量\n  如使用 `String str = \"hello;\"` 代替 `String str = new String(\"hello\");`，前者会在缓存池缓存这个常量\n- 使用StringBuilder和StringBuffer进行字符串的连接\n 使用String时会生成大量的临时字符串存在内存中。\n- 及时释放无用对象的引用\n- 减少静态变量\n- 避免在经常调用的方法、循环中创建java对象\n- 缓存经常使用的对象\n  缓存技术是牺牲空间换时间的，主要使用容器保存已使用的对象，其关键在于如何控制缓存容器的空间使其不至于过大并且能够保留大部分已用过的对象。\n- 尽量不要使用finalize方法\n- 考虑使用SoftReference\n 当创建长度很大的对象时，可以使用软引用包装数组，便于在内存不足的情况下被回收释放。\n \n \n \n \n \n \n\n\n\n\n\n","slug":"java 知识 之 内存管理","published":1,"updated":"2016-11-24T06:31:09.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucib002gg0g5fg5cph94","content":"<blockquote>\n<p>读书笔记：《疯狂java 程序员的基本修养》第四章——java内存管理</p>\n</blockquote>\n<p>java 中的内存管理包括内存分配和内存回收，这些都是由 JVM 帮我们完成的。当创建对象时为其分配内存空间；当失去引用时，GC会自动清除并回收他们所占用的空间。<br><a id=\"more\"></a></p>\n<h2 id=\"一、java-引用的种类\"><a href=\"#一、java-引用的种类\" class=\"headerlink\" title=\"一、java 引用的种类\"></a>一、java 引用的种类</h2><p>当java对象创建完后，垃圾回收机制会实时的监测每个对象的状态，包括对象的申请、引用、被引用。赋值等。当它不存在引用时，对其进行回收。</p>\n<p>当一个对象在堆内存中运行时，根据它对应的有向图的状态，有如下三种状态：</p>\n<ul>\n<li>可达状态<br>当一个对象被创建后，有一个以上的引用变量引用他，在有向图中可以从起点导航到该点，此时可以通过引用变量调用它的属性和方法。</li>\n<li>可恢复状态<br>程序中不再有任何对象引用变量引用它，此时不能从有向图的起点到达它。系统准备回收，再回收之前系统会调用该对象的<code>finalize()</code>方法进行资源清理，如果在finalize 中重新让一个及以上的引用变量引用该对象，则它会再次变为可达状态，否则，进入不可达状态。</li>\n<li>不可达状态<br>所有的关联都被切断，永久性的失去引用，只有在该状态下系统才会真正的回收对象所占用的资源。</li>\n</ul>\n<p>三张状态转换图如下：</p>\n<p><img src=\"/img/article_img/2016/object_state.png\" alt=\"\"></p>\n<h3 id=\"a-强引用\"><a href=\"#a-强引用\" class=\"headerlink\" title=\"a. 强引用\"></a><strong>a. 强引用</strong></h3><p>在java  中，创建一个对象，并把它赋值给一个引用变量，就是强引用。<strong>被强引用所引用的对象时绝对不会被垃圾回收机制回收的，即使系统非常紧张</strong>，因此它是造成内存泄露的主要原因之一。</p>\n<h3 id=\"b-软引用\"><a href=\"#b-软引用\" class=\"headerlink\" title=\"b. 软引用\"></a><strong>b. 软引用</strong></h3><p>软引用需要用<code>SoftReference</code>类来实现，当一个对象只有软引用时，它有可能被回收。对于软引用，<strong>当系统内存空间足够时，不会被回收，否则会被系统回收，该对象不可再被使用</strong>。<br>软引用是强引用很好的替代，他能避免系统内存不足的异常。具体的使用如下（其中Person类有两个属性和一个tostring方法）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SoftReferenceTest &#123;</span><br><span class=\"line\">    public static void main(String[] args)</span><br><span class=\"line\">            throws Exception &#123;</span><br><span class=\"line\">        SoftReference&lt;Person&gt;[] people =</span><br><span class=\"line\">                new SoftReference[100000];</span><br><span class=\"line\">        for (int i = 0; i &lt; people.length; i++) &#123;</span><br><span class=\"line\">            people[i] = new SoftReference&lt;Person&gt;(new Person(</span><br><span class=\"line\">                    &quot;名字&quot; + i, (i + 1) * 4 % 100));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(people[2].get());</span><br><span class=\"line\">        System.out.println(people[4].get());</span><br><span class=\"line\">        // 通知系统进行垃圾回收</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        System.runFinalization();</span><br><span class=\"line\">        // 垃圾回收机制运行之后，SoftReference数组里的元素保持不变</span><br><span class=\"line\">        System.out.println(people[2].get());</span><br><span class=\"line\">        System.out.println(people[4].get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person[name=名字2, age=12]</span><br><span class=\"line\">Person[name=名字4, age=20]</span><br><span class=\"line\">Person[name=名字2, age=12]</span><br><span class=\"line\">Person[name=名字4, age=20]</span><br></pre></td></tr></table></figure></p>\n<p>系统内存足够，在垃圾回收前后结果一样，和强引用并无区别。若指定jvm的内存大小，则软引用所引用的对象会被系统回收，可使用如下命令指定堆内存只有2M，则创建长度为100000的数组可使内存紧张，则会被回收，最终输出均为<br>null：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xmx2m -Xms2m SoftReferenceTest</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Xmx：设置java虚拟机堆内存最大容量；<br>Xms：设置java虚拟机初始容量。 </p>\n</blockquote>\n<p>如果将前面初始化people的方式改为下面的强引用方式，依然指定2M内存，则会抛出<code>java.lang.OutOfMemoryError</code>的内存溢出异常,因而终止程序,此处也体现了前面所说的强引用对象不会回收其所占用的内存，尽管内存不足。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person[] people = new Person[100000];</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"c-弱引用\"><a href=\"#c-弱引用\" class=\"headerlink\" title=\"c. 弱引用\"></a><strong>c. 弱引用</strong></h3><p>弱引用于软引用类似，但他的生存期更短，通过<code>WeakReference</code>类实现。对于只有弱引用的对象，当垃圾机制运行时，<strong>不管内存是否足够，总会回收该对象占用的内存</strong>。<br>如下示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WeakReferenceTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        // 创建一个字符串对象</span><br><span class=\"line\">        String str = new String(&quot;疯狂Java讲义&quot;);</span><br><span class=\"line\">        // 创建一个弱引用，让此弱引用引用到&quot;疯狂Java讲义&quot;字符串</span><br><span class=\"line\">        WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(str);</span><br><span class=\"line\">        // 切断str引用和&quot;疯狂Java讲义&quot;字符串之间的引用</span><br><span class=\"line\">        str = null;      //②</span><br><span class=\"line\">        // 取出弱引用所引用的对象</span><br><span class=\"line\">        System.out.println(wr.get()); //输出：疯狂Java讲义</span><br><span class=\"line\">        // 强制垃圾回收</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        System.runFinalization();</span><br><span class=\"line\">        // 再次取出弱引用所引用的对象</span><br><span class=\"line\">        System.out.println(wr.get());  //输出：null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注：上面代码中创建字符串对象不可采用 “String str = “疯狂Java讲义”;” 这种方式,因为这样的定义系统会把它缓存为常量，使用强引用来引用它，则不会被回收。</p>\n</blockquote>\n<p>上述代码中的内存分配示意图：</p>\n<p><img src=\"/img/article_img/2016/weakreference.png\" alt=\"\"></p>\n<p>在实际使用时，可以使用<code>WeakHashMap</code>来保存弱引用对象。</p>\n<h3 id=\"d-虚引用\"><a href=\"#d-虚引用\" class=\"headerlink\" title=\"d. 虚引用\"></a><strong>d. 虚引用</strong></h3><p>虚引用主要是跟踪对象被垃圾回收的状态，可以通过检查与虚引用关联的队列中是否包含指定的引用，了解对象是否被回收。<br>与软引用和弱引用不同，虚引用不能单独使用。<br>虚引用对象在被释放前会将它添加到他关联的引用队列中。通过<code>PhantomReference</code>类实现，结合引用队列<code>ReferenceQuence</code>使用。如下使用示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PhantomReferenceTest &#123;</span><br><span class=\"line\">    public static void main(String[] args)</span><br><span class=\"line\">            throws Exception &#123;</span><br><span class=\"line\">        // 创建一个字符串对象</span><br><span class=\"line\">        String str = new String(&quot;疯狂Java讲义&quot;);</span><br><span class=\"line\">        // 创建一个引用队列</span><br><span class=\"line\">        ReferenceQueue&lt;String&gt; rq = new ReferenceQueue&lt;String&gt;();</span><br><span class=\"line\">        // 创建一个虚引用，让此虚引用引用到&quot;疯狂Java讲义&quot;字符串</span><br><span class=\"line\">        PhantomReference&lt;String&gt; pr =</span><br><span class=\"line\">                new PhantomReference&lt;String&gt;(str, rq);</span><br><span class=\"line\">        // 切断str引用和&quot;Struts2权威指南&quot;字符串之间的引用</span><br><span class=\"line\">        str = null;</span><br><span class=\"line\">        // 试图取出虚引用所引用的对象，</span><br><span class=\"line\">        // 程序并不能通过虚引用访问被引用的对象</span><br><span class=\"line\">        System.out.println(pr.get());  //输出null</span><br><span class=\"line\">        // 强制垃圾回收</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        System.runFinalization();</span><br><span class=\"line\">        // 取出引用队列中最先进入队列中引用与pr进行比较</span><br><span class=\"line\">        System.out.println(rq.poll() == pr);  //输出：true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、java-的内存泄露\"><a href=\"#二、java-的内存泄露\" class=\"headerlink\" title=\"二、java 的内存泄露\"></a>二、java 的内存泄露</h2><p>与C++程序员不同，java 程序员无需关注内存释放的问题，这些由JVM帮我们完成。然而如果使用不当，一样会出现内存泄露。如果是可达状态的对象，但程序不访问，他们做占用的空间不会被回收，就会产生内存泄露。<br>yi ArrayList中的remove方法为例，每当删除一个元素时，就会让最后一个元素的引用置为null:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elementData[--size] = null;</span><br></pre></td></tr></table></figure>\n<p>在ArrayList中采用数组来保存每个元素的。由于集合中每个元素实际上存的是引用，如果不使用上述的代码，则ArrayList中被删除的元素一直被引用着，处于可达状态，导致无法被回收，因而会产生内存泄露。</p>\n<h2 id=\"三、垃圾回收机制\"><a href=\"#三、垃圾回收机制\" class=\"headerlink\" title=\"三、垃圾回收机制\"></a>三、垃圾回收机制</h2><p>垃圾回收主要完成两件事：</p>\n<ul>\n<li>跟踪监控java对象，当它处于不可达时，回收他所占用的内存；</li>\n<li>清理内存分配和回收过程中产生的内存是碎片。</li>\n</ul>\n<p>垃圾回收的基本算法有：</p>\n<ul>\n<li>串行回收和并行回收</li>\n<li>并发执行和应用程序停止</li>\n<li>压缩/不压缩和复制</li>\n</ul>\n<p>现在的垃圾回收机制用分代的方式采用不同的回收机制，根据<strong>对象生存时间的长短</strong>，把堆内存分为三代：<strong>Yong(新生代)、Old(老年代)、Permanent(永生代)</strong>。</p>\n<p>在java中，绝大多数对象不会被长时间引用，他们在Yong期间被回收，很老的对象和很新的对象之间很少存在相互引用的情况。</p>\n<p>当Yong代的内存快要用完时，垃圾回收机制会对其进行回收，此时回收的系统性能开销小。为次要回收；当Old代快要用完时，垃圾回收机制会进行全面的回收，包括Yong和Old，此时回收成本大，为主要回收。</p>\n<p>Permanent时代主要用于装在Class、方法等信息，默认是64MB，通常不会被回收。</p>\n<h2 id=\"四、内存管理技巧\"><a href=\"#四、内存管理技巧\" class=\"headerlink\" title=\"四、内存管理技巧\"></a>四、内存管理技巧</h2><p>只有很好的掌握了垃圾回收及其机制，才能更好的管理java虚拟机，使我们写出更高性能的java代码。避免内存泄露的主要技巧如下：</p>\n<ul>\n<li>使用直接量<br>如使用 <code>String str = &quot;hello;&quot;</code> 代替 <code>String str = new String(&quot;hello&quot;);</code>，前者会在缓存池缓存这个常量</li>\n<li>使用StringBuilder和StringBuffer进行字符串的连接<br>使用String时会生成大量的临时字符串存在内存中。</li>\n<li>及时释放无用对象的引用</li>\n<li>减少静态变量</li>\n<li>避免在经常调用的方法、循环中创建java对象</li>\n<li>缓存经常使用的对象<br>缓存技术是牺牲空间换时间的，主要使用容器保存已使用的对象，其关键在于如何控制缓存容器的空间使其不至于过大并且能够保留大部分已用过的对象。</li>\n<li>尽量不要使用finalize方法</li>\n<li>考虑使用SoftReference<br>当创建长度很大的对象时，可以使用软引用包装数组，便于在内存不足的情况下被回收释放。</li>\n</ul>\n","excerpt":"<blockquote>\n<p>读书笔记：《疯狂java 程序员的基本修养》第四章——java内存管理</p>\n</blockquote>\n<p>java 中的内存管理包括内存分配和内存回收，这些都是由 JVM 帮我们完成的。当创建对象时为其分配内存空间；当失去引用时，GC会自动清除并回收他们所占用的空间。<br>","more":"</p>\n<h2 id=\"一、java-引用的种类\"><a href=\"#一、java-引用的种类\" class=\"headerlink\" title=\"一、java 引用的种类\"></a>一、java 引用的种类</h2><p>当java对象创建完后，垃圾回收机制会实时的监测每个对象的状态，包括对象的申请、引用、被引用。赋值等。当它不存在引用时，对其进行回收。</p>\n<p>当一个对象在堆内存中运行时，根据它对应的有向图的状态，有如下三种状态：</p>\n<ul>\n<li>可达状态<br>当一个对象被创建后，有一个以上的引用变量引用他，在有向图中可以从起点导航到该点，此时可以通过引用变量调用它的属性和方法。</li>\n<li>可恢复状态<br>程序中不再有任何对象引用变量引用它，此时不能从有向图的起点到达它。系统准备回收，再回收之前系统会调用该对象的<code>finalize()</code>方法进行资源清理，如果在finalize 中重新让一个及以上的引用变量引用该对象，则它会再次变为可达状态，否则，进入不可达状态。</li>\n<li>不可达状态<br>所有的关联都被切断，永久性的失去引用，只有在该状态下系统才会真正的回收对象所占用的资源。</li>\n</ul>\n<p>三张状态转换图如下：</p>\n<p><img src=\"/img/article_img/2016/object_state.png\" alt=\"\"></p>\n<h3 id=\"a-强引用\"><a href=\"#a-强引用\" class=\"headerlink\" title=\"a. 强引用\"></a><strong>a. 强引用</strong></h3><p>在java  中，创建一个对象，并把它赋值给一个引用变量，就是强引用。<strong>被强引用所引用的对象时绝对不会被垃圾回收机制回收的，即使系统非常紧张</strong>，因此它是造成内存泄露的主要原因之一。</p>\n<h3 id=\"b-软引用\"><a href=\"#b-软引用\" class=\"headerlink\" title=\"b. 软引用\"></a><strong>b. 软引用</strong></h3><p>软引用需要用<code>SoftReference</code>类来实现，当一个对象只有软引用时，它有可能被回收。对于软引用，<strong>当系统内存空间足够时，不会被回收，否则会被系统回收，该对象不可再被使用</strong>。<br>软引用是强引用很好的替代，他能避免系统内存不足的异常。具体的使用如下（其中Person类有两个属性和一个tostring方法）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SoftReferenceTest &#123;</span><br><span class=\"line\">    public static void main(String[] args)</span><br><span class=\"line\">            throws Exception &#123;</span><br><span class=\"line\">        SoftReference&lt;Person&gt;[] people =</span><br><span class=\"line\">                new SoftReference[100000];</span><br><span class=\"line\">        for (int i = 0; i &lt; people.length; i++) &#123;</span><br><span class=\"line\">            people[i] = new SoftReference&lt;Person&gt;(new Person(</span><br><span class=\"line\">                    &quot;名字&quot; + i, (i + 1) * 4 % 100));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(people[2].get());</span><br><span class=\"line\">        System.out.println(people[4].get());</span><br><span class=\"line\">        // 通知系统进行垃圾回收</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        System.runFinalization();</span><br><span class=\"line\">        // 垃圾回收机制运行之后，SoftReference数组里的元素保持不变</span><br><span class=\"line\">        System.out.println(people[2].get());</span><br><span class=\"line\">        System.out.println(people[4].get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person[name=名字2, age=12]</span><br><span class=\"line\">Person[name=名字4, age=20]</span><br><span class=\"line\">Person[name=名字2, age=12]</span><br><span class=\"line\">Person[name=名字4, age=20]</span><br></pre></td></tr></table></figure></p>\n<p>系统内存足够，在垃圾回收前后结果一样，和强引用并无区别。若指定jvm的内存大小，则软引用所引用的对象会被系统回收，可使用如下命令指定堆内存只有2M，则创建长度为100000的数组可使内存紧张，则会被回收，最终输出均为<br>null：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xmx2m -Xms2m SoftReferenceTest</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Xmx：设置java虚拟机堆内存最大容量；<br>Xms：设置java虚拟机初始容量。 </p>\n</blockquote>\n<p>如果将前面初始化people的方式改为下面的强引用方式，依然指定2M内存，则会抛出<code>java.lang.OutOfMemoryError</code>的内存溢出异常,因而终止程序,此处也体现了前面所说的强引用对象不会回收其所占用的内存，尽管内存不足。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person[] people = new Person[100000];</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"c-弱引用\"><a href=\"#c-弱引用\" class=\"headerlink\" title=\"c. 弱引用\"></a><strong>c. 弱引用</strong></h3><p>弱引用于软引用类似，但他的生存期更短，通过<code>WeakReference</code>类实现。对于只有弱引用的对象，当垃圾机制运行时，<strong>不管内存是否足够，总会回收该对象占用的内存</strong>。<br>如下示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WeakReferenceTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        // 创建一个字符串对象</span><br><span class=\"line\">        String str = new String(&quot;疯狂Java讲义&quot;);</span><br><span class=\"line\">        // 创建一个弱引用，让此弱引用引用到&quot;疯狂Java讲义&quot;字符串</span><br><span class=\"line\">        WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(str);</span><br><span class=\"line\">        // 切断str引用和&quot;疯狂Java讲义&quot;字符串之间的引用</span><br><span class=\"line\">        str = null;      //②</span><br><span class=\"line\">        // 取出弱引用所引用的对象</span><br><span class=\"line\">        System.out.println(wr.get()); //输出：疯狂Java讲义</span><br><span class=\"line\">        // 强制垃圾回收</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        System.runFinalization();</span><br><span class=\"line\">        // 再次取出弱引用所引用的对象</span><br><span class=\"line\">        System.out.println(wr.get());  //输出：null</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注：上面代码中创建字符串对象不可采用 “String str = “疯狂Java讲义”;” 这种方式,因为这样的定义系统会把它缓存为常量，使用强引用来引用它，则不会被回收。</p>\n</blockquote>\n<p>上述代码中的内存分配示意图：</p>\n<p><img src=\"/img/article_img/2016/weakreference.png\" alt=\"\"></p>\n<p>在实际使用时，可以使用<code>WeakHashMap</code>来保存弱引用对象。</p>\n<h3 id=\"d-虚引用\"><a href=\"#d-虚引用\" class=\"headerlink\" title=\"d. 虚引用\"></a><strong>d. 虚引用</strong></h3><p>虚引用主要是跟踪对象被垃圾回收的状态，可以通过检查与虚引用关联的队列中是否包含指定的引用，了解对象是否被回收。<br>与软引用和弱引用不同，虚引用不能单独使用。<br>虚引用对象在被释放前会将它添加到他关联的引用队列中。通过<code>PhantomReference</code>类实现，结合引用队列<code>ReferenceQuence</code>使用。如下使用示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PhantomReferenceTest &#123;</span><br><span class=\"line\">    public static void main(String[] args)</span><br><span class=\"line\">            throws Exception &#123;</span><br><span class=\"line\">        // 创建一个字符串对象</span><br><span class=\"line\">        String str = new String(&quot;疯狂Java讲义&quot;);</span><br><span class=\"line\">        // 创建一个引用队列</span><br><span class=\"line\">        ReferenceQueue&lt;String&gt; rq = new ReferenceQueue&lt;String&gt;();</span><br><span class=\"line\">        // 创建一个虚引用，让此虚引用引用到&quot;疯狂Java讲义&quot;字符串</span><br><span class=\"line\">        PhantomReference&lt;String&gt; pr =</span><br><span class=\"line\">                new PhantomReference&lt;String&gt;(str, rq);</span><br><span class=\"line\">        // 切断str引用和&quot;Struts2权威指南&quot;字符串之间的引用</span><br><span class=\"line\">        str = null;</span><br><span class=\"line\">        // 试图取出虚引用所引用的对象，</span><br><span class=\"line\">        // 程序并不能通过虚引用访问被引用的对象</span><br><span class=\"line\">        System.out.println(pr.get());  //输出null</span><br><span class=\"line\">        // 强制垃圾回收</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        System.runFinalization();</span><br><span class=\"line\">        // 取出引用队列中最先进入队列中引用与pr进行比较</span><br><span class=\"line\">        System.out.println(rq.poll() == pr);  //输出：true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、java-的内存泄露\"><a href=\"#二、java-的内存泄露\" class=\"headerlink\" title=\"二、java 的内存泄露\"></a>二、java 的内存泄露</h2><p>与C++程序员不同，java 程序员无需关注内存释放的问题，这些由JVM帮我们完成。然而如果使用不当，一样会出现内存泄露。如果是可达状态的对象，但程序不访问，他们做占用的空间不会被回收，就会产生内存泄露。<br>yi ArrayList中的remove方法为例，每当删除一个元素时，就会让最后一个元素的引用置为null:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elementData[--size] = null;</span><br></pre></td></tr></table></figure>\n<p>在ArrayList中采用数组来保存每个元素的。由于集合中每个元素实际上存的是引用，如果不使用上述的代码，则ArrayList中被删除的元素一直被引用着，处于可达状态，导致无法被回收，因而会产生内存泄露。</p>\n<h2 id=\"三、垃圾回收机制\"><a href=\"#三、垃圾回收机制\" class=\"headerlink\" title=\"三、垃圾回收机制\"></a>三、垃圾回收机制</h2><p>垃圾回收主要完成两件事：</p>\n<ul>\n<li>跟踪监控java对象，当它处于不可达时，回收他所占用的内存；</li>\n<li>清理内存分配和回收过程中产生的内存是碎片。</li>\n</ul>\n<p>垃圾回收的基本算法有：</p>\n<ul>\n<li>串行回收和并行回收</li>\n<li>并发执行和应用程序停止</li>\n<li>压缩/不压缩和复制</li>\n</ul>\n<p>现在的垃圾回收机制用分代的方式采用不同的回收机制，根据<strong>对象生存时间的长短</strong>，把堆内存分为三代：<strong>Yong(新生代)、Old(老年代)、Permanent(永生代)</strong>。</p>\n<p>在java中，绝大多数对象不会被长时间引用，他们在Yong期间被回收，很老的对象和很新的对象之间很少存在相互引用的情况。</p>\n<p>当Yong代的内存快要用完时，垃圾回收机制会对其进行回收，此时回收的系统性能开销小。为次要回收；当Old代快要用完时，垃圾回收机制会进行全面的回收，包括Yong和Old，此时回收成本大，为主要回收。</p>\n<p>Permanent时代主要用于装在Class、方法等信息，默认是64MB，通常不会被回收。</p>\n<h2 id=\"四、内存管理技巧\"><a href=\"#四、内存管理技巧\" class=\"headerlink\" title=\"四、内存管理技巧\"></a>四、内存管理技巧</h2><p>只有很好的掌握了垃圾回收及其机制，才能更好的管理java虚拟机，使我们写出更高性能的java代码。避免内存泄露的主要技巧如下：</p>\n<ul>\n<li>使用直接量<br>如使用 <code>String str = &quot;hello;&quot;</code> 代替 <code>String str = new String(&quot;hello&quot;);</code>，前者会在缓存池缓存这个常量</li>\n<li>使用StringBuilder和StringBuffer进行字符串的连接<br>使用String时会生成大量的临时字符串存在内存中。</li>\n<li>及时释放无用对象的引用</li>\n<li>减少静态变量</li>\n<li>避免在经常调用的方法、循环中创建java对象</li>\n<li>缓存经常使用的对象<br>缓存技术是牺牲空间换时间的，主要使用容器保存已使用的对象，其关键在于如何控制缓存容器的空间使其不至于过大并且能够保留大部分已用过的对象。</li>\n<li>尽量不要使用finalize方法</li>\n<li>考虑使用SoftReference<br>当创建长度很大的对象时，可以使用软引用包装数组，便于在内存不足的情况下被回收释放。</li>\n</ul>"},{"title":"java 知识 之 常见java集合的实现细节","date":"2016-11-22T08:06:25.000Z","_content":"> 读书笔记：《疯狂java 程序员的基本修养》第三章——常见java集合的实现细节\n\n\n## 1.java 中集合及其继承关系\n\n\n\n**Collection**中常用的集合类类图如下：<!--more-->\n\n![](/img/article_img/2016/collection_diagram.png)\n\n**Map**中常用的集合类类图如下：\n\n![](/img/article_img/2016/map_diagram.png)\n\n*注：在jdk的安装目录下的 `src.zip`文件中就是jdk的源码，可以解压后查看。可通过NetBeans\n等软件进行逆向工程查看类图。由于习惯使用idea，加上它对uml有一定的支持（主要是NetBeans新版不能在jdk1.8之后看类图），这里采用Idea生成类图。如下图：*\n\n![](/img/article_img/2016/ide_show_class_diagram.png)\n\n为了方便查看，可以新建工程，将jdk中的src解压放到该项目目录下，避免因为导入的包使有些类重复显示。\n\n## 2. Set和Map\n`Set`代表一种集合元素无序、不可重复的集合；`Map`代表一种由多个`key-value`对组成的集合。Map是Set集合的扩展。Map的所有的Key都是不可重复的，他们可以组成一个Set集合，对于Map而言，特可以看做是每个元素都是key-value对的集合。\n \n**HashSet和HashMap**\nHashSet:用采用Hash算法来决定集合元素的存储位置，可以保证快速存取集合；\nHashMap:同样采用Hash算法决定key的存储位置，value紧随key存储。\n\n> 在java中，虽然集合可以存储对象，但真正存储的是对象的引用，通过这些引用指向具体的对象，与引用类型的数组类似。\n\nHashMap的构造器：\n\n- HashMap()\n构建初始容量为16，负载因子为0.75的HashMap；\n- HashMap(int initialCapacity)\n指定初始容量（初始化时会找出大于initialCapacity的最小的2的N次方作为实际的容量，通常情况下实际的容量比initialCapacity大，除非指定的initialCapacity是2的n次方，则指定initialCapacity为2的N次方可以减小系统的开销）\n- HashMap(int initialCapacity, float loadFactor)\n指定初始容量和负载因子\n\n这里的负载因子，增大它会减小Hash表占用的空间，但会增加查询的时间开销；减小负载因子会提高数据查询性能，但会增加内存占用，可以根据实际的需要适当的设置它。\n\n对于HashSet,大部分方法都是调用HashMap的方法来实现的，在hashset中元素实际上由HashMap的Kkey来保存，value则存的是一个PRESENT——一个静态的Object对象。\n\n对于**TreeMap**，它底层采用的**红黑树**（一种自平衡二叉树了，树种的每个节点的值都大于或等于它左子树种所有节点的值，小于或等于它右子树种所有节点的值）来保存的，保证了所有的key都是从小到大排列的。\n\n<p style=\"color:red;\"><strong>HashTable</strong> 是线程安全的。</p>\n\n\n## 3.Map和List\nMap提供了get(K key)方法通过key获取value,List接口提供了get(int index)方法获取指定索引的值。\nStack是Vector的子类，是线程安全的，jdk1.6后不推荐使用它，可以使用ArrayQueue替换。\n\n## 4.ArrayList和LinkedList\nArrayList和Vector的实现绝大部分都是相同的，只是Vector的方法使用了*synchronized*修饰，可以看做Vector是ArrayList的线程安全版本。\nArrayList是通过数组保存集合元素的，但在定义数组时用**transient**进行修饰，\n\nArrayList是一种顺序存储的线性表，LinkdList则是一种链式存储的线性表（双链表、队列、栈）。ArrayList在插入/删除数据时，需要将数据进行“整体搬家”。LinkedList是一个双链表，如果要获取某个元素必须进行逐个的搜索，但提供的有`addFirst(E e)`、`addLast(E e)`等方法，可以快速的定位需要的操作。\n\n大部分情况下，ArrayList的性能总比LinkedList更优。对于经常需要添加和删除的，可以使用LinkedList.\n\n## 5.Iterator迭代器\n\nIterator是一个迭代器接口，用于迭代各种Collection集合，这里使用了“迭代器模式”。\n在迭代过程如果删除元素，若该元素不是最后一个，则会抛出异常。\n","source":"_posts/java 知识 之 常见java集合的实现细节.md","raw":"---\ntitle: java 知识 之 常见java集合的实现细节\ndate: 2016-11-22 16:06:25\ncategories: [java,高级知识]\ntags: [java,集合,内存管理]\n---\n> 读书笔记：《疯狂java 程序员的基本修养》第三章——常见java集合的实现细节\n\n\n## 1.java 中集合及其继承关系\n\n\n\n**Collection**中常用的集合类类图如下：<!--more-->\n\n![](/img/article_img/2016/collection_diagram.png)\n\n**Map**中常用的集合类类图如下：\n\n![](/img/article_img/2016/map_diagram.png)\n\n*注：在jdk的安装目录下的 `src.zip`文件中就是jdk的源码，可以解压后查看。可通过NetBeans\n等软件进行逆向工程查看类图。由于习惯使用idea，加上它对uml有一定的支持（主要是NetBeans新版不能在jdk1.8之后看类图），这里采用Idea生成类图。如下图：*\n\n![](/img/article_img/2016/ide_show_class_diagram.png)\n\n为了方便查看，可以新建工程，将jdk中的src解压放到该项目目录下，避免因为导入的包使有些类重复显示。\n\n## 2. Set和Map\n`Set`代表一种集合元素无序、不可重复的集合；`Map`代表一种由多个`key-value`对组成的集合。Map是Set集合的扩展。Map的所有的Key都是不可重复的，他们可以组成一个Set集合，对于Map而言，特可以看做是每个元素都是key-value对的集合。\n \n**HashSet和HashMap**\nHashSet:用采用Hash算法来决定集合元素的存储位置，可以保证快速存取集合；\nHashMap:同样采用Hash算法决定key的存储位置，value紧随key存储。\n\n> 在java中，虽然集合可以存储对象，但真正存储的是对象的引用，通过这些引用指向具体的对象，与引用类型的数组类似。\n\nHashMap的构造器：\n\n- HashMap()\n构建初始容量为16，负载因子为0.75的HashMap；\n- HashMap(int initialCapacity)\n指定初始容量（初始化时会找出大于initialCapacity的最小的2的N次方作为实际的容量，通常情况下实际的容量比initialCapacity大，除非指定的initialCapacity是2的n次方，则指定initialCapacity为2的N次方可以减小系统的开销）\n- HashMap(int initialCapacity, float loadFactor)\n指定初始容量和负载因子\n\n这里的负载因子，增大它会减小Hash表占用的空间，但会增加查询的时间开销；减小负载因子会提高数据查询性能，但会增加内存占用，可以根据实际的需要适当的设置它。\n\n对于HashSet,大部分方法都是调用HashMap的方法来实现的，在hashset中元素实际上由HashMap的Kkey来保存，value则存的是一个PRESENT——一个静态的Object对象。\n\n对于**TreeMap**，它底层采用的**红黑树**（一种自平衡二叉树了，树种的每个节点的值都大于或等于它左子树种所有节点的值，小于或等于它右子树种所有节点的值）来保存的，保证了所有的key都是从小到大排列的。\n\n<p style=\"color:red;\"><strong>HashTable</strong> 是线程安全的。</p>\n\n\n## 3.Map和List\nMap提供了get(K key)方法通过key获取value,List接口提供了get(int index)方法获取指定索引的值。\nStack是Vector的子类，是线程安全的，jdk1.6后不推荐使用它，可以使用ArrayQueue替换。\n\n## 4.ArrayList和LinkedList\nArrayList和Vector的实现绝大部分都是相同的，只是Vector的方法使用了*synchronized*修饰，可以看做Vector是ArrayList的线程安全版本。\nArrayList是通过数组保存集合元素的，但在定义数组时用**transient**进行修饰，\n\nArrayList是一种顺序存储的线性表，LinkdList则是一种链式存储的线性表（双链表、队列、栈）。ArrayList在插入/删除数据时，需要将数据进行“整体搬家”。LinkedList是一个双链表，如果要获取某个元素必须进行逐个的搜索，但提供的有`addFirst(E e)`、`addLast(E e)`等方法，可以快速的定位需要的操作。\n\n大部分情况下，ArrayList的性能总比LinkedList更优。对于经常需要添加和删除的，可以使用LinkedList.\n\n## 5.Iterator迭代器\n\nIterator是一个迭代器接口，用于迭代各种Collection集合，这里使用了“迭代器模式”。\n在迭代过程如果删除元素，若该元素不是最后一个，则会抛出异常。\n","slug":"java 知识 之 常见java集合的实现细节","published":1,"updated":"2016-11-22T10:20:33.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucib002ig0g5saakc8u8","content":"<blockquote>\n<p>读书笔记：《疯狂java 程序员的基本修养》第三章——常见java集合的实现细节</p>\n</blockquote>\n<h2 id=\"1-java-中集合及其继承关系\"><a href=\"#1-java-中集合及其继承关系\" class=\"headerlink\" title=\"1.java 中集合及其继承关系\"></a>1.java 中集合及其继承关系</h2><p><strong>Collection</strong>中常用的集合类类图如下：<a id=\"more\"></a></p>\n<p><img src=\"/img/article_img/2016/collection_diagram.png\" alt=\"\"></p>\n<p><strong>Map</strong>中常用的集合类类图如下：</p>\n<p><img src=\"/img/article_img/2016/map_diagram.png\" alt=\"\"></p>\n<p><em>注：在jdk的安装目录下的 <code>src.zip</code>文件中就是jdk的源码，可以解压后查看。可通过NetBeans<br>等软件进行逆向工程查看类图。由于习惯使用idea，加上它对uml有一定的支持（主要是NetBeans新版不能在jdk1.8之后看类图），这里采用Idea生成类图。如下图：</em></p>\n<p><img src=\"/img/article_img/2016/ide_show_class_diagram.png\" alt=\"\"></p>\n<p>为了方便查看，可以新建工程，将jdk中的src解压放到该项目目录下，避免因为导入的包使有些类重复显示。</p>\n<h2 id=\"2-Set和Map\"><a href=\"#2-Set和Map\" class=\"headerlink\" title=\"2. Set和Map\"></a>2. Set和Map</h2><p><code>Set</code>代表一种集合元素无序、不可重复的集合；<code>Map</code>代表一种由多个<code>key-value</code>对组成的集合。Map是Set集合的扩展。Map的所有的Key都是不可重复的，他们可以组成一个Set集合，对于Map而言，特可以看做是每个元素都是key-value对的集合。</p>\n<p><strong>HashSet和HashMap</strong><br>HashSet:用采用Hash算法来决定集合元素的存储位置，可以保证快速存取集合；<br>HashMap:同样采用Hash算法决定key的存储位置，value紧随key存储。</p>\n<blockquote>\n<p>在java中，虽然集合可以存储对象，但真正存储的是对象的引用，通过这些引用指向具体的对象，与引用类型的数组类似。</p>\n</blockquote>\n<p>HashMap的构造器：</p>\n<ul>\n<li>HashMap()<br>构建初始容量为16，负载因子为0.75的HashMap；</li>\n<li>HashMap(int initialCapacity)<br>指定初始容量（初始化时会找出大于initialCapacity的最小的2的N次方作为实际的容量，通常情况下实际的容量比initialCapacity大，除非指定的initialCapacity是2的n次方，则指定initialCapacity为2的N次方可以减小系统的开销）</li>\n<li>HashMap(int initialCapacity, float loadFactor)<br>指定初始容量和负载因子</li>\n</ul>\n<p>这里的负载因子，增大它会减小Hash表占用的空间，但会增加查询的时间开销；减小负载因子会提高数据查询性能，但会增加内存占用，可以根据实际的需要适当的设置它。</p>\n<p>对于HashSet,大部分方法都是调用HashMap的方法来实现的，在hashset中元素实际上由HashMap的Kkey来保存，value则存的是一个PRESENT——一个静态的Object对象。</p>\n<p>对于<strong>TreeMap</strong>，它底层采用的<strong>红黑树</strong>（一种自平衡二叉树了，树种的每个节点的值都大于或等于它左子树种所有节点的值，小于或等于它右子树种所有节点的值）来保存的，保证了所有的key都是从小到大排列的。</p>\n<p style=\"color:red;\"><strong>HashTable</strong> 是线程安全的。</p>\n\n\n<h2 id=\"3-Map和List\"><a href=\"#3-Map和List\" class=\"headerlink\" title=\"3.Map和List\"></a>3.Map和List</h2><p>Map提供了get(K key)方法通过key获取value,List接口提供了get(int index)方法获取指定索引的值。<br>Stack是Vector的子类，是线程安全的，jdk1.6后不推荐使用它，可以使用ArrayQueue替换。</p>\n<h2 id=\"4-ArrayList和LinkedList\"><a href=\"#4-ArrayList和LinkedList\" class=\"headerlink\" title=\"4.ArrayList和LinkedList\"></a>4.ArrayList和LinkedList</h2><p>ArrayList和Vector的实现绝大部分都是相同的，只是Vector的方法使用了<em>synchronized</em>修饰，可以看做Vector是ArrayList的线程安全版本。<br>ArrayList是通过数组保存集合元素的，但在定义数组时用<strong>transient</strong>进行修饰，</p>\n<p>ArrayList是一种顺序存储的线性表，LinkdList则是一种链式存储的线性表（双链表、队列、栈）。ArrayList在插入/删除数据时，需要将数据进行“整体搬家”。LinkedList是一个双链表，如果要获取某个元素必须进行逐个的搜索，但提供的有<code>addFirst(E e)</code>、<code>addLast(E e)</code>等方法，可以快速的定位需要的操作。</p>\n<p>大部分情况下，ArrayList的性能总比LinkedList更优。对于经常需要添加和删除的，可以使用LinkedList.</p>\n<h2 id=\"5-Iterator迭代器\"><a href=\"#5-Iterator迭代器\" class=\"headerlink\" title=\"5.Iterator迭代器\"></a>5.Iterator迭代器</h2><p>Iterator是一个迭代器接口，用于迭代各种Collection集合，这里使用了“迭代器模式”。<br>在迭代过程如果删除元素，若该元素不是最后一个，则会抛出异常。</p>\n","excerpt":"<blockquote>\n<p>读书笔记：《疯狂java 程序员的基本修养》第三章——常见java集合的实现细节</p>\n</blockquote>\n<h2 id=\"1-java-中集合及其继承关系\"><a href=\"#1-java-中集合及其继承关系\" class=\"headerlink\" title=\"1.java 中集合及其继承关系\"></a>1.java 中集合及其继承关系</h2><p><strong>Collection</strong>中常用的集合类类图如下：","more":"</p>\n<p><img src=\"/img/article_img/2016/collection_diagram.png\" alt=\"\"></p>\n<p><strong>Map</strong>中常用的集合类类图如下：</p>\n<p><img src=\"/img/article_img/2016/map_diagram.png\" alt=\"\"></p>\n<p><em>注：在jdk的安装目录下的 <code>src.zip</code>文件中就是jdk的源码，可以解压后查看。可通过NetBeans<br>等软件进行逆向工程查看类图。由于习惯使用idea，加上它对uml有一定的支持（主要是NetBeans新版不能在jdk1.8之后看类图），这里采用Idea生成类图。如下图：</em></p>\n<p><img src=\"/img/article_img/2016/ide_show_class_diagram.png\" alt=\"\"></p>\n<p>为了方便查看，可以新建工程，将jdk中的src解压放到该项目目录下，避免因为导入的包使有些类重复显示。</p>\n<h2 id=\"2-Set和Map\"><a href=\"#2-Set和Map\" class=\"headerlink\" title=\"2. Set和Map\"></a>2. Set和Map</h2><p><code>Set</code>代表一种集合元素无序、不可重复的集合；<code>Map</code>代表一种由多个<code>key-value</code>对组成的集合。Map是Set集合的扩展。Map的所有的Key都是不可重复的，他们可以组成一个Set集合，对于Map而言，特可以看做是每个元素都是key-value对的集合。</p>\n<p><strong>HashSet和HashMap</strong><br>HashSet:用采用Hash算法来决定集合元素的存储位置，可以保证快速存取集合；<br>HashMap:同样采用Hash算法决定key的存储位置，value紧随key存储。</p>\n<blockquote>\n<p>在java中，虽然集合可以存储对象，但真正存储的是对象的引用，通过这些引用指向具体的对象，与引用类型的数组类似。</p>\n</blockquote>\n<p>HashMap的构造器：</p>\n<ul>\n<li>HashMap()<br>构建初始容量为16，负载因子为0.75的HashMap；</li>\n<li>HashMap(int initialCapacity)<br>指定初始容量（初始化时会找出大于initialCapacity的最小的2的N次方作为实际的容量，通常情况下实际的容量比initialCapacity大，除非指定的initialCapacity是2的n次方，则指定initialCapacity为2的N次方可以减小系统的开销）</li>\n<li>HashMap(int initialCapacity, float loadFactor)<br>指定初始容量和负载因子</li>\n</ul>\n<p>这里的负载因子，增大它会减小Hash表占用的空间，但会增加查询的时间开销；减小负载因子会提高数据查询性能，但会增加内存占用，可以根据实际的需要适当的设置它。</p>\n<p>对于HashSet,大部分方法都是调用HashMap的方法来实现的，在hashset中元素实际上由HashMap的Kkey来保存，value则存的是一个PRESENT——一个静态的Object对象。</p>\n<p>对于<strong>TreeMap</strong>，它底层采用的<strong>红黑树</strong>（一种自平衡二叉树了，树种的每个节点的值都大于或等于它左子树种所有节点的值，小于或等于它右子树种所有节点的值）来保存的，保证了所有的key都是从小到大排列的。</p>\n<p style=\"color:red;\"><strong>HashTable</strong> 是线程安全的。</p>\n\n\n<h2 id=\"3-Map和List\"><a href=\"#3-Map和List\" class=\"headerlink\" title=\"3.Map和List\"></a>3.Map和List</h2><p>Map提供了get(K key)方法通过key获取value,List接口提供了get(int index)方法获取指定索引的值。<br>Stack是Vector的子类，是线程安全的，jdk1.6后不推荐使用它，可以使用ArrayQueue替换。</p>\n<h2 id=\"4-ArrayList和LinkedList\"><a href=\"#4-ArrayList和LinkedList\" class=\"headerlink\" title=\"4.ArrayList和LinkedList\"></a>4.ArrayList和LinkedList</h2><p>ArrayList和Vector的实现绝大部分都是相同的，只是Vector的方法使用了<em>synchronized</em>修饰，可以看做Vector是ArrayList的线程安全版本。<br>ArrayList是通过数组保存集合元素的，但在定义数组时用<strong>transient</strong>进行修饰，</p>\n<p>ArrayList是一种顺序存储的线性表，LinkdList则是一种链式存储的线性表（双链表、队列、栈）。ArrayList在插入/删除数据时，需要将数据进行“整体搬家”。LinkedList是一个双链表，如果要获取某个元素必须进行逐个的搜索，但提供的有<code>addFirst(E e)</code>、<code>addLast(E e)</code>等方法，可以快速的定位需要的操作。</p>\n<p>大部分情况下，ArrayList的性能总比LinkedList更优。对于经常需要添加和删除的，可以使用LinkedList.</p>\n<h2 id=\"5-Iterator迭代器\"><a href=\"#5-Iterator迭代器\" class=\"headerlink\" title=\"5.Iterator迭代器\"></a>5.Iterator迭代器</h2><p>Iterator是一个迭代器接口，用于迭代各种Collection集合，这里使用了“迭代器模式”。<br>在迭代过程如果删除元素，若该元素不是最后一个，则会抛出异常。</p>"},{"title":"java 知识之 反射的使用","date":"2016-11-25T08:06:25.000Z","_content":"\n\n所谓反射，是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。<!--more-->\n\n反射有如下的功能：\n\n- 在运行时判断任意一个对象所属的类；\n- 在运行时构造任意一个类的对象；\n- 在运行时判断任意一个类所具有的成员变量和方法；\n- 在运行时调用任意一个对象的方法；\n- 生成动态代理。\n\n这里的反射主要通过`Class`类来实现。\n\n## 一、Class类的使用\n\n`Class`类的实例表示java 应用运行时的类或者接口，包括数组、基本类型(`int/long/Indeger/String/...`)、关键字(`void/...`)等。没有共有构造方法，在使用new创建对象或者加载ClassLoader时，由JVM自动调用。\n\n> 每个java类运行时都在JVM里表现为一个class对象，可通过类名.class,类型.getClass(),Class.forName(\"类名\")等方法获取class对象。\n\n可以通过下面三种方式获得Class对象：\n\n1.通过 类名.class 获取，可以认为每个类都有一个静态的Class对象。\n ```\nClass c1 = Person.class;\n ```\n\n2.通过类的对象获取\n ```\n Person person = new Person();\n Class c2 = person.getClass();\n ```\n \n3.通过类名获取，**动态加载**（这个再很多地方都有使用，如：加载数据库驱动）\n ```\n Class c3 = null;\n    try {\n        c3 = Class.forName(\"Person\");\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n ```\n\n上面的**c1/c2是Person的类类型，Person是Class类的对象。可以理解为一切类都是Class的对象**。\n\n打印上面三种方法获取的Class对象：\n\n```\nSystem.out.println(c1 == c2);//true\nSystem.out.println(c1 == c3);//true\nSystem.out.println(c2 == c3);//true\n```\n\n上面三种方式获取的Class对象，两两均相等。可见，可以理解为每个对象都有一个静态的Class变量。因为在java 中，*Object* 是一切类的父类，在Object中有一个获取Class对象的native(由C++或C语言实现，通过java 调用，具体的可参见jni相关的知识)方法。如下部分Object开头源码：\n\n```\n public class Object {\n     \n     // ...\n      \n     /**\n     * Returns the runtime class of this {@code Object}. The returned\n     * {@code Class} object is the object that is locked by {@code\n     * static synchronized} methods of the represented class.\n     *\n     * <p><b>The actual result type is {@code Class<? extends |X|>}\n     * where {@code |X|} is the erasure of the static type of the\n     * expression on which {@code getClass} is called.</b> For\n     * example, no cast is required in this code fragment:</p>\n    \n     * @return The {@code Class} object that represents the runtime\n     *         class of this object.\n     *         \n */\n    public final native Class<?> getClass();\n    \n   // ...\n```\n\n通过上面 getClass 方法前的部分注释，可以清楚的明白他的作用。\n \n## 二、动态加载类\n\n在java 中，使用new创建的对象都是静态加载的，这些类必须存在，不管在实际中是否使用，否则编译不通过。可以通过动态加载类来解决该问题。\n通过Class类的forName方法进行加载,传入相应的名加载具体的类，可以使程序的扩展性更好，避免编译出错。\n\n该方法的原型为：\n\n```\n  public static Class<?> forName(String className)\n```\n## 三、使用Class获取类信息\n\nClass类提供的部分获取类信息的方法如下：\n\n|方法名|说明|\n|:-----|:----:|\n|getFields() | 获取所有public类型的成员变量|\n| getDeclaredFields()|获取该类自己声明的所有变量 |\n|getConstructors() |获取所所有public类型的构造方法 |\n|getDeclaredConstructors() |获取所有的构造方法|\n|getMethods() |获取所有的public函数，包括父类继承来的|\n|getDeclaredMethods |获取该类所有声明的方法|\n\n上面分别为获取成员变量、构造方法和成员方法。\n\n**获取成员参数**\n\n```\npublic class ClassUtils {\n    public static void getClassField(Object obj) {\n            Class c = obj.getClass();\n            Field[] fs = c.getDeclaredFields();// c.getMethods();\n            for (Field f : fs) {\n                Class fieldType = f.getType();\n                System.out.println(fieldType.getName() + \" \" + f.getName());\n            }\n        }\n}\n```\n\n上述代码是获取所有成员变量的，获取的每个成员方法都是 `Fidld` 类型的对象。\n如下测试代码获取String类中的成员变量：\n\n```\nClassUtils.getClassField(\"reflect\");\n```\n\n运行结果：\n\n```\n[C value\nint hash\nlong serialVersionUID\n[Ljava.io.ObjectStreamField; serialPersistentFields\njava.util.Comparator CASE_INSENSITIVE_ORDER\n```\n\n其中第一个和第三个表示的是数组。查看String中的源码，成员变量如下：\n\n```\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    \n    private final char value[];\n\n    private int hash; // Default to 0\n\n    private static final long serialVersionUID = -6849794470754667710L;\n\n    private static final ObjectStreamField[] serialPersistentFields =\n            new ObjectStreamField[0];\n            \n    //...\n     public static final Comparator<String> CASE_INSENSITIVE_ORDER\n                                         = new CaseInsensitiveComparator();\n    \n    //...\n}\n```\n同样的可以调用该方法查看其他类中的成员变量。\n\n\n**获取构造方法和成员方法**\n\n类似于上面获取成员变量的方法，如下获取构造函数和成员方法则很好理解了。\n```\npublic class ClassUtils {\n    //...\n    \n    /**\n     * 获取所有的成员方法\n     *\n     * @param obj\n     */\n    public static void getClassMethods(Object obj) {\n        Class c = obj.getClass();\n        System.out.println(\"类名为：\" + c.getName());\n        Method[] ms = c.getDeclaredMethods();\n\n        for (Method m : ms) {\n            Class returnType = m.getReturnType();\n            //返回值的类类型，如String-->String.class\n            System.out.print(returnType.getName() + \" \");\n            //方法名称\n            System.out.print(m.getName() + \"(\");\n            //获取参数--参数列表的类类型\n            Class[] paramTypes = m.getParameterTypes();\n            int paramsNum = paramTypes.length;\n            Class paramType;\n            for (int i = 0; i < paramsNum; i++) {\n                paramType = paramTypes[i];\n                if (i == 1 || (i == paramsNum - 1))\n                    System.out.print(paramType.getName());\n                else\n                    System.out.print(paramType.getName() + \" ,\");\n            }\n            System.out.println(\")\");\n        }\n    }\n    /**\n     * 获取所有的构造函数\n     *\n     * @param obj\n     */\n    public static void printConMessage(Object obj) {\n        Class c = obj.getClass();\n        Constructor[] cs = c.getDeclaredConstructors();\n        for (Constructor constructor : cs) {\n            System.out.print(constructor.getName() + \" (\");\n            Class[] paramTypes = constructor.getParameterTypes();\n            int paramsNum = paramTypes.length;\n            Class paramType;\n            for (int i = 0; i < paramsNum; i++) {\n                paramType = paramTypes[i];\n                if (i == 1 || (i == paramsNum - 1))\n                    System.out.print(paramType.getName());\n                else\n                    System.out.print(paramType.getName() + \" ,\");\n            }\n            System.out.println(\")\");\n        }\n    }\n}\n```\n此处省略测试。\n\n## 四、方法反射的基本操作\n对于方法的获取，可以通过方法名称和参数列表来确定某个方法。主要使用了 `Method.invoke(对象,参数列表);` 操作。\n\n**首先需要获取类信息，然后指定方法名和参数获取方法对象，再通过`Method.invoke()`进行反射获取方法执行结果。若该方法无返回值，则invoke方法最后返回null,否则返回相应的结果**。\n\n如下示例代码：\n\n```\npublic class TestDemo {\n    public static void main(String[] args) {\n        //1.获取类信息\n        A a = new A();\n        Class aClass = a.getClass();\n        //2.获取方法名称和参数\n        try {\n//            Method method = aClass.getMethod(\"print\",new Class[]{int.class,int.class});\n            Method method = aClass.getMethod(\"print\", int.class, int.class);\n            //方法返回结果：若无返回结果则o为null，否则为返回结果，这里返回为30\n            Object o = method.invoke(a, 10, 20);\n            System.out.println(o);//30\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    }\n}\n//测试反射方法\nclass A {\n    public int print(int a, int b) {\n        System.out.println(a + b);\n        return a + b;\n    }\n\n    public void print(String a, String b) {\n        System.out.println(a.toUpperCase() + \"-----\" + b.toUpperCase());\n    }\n}\n\n```\n其中 Method()和invoke()方法第二个参数为可变数组，可有可无，如果有接写。可以通过new数组的方式或者直接一个个写出。\n\n## 五、通过反射了解集合泛型的本质\n\n我们都知道，在java中，定义集合指定什么泛型，就只能添加该类型的数据到集合中，否则就会报错。\n\n通过反射可以往集合中添加不同类型的数据，这样虽没有多大意义，不便于遍历。这里主要说明了集合在编译后是去泛型化的，集合的泛型可以防止错误输入，在编译极前有效。\n\n如下测试代码：\n```\npublic class TestDemo04 {\n    public static void main(String[] args) {\n        ArrayList<String> l1 = new ArrayList<>();\n        ArrayList l2 = new ArrayList();\n        l1.add(\"java reflect\");\n//        datas.add(100);//报错\n        Class c1 = l1.getClass();\n        Class c2 = l2.getClass();\n        System.out.println(c1 == c2);//true\n        try {\n            Method method = c2.getMethod(\"add\", Object.class);\n            method.invoke(l1, 100);\n            System.out.println(\"数组大小：\"+l1.size());\n            System.out.println(\"数组内容：\"+l1.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n输出结果：\n```\ntrue\n数组大小：2\n数组内容：[java reflect, 100]\n```\n上面的代码，通过反射往String类型的集合中添加了int类型的100。\n\n通过对反射的学习，发现反射是从.class到.java的过程，感觉像反编译字节码。以 `Class c1 = Person.class;`为例，Person.java类在编译后生成的字节码文件为Person.class,这里获取的Class正式这样的。\n\n\n\n","source":"_posts/java 知识之 反射的使用.md","raw":"\n---\ntitle: java 知识之 反射的使用\ndate: 2016-11-25 16:06:25\ncategories: [java,高级知识]\ntags: [java,反射]\n---\n\n\n所谓反射，是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。<!--more-->\n\n反射有如下的功能：\n\n- 在运行时判断任意一个对象所属的类；\n- 在运行时构造任意一个类的对象；\n- 在运行时判断任意一个类所具有的成员变量和方法；\n- 在运行时调用任意一个对象的方法；\n- 生成动态代理。\n\n这里的反射主要通过`Class`类来实现。\n\n## 一、Class类的使用\n\n`Class`类的实例表示java 应用运行时的类或者接口，包括数组、基本类型(`int/long/Indeger/String/...`)、关键字(`void/...`)等。没有共有构造方法，在使用new创建对象或者加载ClassLoader时，由JVM自动调用。\n\n> 每个java类运行时都在JVM里表现为一个class对象，可通过类名.class,类型.getClass(),Class.forName(\"类名\")等方法获取class对象。\n\n可以通过下面三种方式获得Class对象：\n\n1.通过 类名.class 获取，可以认为每个类都有一个静态的Class对象。\n ```\nClass c1 = Person.class;\n ```\n\n2.通过类的对象获取\n ```\n Person person = new Person();\n Class c2 = person.getClass();\n ```\n \n3.通过类名获取，**动态加载**（这个再很多地方都有使用，如：加载数据库驱动）\n ```\n Class c3 = null;\n    try {\n        c3 = Class.forName(\"Person\");\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n ```\n\n上面的**c1/c2是Person的类类型，Person是Class类的对象。可以理解为一切类都是Class的对象**。\n\n打印上面三种方法获取的Class对象：\n\n```\nSystem.out.println(c1 == c2);//true\nSystem.out.println(c1 == c3);//true\nSystem.out.println(c2 == c3);//true\n```\n\n上面三种方式获取的Class对象，两两均相等。可见，可以理解为每个对象都有一个静态的Class变量。因为在java 中，*Object* 是一切类的父类，在Object中有一个获取Class对象的native(由C++或C语言实现，通过java 调用，具体的可参见jni相关的知识)方法。如下部分Object开头源码：\n\n```\n public class Object {\n     \n     // ...\n      \n     /**\n     * Returns the runtime class of this {@code Object}. The returned\n     * {@code Class} object is the object that is locked by {@code\n     * static synchronized} methods of the represented class.\n     *\n     * <p><b>The actual result type is {@code Class<? extends |X|>}\n     * where {@code |X|} is the erasure of the static type of the\n     * expression on which {@code getClass} is called.</b> For\n     * example, no cast is required in this code fragment:</p>\n    \n     * @return The {@code Class} object that represents the runtime\n     *         class of this object.\n     *         \n */\n    public final native Class<?> getClass();\n    \n   // ...\n```\n\n通过上面 getClass 方法前的部分注释，可以清楚的明白他的作用。\n \n## 二、动态加载类\n\n在java 中，使用new创建的对象都是静态加载的，这些类必须存在，不管在实际中是否使用，否则编译不通过。可以通过动态加载类来解决该问题。\n通过Class类的forName方法进行加载,传入相应的名加载具体的类，可以使程序的扩展性更好，避免编译出错。\n\n该方法的原型为：\n\n```\n  public static Class<?> forName(String className)\n```\n## 三、使用Class获取类信息\n\nClass类提供的部分获取类信息的方法如下：\n\n|方法名|说明|\n|:-----|:----:|\n|getFields() | 获取所有public类型的成员变量|\n| getDeclaredFields()|获取该类自己声明的所有变量 |\n|getConstructors() |获取所所有public类型的构造方法 |\n|getDeclaredConstructors() |获取所有的构造方法|\n|getMethods() |获取所有的public函数，包括父类继承来的|\n|getDeclaredMethods |获取该类所有声明的方法|\n\n上面分别为获取成员变量、构造方法和成员方法。\n\n**获取成员参数**\n\n```\npublic class ClassUtils {\n    public static void getClassField(Object obj) {\n            Class c = obj.getClass();\n            Field[] fs = c.getDeclaredFields();// c.getMethods();\n            for (Field f : fs) {\n                Class fieldType = f.getType();\n                System.out.println(fieldType.getName() + \" \" + f.getName());\n            }\n        }\n}\n```\n\n上述代码是获取所有成员变量的，获取的每个成员方法都是 `Fidld` 类型的对象。\n如下测试代码获取String类中的成员变量：\n\n```\nClassUtils.getClassField(\"reflect\");\n```\n\n运行结果：\n\n```\n[C value\nint hash\nlong serialVersionUID\n[Ljava.io.ObjectStreamField; serialPersistentFields\njava.util.Comparator CASE_INSENSITIVE_ORDER\n```\n\n其中第一个和第三个表示的是数组。查看String中的源码，成员变量如下：\n\n```\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    \n    private final char value[];\n\n    private int hash; // Default to 0\n\n    private static final long serialVersionUID = -6849794470754667710L;\n\n    private static final ObjectStreamField[] serialPersistentFields =\n            new ObjectStreamField[0];\n            \n    //...\n     public static final Comparator<String> CASE_INSENSITIVE_ORDER\n                                         = new CaseInsensitiveComparator();\n    \n    //...\n}\n```\n同样的可以调用该方法查看其他类中的成员变量。\n\n\n**获取构造方法和成员方法**\n\n类似于上面获取成员变量的方法，如下获取构造函数和成员方法则很好理解了。\n```\npublic class ClassUtils {\n    //...\n    \n    /**\n     * 获取所有的成员方法\n     *\n     * @param obj\n     */\n    public static void getClassMethods(Object obj) {\n        Class c = obj.getClass();\n        System.out.println(\"类名为：\" + c.getName());\n        Method[] ms = c.getDeclaredMethods();\n\n        for (Method m : ms) {\n            Class returnType = m.getReturnType();\n            //返回值的类类型，如String-->String.class\n            System.out.print(returnType.getName() + \" \");\n            //方法名称\n            System.out.print(m.getName() + \"(\");\n            //获取参数--参数列表的类类型\n            Class[] paramTypes = m.getParameterTypes();\n            int paramsNum = paramTypes.length;\n            Class paramType;\n            for (int i = 0; i < paramsNum; i++) {\n                paramType = paramTypes[i];\n                if (i == 1 || (i == paramsNum - 1))\n                    System.out.print(paramType.getName());\n                else\n                    System.out.print(paramType.getName() + \" ,\");\n            }\n            System.out.println(\")\");\n        }\n    }\n    /**\n     * 获取所有的构造函数\n     *\n     * @param obj\n     */\n    public static void printConMessage(Object obj) {\n        Class c = obj.getClass();\n        Constructor[] cs = c.getDeclaredConstructors();\n        for (Constructor constructor : cs) {\n            System.out.print(constructor.getName() + \" (\");\n            Class[] paramTypes = constructor.getParameterTypes();\n            int paramsNum = paramTypes.length;\n            Class paramType;\n            for (int i = 0; i < paramsNum; i++) {\n                paramType = paramTypes[i];\n                if (i == 1 || (i == paramsNum - 1))\n                    System.out.print(paramType.getName());\n                else\n                    System.out.print(paramType.getName() + \" ,\");\n            }\n            System.out.println(\")\");\n        }\n    }\n}\n```\n此处省略测试。\n\n## 四、方法反射的基本操作\n对于方法的获取，可以通过方法名称和参数列表来确定某个方法。主要使用了 `Method.invoke(对象,参数列表);` 操作。\n\n**首先需要获取类信息，然后指定方法名和参数获取方法对象，再通过`Method.invoke()`进行反射获取方法执行结果。若该方法无返回值，则invoke方法最后返回null,否则返回相应的结果**。\n\n如下示例代码：\n\n```\npublic class TestDemo {\n    public static void main(String[] args) {\n        //1.获取类信息\n        A a = new A();\n        Class aClass = a.getClass();\n        //2.获取方法名称和参数\n        try {\n//            Method method = aClass.getMethod(\"print\",new Class[]{int.class,int.class});\n            Method method = aClass.getMethod(\"print\", int.class, int.class);\n            //方法返回结果：若无返回结果则o为null，否则为返回结果，这里返回为30\n            Object o = method.invoke(a, 10, 20);\n            System.out.println(o);//30\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    }\n}\n//测试反射方法\nclass A {\n    public int print(int a, int b) {\n        System.out.println(a + b);\n        return a + b;\n    }\n\n    public void print(String a, String b) {\n        System.out.println(a.toUpperCase() + \"-----\" + b.toUpperCase());\n    }\n}\n\n```\n其中 Method()和invoke()方法第二个参数为可变数组，可有可无，如果有接写。可以通过new数组的方式或者直接一个个写出。\n\n## 五、通过反射了解集合泛型的本质\n\n我们都知道，在java中，定义集合指定什么泛型，就只能添加该类型的数据到集合中，否则就会报错。\n\n通过反射可以往集合中添加不同类型的数据，这样虽没有多大意义，不便于遍历。这里主要说明了集合在编译后是去泛型化的，集合的泛型可以防止错误输入，在编译极前有效。\n\n如下测试代码：\n```\npublic class TestDemo04 {\n    public static void main(String[] args) {\n        ArrayList<String> l1 = new ArrayList<>();\n        ArrayList l2 = new ArrayList();\n        l1.add(\"java reflect\");\n//        datas.add(100);//报错\n        Class c1 = l1.getClass();\n        Class c2 = l2.getClass();\n        System.out.println(c1 == c2);//true\n        try {\n            Method method = c2.getMethod(\"add\", Object.class);\n            method.invoke(l1, 100);\n            System.out.println(\"数组大小：\"+l1.size());\n            System.out.println(\"数组内容：\"+l1.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n输出结果：\n```\ntrue\n数组大小：2\n数组内容：[java reflect, 100]\n```\n上面的代码，通过反射往String类型的集合中添加了int类型的100。\n\n通过对反射的学习，发现反射是从.class到.java的过程，感觉像反编译字节码。以 `Class c1 = Person.class;`为例，Person.java类在编译后生成的字节码文件为Person.class,这里获取的Class正式这样的。\n\n\n\n","slug":"java 知识之 反射的使用","published":1,"updated":"2016-11-26T03:33:52.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucib002mg0g53jnqke6j","content":"<p>所谓反射，是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。<a id=\"more\"></a></p>\n<p>反射有如下的功能：</p>\n<ul>\n<li>在运行时判断任意一个对象所属的类；</li>\n<li>在运行时构造任意一个类的对象；</li>\n<li>在运行时判断任意一个类所具有的成员变量和方法；</li>\n<li>在运行时调用任意一个对象的方法；</li>\n<li>生成动态代理。</li>\n</ul>\n<p>这里的反射主要通过<code>Class</code>类来实现。</p>\n<h2 id=\"一、Class类的使用\"><a href=\"#一、Class类的使用\" class=\"headerlink\" title=\"一、Class类的使用\"></a>一、Class类的使用</h2><p><code>Class</code>类的实例表示java 应用运行时的类或者接口，包括数组、基本类型(<code>int/long/Indeger/String/...</code>)、关键字(<code>void/...</code>)等。没有共有构造方法，在使用new创建对象或者加载ClassLoader时，由JVM自动调用。</p>\n<blockquote>\n<p>每个java类运行时都在JVM里表现为一个class对象，可通过类名.class,类型.getClass(),Class.forName(“类名”)等方法获取class对象。</p>\n</blockquote>\n<p>可以通过下面三种方式获得Class对象：</p>\n<p>1.通过 类名.class 获取，可以认为每个类都有一个静态的Class对象。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c1 = Person.class;</span><br></pre></td></tr></table></figure></p>\n<p>2.通过类的对象获取<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person person = new Person();</span><br><span class=\"line\">Class c2 = person.getClass();</span><br></pre></td></tr></table></figure></p>\n<p>3.通过类名获取，<strong>动态加载</strong>（这个再很多地方都有使用，如：加载数据库驱动）<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c3 = null;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">       c3 = Class.forName(&quot;Person&quot;);</span><br><span class=\"line\">   &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">       e.printStackTrace();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的<strong>c1/c2是Person的类类型，Person是Class类的对象。可以理解为一切类都是Class的对象</strong>。</p>\n<p>打印上面三种方法获取的Class对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(c1 == c2);//true</span><br><span class=\"line\">System.out.println(c1 == c3);//true</span><br><span class=\"line\">System.out.println(c2 == c3);//true</span><br></pre></td></tr></table></figure>\n<p>上面三种方式获取的Class对象，两两均相等。可见，可以理解为每个对象都有一个静态的Class变量。因为在java 中，<em>Object</em> 是一切类的父类，在Object中有一个获取Class对象的native(由C++或C语言实现，通过java 调用，具体的可参见jni相关的知识)方法。如下部分Object开头源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Object &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // ...</span><br><span class=\"line\">     </span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * Returns the runtime class of this &#123;@code Object&#125;. The returned</span><br><span class=\"line\">    * &#123;@code Class&#125; object is the object that is locked by &#123;@code</span><br><span class=\"line\">    * static synchronized&#125; methods of the represented class.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * &lt;p&gt;&lt;b&gt;The actual result type is &#123;@code Class&lt;? extends |X|&gt;&#125;</span><br><span class=\"line\">    * where &#123;@code |X|&#125; is the erasure of the static type of the</span><br><span class=\"line\">    * expression on which &#123;@code getClass&#125; is called.&lt;/b&gt; For</span><br><span class=\"line\">    * example, no cast is required in this code fragment:&lt;/p&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">    * @return The &#123;@code Class&#125; object that represents the runtime</span><br><span class=\"line\">    *         class of this object.</span><br><span class=\"line\">    *         </span><br><span class=\"line\">*/</span><br><span class=\"line\">   public final native Class&lt;?&gt; getClass();</span><br><span class=\"line\">   </span><br><span class=\"line\">  // ...</span><br></pre></td></tr></table></figure>\n<p>通过上面 getClass 方法前的部分注释，可以清楚的明白他的作用。</p>\n<h2 id=\"二、动态加载类\"><a href=\"#二、动态加载类\" class=\"headerlink\" title=\"二、动态加载类\"></a>二、动态加载类</h2><p>在java 中，使用new创建的对象都是静态加载的，这些类必须存在，不管在实际中是否使用，否则编译不通过。可以通过动态加载类来解决该问题。<br>通过Class类的forName方法进行加载,传入相应的名加载具体的类，可以使程序的扩展性更好，避免编译出错。</p>\n<p>该方法的原型为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Class&lt;?&gt; forName(String className)</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、使用Class获取类信息\"><a href=\"#三、使用Class获取类信息\" class=\"headerlink\" title=\"三、使用Class获取类信息\"></a>三、使用Class获取类信息</h2><p>Class类提供的部分获取类信息的方法如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法名</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">getFields()</td>\n<td style=\"text-align:center\">获取所有public类型的成员变量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">getDeclaredFields()</td>\n<td style=\"text-align:center\">获取该类自己声明的所有变量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">getConstructors()</td>\n<td style=\"text-align:center\">获取所所有public类型的构造方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">getDeclaredConstructors()</td>\n<td style=\"text-align:center\">获取所有的构造方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">getMethods()</td>\n<td style=\"text-align:center\">获取所有的public函数，包括父类继承来的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">getDeclaredMethods</td>\n<td style=\"text-align:center\">获取该类所有声明的方法</td>\n</tr>\n</tbody>\n</table>\n<p>上面分别为获取成员变量、构造方法和成员方法。</p>\n<p><strong>获取成员参数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ClassUtils &#123;</span><br><span class=\"line\">    public static void getClassField(Object obj) &#123;</span><br><span class=\"line\">            Class c = obj.getClass();</span><br><span class=\"line\">            Field[] fs = c.getDeclaredFields();// c.getMethods();</span><br><span class=\"line\">            for (Field f : fs) &#123;</span><br><span class=\"line\">                Class fieldType = f.getType();</span><br><span class=\"line\">                System.out.println(fieldType.getName() + &quot; &quot; + f.getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是获取所有成员变量的，获取的每个成员方法都是 <code>Fidld</code> 类型的对象。<br>如下测试代码获取String类中的成员变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassUtils.getClassField(&quot;reflect&quot;);</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[C value</span><br><span class=\"line\">int hash</span><br><span class=\"line\">long serialVersionUID</span><br><span class=\"line\">[Ljava.io.ObjectStreamField; serialPersistentFields</span><br><span class=\"line\">java.util.Comparator CASE_INSENSITIVE_ORDER</span><br></pre></td></tr></table></figure>\n<p>其中第一个和第三个表示的是数组。查看String中的源码，成员变量如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class String</span><br><span class=\"line\">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private final char value[];</span><br><span class=\"line\"></span><br><span class=\"line\">    private int hash; // Default to 0</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final long serialVersionUID = -6849794470754667710L;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final ObjectStreamField[] serialPersistentFields =</span><br><span class=\"line\">            new ObjectStreamField[0];</span><br><span class=\"line\">            </span><br><span class=\"line\">    //...</span><br><span class=\"line\">     public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class=\"line\">                                         = new CaseInsensitiveComparator();</span><br><span class=\"line\">    </span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的可以调用该方法查看其他类中的成员变量。</p>\n<p><strong>获取构造方法和成员方法</strong></p>\n<p>类似于上面获取成员变量的方法，如下获取构造函数和成员方法则很好理解了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ClassUtils &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    </span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取所有的成员方法</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param obj</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void getClassMethods(Object obj) &#123;</span><br><span class=\"line\">        Class c = obj.getClass();</span><br><span class=\"line\">        System.out.println(&quot;类名为：&quot; + c.getName());</span><br><span class=\"line\">        Method[] ms = c.getDeclaredMethods();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Method m : ms) &#123;</span><br><span class=\"line\">            Class returnType = m.getReturnType();</span><br><span class=\"line\">            //返回值的类类型，如String--&gt;String.class</span><br><span class=\"line\">            System.out.print(returnType.getName() + &quot; &quot;);</span><br><span class=\"line\">            //方法名称</span><br><span class=\"line\">            System.out.print(m.getName() + &quot;(&quot;);</span><br><span class=\"line\">            //获取参数--参数列表的类类型</span><br><span class=\"line\">            Class[] paramTypes = m.getParameterTypes();</span><br><span class=\"line\">            int paramsNum = paramTypes.length;</span><br><span class=\"line\">            Class paramType;</span><br><span class=\"line\">            for (int i = 0; i &lt; paramsNum; i++) &#123;</span><br><span class=\"line\">                paramType = paramTypes[i];</span><br><span class=\"line\">                if (i == 1 || (i == paramsNum - 1))</span><br><span class=\"line\">                    System.out.print(paramType.getName());</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    System.out.print(paramType.getName() + &quot; ,&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;)&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取所有的构造函数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param obj</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void printConMessage(Object obj) &#123;</span><br><span class=\"line\">        Class c = obj.getClass();</span><br><span class=\"line\">        Constructor[] cs = c.getDeclaredConstructors();</span><br><span class=\"line\">        for (Constructor constructor : cs) &#123;</span><br><span class=\"line\">            System.out.print(constructor.getName() + &quot; (&quot;);</span><br><span class=\"line\">            Class[] paramTypes = constructor.getParameterTypes();</span><br><span class=\"line\">            int paramsNum = paramTypes.length;</span><br><span class=\"line\">            Class paramType;</span><br><span class=\"line\">            for (int i = 0; i &lt; paramsNum; i++) &#123;</span><br><span class=\"line\">                paramType = paramTypes[i];</span><br><span class=\"line\">                if (i == 1 || (i == paramsNum - 1))</span><br><span class=\"line\">                    System.out.print(paramType.getName());</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    System.out.print(paramType.getName() + &quot; ,&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;)&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此处省略测试。</p>\n<h2 id=\"四、方法反射的基本操作\"><a href=\"#四、方法反射的基本操作\" class=\"headerlink\" title=\"四、方法反射的基本操作\"></a>四、方法反射的基本操作</h2><p>对于方法的获取，可以通过方法名称和参数列表来确定某个方法。主要使用了 <code>Method.invoke(对象,参数列表);</code> 操作。</p>\n<p><strong>首先需要获取类信息，然后指定方法名和参数获取方法对象，再通过<code>Method.invoke()</code>进行反射获取方法执行结果。若该方法无返回值，则invoke方法最后返回null,否则返回相应的结果</strong>。</p>\n<p>如下示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //1.获取类信息</span><br><span class=\"line\">        A a = new A();</span><br><span class=\"line\">        Class aClass = a.getClass();</span><br><span class=\"line\">        //2.获取方法名称和参数</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">//            Method method = aClass.getMethod(&quot;print&quot;,new Class[]&#123;int.class,int.class&#125;);</span><br><span class=\"line\">            Method method = aClass.getMethod(&quot;print&quot;, int.class, int.class);</span><br><span class=\"line\">            //方法返回结果：若无返回结果则o为null，否则为返回结果，这里返回为30</span><br><span class=\"line\">            Object o = method.invoke(a, 10, 20);</span><br><span class=\"line\">            System.out.println(o);//30</span><br><span class=\"line\">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//测试反射方法</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">    public int print(int a, int b) &#123;</span><br><span class=\"line\">        System.out.println(a + b);</span><br><span class=\"line\">        return a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void print(String a, String b) &#123;</span><br><span class=\"line\">        System.out.println(a.toUpperCase() + &quot;-----&quot; + b.toUpperCase());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 Method()和invoke()方法第二个参数为可变数组，可有可无，如果有接写。可以通过new数组的方式或者直接一个个写出。</p>\n<h2 id=\"五、通过反射了解集合泛型的本质\"><a href=\"#五、通过反射了解集合泛型的本质\" class=\"headerlink\" title=\"五、通过反射了解集合泛型的本质\"></a>五、通过反射了解集合泛型的本质</h2><p>我们都知道，在java中，定义集合指定什么泛型，就只能添加该类型的数据到集合中，否则就会报错。</p>\n<p>通过反射可以往集合中添加不同类型的数据，这样虽没有多大意义，不便于遍历。这里主要说明了集合在编译后是去泛型化的，集合的泛型可以防止错误输入，在编译极前有效。</p>\n<p>如下测试代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestDemo04 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; l1 = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        ArrayList l2 = new ArrayList();</span><br><span class=\"line\">        l1.add(&quot;java reflect&quot;);</span><br><span class=\"line\">//        datas.add(100);//报错</span><br><span class=\"line\">        Class c1 = l1.getClass();</span><br><span class=\"line\">        Class c2 = l2.getClass();</span><br><span class=\"line\">        System.out.println(c1 == c2);//true</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Method method = c2.getMethod(&quot;add&quot;, Object.class);</span><br><span class=\"line\">            method.invoke(l1, 100);</span><br><span class=\"line\">            System.out.println(&quot;数组大小：&quot;+l1.size());</span><br><span class=\"line\">            System.out.println(&quot;数组内容：&quot;+l1.toString());</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">true</span><br><span class=\"line\">数组大小：2</span><br><span class=\"line\">数组内容：[java reflect, 100]</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，通过反射往String类型的集合中添加了int类型的100。</p>\n<p>通过对反射的学习，发现反射是从.class到.java的过程，感觉像反编译字节码。以 <code>Class c1 = Person.class;</code>为例，Person.java类在编译后生成的字节码文件为Person.class,这里获取的Class正式这样的。</p>\n","excerpt":"<p>所谓反射，是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。","more":"</p>\n<p>反射有如下的功能：</p>\n<ul>\n<li>在运行时判断任意一个对象所属的类；</li>\n<li>在运行时构造任意一个类的对象；</li>\n<li>在运行时判断任意一个类所具有的成员变量和方法；</li>\n<li>在运行时调用任意一个对象的方法；</li>\n<li>生成动态代理。</li>\n</ul>\n<p>这里的反射主要通过<code>Class</code>类来实现。</p>\n<h2 id=\"一、Class类的使用\"><a href=\"#一、Class类的使用\" class=\"headerlink\" title=\"一、Class类的使用\"></a>一、Class类的使用</h2><p><code>Class</code>类的实例表示java 应用运行时的类或者接口，包括数组、基本类型(<code>int/long/Indeger/String/...</code>)、关键字(<code>void/...</code>)等。没有共有构造方法，在使用new创建对象或者加载ClassLoader时，由JVM自动调用。</p>\n<blockquote>\n<p>每个java类运行时都在JVM里表现为一个class对象，可通过类名.class,类型.getClass(),Class.forName(“类名”)等方法获取class对象。</p>\n</blockquote>\n<p>可以通过下面三种方式获得Class对象：</p>\n<p>1.通过 类名.class 获取，可以认为每个类都有一个静态的Class对象。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c1 = Person.class;</span><br></pre></td></tr></table></figure></p>\n<p>2.通过类的对象获取<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person person = new Person();</span><br><span class=\"line\">Class c2 = person.getClass();</span><br></pre></td></tr></table></figure></p>\n<p>3.通过类名获取，<strong>动态加载</strong>（这个再很多地方都有使用，如：加载数据库驱动）<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c3 = null;</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">       c3 = Class.forName(&quot;Person&quot;);</span><br><span class=\"line\">   &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">       e.printStackTrace();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的<strong>c1/c2是Person的类类型，Person是Class类的对象。可以理解为一切类都是Class的对象</strong>。</p>\n<p>打印上面三种方法获取的Class对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(c1 == c2);//true</span><br><span class=\"line\">System.out.println(c1 == c3);//true</span><br><span class=\"line\">System.out.println(c2 == c3);//true</span><br></pre></td></tr></table></figure>\n<p>上面三种方式获取的Class对象，两两均相等。可见，可以理解为每个对象都有一个静态的Class变量。因为在java 中，<em>Object</em> 是一切类的父类，在Object中有一个获取Class对象的native(由C++或C语言实现，通过java 调用，具体的可参见jni相关的知识)方法。如下部分Object开头源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Object &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // ...</span><br><span class=\"line\">     </span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * Returns the runtime class of this &#123;@code Object&#125;. The returned</span><br><span class=\"line\">    * &#123;@code Class&#125; object is the object that is locked by &#123;@code</span><br><span class=\"line\">    * static synchronized&#125; methods of the represented class.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * &lt;p&gt;&lt;b&gt;The actual result type is &#123;@code Class&lt;? extends |X|&gt;&#125;</span><br><span class=\"line\">    * where &#123;@code |X|&#125; is the erasure of the static type of the</span><br><span class=\"line\">    * expression on which &#123;@code getClass&#125; is called.&lt;/b&gt; For</span><br><span class=\"line\">    * example, no cast is required in this code fragment:&lt;/p&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">    * @return The &#123;@code Class&#125; object that represents the runtime</span><br><span class=\"line\">    *         class of this object.</span><br><span class=\"line\">    *         </span><br><span class=\"line\">*/</span><br><span class=\"line\">   public final native Class&lt;?&gt; getClass();</span><br><span class=\"line\">   </span><br><span class=\"line\">  // ...</span><br></pre></td></tr></table></figure>\n<p>通过上面 getClass 方法前的部分注释，可以清楚的明白他的作用。</p>\n<h2 id=\"二、动态加载类\"><a href=\"#二、动态加载类\" class=\"headerlink\" title=\"二、动态加载类\"></a>二、动态加载类</h2><p>在java 中，使用new创建的对象都是静态加载的，这些类必须存在，不管在实际中是否使用，否则编译不通过。可以通过动态加载类来解决该问题。<br>通过Class类的forName方法进行加载,传入相应的名加载具体的类，可以使程序的扩展性更好，避免编译出错。</p>\n<p>该方法的原型为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Class&lt;?&gt; forName(String className)</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、使用Class获取类信息\"><a href=\"#三、使用Class获取类信息\" class=\"headerlink\" title=\"三、使用Class获取类信息\"></a>三、使用Class获取类信息</h2><p>Class类提供的部分获取类信息的方法如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法名</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">getFields()</td>\n<td style=\"text-align:center\">获取所有public类型的成员变量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">getDeclaredFields()</td>\n<td style=\"text-align:center\">获取该类自己声明的所有变量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">getConstructors()</td>\n<td style=\"text-align:center\">获取所所有public类型的构造方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">getDeclaredConstructors()</td>\n<td style=\"text-align:center\">获取所有的构造方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">getMethods()</td>\n<td style=\"text-align:center\">获取所有的public函数，包括父类继承来的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">getDeclaredMethods</td>\n<td style=\"text-align:center\">获取该类所有声明的方法</td>\n</tr>\n</tbody>\n</table>\n<p>上面分别为获取成员变量、构造方法和成员方法。</p>\n<p><strong>获取成员参数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ClassUtils &#123;</span><br><span class=\"line\">    public static void getClassField(Object obj) &#123;</span><br><span class=\"line\">            Class c = obj.getClass();</span><br><span class=\"line\">            Field[] fs = c.getDeclaredFields();// c.getMethods();</span><br><span class=\"line\">            for (Field f : fs) &#123;</span><br><span class=\"line\">                Class fieldType = f.getType();</span><br><span class=\"line\">                System.out.println(fieldType.getName() + &quot; &quot; + f.getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是获取所有成员变量的，获取的每个成员方法都是 <code>Fidld</code> 类型的对象。<br>如下测试代码获取String类中的成员变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassUtils.getClassField(&quot;reflect&quot;);</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[C value</span><br><span class=\"line\">int hash</span><br><span class=\"line\">long serialVersionUID</span><br><span class=\"line\">[Ljava.io.ObjectStreamField; serialPersistentFields</span><br><span class=\"line\">java.util.Comparator CASE_INSENSITIVE_ORDER</span><br></pre></td></tr></table></figure>\n<p>其中第一个和第三个表示的是数组。查看String中的源码，成员变量如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class String</span><br><span class=\"line\">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private final char value[];</span><br><span class=\"line\"></span><br><span class=\"line\">    private int hash; // Default to 0</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final long serialVersionUID = -6849794470754667710L;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final ObjectStreamField[] serialPersistentFields =</span><br><span class=\"line\">            new ObjectStreamField[0];</span><br><span class=\"line\">            </span><br><span class=\"line\">    //...</span><br><span class=\"line\">     public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class=\"line\">                                         = new CaseInsensitiveComparator();</span><br><span class=\"line\">    </span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样的可以调用该方法查看其他类中的成员变量。</p>\n<p><strong>获取构造方法和成员方法</strong></p>\n<p>类似于上面获取成员变量的方法，如下获取构造函数和成员方法则很好理解了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ClassUtils &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    </span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取所有的成员方法</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param obj</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void getClassMethods(Object obj) &#123;</span><br><span class=\"line\">        Class c = obj.getClass();</span><br><span class=\"line\">        System.out.println(&quot;类名为：&quot; + c.getName());</span><br><span class=\"line\">        Method[] ms = c.getDeclaredMethods();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Method m : ms) &#123;</span><br><span class=\"line\">            Class returnType = m.getReturnType();</span><br><span class=\"line\">            //返回值的类类型，如String--&gt;String.class</span><br><span class=\"line\">            System.out.print(returnType.getName() + &quot; &quot;);</span><br><span class=\"line\">            //方法名称</span><br><span class=\"line\">            System.out.print(m.getName() + &quot;(&quot;);</span><br><span class=\"line\">            //获取参数--参数列表的类类型</span><br><span class=\"line\">            Class[] paramTypes = m.getParameterTypes();</span><br><span class=\"line\">            int paramsNum = paramTypes.length;</span><br><span class=\"line\">            Class paramType;</span><br><span class=\"line\">            for (int i = 0; i &lt; paramsNum; i++) &#123;</span><br><span class=\"line\">                paramType = paramTypes[i];</span><br><span class=\"line\">                if (i == 1 || (i == paramsNum - 1))</span><br><span class=\"line\">                    System.out.print(paramType.getName());</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    System.out.print(paramType.getName() + &quot; ,&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;)&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取所有的构造函数</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param obj</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void printConMessage(Object obj) &#123;</span><br><span class=\"line\">        Class c = obj.getClass();</span><br><span class=\"line\">        Constructor[] cs = c.getDeclaredConstructors();</span><br><span class=\"line\">        for (Constructor constructor : cs) &#123;</span><br><span class=\"line\">            System.out.print(constructor.getName() + &quot; (&quot;);</span><br><span class=\"line\">            Class[] paramTypes = constructor.getParameterTypes();</span><br><span class=\"line\">            int paramsNum = paramTypes.length;</span><br><span class=\"line\">            Class paramType;</span><br><span class=\"line\">            for (int i = 0; i &lt; paramsNum; i++) &#123;</span><br><span class=\"line\">                paramType = paramTypes[i];</span><br><span class=\"line\">                if (i == 1 || (i == paramsNum - 1))</span><br><span class=\"line\">                    System.out.print(paramType.getName());</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    System.out.print(paramType.getName() + &quot; ,&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;)&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此处省略测试。</p>\n<h2 id=\"四、方法反射的基本操作\"><a href=\"#四、方法反射的基本操作\" class=\"headerlink\" title=\"四、方法反射的基本操作\"></a>四、方法反射的基本操作</h2><p>对于方法的获取，可以通过方法名称和参数列表来确定某个方法。主要使用了 <code>Method.invoke(对象,参数列表);</code> 操作。</p>\n<p><strong>首先需要获取类信息，然后指定方法名和参数获取方法对象，再通过<code>Method.invoke()</code>进行反射获取方法执行结果。若该方法无返回值，则invoke方法最后返回null,否则返回相应的结果</strong>。</p>\n<p>如下示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //1.获取类信息</span><br><span class=\"line\">        A a = new A();</span><br><span class=\"line\">        Class aClass = a.getClass();</span><br><span class=\"line\">        //2.获取方法名称和参数</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">//            Method method = aClass.getMethod(&quot;print&quot;,new Class[]&#123;int.class,int.class&#125;);</span><br><span class=\"line\">            Method method = aClass.getMethod(&quot;print&quot;, int.class, int.class);</span><br><span class=\"line\">            //方法返回结果：若无返回结果则o为null，否则为返回结果，这里返回为30</span><br><span class=\"line\">            Object o = method.invoke(a, 10, 20);</span><br><span class=\"line\">            System.out.println(o);//30</span><br><span class=\"line\">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//测试反射方法</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">    public int print(int a, int b) &#123;</span><br><span class=\"line\">        System.out.println(a + b);</span><br><span class=\"line\">        return a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void print(String a, String b) &#123;</span><br><span class=\"line\">        System.out.println(a.toUpperCase() + &quot;-----&quot; + b.toUpperCase());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 Method()和invoke()方法第二个参数为可变数组，可有可无，如果有接写。可以通过new数组的方式或者直接一个个写出。</p>\n<h2 id=\"五、通过反射了解集合泛型的本质\"><a href=\"#五、通过反射了解集合泛型的本质\" class=\"headerlink\" title=\"五、通过反射了解集合泛型的本质\"></a>五、通过反射了解集合泛型的本质</h2><p>我们都知道，在java中，定义集合指定什么泛型，就只能添加该类型的数据到集合中，否则就会报错。</p>\n<p>通过反射可以往集合中添加不同类型的数据，这样虽没有多大意义，不便于遍历。这里主要说明了集合在编译后是去泛型化的，集合的泛型可以防止错误输入，在编译极前有效。</p>\n<p>如下测试代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestDemo04 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; l1 = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        ArrayList l2 = new ArrayList();</span><br><span class=\"line\">        l1.add(&quot;java reflect&quot;);</span><br><span class=\"line\">//        datas.add(100);//报错</span><br><span class=\"line\">        Class c1 = l1.getClass();</span><br><span class=\"line\">        Class c2 = l2.getClass();</span><br><span class=\"line\">        System.out.println(c1 == c2);//true</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Method method = c2.getMethod(&quot;add&quot;, Object.class);</span><br><span class=\"line\">            method.invoke(l1, 100);</span><br><span class=\"line\">            System.out.println(&quot;数组大小：&quot;+l1.size());</span><br><span class=\"line\">            System.out.println(&quot;数组内容：&quot;+l1.toString());</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">true</span><br><span class=\"line\">数组大小：2</span><br><span class=\"line\">数组内容：[java reflect, 100]</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，通过反射往String类型的集合中添加了int类型的100。</p>\n<p>通过对反射的学习，发现反射是从.class到.java的过程，感觉像反编译字节码。以 <code>Class c1 = Person.class;</code>为例，Person.java类在编译后生成的字节码文件为Person.class,这里获取的Class正式这样的。</p>"},{"title":"java知识 之 对象及其内存管理","date":"2016-11-19T08:06:25.000Z","_content":"> 读书笔记：《疯狂java 程序员的基本修养》第二章——对象及其内存管理\n\n\njava中的内存管理分为两个方面：\n\n- **内存分配**：指创建java对象时JVM为该对象在堆空间中所分配的内存空间。\n \n- **内存回收**：指java 对象失去引用，变成垃圾时，JVM的垃圾回收机制自动清理该对象，并回收该对象所占用的内存。<!--more-->\n\n虽然JVM 内置了垃圾回收机制，但仍可能导致内存泄露、资源泄露等，所以我们不能肆无忌惮的创建对象。此外，垃圾回收机制是由一个后台线程完成，也是很消耗性能的。\n\n## 1.实例变量和类变量\njava程序中的变量，大体可以分为**成员变量**和**局部变量**。其中局部变量可分为如下三类：\n\n- **形参**：在方法名中定义的变量，有方法调用者负责为其赋值，随着方法的结束而消亡。\n- **方法内局部变量**：在方法内定义的变量，必须在方法内对其进行初始化。它从初始化完成后开始生效，随着方法结束而消亡。\n- **代码块内局部变量**：在代码块内定义的变量，必须在代码块内对其显示初始化。从初始化完成后生效，随着代码块的结束而消亡。\n\n*局部变量的作用时间很短暂，他们被存在栈内存中。*\n类体内定义的变量为成员变量。如果使用`static`修饰，则为静态变量或者类变量，否则成为非静态变量或者实例变量。\n> **static**:\n他的作用是将实例成员编程类成员。只能修饰在类里定义的成员部分，包括变量、方法、内部内（枚举与接口）、初始化块。不能用于修饰外部类、局部变量、局部内部类。\n\n**使用static修饰的成员变量是类类型，属于类本身，没有修饰的属于实例变量，属于该类的实例。在同一个JVM中，每个类可以创建多个java对象。同一个JVM中每个类只对应一个Class对象，机类变量只占一块内存空间，但是实例变量，每次创建便会分配一块内存空间。**\n\n```\nclass Person\n{\n\tString name;\n\tint age;\n\tstatic int eyeNum;\n\tpublic void info()\n\t{\n\t\tSystem.out.println(\"我的名字是：\" + name\n\t\t\t+ \"， 我的年龄是：\" + age);\n\t}\n}\npublic class FieldTest\n{\n\tpublic static void main(String[] args)\n\t{\n\t\t// 类变量属于该类本身，只要该类初始化完成，\n\t\t// 程序即可使用类变量。\n\t\tPerson.eyeNum = 2; \t\t  //①\n\t\t// 通过Person类访问eyeNum类变量\n\t\tSystem.out.println(\"Person的eyeNum属性：\"\n\t\t\t+ Person.eyeNum);\n\t\t// 创建第一个Person对象\n\t\tPerson p = new Person();\n\t\tp.name = \"猪八戒\";\n\t\tp.age = 300;\n\t\t// 通过p访问Person类的eyeNum类变量\n\t\tSystem.out.println(\"通过p变量访问eyeNum类变量：\"\n\t\t\t+ p.eyeNum);           //②\n\t\tp.info();\n\t\t// 创建第二个Person对象\n\t\tPerson p2 = new Person();\n\t\tp2.name = \"孙悟空\";\n\t\tp2.age = 500;\n\t\tp2.info();\n\t\t// 通过p2修改Person类的eyeNum类变量\n\t\tp2.eyeNum = 3;     \t\t   //③\n\t\t// 分别通过p、p2和Person访问Person类的eyeNum类变量\n\t\tSystem.out.println(\"通过p变量访问eyeNum类变量：\"\n\t\t\t+ p.eyeNum);\n\t\tSystem.out.println(\"通过p2变量访问eyeNum类变量：\"\n\t\t\t+ p2.eyeNum);\n\t\tSystem.out.println(\"通过Person类访问eyeNum类变量：\"\n\t\t\t+ Person.eyeNum);\n\t}\n}\n```\n上述代码中的内存分配如下：\n\n![](/img/article_img/2016/对象内存分配1.png)\n\n当Person类初始化完成，类变量也随之初始化完成，不管再创建多少个Person对象，系统都不再为 eyeNum 分配内存，但会为 name 和age 分配内存并初始化。当eyeNum值改变后，通过每个Person对象访问eyeNum的值都随之改变。\n\n### **a.实例变量的初始化**\n对于实例变量，它属于java对象本身，每次程序创建java对象时都会为其分配内存空间，并初始化。\n实例变量初始化地方：\n\n- 定义实例化变量时；\n- 非静态初始化块中；\n- 构造器中。\n\n其中前两种比第三种更早执行，而前两种的执行顺序与他们在程序中的排列顺序相同。它们三种作用完全类似，经过编译后都会提取到构造器中执行，且位于所有语句之前，定义变量赋值和初始化块赋值的顺序与他们在源代码中一致。\n\n可以使用 `javap`命令查看java编译器的机制：\n```\n用法: javap <options> <classes>\n其中, 可能的选项包括:\n-help  --help  -?        输出此用法消息\n-version                 版本信息\n-v  -verbose             输出附加信息\n-l                       输出行号和本地变量表\n-public                  仅显示公共类和成员\n-protected               显示受保护的/公共类和成员\n-package                 显示程序包/受保护的/公共类\n                       和成员 (默认)\n-p  -private             显示所有类和成员\n-c                       对代码进行反汇编\n-s                       输出内部类型签名\n-sysinfo                 显示正在处理的类的\n                       系统信息 (路径, 大小, 日期, MD5 散列)\n-constants               显示最终常量\n-classpath <path>        指定查找用户类文件的位置\n-cp <path>               指定查找用户类文件的位置\n-bootclasspath <path>    覆盖引导类文件的位置\n```\n\n### **b.类变量的初始化**\n类变量属于java 类本身，每次运行时才会初始化。\n类变量的初始化地方：\n\n- 定义类变量时初始化；\n- 静态代码块中初始化\n\n如下代码，表面上看输出的是：17.2,17.2；但是实际上输出的是：-2.8,17.2\n```\nclass Price\n{\n    // 类成员是Price实例\n    final static Price INSTANCE = new Price(2.8);\n    // 在定义一个类变量。\n    static double initPrice = 20;\n    // 定义该Price的currentPrice实例变量\n    double currentPrice;\n    public Price(double discount)\n    {\n        // 根据静态变量计算实例变量\n        currentPrice = initPrice - discount;\n    }\n}\npublic class PriceTest\n{\n    public static void main(String[] args)\n    {\n        // 通过Price的INSTANCE访问currentPrice实例变量\n        System.out.println(Price.INSTANCE.currentPrice);//输出：-2.8\n        // 显式创建Price实例\n        Price p = new Price(2.8);\n        // 通过先是创建的Price实例访问currentPrice实例变量\n        System.out.println(p.currentPrice);            //输出：17.2\n    }\n}\n```\n第一次使用Price 时，程序对其进行初始化，可分为两个阶段：\n（1）系统为类变量分配内存空间；\n（2）按初始化代码顺序对变量进行初始化。\n\n这里的运行结果为：-2.8,17.2\n**说明**：初始化第一阶段，系统先为 INSTANCE，initPrice两个类变量分配内存空间，他们的默认值为null和0.0，接着第二阶段依次为他们赋值。对 INSTANCE 赋值时要调用 Price(2.8),创建Price实例，为currentPrice赋值，此时，还未对 initPrice 赋值，就是用他的默认值0，则 currentPrice 值为-2.8，接着程序再次将 initPrice 赋值为20，但对于 currentPrice 实例变量已经不起作用了。\n\n以下为在ide中的debug结果截图：\n\n![](/img/article_img/2016/对象内存分配-debug.png)\n\n\n## 2.父类构造器\n\njava中，创建对象时，首先会依次调用每个父类的非静态初始化块、构造器（总是先从Object开始），然后再使用本类的非静态初始化块和构造器进行初始化。在调用父类时可以用`super`进行**显示调用**，也可以**隐式调用**。\n\n在子类调用父类构造器时，有以下几种场景：\n\n- 子类构造器第一行代码是用**super()**进行显示调用父类构造器，则根据super传入的参数调用相应的构造器；\n- 子类构造器第一行代码是用**this()**进行显示调用本类中重载的构造器，则根据传入this的参数调用相应的构造器；\n- 之类构造器中没有this和super,则在执行子类构造器前，隐式调用父类无参构造器。\n\n> 注：super和this都是显示调用构造器，只能在构造器中使用，且必须在第一行，只能使用它们其中之一，最多只能调用一次。\n\n\n一般情况下，子类对象可以访问父类的实例变量，但父类不能访问子类的，因为父类不知道它会被哪个子类继承，子类又会添加怎样的方法。但在极端的情况下，父类可以访问子类变量的情况，如下实例代码：\n```\npackage cn.imtianx.p02;\n\nclass Base {\n    private int i = 2;\n    public Base() {\n        this.display();//this：运行时是Driver类型，编译时是Base 类型，这里是Driver对象\n    }\n    public void display() {\n        System.out.println(i);\n    }\n}\n\n// 继承Base的Derived子类\nclass Derived extends Base {\n    private int i = 22;\n    public Derived() {\n        i = 222;\n    }\n    public void display() {\n        System.out.println(i);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        // 创建Derived的构造器创建实例\n        new Derived();\n    }\n}\n```\n上面的代码执行后，输出的并不是2、22或者222，而是**0**。在调用Derived 的构造器前会隐式调用Base的无参构造器，初始化 i= 2，此时如果输出`this.i`则为2，它访问的是Base 类中的实例变量，但是当调用`this.display()`时，表现的为Driver对象的行为，对于driver对象，它的变量i还未赋初始值，仅仅是为其开辟了内存空间，其值为0。\n\n**在java 中，构造器负责实例变量的初始化（即，赋初始值），在执行构造器前，该对象内存空间已经被分配了，他们在内存中存的事其类型所对应的默认值。**\n\n**在上面的代码中，出现了变量的编译时类型与运行时类型不同。通过该变量访问他所引用的对象的实例变量时，该实例变量的值由申明该变量的类型决定的，当通过该变量调用它所引用的实例对象的实例方法时，该方法将由它实际所引用的对象来决定**\n\n当子类重写父类方法时，也会出现父类调用之类方法的情形，如下具体代码，通过上面的则很容易理解。\n```\nclass Animal\n{\n\tprivate String desc;\n\tpublic Animal()\n\t{\n\t\tthis.desc = getDesc();       \n\t}\n\tpublic String getDesc()\n\t{\n\t\treturn \"Animal\";\n\t}\n\tpublic String toString()\n\t{\n\t\treturn desc;\n\t}\n}\npublic class Wolf extends Animal\n{\n\tprivate String name;\n\tprivate double weight;\n\tpublic Wolf(String name , double weight)\n\t{\n\t\tthis.name = name;\n\t\tthis.weight = weight;\n\t}\n\t// 重写父类的getDesc()方法\n\t@Override\n\tpublic String getDesc()\n\t{\n\t\treturn \"Wolf[name=\" + name + \" , weight=\"\n\t\t\t+ weight + \"]\";  //输出：Wolf[name=null , weight=0.0]\n\t}\n\tpublic static void main(String[] args)\n\t{\n\t\tSystem.out.println(new Wolf(\"灰太狼\" , 32.3)); \n\t}\n}\n```\n\n## 3.父子实例的内存控制\n\njava中的继承，在处理成员变量和方法时是不同的。如果之类重写了父类的方法，则完全覆盖父类的方法，并将其其移到子类中，但如果是完全同名的实例变量，则不会覆盖，不会从父类中移到子类中。所以，对于一个引用类型的变量，如果访问他所引用对象的实例变量时，该实例变量的值取决于申明该变量的类型，而调用方法时，则取决于它实际引用对象的类型。\n\n在继承中，内存中子类实例保存有父类的变量的实例。\n\n```\nclass Base {\n    int count = 2;\n}\nclass Mid extends Base {\n    int count = 20;\n}\npublic class Sub extends Mid {\n    int count = 200;\n    public static void main(String[] args) {\n        // 创建一个Sub对象\n        Sub s = new Sub();\n        // 将Sub对象向上转型后赋为Mid、Base类型的变量\n        Mid s2m = s;\n        Base s2b = s;\n        // 分别通过3个变量来访问count实例变量\n        System.out.println(s.count);    //输出：200\n        System.out.println(s2m.count);    //输出：20\n        System.out.println(s2b.count);    //输出：2\n    }\n}\n```\n内存中的示意图：\n\n![](/img/article_img/2016/对象内存分配2.png)\n\n在内存中只有一个Sub对象，并没有Mid和Base对象，但存在3个count的实例变量。\n\n**子类中会隐藏父类的变量可以通过super来获取,对于类变量，也可以通过super来访问。**\n\n## 4.final 修饰符\n\nfinal 的修饰范围：\n\n- 修饰变量，被赋初始值后不可重新赋值；\n- 修饰方法 ，不能被重写；\n- 修饰类，不能派生出子类。\n\n对于final 类型的变量，初始化可以在：定义时、非静态代码块和构造器中；对于final 类型的类变量，初始化可以在：定义时和静态代码块中。\n\n> 当final类型的变量定义时就指定初始值，那么该该变量本质上是一个“宏变量”，编译器会把用到该变量的地方直接用其值替换。\n\n如果在内部内中使用局部变量，必须将其指定为final类型的。普通的变量作用域就是该方法，随着方法的执行结束，局部变量也随之消失，但内部类可能产生隐式的“闭包”，使局部变量脱离它所在的方法继续存在。内部内可能扩大局部变量的作用域，如果内部内中访问的局部变量没有适用final修饰，则可以随意修改它的值，这样将会引起混乱，所以编译器要求被内部访问的局部变量必须使用final 修饰。\n\n\n\n\n\n","source":"_posts/java 知识之 对象及其内存管理.md","raw":"---\ntitle: java知识 之 对象及其内存管理\ndate: 2016-11-19 16:06:25\ncategories: [java,高级知识]\ntags: [java,对象,内存管理]\n---\n> 读书笔记：《疯狂java 程序员的基本修养》第二章——对象及其内存管理\n\n\njava中的内存管理分为两个方面：\n\n- **内存分配**：指创建java对象时JVM为该对象在堆空间中所分配的内存空间。\n \n- **内存回收**：指java 对象失去引用，变成垃圾时，JVM的垃圾回收机制自动清理该对象，并回收该对象所占用的内存。<!--more-->\n\n虽然JVM 内置了垃圾回收机制，但仍可能导致内存泄露、资源泄露等，所以我们不能肆无忌惮的创建对象。此外，垃圾回收机制是由一个后台线程完成，也是很消耗性能的。\n\n## 1.实例变量和类变量\njava程序中的变量，大体可以分为**成员变量**和**局部变量**。其中局部变量可分为如下三类：\n\n- **形参**：在方法名中定义的变量，有方法调用者负责为其赋值，随着方法的结束而消亡。\n- **方法内局部变量**：在方法内定义的变量，必须在方法内对其进行初始化。它从初始化完成后开始生效，随着方法结束而消亡。\n- **代码块内局部变量**：在代码块内定义的变量，必须在代码块内对其显示初始化。从初始化完成后生效，随着代码块的结束而消亡。\n\n*局部变量的作用时间很短暂，他们被存在栈内存中。*\n类体内定义的变量为成员变量。如果使用`static`修饰，则为静态变量或者类变量，否则成为非静态变量或者实例变量。\n> **static**:\n他的作用是将实例成员编程类成员。只能修饰在类里定义的成员部分，包括变量、方法、内部内（枚举与接口）、初始化块。不能用于修饰外部类、局部变量、局部内部类。\n\n**使用static修饰的成员变量是类类型，属于类本身，没有修饰的属于实例变量，属于该类的实例。在同一个JVM中，每个类可以创建多个java对象。同一个JVM中每个类只对应一个Class对象，机类变量只占一块内存空间，但是实例变量，每次创建便会分配一块内存空间。**\n\n```\nclass Person\n{\n\tString name;\n\tint age;\n\tstatic int eyeNum;\n\tpublic void info()\n\t{\n\t\tSystem.out.println(\"我的名字是：\" + name\n\t\t\t+ \"， 我的年龄是：\" + age);\n\t}\n}\npublic class FieldTest\n{\n\tpublic static void main(String[] args)\n\t{\n\t\t// 类变量属于该类本身，只要该类初始化完成，\n\t\t// 程序即可使用类变量。\n\t\tPerson.eyeNum = 2; \t\t  //①\n\t\t// 通过Person类访问eyeNum类变量\n\t\tSystem.out.println(\"Person的eyeNum属性：\"\n\t\t\t+ Person.eyeNum);\n\t\t// 创建第一个Person对象\n\t\tPerson p = new Person();\n\t\tp.name = \"猪八戒\";\n\t\tp.age = 300;\n\t\t// 通过p访问Person类的eyeNum类变量\n\t\tSystem.out.println(\"通过p变量访问eyeNum类变量：\"\n\t\t\t+ p.eyeNum);           //②\n\t\tp.info();\n\t\t// 创建第二个Person对象\n\t\tPerson p2 = new Person();\n\t\tp2.name = \"孙悟空\";\n\t\tp2.age = 500;\n\t\tp2.info();\n\t\t// 通过p2修改Person类的eyeNum类变量\n\t\tp2.eyeNum = 3;     \t\t   //③\n\t\t// 分别通过p、p2和Person访问Person类的eyeNum类变量\n\t\tSystem.out.println(\"通过p变量访问eyeNum类变量：\"\n\t\t\t+ p.eyeNum);\n\t\tSystem.out.println(\"通过p2变量访问eyeNum类变量：\"\n\t\t\t+ p2.eyeNum);\n\t\tSystem.out.println(\"通过Person类访问eyeNum类变量：\"\n\t\t\t+ Person.eyeNum);\n\t}\n}\n```\n上述代码中的内存分配如下：\n\n![](/img/article_img/2016/对象内存分配1.png)\n\n当Person类初始化完成，类变量也随之初始化完成，不管再创建多少个Person对象，系统都不再为 eyeNum 分配内存，但会为 name 和age 分配内存并初始化。当eyeNum值改变后，通过每个Person对象访问eyeNum的值都随之改变。\n\n### **a.实例变量的初始化**\n对于实例变量，它属于java对象本身，每次程序创建java对象时都会为其分配内存空间，并初始化。\n实例变量初始化地方：\n\n- 定义实例化变量时；\n- 非静态初始化块中；\n- 构造器中。\n\n其中前两种比第三种更早执行，而前两种的执行顺序与他们在程序中的排列顺序相同。它们三种作用完全类似，经过编译后都会提取到构造器中执行，且位于所有语句之前，定义变量赋值和初始化块赋值的顺序与他们在源代码中一致。\n\n可以使用 `javap`命令查看java编译器的机制：\n```\n用法: javap <options> <classes>\n其中, 可能的选项包括:\n-help  --help  -?        输出此用法消息\n-version                 版本信息\n-v  -verbose             输出附加信息\n-l                       输出行号和本地变量表\n-public                  仅显示公共类和成员\n-protected               显示受保护的/公共类和成员\n-package                 显示程序包/受保护的/公共类\n                       和成员 (默认)\n-p  -private             显示所有类和成员\n-c                       对代码进行反汇编\n-s                       输出内部类型签名\n-sysinfo                 显示正在处理的类的\n                       系统信息 (路径, 大小, 日期, MD5 散列)\n-constants               显示最终常量\n-classpath <path>        指定查找用户类文件的位置\n-cp <path>               指定查找用户类文件的位置\n-bootclasspath <path>    覆盖引导类文件的位置\n```\n\n### **b.类变量的初始化**\n类变量属于java 类本身，每次运行时才会初始化。\n类变量的初始化地方：\n\n- 定义类变量时初始化；\n- 静态代码块中初始化\n\n如下代码，表面上看输出的是：17.2,17.2；但是实际上输出的是：-2.8,17.2\n```\nclass Price\n{\n    // 类成员是Price实例\n    final static Price INSTANCE = new Price(2.8);\n    // 在定义一个类变量。\n    static double initPrice = 20;\n    // 定义该Price的currentPrice实例变量\n    double currentPrice;\n    public Price(double discount)\n    {\n        // 根据静态变量计算实例变量\n        currentPrice = initPrice - discount;\n    }\n}\npublic class PriceTest\n{\n    public static void main(String[] args)\n    {\n        // 通过Price的INSTANCE访问currentPrice实例变量\n        System.out.println(Price.INSTANCE.currentPrice);//输出：-2.8\n        // 显式创建Price实例\n        Price p = new Price(2.8);\n        // 通过先是创建的Price实例访问currentPrice实例变量\n        System.out.println(p.currentPrice);            //输出：17.2\n    }\n}\n```\n第一次使用Price 时，程序对其进行初始化，可分为两个阶段：\n（1）系统为类变量分配内存空间；\n（2）按初始化代码顺序对变量进行初始化。\n\n这里的运行结果为：-2.8,17.2\n**说明**：初始化第一阶段，系统先为 INSTANCE，initPrice两个类变量分配内存空间，他们的默认值为null和0.0，接着第二阶段依次为他们赋值。对 INSTANCE 赋值时要调用 Price(2.8),创建Price实例，为currentPrice赋值，此时，还未对 initPrice 赋值，就是用他的默认值0，则 currentPrice 值为-2.8，接着程序再次将 initPrice 赋值为20，但对于 currentPrice 实例变量已经不起作用了。\n\n以下为在ide中的debug结果截图：\n\n![](/img/article_img/2016/对象内存分配-debug.png)\n\n\n## 2.父类构造器\n\njava中，创建对象时，首先会依次调用每个父类的非静态初始化块、构造器（总是先从Object开始），然后再使用本类的非静态初始化块和构造器进行初始化。在调用父类时可以用`super`进行**显示调用**，也可以**隐式调用**。\n\n在子类调用父类构造器时，有以下几种场景：\n\n- 子类构造器第一行代码是用**super()**进行显示调用父类构造器，则根据super传入的参数调用相应的构造器；\n- 子类构造器第一行代码是用**this()**进行显示调用本类中重载的构造器，则根据传入this的参数调用相应的构造器；\n- 之类构造器中没有this和super,则在执行子类构造器前，隐式调用父类无参构造器。\n\n> 注：super和this都是显示调用构造器，只能在构造器中使用，且必须在第一行，只能使用它们其中之一，最多只能调用一次。\n\n\n一般情况下，子类对象可以访问父类的实例变量，但父类不能访问子类的，因为父类不知道它会被哪个子类继承，子类又会添加怎样的方法。但在极端的情况下，父类可以访问子类变量的情况，如下实例代码：\n```\npackage cn.imtianx.p02;\n\nclass Base {\n    private int i = 2;\n    public Base() {\n        this.display();//this：运行时是Driver类型，编译时是Base 类型，这里是Driver对象\n    }\n    public void display() {\n        System.out.println(i);\n    }\n}\n\n// 继承Base的Derived子类\nclass Derived extends Base {\n    private int i = 22;\n    public Derived() {\n        i = 222;\n    }\n    public void display() {\n        System.out.println(i);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        // 创建Derived的构造器创建实例\n        new Derived();\n    }\n}\n```\n上面的代码执行后，输出的并不是2、22或者222，而是**0**。在调用Derived 的构造器前会隐式调用Base的无参构造器，初始化 i= 2，此时如果输出`this.i`则为2，它访问的是Base 类中的实例变量，但是当调用`this.display()`时，表现的为Driver对象的行为，对于driver对象，它的变量i还未赋初始值，仅仅是为其开辟了内存空间，其值为0。\n\n**在java 中，构造器负责实例变量的初始化（即，赋初始值），在执行构造器前，该对象内存空间已经被分配了，他们在内存中存的事其类型所对应的默认值。**\n\n**在上面的代码中，出现了变量的编译时类型与运行时类型不同。通过该变量访问他所引用的对象的实例变量时，该实例变量的值由申明该变量的类型决定的，当通过该变量调用它所引用的实例对象的实例方法时，该方法将由它实际所引用的对象来决定**\n\n当子类重写父类方法时，也会出现父类调用之类方法的情形，如下具体代码，通过上面的则很容易理解。\n```\nclass Animal\n{\n\tprivate String desc;\n\tpublic Animal()\n\t{\n\t\tthis.desc = getDesc();       \n\t}\n\tpublic String getDesc()\n\t{\n\t\treturn \"Animal\";\n\t}\n\tpublic String toString()\n\t{\n\t\treturn desc;\n\t}\n}\npublic class Wolf extends Animal\n{\n\tprivate String name;\n\tprivate double weight;\n\tpublic Wolf(String name , double weight)\n\t{\n\t\tthis.name = name;\n\t\tthis.weight = weight;\n\t}\n\t// 重写父类的getDesc()方法\n\t@Override\n\tpublic String getDesc()\n\t{\n\t\treturn \"Wolf[name=\" + name + \" , weight=\"\n\t\t\t+ weight + \"]\";  //输出：Wolf[name=null , weight=0.0]\n\t}\n\tpublic static void main(String[] args)\n\t{\n\t\tSystem.out.println(new Wolf(\"灰太狼\" , 32.3)); \n\t}\n}\n```\n\n## 3.父子实例的内存控制\n\njava中的继承，在处理成员变量和方法时是不同的。如果之类重写了父类的方法，则完全覆盖父类的方法，并将其其移到子类中，但如果是完全同名的实例变量，则不会覆盖，不会从父类中移到子类中。所以，对于一个引用类型的变量，如果访问他所引用对象的实例变量时，该实例变量的值取决于申明该变量的类型，而调用方法时，则取决于它实际引用对象的类型。\n\n在继承中，内存中子类实例保存有父类的变量的实例。\n\n```\nclass Base {\n    int count = 2;\n}\nclass Mid extends Base {\n    int count = 20;\n}\npublic class Sub extends Mid {\n    int count = 200;\n    public static void main(String[] args) {\n        // 创建一个Sub对象\n        Sub s = new Sub();\n        // 将Sub对象向上转型后赋为Mid、Base类型的变量\n        Mid s2m = s;\n        Base s2b = s;\n        // 分别通过3个变量来访问count实例变量\n        System.out.println(s.count);    //输出：200\n        System.out.println(s2m.count);    //输出：20\n        System.out.println(s2b.count);    //输出：2\n    }\n}\n```\n内存中的示意图：\n\n![](/img/article_img/2016/对象内存分配2.png)\n\n在内存中只有一个Sub对象，并没有Mid和Base对象，但存在3个count的实例变量。\n\n**子类中会隐藏父类的变量可以通过super来获取,对于类变量，也可以通过super来访问。**\n\n## 4.final 修饰符\n\nfinal 的修饰范围：\n\n- 修饰变量，被赋初始值后不可重新赋值；\n- 修饰方法 ，不能被重写；\n- 修饰类，不能派生出子类。\n\n对于final 类型的变量，初始化可以在：定义时、非静态代码块和构造器中；对于final 类型的类变量，初始化可以在：定义时和静态代码块中。\n\n> 当final类型的变量定义时就指定初始值，那么该该变量本质上是一个“宏变量”，编译器会把用到该变量的地方直接用其值替换。\n\n如果在内部内中使用局部变量，必须将其指定为final类型的。普通的变量作用域就是该方法，随着方法的执行结束，局部变量也随之消失，但内部类可能产生隐式的“闭包”，使局部变量脱离它所在的方法继续存在。内部内可能扩大局部变量的作用域，如果内部内中访问的局部变量没有适用final修饰，则可以随意修改它的值，这样将会引起混乱，所以编译器要求被内部访问的局部变量必须使用final 修饰。\n\n\n\n\n\n","slug":"java 知识之 对象及其内存管理","published":1,"updated":"2016-11-24T06:33:03.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucib002pg0g5gmfo79gv","content":"<blockquote>\n<p>读书笔记：《疯狂java 程序员的基本修养》第二章——对象及其内存管理</p>\n</blockquote>\n<p>java中的内存管理分为两个方面：</p>\n<ul>\n<li><p><strong>内存分配</strong>：指创建java对象时JVM为该对象在堆空间中所分配的内存空间。</p>\n</li>\n<li><p><strong>内存回收</strong>：指java 对象失去引用，变成垃圾时，JVM的垃圾回收机制自动清理该对象，并回收该对象所占用的内存。<a id=\"more\"></a></p>\n</li>\n</ul>\n<p>虽然JVM 内置了垃圾回收机制，但仍可能导致内存泄露、资源泄露等，所以我们不能肆无忌惮的创建对象。此外，垃圾回收机制是由一个后台线程完成，也是很消耗性能的。</p>\n<h2 id=\"1-实例变量和类变量\"><a href=\"#1-实例变量和类变量\" class=\"headerlink\" title=\"1.实例变量和类变量\"></a>1.实例变量和类变量</h2><p>java程序中的变量，大体可以分为<strong>成员变量</strong>和<strong>局部变量</strong>。其中局部变量可分为如下三类：</p>\n<ul>\n<li><strong>形参</strong>：在方法名中定义的变量，有方法调用者负责为其赋值，随着方法的结束而消亡。</li>\n<li><strong>方法内局部变量</strong>：在方法内定义的变量，必须在方法内对其进行初始化。它从初始化完成后开始生效，随着方法结束而消亡。</li>\n<li><strong>代码块内局部变量</strong>：在代码块内定义的变量，必须在代码块内对其显示初始化。从初始化完成后生效，随着代码块的结束而消亡。</li>\n</ul>\n<p><em>局部变量的作用时间很短暂，他们被存在栈内存中。</em><br>类体内定义的变量为成员变量。如果使用<code>static</code>修饰，则为静态变量或者类变量，否则成为非静态变量或者实例变量。</p>\n<blockquote>\n<p><strong>static</strong>:<br>他的作用是将实例成员编程类成员。只能修饰在类里定义的成员部分，包括变量、方法、内部内（枚举与接口）、初始化块。不能用于修饰外部类、局部变量、局部内部类。</p>\n</blockquote>\n<p><strong>使用static修饰的成员变量是类类型，属于类本身，没有修饰的属于实例变量，属于该类的实例。在同一个JVM中，每个类可以创建多个java对象。同一个JVM中每个类只对应一个Class对象，机类变量只占一块内存空间，但是实例变量，每次创建便会分配一块内存空间。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tstatic int eyeNum;</span><br><span class=\"line\">\tpublic void info()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;我的名字是：&quot; + name</span><br><span class=\"line\">\t\t\t+ &quot;， 我的年龄是：&quot; + age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class FieldTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t// 类变量属于该类本身，只要该类初始化完成，</span><br><span class=\"line\">\t\t// 程序即可使用类变量。</span><br><span class=\"line\">\t\tPerson.eyeNum = 2; \t\t  //①</span><br><span class=\"line\">\t\t// 通过Person类访问eyeNum类变量</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Person的eyeNum属性：&quot;</span><br><span class=\"line\">\t\t\t+ Person.eyeNum);</span><br><span class=\"line\">\t\t// 创建第一个Person对象</span><br><span class=\"line\">\t\tPerson p = new Person();</span><br><span class=\"line\">\t\tp.name = &quot;猪八戒&quot;;</span><br><span class=\"line\">\t\tp.age = 300;</span><br><span class=\"line\">\t\t// 通过p访问Person类的eyeNum类变量</span><br><span class=\"line\">\t\tSystem.out.println(&quot;通过p变量访问eyeNum类变量：&quot;</span><br><span class=\"line\">\t\t\t+ p.eyeNum);           //②</span><br><span class=\"line\">\t\tp.info();</span><br><span class=\"line\">\t\t// 创建第二个Person对象</span><br><span class=\"line\">\t\tPerson p2 = new Person();</span><br><span class=\"line\">\t\tp2.name = &quot;孙悟空&quot;;</span><br><span class=\"line\">\t\tp2.age = 500;</span><br><span class=\"line\">\t\tp2.info();</span><br><span class=\"line\">\t\t// 通过p2修改Person类的eyeNum类变量</span><br><span class=\"line\">\t\tp2.eyeNum = 3;     \t\t   //③</span><br><span class=\"line\">\t\t// 分别通过p、p2和Person访问Person类的eyeNum类变量</span><br><span class=\"line\">\t\tSystem.out.println(&quot;通过p变量访问eyeNum类变量：&quot;</span><br><span class=\"line\">\t\t\t+ p.eyeNum);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;通过p2变量访问eyeNum类变量：&quot;</span><br><span class=\"line\">\t\t\t+ p2.eyeNum);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;通过Person类访问eyeNum类变量：&quot;</span><br><span class=\"line\">\t\t\t+ Person.eyeNum);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中的内存分配如下：</p>\n<p><img src=\"/img/article_img/2016/对象内存分配1.png\" alt=\"\"></p>\n<p>当Person类初始化完成，类变量也随之初始化完成，不管再创建多少个Person对象，系统都不再为 eyeNum 分配内存，但会为 name 和age 分配内存并初始化。当eyeNum值改变后，通过每个Person对象访问eyeNum的值都随之改变。</p>\n<h3 id=\"a-实例变量的初始化\"><a href=\"#a-实例变量的初始化\" class=\"headerlink\" title=\"a.实例变量的初始化\"></a><strong>a.实例变量的初始化</strong></h3><p>对于实例变量，它属于java对象本身，每次程序创建java对象时都会为其分配内存空间，并初始化。<br>实例变量初始化地方：</p>\n<ul>\n<li>定义实例化变量时；</li>\n<li>非静态初始化块中；</li>\n<li>构造器中。</li>\n</ul>\n<p>其中前两种比第三种更早执行，而前两种的执行顺序与他们在程序中的排列顺序相同。它们三种作用完全类似，经过编译后都会提取到构造器中执行，且位于所有语句之前，定义变量赋值和初始化块赋值的顺序与他们在源代码中一致。</p>\n<p>可以使用 <code>javap</code>命令查看java编译器的机制：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class=\"line\">其中, 可能的选项包括:</span><br><span class=\"line\">-help  --help  -?        输出此用法消息</span><br><span class=\"line\">-version                 版本信息</span><br><span class=\"line\">-v  -verbose             输出附加信息</span><br><span class=\"line\">-l                       输出行号和本地变量表</span><br><span class=\"line\">-public                  仅显示公共类和成员</span><br><span class=\"line\">-protected               显示受保护的/公共类和成员</span><br><span class=\"line\">-package                 显示程序包/受保护的/公共类</span><br><span class=\"line\">                       和成员 (默认)</span><br><span class=\"line\">-p  -private             显示所有类和成员</span><br><span class=\"line\">-c                       对代码进行反汇编</span><br><span class=\"line\">-s                       输出内部类型签名</span><br><span class=\"line\">-sysinfo                 显示正在处理的类的</span><br><span class=\"line\">                       系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class=\"line\">-constants               显示最终常量</span><br><span class=\"line\">-classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class=\"line\">-cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class=\"line\">-bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"b-类变量的初始化\"><a href=\"#b-类变量的初始化\" class=\"headerlink\" title=\"b.类变量的初始化\"></a><strong>b.类变量的初始化</strong></h3><p>类变量属于java 类本身，每次运行时才会初始化。<br>类变量的初始化地方：</p>\n<ul>\n<li>定义类变量时初始化；</li>\n<li>静态代码块中初始化</li>\n</ul>\n<p>如下代码，表面上看输出的是：17.2,17.2；但是实际上输出的是：-2.8,17.2<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Price</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 类成员是Price实例</span><br><span class=\"line\">    final static Price INSTANCE = new Price(2.8);</span><br><span class=\"line\">    // 在定义一个类变量。</span><br><span class=\"line\">    static double initPrice = 20;</span><br><span class=\"line\">    // 定义该Price的currentPrice实例变量</span><br><span class=\"line\">    double currentPrice;</span><br><span class=\"line\">    public Price(double discount)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 根据静态变量计算实例变量</span><br><span class=\"line\">        currentPrice = initPrice - discount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class PriceTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public static void main(String[] args)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 通过Price的INSTANCE访问currentPrice实例变量</span><br><span class=\"line\">        System.out.println(Price.INSTANCE.currentPrice);//输出：-2.8</span><br><span class=\"line\">        // 显式创建Price实例</span><br><span class=\"line\">        Price p = new Price(2.8);</span><br><span class=\"line\">        // 通过先是创建的Price实例访问currentPrice实例变量</span><br><span class=\"line\">        System.out.println(p.currentPrice);            //输出：17.2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第一次使用Price 时，程序对其进行初始化，可分为两个阶段：<br>（1）系统为类变量分配内存空间；<br>（2）按初始化代码顺序对变量进行初始化。</p>\n<p>这里的运行结果为：-2.8,17.2<br><strong>说明</strong>：初始化第一阶段，系统先为 INSTANCE，initPrice两个类变量分配内存空间，他们的默认值为null和0.0，接着第二阶段依次为他们赋值。对 INSTANCE 赋值时要调用 Price(2.8),创建Price实例，为currentPrice赋值，此时，还未对 initPrice 赋值，就是用他的默认值0，则 currentPrice 值为-2.8，接着程序再次将 initPrice 赋值为20，但对于 currentPrice 实例变量已经不起作用了。</p>\n<p>以下为在ide中的debug结果截图：</p>\n<p><img src=\"/img/article_img/2016/对象内存分配-debug.png\" alt=\"\"></p>\n<h2 id=\"2-父类构造器\"><a href=\"#2-父类构造器\" class=\"headerlink\" title=\"2.父类构造器\"></a>2.父类构造器</h2><p>java中，创建对象时，首先会依次调用每个父类的非静态初始化块、构造器（总是先从Object开始），然后再使用本类的非静态初始化块和构造器进行初始化。在调用父类时可以用<code>super</code>进行<strong>显示调用</strong>，也可以<strong>隐式调用</strong>。</p>\n<p>在子类调用父类构造器时，有以下几种场景：</p>\n<ul>\n<li>子类构造器第一行代码是用<strong>super()</strong>进行显示调用父类构造器，则根据super传入的参数调用相应的构造器；</li>\n<li>子类构造器第一行代码是用<strong>this()</strong>进行显示调用本类中重载的构造器，则根据传入this的参数调用相应的构造器；</li>\n<li>之类构造器中没有this和super,则在执行子类构造器前，隐式调用父类无参构造器。</li>\n</ul>\n<blockquote>\n<p>注：super和this都是显示调用构造器，只能在构造器中使用，且必须在第一行，只能使用它们其中之一，最多只能调用一次。</p>\n</blockquote>\n<p>一般情况下，子类对象可以访问父类的实例变量，但父类不能访问子类的，因为父类不知道它会被哪个子类继承，子类又会添加怎样的方法。但在极端的情况下，父类可以访问子类变量的情况，如下实例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.imtianx.p02;</span><br><span class=\"line\"></span><br><span class=\"line\">class Base &#123;</span><br><span class=\"line\">    private int i = 2;</span><br><span class=\"line\">    public Base() &#123;</span><br><span class=\"line\">        this.display();//this：运行时是Driver类型，编译时是Base 类型，这里是Driver对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void display() &#123;</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承Base的Derived子类</span><br><span class=\"line\">class Derived extends Base &#123;</span><br><span class=\"line\">    private int i = 22;</span><br><span class=\"line\">    public Derived() &#123;</span><br><span class=\"line\">        i = 222;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void display() &#123;</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 创建Derived的构造器创建实例</span><br><span class=\"line\">        new Derived();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码执行后，输出的并不是2、22或者222，而是<strong>0</strong>。在调用Derived 的构造器前会隐式调用Base的无参构造器，初始化 i= 2，此时如果输出<code>this.i</code>则为2，它访问的是Base 类中的实例变量，但是当调用<code>this.display()</code>时，表现的为Driver对象的行为，对于driver对象，它的变量i还未赋初始值，仅仅是为其开辟了内存空间，其值为0。</p>\n<p><strong>在java 中，构造器负责实例变量的初始化（即，赋初始值），在执行构造器前，该对象内存空间已经被分配了，他们在内存中存的事其类型所对应的默认值。</strong></p>\n<p><strong>在上面的代码中，出现了变量的编译时类型与运行时类型不同。通过该变量访问他所引用的对象的实例变量时，该实例变量的值由申明该变量的类型决定的，当通过该变量调用它所引用的实例对象的实例方法时，该方法将由它实际所引用的对象来决定</strong></p>\n<p>当子类重写父类方法时，也会出现父类调用之类方法的情形，如下具体代码，通过上面的则很容易理解。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate String desc;</span><br><span class=\"line\">\tpublic Animal()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthis.desc = getDesc();       </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic String getDesc()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn &quot;Animal&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic String toString()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn desc;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Wolf extends Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate String name;</span><br><span class=\"line\">\tprivate double weight;</span><br><span class=\"line\">\tpublic Wolf(String name , double weight)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthis.name = name;</span><br><span class=\"line\">\t\tthis.weight = weight;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 重写父类的getDesc()方法</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic String getDesc()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn &quot;Wolf[name=&quot; + name + &quot; , weight=&quot;</span><br><span class=\"line\">\t\t\t+ weight + &quot;]&quot;;  //输出：Wolf[name=null , weight=0.0]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static void main(String[] args)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(new Wolf(&quot;灰太狼&quot; , 32.3)); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-父子实例的内存控制\"><a href=\"#3-父子实例的内存控制\" class=\"headerlink\" title=\"3.父子实例的内存控制\"></a>3.父子实例的内存控制</h2><p>java中的继承，在处理成员变量和方法时是不同的。如果之类重写了父类的方法，则完全覆盖父类的方法，并将其其移到子类中，但如果是完全同名的实例变量，则不会覆盖，不会从父类中移到子类中。所以，对于一个引用类型的变量，如果访问他所引用对象的实例变量时，该实例变量的值取决于申明该变量的类型，而调用方法时，则取决于它实际引用对象的类型。</p>\n<p>在继承中，内存中子类实例保存有父类的变量的实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123;</span><br><span class=\"line\">    int count = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Mid extends Base &#123;</span><br><span class=\"line\">    int count = 20;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Sub extends Mid &#123;</span><br><span class=\"line\">    int count = 200;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 创建一个Sub对象</span><br><span class=\"line\">        Sub s = new Sub();</span><br><span class=\"line\">        // 将Sub对象向上转型后赋为Mid、Base类型的变量</span><br><span class=\"line\">        Mid s2m = s;</span><br><span class=\"line\">        Base s2b = s;</span><br><span class=\"line\">        // 分别通过3个变量来访问count实例变量</span><br><span class=\"line\">        System.out.println(s.count);    //输出：200</span><br><span class=\"line\">        System.out.println(s2m.count);    //输出：20</span><br><span class=\"line\">        System.out.println(s2b.count);    //输出：2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内存中的示意图：</p>\n<p><img src=\"/img/article_img/2016/对象内存分配2.png\" alt=\"\"></p>\n<p>在内存中只有一个Sub对象，并没有Mid和Base对象，但存在3个count的实例变量。</p>\n<p><strong>子类中会隐藏父类的变量可以通过super来获取,对于类变量，也可以通过super来访问。</strong></p>\n<h2 id=\"4-final-修饰符\"><a href=\"#4-final-修饰符\" class=\"headerlink\" title=\"4.final 修饰符\"></a>4.final 修饰符</h2><p>final 的修饰范围：</p>\n<ul>\n<li>修饰变量，被赋初始值后不可重新赋值；</li>\n<li>修饰方法 ，不能被重写；</li>\n<li>修饰类，不能派生出子类。</li>\n</ul>\n<p>对于final 类型的变量，初始化可以在：定义时、非静态代码块和构造器中；对于final 类型的类变量，初始化可以在：定义时和静态代码块中。</p>\n<blockquote>\n<p>当final类型的变量定义时就指定初始值，那么该该变量本质上是一个“宏变量”，编译器会把用到该变量的地方直接用其值替换。</p>\n</blockquote>\n<p>如果在内部内中使用局部变量，必须将其指定为final类型的。普通的变量作用域就是该方法，随着方法的执行结束，局部变量也随之消失，但内部类可能产生隐式的“闭包”，使局部变量脱离它所在的方法继续存在。内部内可能扩大局部变量的作用域，如果内部内中访问的局部变量没有适用final修饰，则可以随意修改它的值，这样将会引起混乱，所以编译器要求被内部访问的局部变量必须使用final 修饰。</p>\n","excerpt":"<blockquote>\n<p>读书笔记：《疯狂java 程序员的基本修养》第二章——对象及其内存管理</p>\n</blockquote>\n<p>java中的内存管理分为两个方面：</p>\n<ul>\n<li><p><strong>内存分配</strong>：指创建java对象时JVM为该对象在堆空间中所分配的内存空间。</p>\n</li>\n<li><p><strong>内存回收</strong>：指java 对象失去引用，变成垃圾时，JVM的垃圾回收机制自动清理该对象，并回收该对象所占用的内存。","more":"</p>\n</li>\n</ul>\n<p>虽然JVM 内置了垃圾回收机制，但仍可能导致内存泄露、资源泄露等，所以我们不能肆无忌惮的创建对象。此外，垃圾回收机制是由一个后台线程完成，也是很消耗性能的。</p>\n<h2 id=\"1-实例变量和类变量\"><a href=\"#1-实例变量和类变量\" class=\"headerlink\" title=\"1.实例变量和类变量\"></a>1.实例变量和类变量</h2><p>java程序中的变量，大体可以分为<strong>成员变量</strong>和<strong>局部变量</strong>。其中局部变量可分为如下三类：</p>\n<ul>\n<li><strong>形参</strong>：在方法名中定义的变量，有方法调用者负责为其赋值，随着方法的结束而消亡。</li>\n<li><strong>方法内局部变量</strong>：在方法内定义的变量，必须在方法内对其进行初始化。它从初始化完成后开始生效，随着方法结束而消亡。</li>\n<li><strong>代码块内局部变量</strong>：在代码块内定义的变量，必须在代码块内对其显示初始化。从初始化完成后生效，随着代码块的结束而消亡。</li>\n</ul>\n<p><em>局部变量的作用时间很短暂，他们被存在栈内存中。</em><br>类体内定义的变量为成员变量。如果使用<code>static</code>修饰，则为静态变量或者类变量，否则成为非静态变量或者实例变量。</p>\n<blockquote>\n<p><strong>static</strong>:<br>他的作用是将实例成员编程类成员。只能修饰在类里定义的成员部分，包括变量、方法、内部内（枚举与接口）、初始化块。不能用于修饰外部类、局部变量、局部内部类。</p>\n</blockquote>\n<p><strong>使用static修饰的成员变量是类类型，属于类本身，没有修饰的属于实例变量，属于该类的实例。在同一个JVM中，每个类可以创建多个java对象。同一个JVM中每个类只对应一个Class对象，机类变量只占一块内存空间，但是实例变量，每次创建便会分配一块内存空间。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tstatic int eyeNum;</span><br><span class=\"line\">\tpublic void info()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;我的名字是：&quot; + name</span><br><span class=\"line\">\t\t\t+ &quot;， 我的年龄是：&quot; + age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class FieldTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t// 类变量属于该类本身，只要该类初始化完成，</span><br><span class=\"line\">\t\t// 程序即可使用类变量。</span><br><span class=\"line\">\t\tPerson.eyeNum = 2; \t\t  //①</span><br><span class=\"line\">\t\t// 通过Person类访问eyeNum类变量</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Person的eyeNum属性：&quot;</span><br><span class=\"line\">\t\t\t+ Person.eyeNum);</span><br><span class=\"line\">\t\t// 创建第一个Person对象</span><br><span class=\"line\">\t\tPerson p = new Person();</span><br><span class=\"line\">\t\tp.name = &quot;猪八戒&quot;;</span><br><span class=\"line\">\t\tp.age = 300;</span><br><span class=\"line\">\t\t// 通过p访问Person类的eyeNum类变量</span><br><span class=\"line\">\t\tSystem.out.println(&quot;通过p变量访问eyeNum类变量：&quot;</span><br><span class=\"line\">\t\t\t+ p.eyeNum);           //②</span><br><span class=\"line\">\t\tp.info();</span><br><span class=\"line\">\t\t// 创建第二个Person对象</span><br><span class=\"line\">\t\tPerson p2 = new Person();</span><br><span class=\"line\">\t\tp2.name = &quot;孙悟空&quot;;</span><br><span class=\"line\">\t\tp2.age = 500;</span><br><span class=\"line\">\t\tp2.info();</span><br><span class=\"line\">\t\t// 通过p2修改Person类的eyeNum类变量</span><br><span class=\"line\">\t\tp2.eyeNum = 3;     \t\t   //③</span><br><span class=\"line\">\t\t// 分别通过p、p2和Person访问Person类的eyeNum类变量</span><br><span class=\"line\">\t\tSystem.out.println(&quot;通过p变量访问eyeNum类变量：&quot;</span><br><span class=\"line\">\t\t\t+ p.eyeNum);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;通过p2变量访问eyeNum类变量：&quot;</span><br><span class=\"line\">\t\t\t+ p2.eyeNum);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;通过Person类访问eyeNum类变量：&quot;</span><br><span class=\"line\">\t\t\t+ Person.eyeNum);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中的内存分配如下：</p>\n<p><img src=\"/img/article_img/2016/对象内存分配1.png\" alt=\"\"></p>\n<p>当Person类初始化完成，类变量也随之初始化完成，不管再创建多少个Person对象，系统都不再为 eyeNum 分配内存，但会为 name 和age 分配内存并初始化。当eyeNum值改变后，通过每个Person对象访问eyeNum的值都随之改变。</p>\n<h3 id=\"a-实例变量的初始化\"><a href=\"#a-实例变量的初始化\" class=\"headerlink\" title=\"a.实例变量的初始化\"></a><strong>a.实例变量的初始化</strong></h3><p>对于实例变量，它属于java对象本身，每次程序创建java对象时都会为其分配内存空间，并初始化。<br>实例变量初始化地方：</p>\n<ul>\n<li>定义实例化变量时；</li>\n<li>非静态初始化块中；</li>\n<li>构造器中。</li>\n</ul>\n<p>其中前两种比第三种更早执行，而前两种的执行顺序与他们在程序中的排列顺序相同。它们三种作用完全类似，经过编译后都会提取到构造器中执行，且位于所有语句之前，定义变量赋值和初始化块赋值的顺序与他们在源代码中一致。</p>\n<p>可以使用 <code>javap</code>命令查看java编译器的机制：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class=\"line\">其中, 可能的选项包括:</span><br><span class=\"line\">-help  --help  -?        输出此用法消息</span><br><span class=\"line\">-version                 版本信息</span><br><span class=\"line\">-v  -verbose             输出附加信息</span><br><span class=\"line\">-l                       输出行号和本地变量表</span><br><span class=\"line\">-public                  仅显示公共类和成员</span><br><span class=\"line\">-protected               显示受保护的/公共类和成员</span><br><span class=\"line\">-package                 显示程序包/受保护的/公共类</span><br><span class=\"line\">                       和成员 (默认)</span><br><span class=\"line\">-p  -private             显示所有类和成员</span><br><span class=\"line\">-c                       对代码进行反汇编</span><br><span class=\"line\">-s                       输出内部类型签名</span><br><span class=\"line\">-sysinfo                 显示正在处理的类的</span><br><span class=\"line\">                       系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class=\"line\">-constants               显示最终常量</span><br><span class=\"line\">-classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class=\"line\">-cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class=\"line\">-bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"b-类变量的初始化\"><a href=\"#b-类变量的初始化\" class=\"headerlink\" title=\"b.类变量的初始化\"></a><strong>b.类变量的初始化</strong></h3><p>类变量属于java 类本身，每次运行时才会初始化。<br>类变量的初始化地方：</p>\n<ul>\n<li>定义类变量时初始化；</li>\n<li>静态代码块中初始化</li>\n</ul>\n<p>如下代码，表面上看输出的是：17.2,17.2；但是实际上输出的是：-2.8,17.2<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Price</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 类成员是Price实例</span><br><span class=\"line\">    final static Price INSTANCE = new Price(2.8);</span><br><span class=\"line\">    // 在定义一个类变量。</span><br><span class=\"line\">    static double initPrice = 20;</span><br><span class=\"line\">    // 定义该Price的currentPrice实例变量</span><br><span class=\"line\">    double currentPrice;</span><br><span class=\"line\">    public Price(double discount)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 根据静态变量计算实例变量</span><br><span class=\"line\">        currentPrice = initPrice - discount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class PriceTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public static void main(String[] args)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 通过Price的INSTANCE访问currentPrice实例变量</span><br><span class=\"line\">        System.out.println(Price.INSTANCE.currentPrice);//输出：-2.8</span><br><span class=\"line\">        // 显式创建Price实例</span><br><span class=\"line\">        Price p = new Price(2.8);</span><br><span class=\"line\">        // 通过先是创建的Price实例访问currentPrice实例变量</span><br><span class=\"line\">        System.out.println(p.currentPrice);            //输出：17.2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第一次使用Price 时，程序对其进行初始化，可分为两个阶段：<br>（1）系统为类变量分配内存空间；<br>（2）按初始化代码顺序对变量进行初始化。</p>\n<p>这里的运行结果为：-2.8,17.2<br><strong>说明</strong>：初始化第一阶段，系统先为 INSTANCE，initPrice两个类变量分配内存空间，他们的默认值为null和0.0，接着第二阶段依次为他们赋值。对 INSTANCE 赋值时要调用 Price(2.8),创建Price实例，为currentPrice赋值，此时，还未对 initPrice 赋值，就是用他的默认值0，则 currentPrice 值为-2.8，接着程序再次将 initPrice 赋值为20，但对于 currentPrice 实例变量已经不起作用了。</p>\n<p>以下为在ide中的debug结果截图：</p>\n<p><img src=\"/img/article_img/2016/对象内存分配-debug.png\" alt=\"\"></p>\n<h2 id=\"2-父类构造器\"><a href=\"#2-父类构造器\" class=\"headerlink\" title=\"2.父类构造器\"></a>2.父类构造器</h2><p>java中，创建对象时，首先会依次调用每个父类的非静态初始化块、构造器（总是先从Object开始），然后再使用本类的非静态初始化块和构造器进行初始化。在调用父类时可以用<code>super</code>进行<strong>显示调用</strong>，也可以<strong>隐式调用</strong>。</p>\n<p>在子类调用父类构造器时，有以下几种场景：</p>\n<ul>\n<li>子类构造器第一行代码是用<strong>super()</strong>进行显示调用父类构造器，则根据super传入的参数调用相应的构造器；</li>\n<li>子类构造器第一行代码是用<strong>this()</strong>进行显示调用本类中重载的构造器，则根据传入this的参数调用相应的构造器；</li>\n<li>之类构造器中没有this和super,则在执行子类构造器前，隐式调用父类无参构造器。</li>\n</ul>\n<blockquote>\n<p>注：super和this都是显示调用构造器，只能在构造器中使用，且必须在第一行，只能使用它们其中之一，最多只能调用一次。</p>\n</blockquote>\n<p>一般情况下，子类对象可以访问父类的实例变量，但父类不能访问子类的，因为父类不知道它会被哪个子类继承，子类又会添加怎样的方法。但在极端的情况下，父类可以访问子类变量的情况，如下实例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.imtianx.p02;</span><br><span class=\"line\"></span><br><span class=\"line\">class Base &#123;</span><br><span class=\"line\">    private int i = 2;</span><br><span class=\"line\">    public Base() &#123;</span><br><span class=\"line\">        this.display();//this：运行时是Driver类型，编译时是Base 类型，这里是Driver对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void display() &#123;</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承Base的Derived子类</span><br><span class=\"line\">class Derived extends Base &#123;</span><br><span class=\"line\">    private int i = 22;</span><br><span class=\"line\">    public Derived() &#123;</span><br><span class=\"line\">        i = 222;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void display() &#123;</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 创建Derived的构造器创建实例</span><br><span class=\"line\">        new Derived();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码执行后，输出的并不是2、22或者222，而是<strong>0</strong>。在调用Derived 的构造器前会隐式调用Base的无参构造器，初始化 i= 2，此时如果输出<code>this.i</code>则为2，它访问的是Base 类中的实例变量，但是当调用<code>this.display()</code>时，表现的为Driver对象的行为，对于driver对象，它的变量i还未赋初始值，仅仅是为其开辟了内存空间，其值为0。</p>\n<p><strong>在java 中，构造器负责实例变量的初始化（即，赋初始值），在执行构造器前，该对象内存空间已经被分配了，他们在内存中存的事其类型所对应的默认值。</strong></p>\n<p><strong>在上面的代码中，出现了变量的编译时类型与运行时类型不同。通过该变量访问他所引用的对象的实例变量时，该实例变量的值由申明该变量的类型决定的，当通过该变量调用它所引用的实例对象的实例方法时，该方法将由它实际所引用的对象来决定</strong></p>\n<p>当子类重写父类方法时，也会出现父类调用之类方法的情形，如下具体代码，通过上面的则很容易理解。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate String desc;</span><br><span class=\"line\">\tpublic Animal()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthis.desc = getDesc();       </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic String getDesc()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn &quot;Animal&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic String toString()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn desc;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Wolf extends Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tprivate String name;</span><br><span class=\"line\">\tprivate double weight;</span><br><span class=\"line\">\tpublic Wolf(String name , double weight)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthis.name = name;</span><br><span class=\"line\">\t\tthis.weight = weight;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// 重写父类的getDesc()方法</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic String getDesc()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn &quot;Wolf[name=&quot; + name + &quot; , weight=&quot;</span><br><span class=\"line\">\t\t\t+ weight + &quot;]&quot;;  //输出：Wolf[name=null , weight=0.0]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static void main(String[] args)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(new Wolf(&quot;灰太狼&quot; , 32.3)); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-父子实例的内存控制\"><a href=\"#3-父子实例的内存控制\" class=\"headerlink\" title=\"3.父子实例的内存控制\"></a>3.父子实例的内存控制</h2><p>java中的继承，在处理成员变量和方法时是不同的。如果之类重写了父类的方法，则完全覆盖父类的方法，并将其其移到子类中，但如果是完全同名的实例变量，则不会覆盖，不会从父类中移到子类中。所以，对于一个引用类型的变量，如果访问他所引用对象的实例变量时，该实例变量的值取决于申明该变量的类型，而调用方法时，则取决于它实际引用对象的类型。</p>\n<p>在继承中，内存中子类实例保存有父类的变量的实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123;</span><br><span class=\"line\">    int count = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Mid extends Base &#123;</span><br><span class=\"line\">    int count = 20;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Sub extends Mid &#123;</span><br><span class=\"line\">    int count = 200;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 创建一个Sub对象</span><br><span class=\"line\">        Sub s = new Sub();</span><br><span class=\"line\">        // 将Sub对象向上转型后赋为Mid、Base类型的变量</span><br><span class=\"line\">        Mid s2m = s;</span><br><span class=\"line\">        Base s2b = s;</span><br><span class=\"line\">        // 分别通过3个变量来访问count实例变量</span><br><span class=\"line\">        System.out.println(s.count);    //输出：200</span><br><span class=\"line\">        System.out.println(s2m.count);    //输出：20</span><br><span class=\"line\">        System.out.println(s2b.count);    //输出：2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内存中的示意图：</p>\n<p><img src=\"/img/article_img/2016/对象内存分配2.png\" alt=\"\"></p>\n<p>在内存中只有一个Sub对象，并没有Mid和Base对象，但存在3个count的实例变量。</p>\n<p><strong>子类中会隐藏父类的变量可以通过super来获取,对于类变量，也可以通过super来访问。</strong></p>\n<h2 id=\"4-final-修饰符\"><a href=\"#4-final-修饰符\" class=\"headerlink\" title=\"4.final 修饰符\"></a>4.final 修饰符</h2><p>final 的修饰范围：</p>\n<ul>\n<li>修饰变量，被赋初始值后不可重新赋值；</li>\n<li>修饰方法 ，不能被重写；</li>\n<li>修饰类，不能派生出子类。</li>\n</ul>\n<p>对于final 类型的变量，初始化可以在：定义时、非静态代码块和构造器中；对于final 类型的类变量，初始化可以在：定义时和静态代码块中。</p>\n<blockquote>\n<p>当final类型的变量定义时就指定初始值，那么该该变量本质上是一个“宏变量”，编译器会把用到该变量的地方直接用其值替换。</p>\n</blockquote>\n<p>如果在内部内中使用局部变量，必须将其指定为final类型的。普通的变量作用域就是该方法，随着方法的执行结束，局部变量也随之消失，但内部类可能产生隐式的“闭包”，使局部变量脱离它所在的方法继续存在。内部内可能扩大局部变量的作用域，如果内部内中访问的局部变量没有适用final修饰，则可以随意修改它的值，这样将会引起混乱，所以编译器要求被内部访问的局部变量必须使用final 修饰。</p>"},{"title":"java知识 之 数组及其内存管理","date":"2016-11-17T08:06:25.000Z","_content":"\n\n> 读书笔记：《疯狂java 程序员的基本修养》第一章——数组及其内存管理\n\n## 1.数组初始化\n数组是一个复合数据结构，当需要多个类型相同的变量时，可以定义数组惊醒使用。在java中，数组变量是一个引用类型的变量。<!--more-->\njava 中的数组是**静态的**，即初始化后，它索占的内存空间、数组长度是不变的。而且必须先**初始化**后使用。\n\n**数组的初始化方式：**\n\n- **静态初始化：**初始化是指定数组的元素的值，由系统决定其长度。\n```\nString[] datas = new String[]{\"java\",\"C++\",\"html\"};\n```\n\n- **动态初始化:**指定长度，由系统为数组元素分配初始值。\n```\nString[] datas = new String[5];//指定长度为5，系统为每个元素指定初始值为null\n```\n初始值分配规则：\n\n| 数组类型| 初始化值 |\n| :------ | :-----:  |\n| byte、short、long| 0 |\n|float、double | 0.0 |\n|char | '\\u0000' |\n|boolean | false |\n|引用类型（类、接口） | null |\n\n*注：不要同时使用静态和动态初始化，即同时指定数组长度和元素初始值*\n\n## 2.数组的内存分析\n如下定义三个数组并初始化：\n```\n//1.静态初始化一\nString[] books = new String[]{\n        \"疯狂java 讲义\",\n        \"轻量级javaee企业应用实战\",\n        \"疯狂ajax讲义\",\n        \"疯狂XNL讲义\"\n};\nSystem.out.println(\"第一个数组的长度为：\" + books.length);// 4\n//2.静态初始化二\nString[] names = {\n        \"孙悟空\",\n        \"猪八戒\",\n        \"白骨精\"\n};\nSystem.out.println(\"第二个数组的长度为：\" + names.length);// 3\n//3.动态初始化\nString[] strArr = new String[5];\nSystem.out.println(\"第三个数组的长度为：\" + strArr.length); // 5\n```\n上面采用两种静态和一种动态方式初始化数组，其长度分别为4、3、5，其内存分配如下：\n\n![](/img/article_img/2016/数组内存分配1.png)\n\n\n数组变量存在栈区，数组对象存在堆内存，只能通过引用来访问堆内存中的数据。\n\n数组一旦初始化完成后，其内存空间即分配结束，无法改变其长度，但可以修改其元素的值。但数组是一中引用类型的变量，他只是指向对内存中的数组对象，可以改变其引用，从而造成其长度可变的假象，如下：\n\n```\nbooks = names;\nSystem.out.println(\"books数组的长度为：\" + books.length);\nstrArr = names;\nSystem.out.println(\"strArr数组的长度为：\" + strArr.length);\nbooks[1] = \"唐僧\";\nSystem.out.println(\"snames的第三个元素：\" + books[1]);\n```\n>输出结果为：\nbooks数组的长度为：3\nstrArr数组的长度为：3\nstrArr数组的长度为：唐僧\n\nbooks原本长度为4，现在打印出来的是3，这里只是其引用变了导致的，原来books变量引用的数组长度依然是4，只是没有任何引用了，将会被GC回收。内存变化如下：\n\n![](/img/article_img/2016/数组内存分配2.png)\n\n**java 中的数组变量只是引用变量，他并不是数组的本身，只要让数组变量指向有效的数组对象，即可使用该数组变量.**\n\n```\n int[] nums = new int[]{3,5,20,12};\nint[] prices;\nprices = nums;//prices 未初始化，但将其指向nums所引用的数组\nfor (int i = 0; i < prices.length; i++) {\n    System.out.println(prices[i]);\n}\n//为prices第三个元素赋值\nprices[2] = 34;\nSystem.out.println(\"nums数组第三个元素为：\"+nums[2]);//输出34\n```\nprices数组并没有初始化，但可以使用，执行`prices = nums;`后，他们指向相同的数组对象，是等价的，因此，修改prices的数组元素值，nums的也会随之改变。**对于数组，只要让其指向有效的数组对象，即可使用该变量。**\n\n> 注意： 引用变量本质上是一个指针，只要通过引用变量访问属性或调用方法，该引用变量就会由它所引用的对象替换。\n\n## 3.引用类型数组初始化\n引用类型的数组元素依然是一用类型的，它存储的是引用，指向另一块内存，该内存中存储了引用变量所引用的对象（包括数组和java对象）。\n\n定义一个Person类，用于定义改类型的数组：\n```\npublic class Person {\n    public int age;\n    public double height;\n\n    public void printInfo() {\n        System.out.println(\"年龄是：\" + age + \", 身高是：\" + height);\n    }\n}\n```\n定义person数组：\n```\nPerson[] students;\nstudents = new Person[2];\nSystem.out.println(\"students数组长度：\" + students.length);\nPerson zhang = new Person();\nzhang.age = 12;\nzhang.height = 158;\n\nPerson lee = new Person();\nlee.age = 16;\nlee.height = 161;\n\nstudents[0] = zhang;\nstudents[1] = lee;\n\n//lee和students[1]指向同一个person的实例，以下两句执行效果一样\nlee.printInfo();\nstudents[1].printInfo();\n```\n上述数组内存分配图：\n\n![](/img/article_img/2016/数组内存分配3.png)\n\nstudent数组的两个元素相当于两个引用，分别指向zhang和lee,lee和studentd[1]是指到同一个对象的，同一块内存，有相同的效果。\n\n## 4.数组的使用\n当定义一个数组，初始化后就相当于定义了多个相同类型的变量。通过索引使用数组元素时，可将其作为普通变量的使用。\n```\nclass Cat\n{\n\tdouble weight;\n\tint age;\n\tpublic Cat(double weight , int age)\n\t{\n\t\tthis.weight = weight;\n\t\tthis.age = age;\n\t}\n}\npublic class ArrayTest\n{\n\tpublic static void main(String[] args)\n\t{\n\t\t// 定义，并动态初始化一个int[]数组\n\t\tint[] pos = new int[5];\n\t\t// 采用循环为每个数组元素赋值\n\t\tfor (int i = 0; i < pos.length ; i++ )\n\t\t{\n\t\t\tpos[i] = (i + 1) * 2;\n\t\t}\n\t\t// 对于pos数组的元素来说，用起来完全等同于普通变量\n\t\t// 下面即可将数组元素的值赋给int变量，\n\t\t// 也可将int变量的值赋给数组元素\n\t\tint a = pos[1];\n\t\tint b = 20;\n\t\tpos[2] = b;             \n\t\t// 定义，并动态初始化一个Cat[]数组\n\t\tCat[] cats = new Cat[2];\n\t\tcats[0] = new Cat(3.34, 2);\n\t\t// 将cats数组的第1个元素的值赋给c1。\n\t\tCat c1 = cats[0];\n\t\tCat c2 = new Cat(4.3, 3);\n\t\t// 将c2的值赋给cats数组的第2个元素\n\t\tcats[1] = c2;             \n\t}\n}\n```\n上述代码中，相关的内存分配图示意图：\n\n![](/img/article_img/2016/数组内存分配4.png)\n\n## 5.多维数组\n对于 `int`类型，添加 `[]`后就是一个数组类型，若以`int[]`类型为已有类型，则增加一个`[]`,`int[][]`，也是一个数组类型。因此，所谓的多维数组，其数组元素依然是一个数组，即N维数组，是数组元素为N-1维数组的一维数组。\n如下示例：\n```\nint[][] a = new int[4][];\na[0] = new int[2];\na[0][1] = 6;\n```\n内存空间分配图：\n\n![](/img/article_img/2016/数组内存分配5.png)\n\n如果将其扩展成三维数组，则6所对应的数组元素指向两一个数组。\n\n**多维数组的本质是一维数组。**\n\n\n\n\n","source":"_posts/java 知识之 数组及其内存管理.md","raw":"\n---\ntitle: java知识 之 数组及其内存管理\ndate: 2016-11-17 16:06:25\ncategories: [java,高级知识]\ntags: [java,数组,内存管理]\n---\n\n\n> 读书笔记：《疯狂java 程序员的基本修养》第一章——数组及其内存管理\n\n## 1.数组初始化\n数组是一个复合数据结构，当需要多个类型相同的变量时，可以定义数组惊醒使用。在java中，数组变量是一个引用类型的变量。<!--more-->\njava 中的数组是**静态的**，即初始化后，它索占的内存空间、数组长度是不变的。而且必须先**初始化**后使用。\n\n**数组的初始化方式：**\n\n- **静态初始化：**初始化是指定数组的元素的值，由系统决定其长度。\n```\nString[] datas = new String[]{\"java\",\"C++\",\"html\"};\n```\n\n- **动态初始化:**指定长度，由系统为数组元素分配初始值。\n```\nString[] datas = new String[5];//指定长度为5，系统为每个元素指定初始值为null\n```\n初始值分配规则：\n\n| 数组类型| 初始化值 |\n| :------ | :-----:  |\n| byte、short、long| 0 |\n|float、double | 0.0 |\n|char | '\\u0000' |\n|boolean | false |\n|引用类型（类、接口） | null |\n\n*注：不要同时使用静态和动态初始化，即同时指定数组长度和元素初始值*\n\n## 2.数组的内存分析\n如下定义三个数组并初始化：\n```\n//1.静态初始化一\nString[] books = new String[]{\n        \"疯狂java 讲义\",\n        \"轻量级javaee企业应用实战\",\n        \"疯狂ajax讲义\",\n        \"疯狂XNL讲义\"\n};\nSystem.out.println(\"第一个数组的长度为：\" + books.length);// 4\n//2.静态初始化二\nString[] names = {\n        \"孙悟空\",\n        \"猪八戒\",\n        \"白骨精\"\n};\nSystem.out.println(\"第二个数组的长度为：\" + names.length);// 3\n//3.动态初始化\nString[] strArr = new String[5];\nSystem.out.println(\"第三个数组的长度为：\" + strArr.length); // 5\n```\n上面采用两种静态和一种动态方式初始化数组，其长度分别为4、3、5，其内存分配如下：\n\n![](/img/article_img/2016/数组内存分配1.png)\n\n\n数组变量存在栈区，数组对象存在堆内存，只能通过引用来访问堆内存中的数据。\n\n数组一旦初始化完成后，其内存空间即分配结束，无法改变其长度，但可以修改其元素的值。但数组是一中引用类型的变量，他只是指向对内存中的数组对象，可以改变其引用，从而造成其长度可变的假象，如下：\n\n```\nbooks = names;\nSystem.out.println(\"books数组的长度为：\" + books.length);\nstrArr = names;\nSystem.out.println(\"strArr数组的长度为：\" + strArr.length);\nbooks[1] = \"唐僧\";\nSystem.out.println(\"snames的第三个元素：\" + books[1]);\n```\n>输出结果为：\nbooks数组的长度为：3\nstrArr数组的长度为：3\nstrArr数组的长度为：唐僧\n\nbooks原本长度为4，现在打印出来的是3，这里只是其引用变了导致的，原来books变量引用的数组长度依然是4，只是没有任何引用了，将会被GC回收。内存变化如下：\n\n![](/img/article_img/2016/数组内存分配2.png)\n\n**java 中的数组变量只是引用变量，他并不是数组的本身，只要让数组变量指向有效的数组对象，即可使用该数组变量.**\n\n```\n int[] nums = new int[]{3,5,20,12};\nint[] prices;\nprices = nums;//prices 未初始化，但将其指向nums所引用的数组\nfor (int i = 0; i < prices.length; i++) {\n    System.out.println(prices[i]);\n}\n//为prices第三个元素赋值\nprices[2] = 34;\nSystem.out.println(\"nums数组第三个元素为：\"+nums[2]);//输出34\n```\nprices数组并没有初始化，但可以使用，执行`prices = nums;`后，他们指向相同的数组对象，是等价的，因此，修改prices的数组元素值，nums的也会随之改变。**对于数组，只要让其指向有效的数组对象，即可使用该变量。**\n\n> 注意： 引用变量本质上是一个指针，只要通过引用变量访问属性或调用方法，该引用变量就会由它所引用的对象替换。\n\n## 3.引用类型数组初始化\n引用类型的数组元素依然是一用类型的，它存储的是引用，指向另一块内存，该内存中存储了引用变量所引用的对象（包括数组和java对象）。\n\n定义一个Person类，用于定义改类型的数组：\n```\npublic class Person {\n    public int age;\n    public double height;\n\n    public void printInfo() {\n        System.out.println(\"年龄是：\" + age + \", 身高是：\" + height);\n    }\n}\n```\n定义person数组：\n```\nPerson[] students;\nstudents = new Person[2];\nSystem.out.println(\"students数组长度：\" + students.length);\nPerson zhang = new Person();\nzhang.age = 12;\nzhang.height = 158;\n\nPerson lee = new Person();\nlee.age = 16;\nlee.height = 161;\n\nstudents[0] = zhang;\nstudents[1] = lee;\n\n//lee和students[1]指向同一个person的实例，以下两句执行效果一样\nlee.printInfo();\nstudents[1].printInfo();\n```\n上述数组内存分配图：\n\n![](/img/article_img/2016/数组内存分配3.png)\n\nstudent数组的两个元素相当于两个引用，分别指向zhang和lee,lee和studentd[1]是指到同一个对象的，同一块内存，有相同的效果。\n\n## 4.数组的使用\n当定义一个数组，初始化后就相当于定义了多个相同类型的变量。通过索引使用数组元素时，可将其作为普通变量的使用。\n```\nclass Cat\n{\n\tdouble weight;\n\tint age;\n\tpublic Cat(double weight , int age)\n\t{\n\t\tthis.weight = weight;\n\t\tthis.age = age;\n\t}\n}\npublic class ArrayTest\n{\n\tpublic static void main(String[] args)\n\t{\n\t\t// 定义，并动态初始化一个int[]数组\n\t\tint[] pos = new int[5];\n\t\t// 采用循环为每个数组元素赋值\n\t\tfor (int i = 0; i < pos.length ; i++ )\n\t\t{\n\t\t\tpos[i] = (i + 1) * 2;\n\t\t}\n\t\t// 对于pos数组的元素来说，用起来完全等同于普通变量\n\t\t// 下面即可将数组元素的值赋给int变量，\n\t\t// 也可将int变量的值赋给数组元素\n\t\tint a = pos[1];\n\t\tint b = 20;\n\t\tpos[2] = b;             \n\t\t// 定义，并动态初始化一个Cat[]数组\n\t\tCat[] cats = new Cat[2];\n\t\tcats[0] = new Cat(3.34, 2);\n\t\t// 将cats数组的第1个元素的值赋给c1。\n\t\tCat c1 = cats[0];\n\t\tCat c2 = new Cat(4.3, 3);\n\t\t// 将c2的值赋给cats数组的第2个元素\n\t\tcats[1] = c2;             \n\t}\n}\n```\n上述代码中，相关的内存分配图示意图：\n\n![](/img/article_img/2016/数组内存分配4.png)\n\n## 5.多维数组\n对于 `int`类型，添加 `[]`后就是一个数组类型，若以`int[]`类型为已有类型，则增加一个`[]`,`int[][]`，也是一个数组类型。因此，所谓的多维数组，其数组元素依然是一个数组，即N维数组，是数组元素为N-1维数组的一维数组。\n如下示例：\n```\nint[][] a = new int[4][];\na[0] = new int[2];\na[0][1] = 6;\n```\n内存空间分配图：\n\n![](/img/article_img/2016/数组内存分配5.png)\n\n如果将其扩展成三维数组，则6所对应的数组元素指向两一个数组。\n\n**多维数组的本质是一维数组。**\n\n\n\n\n","slug":"java 知识之 数组及其内存管理","published":1,"updated":"2016-11-19T05:09:35.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucir002tg0g5l4ja2gnx","content":"<blockquote>\n<p>读书笔记：《疯狂java 程序员的基本修养》第一章——数组及其内存管理</p>\n</blockquote>\n<h2 id=\"1-数组初始化\"><a href=\"#1-数组初始化\" class=\"headerlink\" title=\"1.数组初始化\"></a>1.数组初始化</h2><p>数组是一个复合数据结构，当需要多个类型相同的变量时，可以定义数组惊醒使用。在java中，数组变量是一个引用类型的变量。<a id=\"more\"></a><br>java 中的数组是<strong>静态的</strong>，即初始化后，它索占的内存空间、数组长度是不变的。而且必须先<strong>初始化</strong>后使用。</p>\n<p><strong>数组的初始化方式：</strong></p>\n<ul>\n<li><p><strong>静态初始化：</strong>初始化是指定数组的元素的值，由系统决定其长度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] datas = new String[]&#123;&quot;java&quot;,&quot;C++&quot;,&quot;html&quot;&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>动态初始化:</strong>指定长度，由系统为数组元素分配初始值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] datas = new String[5];//指定长度为5，系统为每个元素指定初始值为null</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>初始值分配规则：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">数组类型</th>\n<th style=\"text-align:center\">初始化值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">byte、short、long</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">float、double</td>\n<td style=\"text-align:center\">0.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">char</td>\n<td style=\"text-align:center\">‘\\u0000’</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">boolean</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">引用类型（类、接口）</td>\n<td style=\"text-align:center\">null</td>\n</tr>\n</tbody>\n</table>\n<p><em>注：不要同时使用静态和动态初始化，即同时指定数组长度和元素初始值</em></p>\n<h2 id=\"2-数组的内存分析\"><a href=\"#2-数组的内存分析\" class=\"headerlink\" title=\"2.数组的内存分析\"></a>2.数组的内存分析</h2><p>如下定义三个数组并初始化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.静态初始化一</span><br><span class=\"line\">String[] books = new String[]&#123;</span><br><span class=\"line\">        &quot;疯狂java 讲义&quot;,</span><br><span class=\"line\">        &quot;轻量级javaee企业应用实战&quot;,</span><br><span class=\"line\">        &quot;疯狂ajax讲义&quot;,</span><br><span class=\"line\">        &quot;疯狂XNL讲义&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">System.out.println(&quot;第一个数组的长度为：&quot; + books.length);// 4</span><br><span class=\"line\">//2.静态初始化二</span><br><span class=\"line\">String[] names = &#123;</span><br><span class=\"line\">        &quot;孙悟空&quot;,</span><br><span class=\"line\">        &quot;猪八戒&quot;,</span><br><span class=\"line\">        &quot;白骨精&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">System.out.println(&quot;第二个数组的长度为：&quot; + names.length);// 3</span><br><span class=\"line\">//3.动态初始化</span><br><span class=\"line\">String[] strArr = new String[5];</span><br><span class=\"line\">System.out.println(&quot;第三个数组的长度为：&quot; + strArr.length); // 5</span><br></pre></td></tr></table></figure></p>\n<p>上面采用两种静态和一种动态方式初始化数组，其长度分别为4、3、5，其内存分配如下：</p>\n<p><img src=\"/img/article_img/2016/数组内存分配1.png\" alt=\"\"></p>\n<p>数组变量存在栈区，数组对象存在堆内存，只能通过引用来访问堆内存中的数据。</p>\n<p>数组一旦初始化完成后，其内存空间即分配结束，无法改变其长度，但可以修改其元素的值。但数组是一中引用类型的变量，他只是指向对内存中的数组对象，可以改变其引用，从而造成其长度可变的假象，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">books = names;</span><br><span class=\"line\">System.out.println(&quot;books数组的长度为：&quot; + books.length);</span><br><span class=\"line\">strArr = names;</span><br><span class=\"line\">System.out.println(&quot;strArr数组的长度为：&quot; + strArr.length);</span><br><span class=\"line\">books[1] = &quot;唐僧&quot;;</span><br><span class=\"line\">System.out.println(&quot;snames的第三个元素：&quot; + books[1]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出结果为：<br>books数组的长度为：3<br>strArr数组的长度为：3<br>strArr数组的长度为：唐僧</p>\n</blockquote>\n<p>books原本长度为4，现在打印出来的是3，这里只是其引用变了导致的，原来books变量引用的数组长度依然是4，只是没有任何引用了，将会被GC回收。内存变化如下：</p>\n<p><img src=\"/img/article_img/2016/数组内存分配2.png\" alt=\"\"></p>\n<p><strong>java 中的数组变量只是引用变量，他并不是数组的本身，只要让数组变量指向有效的数组对象，即可使用该数组变量.</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> int[] nums = new int[]&#123;3,5,20,12&#125;;</span><br><span class=\"line\">int[] prices;</span><br><span class=\"line\">prices = nums;//prices 未初始化，但将其指向nums所引用的数组</span><br><span class=\"line\">for (int i = 0; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">    System.out.println(prices[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//为prices第三个元素赋值</span><br><span class=\"line\">prices[2] = 34;</span><br><span class=\"line\">System.out.println(&quot;nums数组第三个元素为：&quot;+nums[2]);//输出34</span><br></pre></td></tr></table></figure>\n<p>prices数组并没有初始化，但可以使用，执行<code>prices = nums;</code>后，他们指向相同的数组对象，是等价的，因此，修改prices的数组元素值，nums的也会随之改变。<strong>对于数组，只要让其指向有效的数组对象，即可使用该变量。</strong></p>\n<blockquote>\n<p>注意： 引用变量本质上是一个指针，只要通过引用变量访问属性或调用方法，该引用变量就会由它所引用的对象替换。</p>\n</blockquote>\n<h2 id=\"3-引用类型数组初始化\"><a href=\"#3-引用类型数组初始化\" class=\"headerlink\" title=\"3.引用类型数组初始化\"></a>3.引用类型数组初始化</h2><p>引用类型的数组元素依然是一用类型的，它存储的是引用，指向另一块内存，该内存中存储了引用变量所引用的对象（包括数组和java对象）。</p>\n<p>定义一个Person类，用于定义改类型的数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person &#123;</span><br><span class=\"line\">    public int age;</span><br><span class=\"line\">    public double height;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void printInfo() &#123;</span><br><span class=\"line\">        System.out.println(&quot;年龄是：&quot; + age + &quot;, 身高是：&quot; + height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>定义person数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person[] students;</span><br><span class=\"line\">students = new Person[2];</span><br><span class=\"line\">System.out.println(&quot;students数组长度：&quot; + students.length);</span><br><span class=\"line\">Person zhang = new Person();</span><br><span class=\"line\">zhang.age = 12;</span><br><span class=\"line\">zhang.height = 158;</span><br><span class=\"line\"></span><br><span class=\"line\">Person lee = new Person();</span><br><span class=\"line\">lee.age = 16;</span><br><span class=\"line\">lee.height = 161;</span><br><span class=\"line\"></span><br><span class=\"line\">students[0] = zhang;</span><br><span class=\"line\">students[1] = lee;</span><br><span class=\"line\"></span><br><span class=\"line\">//lee和students[1]指向同一个person的实例，以下两句执行效果一样</span><br><span class=\"line\">lee.printInfo();</span><br><span class=\"line\">students[1].printInfo();</span><br></pre></td></tr></table></figure></p>\n<p>上述数组内存分配图：</p>\n<p><img src=\"/img/article_img/2016/数组内存分配3.png\" alt=\"\"></p>\n<p>student数组的两个元素相当于两个引用，分别指向zhang和lee,lee和studentd[1]是指到同一个对象的，同一块内存，有相同的效果。</p>\n<h2 id=\"4-数组的使用\"><a href=\"#4-数组的使用\" class=\"headerlink\" title=\"4.数组的使用\"></a>4.数组的使用</h2><p>当定义一个数组，初始化后就相当于定义了多个相同类型的变量。通过索引使用数组元素时，可将其作为普通变量的使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Cat</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdouble weight;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tpublic Cat(double weight , int age)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthis.weight = weight;</span><br><span class=\"line\">\t\tthis.age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class ArrayTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t// 定义，并动态初始化一个int[]数组</span><br><span class=\"line\">\t\tint[] pos = new int[5];</span><br><span class=\"line\">\t\t// 采用循环为每个数组元素赋值</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; pos.length ; i++ )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpos[i] = (i + 1) * 2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 对于pos数组的元素来说，用起来完全等同于普通变量</span><br><span class=\"line\">\t\t// 下面即可将数组元素的值赋给int变量，</span><br><span class=\"line\">\t\t// 也可将int变量的值赋给数组元素</span><br><span class=\"line\">\t\tint a = pos[1];</span><br><span class=\"line\">\t\tint b = 20;</span><br><span class=\"line\">\t\tpos[2] = b;             </span><br><span class=\"line\">\t\t// 定义，并动态初始化一个Cat[]数组</span><br><span class=\"line\">\t\tCat[] cats = new Cat[2];</span><br><span class=\"line\">\t\tcats[0] = new Cat(3.34, 2);</span><br><span class=\"line\">\t\t// 将cats数组的第1个元素的值赋给c1。</span><br><span class=\"line\">\t\tCat c1 = cats[0];</span><br><span class=\"line\">\t\tCat c2 = new Cat(4.3, 3);</span><br><span class=\"line\">\t\t// 将c2的值赋给cats数组的第2个元素</span><br><span class=\"line\">\t\tcats[1] = c2;             </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中，相关的内存分配图示意图：</p>\n<p><img src=\"/img/article_img/2016/数组内存分配4.png\" alt=\"\"></p>\n<h2 id=\"5-多维数组\"><a href=\"#5-多维数组\" class=\"headerlink\" title=\"5.多维数组\"></a>5.多维数组</h2><p>对于 <code>int</code>类型，添加 <code>[]</code>后就是一个数组类型，若以<code>int[]</code>类型为已有类型，则增加一个<code>[]</code>,<code>int[][]</code>，也是一个数组类型。因此，所谓的多维数组，其数组元素依然是一个数组，即N维数组，是数组元素为N-1维数组的一维数组。<br>如下示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[][] a = new int[4][];</span><br><span class=\"line\">a[0] = new int[2];</span><br><span class=\"line\">a[0][1] = 6;</span><br></pre></td></tr></table></figure></p>\n<p>内存空间分配图：</p>\n<p><img src=\"/img/article_img/2016/数组内存分配5.png\" alt=\"\"></p>\n<p>如果将其扩展成三维数组，则6所对应的数组元素指向两一个数组。</p>\n<p><strong>多维数组的本质是一维数组。</strong></p>\n","excerpt":"<blockquote>\n<p>读书笔记：《疯狂java 程序员的基本修养》第一章——数组及其内存管理</p>\n</blockquote>\n<h2 id=\"1-数组初始化\"><a href=\"#1-数组初始化\" class=\"headerlink\" title=\"1.数组初始化\"></a>1.数组初始化</h2><p>数组是一个复合数据结构，当需要多个类型相同的变量时，可以定义数组惊醒使用。在java中，数组变量是一个引用类型的变量。","more":"<br>java 中的数组是<strong>静态的</strong>，即初始化后，它索占的内存空间、数组长度是不变的。而且必须先<strong>初始化</strong>后使用。</p>\n<p><strong>数组的初始化方式：</strong></p>\n<ul>\n<li><p><strong>静态初始化：</strong>初始化是指定数组的元素的值，由系统决定其长度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] datas = new String[]&#123;&quot;java&quot;,&quot;C++&quot;,&quot;html&quot;&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>动态初始化:</strong>指定长度，由系统为数组元素分配初始值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] datas = new String[5];//指定长度为5，系统为每个元素指定初始值为null</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>初始值分配规则：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">数组类型</th>\n<th style=\"text-align:center\">初始化值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">byte、short、long</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">float、double</td>\n<td style=\"text-align:center\">0.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">char</td>\n<td style=\"text-align:center\">‘\\u0000’</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">boolean</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">引用类型（类、接口）</td>\n<td style=\"text-align:center\">null</td>\n</tr>\n</tbody>\n</table>\n<p><em>注：不要同时使用静态和动态初始化，即同时指定数组长度和元素初始值</em></p>\n<h2 id=\"2-数组的内存分析\"><a href=\"#2-数组的内存分析\" class=\"headerlink\" title=\"2.数组的内存分析\"></a>2.数组的内存分析</h2><p>如下定义三个数组并初始化：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.静态初始化一</span><br><span class=\"line\">String[] books = new String[]&#123;</span><br><span class=\"line\">        &quot;疯狂java 讲义&quot;,</span><br><span class=\"line\">        &quot;轻量级javaee企业应用实战&quot;,</span><br><span class=\"line\">        &quot;疯狂ajax讲义&quot;,</span><br><span class=\"line\">        &quot;疯狂XNL讲义&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">System.out.println(&quot;第一个数组的长度为：&quot; + books.length);// 4</span><br><span class=\"line\">//2.静态初始化二</span><br><span class=\"line\">String[] names = &#123;</span><br><span class=\"line\">        &quot;孙悟空&quot;,</span><br><span class=\"line\">        &quot;猪八戒&quot;,</span><br><span class=\"line\">        &quot;白骨精&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">System.out.println(&quot;第二个数组的长度为：&quot; + names.length);// 3</span><br><span class=\"line\">//3.动态初始化</span><br><span class=\"line\">String[] strArr = new String[5];</span><br><span class=\"line\">System.out.println(&quot;第三个数组的长度为：&quot; + strArr.length); // 5</span><br></pre></td></tr></table></figure></p>\n<p>上面采用两种静态和一种动态方式初始化数组，其长度分别为4、3、5，其内存分配如下：</p>\n<p><img src=\"/img/article_img/2016/数组内存分配1.png\" alt=\"\"></p>\n<p>数组变量存在栈区，数组对象存在堆内存，只能通过引用来访问堆内存中的数据。</p>\n<p>数组一旦初始化完成后，其内存空间即分配结束，无法改变其长度，但可以修改其元素的值。但数组是一中引用类型的变量，他只是指向对内存中的数组对象，可以改变其引用，从而造成其长度可变的假象，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">books = names;</span><br><span class=\"line\">System.out.println(&quot;books数组的长度为：&quot; + books.length);</span><br><span class=\"line\">strArr = names;</span><br><span class=\"line\">System.out.println(&quot;strArr数组的长度为：&quot; + strArr.length);</span><br><span class=\"line\">books[1] = &quot;唐僧&quot;;</span><br><span class=\"line\">System.out.println(&quot;snames的第三个元素：&quot; + books[1]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出结果为：<br>books数组的长度为：3<br>strArr数组的长度为：3<br>strArr数组的长度为：唐僧</p>\n</blockquote>\n<p>books原本长度为4，现在打印出来的是3，这里只是其引用变了导致的，原来books变量引用的数组长度依然是4，只是没有任何引用了，将会被GC回收。内存变化如下：</p>\n<p><img src=\"/img/article_img/2016/数组内存分配2.png\" alt=\"\"></p>\n<p><strong>java 中的数组变量只是引用变量，他并不是数组的本身，只要让数组变量指向有效的数组对象，即可使用该数组变量.</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> int[] nums = new int[]&#123;3,5,20,12&#125;;</span><br><span class=\"line\">int[] prices;</span><br><span class=\"line\">prices = nums;//prices 未初始化，但将其指向nums所引用的数组</span><br><span class=\"line\">for (int i = 0; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">    System.out.println(prices[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//为prices第三个元素赋值</span><br><span class=\"line\">prices[2] = 34;</span><br><span class=\"line\">System.out.println(&quot;nums数组第三个元素为：&quot;+nums[2]);//输出34</span><br></pre></td></tr></table></figure>\n<p>prices数组并没有初始化，但可以使用，执行<code>prices = nums;</code>后，他们指向相同的数组对象，是等价的，因此，修改prices的数组元素值，nums的也会随之改变。<strong>对于数组，只要让其指向有效的数组对象，即可使用该变量。</strong></p>\n<blockquote>\n<p>注意： 引用变量本质上是一个指针，只要通过引用变量访问属性或调用方法，该引用变量就会由它所引用的对象替换。</p>\n</blockquote>\n<h2 id=\"3-引用类型数组初始化\"><a href=\"#3-引用类型数组初始化\" class=\"headerlink\" title=\"3.引用类型数组初始化\"></a>3.引用类型数组初始化</h2><p>引用类型的数组元素依然是一用类型的，它存储的是引用，指向另一块内存，该内存中存储了引用变量所引用的对象（包括数组和java对象）。</p>\n<p>定义一个Person类，用于定义改类型的数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person &#123;</span><br><span class=\"line\">    public int age;</span><br><span class=\"line\">    public double height;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void printInfo() &#123;</span><br><span class=\"line\">        System.out.println(&quot;年龄是：&quot; + age + &quot;, 身高是：&quot; + height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>定义person数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person[] students;</span><br><span class=\"line\">students = new Person[2];</span><br><span class=\"line\">System.out.println(&quot;students数组长度：&quot; + students.length);</span><br><span class=\"line\">Person zhang = new Person();</span><br><span class=\"line\">zhang.age = 12;</span><br><span class=\"line\">zhang.height = 158;</span><br><span class=\"line\"></span><br><span class=\"line\">Person lee = new Person();</span><br><span class=\"line\">lee.age = 16;</span><br><span class=\"line\">lee.height = 161;</span><br><span class=\"line\"></span><br><span class=\"line\">students[0] = zhang;</span><br><span class=\"line\">students[1] = lee;</span><br><span class=\"line\"></span><br><span class=\"line\">//lee和students[1]指向同一个person的实例，以下两句执行效果一样</span><br><span class=\"line\">lee.printInfo();</span><br><span class=\"line\">students[1].printInfo();</span><br></pre></td></tr></table></figure></p>\n<p>上述数组内存分配图：</p>\n<p><img src=\"/img/article_img/2016/数组内存分配3.png\" alt=\"\"></p>\n<p>student数组的两个元素相当于两个引用，分别指向zhang和lee,lee和studentd[1]是指到同一个对象的，同一块内存，有相同的效果。</p>\n<h2 id=\"4-数组的使用\"><a href=\"#4-数组的使用\" class=\"headerlink\" title=\"4.数组的使用\"></a>4.数组的使用</h2><p>当定义一个数组，初始化后就相当于定义了多个相同类型的变量。通过索引使用数组元素时，可将其作为普通变量的使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Cat</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdouble weight;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">\tpublic Cat(double weight , int age)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthis.weight = weight;</span><br><span class=\"line\">\t\tthis.age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class ArrayTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t// 定义，并动态初始化一个int[]数组</span><br><span class=\"line\">\t\tint[] pos = new int[5];</span><br><span class=\"line\">\t\t// 采用循环为每个数组元素赋值</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; pos.length ; i++ )</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpos[i] = (i + 1) * 2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t// 对于pos数组的元素来说，用起来完全等同于普通变量</span><br><span class=\"line\">\t\t// 下面即可将数组元素的值赋给int变量，</span><br><span class=\"line\">\t\t// 也可将int变量的值赋给数组元素</span><br><span class=\"line\">\t\tint a = pos[1];</span><br><span class=\"line\">\t\tint b = 20;</span><br><span class=\"line\">\t\tpos[2] = b;             </span><br><span class=\"line\">\t\t// 定义，并动态初始化一个Cat[]数组</span><br><span class=\"line\">\t\tCat[] cats = new Cat[2];</span><br><span class=\"line\">\t\tcats[0] = new Cat(3.34, 2);</span><br><span class=\"line\">\t\t// 将cats数组的第1个元素的值赋给c1。</span><br><span class=\"line\">\t\tCat c1 = cats[0];</span><br><span class=\"line\">\t\tCat c2 = new Cat(4.3, 3);</span><br><span class=\"line\">\t\t// 将c2的值赋给cats数组的第2个元素</span><br><span class=\"line\">\t\tcats[1] = c2;             </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中，相关的内存分配图示意图：</p>\n<p><img src=\"/img/article_img/2016/数组内存分配4.png\" alt=\"\"></p>\n<h2 id=\"5-多维数组\"><a href=\"#5-多维数组\" class=\"headerlink\" title=\"5.多维数组\"></a>5.多维数组</h2><p>对于 <code>int</code>类型，添加 <code>[]</code>后就是一个数组类型，若以<code>int[]</code>类型为已有类型，则增加一个<code>[]</code>,<code>int[][]</code>，也是一个数组类型。因此，所谓的多维数组，其数组元素依然是一个数组，即N维数组，是数组元素为N-1维数组的一维数组。<br>如下示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[][] a = new int[4][];</span><br><span class=\"line\">a[0] = new int[2];</span><br><span class=\"line\">a[0][1] = 6;</span><br></pre></td></tr></table></figure></p>\n<p>内存空间分配图：</p>\n<p><img src=\"/img/article_img/2016/数组内存分配5.png\" alt=\"\"></p>\n<p>如果将其扩展成三维数组，则6所对应的数组元素指向两一个数组。</p>\n<p><strong>多维数组的本质是一维数组。</strong></p>"},{"title":"java 知识之 注解的使用和解析","date":"2016-11-26T02:06:25.000Z","_content":"\n\n在java中，例如重写父类方法使用的 `@Override`，就是注解。在开发中使用的框架，大部分也是用了注解。通过注解可以是代码更加简洁，更加清晰。在jdk1.5后，引入了注解。<!--more-->\n官方概念：java提供了已汇总源程序中的元素关联任何信息和任何元数据的途径和方法。\n\n\n\n## 一 、常见的注解\n在java 中主要有如下三个注解：\n\n- @Override\n 指明被注解的方法需要覆写父类中的方法，该方法在父类或接口中一定定存在，而且定义的一模一样（包括方法名、返回类型、参数），否则会报错误。\n- @Deprecated\n 表明该类被废弃，但仍然可以使用，只是使用时方法中间显示一横线。\n- @SuppressWarnings(\"deprecation\")\n 这个主要是排除因使用了被Deprecated 标记的方法而出现的警告，尽量在方法上使用来压制警告。\n\n更多java注解类的信息请查看源码 `java.lang.annotation` 包下面的注解类。\n\n**第三方注解：**\n 如果使用过Spring和Mybatis后台框架，对Spring中的@Autowired、@Service、@Repository以及Mybatis中的@InsertProvider、@UpdateProvider、@Options的使用就较为了解。\n \n \n## 二、 注解的分类\n\n按照**运行时机制**分为：\n \n- 源码注解\n注解只存在源码中，编译后的.class文件中不存在\n\n- 编译时注解\n在源码和.class中都存在，比如前面java中的 `@Override、@Deprecated、@SuppressWarnings(\"deprecation\")`\n- 运行时注解\n在运行阶段起作用，会影响运行逻辑的注解。\n\n按照**来源**分为：\n\n- 来自jdk的注解\n- 第三方注解\n- 自定义注解\n\n## 三、自定义注解\n\n在进行自定义注解时 使用 `@interface`关键字，与新建类类似。idea中新建java class时类型可以选择为`Annotation`，可以直接建立注解类。\n\n> 建立注解类时，若类中只有一个成员时，方法名必须为**value**，使用时可以忽略成员名和赋值号；\n如果没有成员，则该注解成为标识注解，如 `@Inherited`；注解中，成员的类型可以为java中的基本类型（int/float/double/...）,也可以是String、Class、Annotation,Enumeration。此外，还可以使用 `default`关键字指定默认值。\n\n如下简单注解例子：\n\n```\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited//允许子类继承\n@Documented//生成java doc时包含注解信息\npublic @interface Description {\n\n    String desc();\n\n    String author();\n\n    int age() default 18;//指定默认值\n}\n```\n上面的注解中，`@Target`指注解的作用域，包含java中的类、构造方法、属性等，具体参数如下：\n```\nElementType.METHOD  //方法声明\nElementType.TYPE     //类、接口\nElementType.CONSTRUCTOR    //构造方法声明\nElementType.TYPE.FIELD  //属性声明\nElementType.LOCAL_VARIABLE  //局部变量声明\nElementType.PACKAGE //包声明\nElementType.PARAMETER   //参数声明\n\n```\n`@Retention` 是指注解的生命周期，可以为：\n```\nRetentionPolicy.RUNTIME     // 运行时，可以通过反射获取；\nRetentionPolicy.SOURCE      //源码中显示，编译后丢弃；\nRetentionPolicy.CLASS       //编译时记录到class中，运行时忽略\n```\n\n`@Inherited` 表示允许子类继承，这个只能用与类，而且子类只能继承父类的类注解，不能继承方法上的注解。\n`@Documented` 表示生成javadoc时包含注解信息\n\n在注解类名之前的注解称为元注解。\n\n**自定义注解的使用语法：\n@注解名(成员名1=XXX,成员名2=XXX,...)；**\n对于只有一个成员的注解，直接用**@注解名(XXX)**\n\n上面的注解可以使用在类和方法上，如下为在方法上的使用：\n```\n@Description(desc = \"run\",author = \"imtianx\",age = 20)\npublic void run() {\n\n}\n```\n## 四、解析注解\n对于注解的解析，主要用到了反射技术。\n通过反射获取类、函数或成员上的运行时注解信息，实现动态的控制程序的逻辑。\n\n这里介绍下注解内容的获取，首先在使用注解到需要的类上：\n```\n@Description(desc = \"student\",author = \"imtianx\",age = 20)\npublic class Student implements Person {\n\n    public String name;\n\n    @Description(desc = \"run-M\",author = \"imtianx-M\",age = 21)\n    public void run() {\n    }\n\n    @Override\n    public void sign() {\n\n    }\n}\n```\n测试获取注解内容：\n```\npublic class TestDemo01 {\n\n    public static void main(String[] args) {\n\n        try {\n            //1.反射获取类信息\n            Class c = Class.forName(\"Student\");\n\n            //2.获取类上面的注解\n            boolean hasCAnno = c.isAnnotationPresent(Description.class);\n            if (hasCAnno) {\n                Description d = (Description) c.getAnnotation(Description.class);\n                System.out.println(d.desc());\n                System.out.println(d.author());\n                System.out.println(d.age());\n\n            }\n            //3.获取方法上的注解\n            Method[] methods = c.getMethods();\n            for (Method method : methods) {\n                boolean isMAnno = method.isAnnotationPresent(Description.class);\n                if (isMAnno) {\n                    Description md = method.getAnnotation(Description.class);\n                    System.out.println(md.desc());\n                    System.out.println(md.author());\n                    System.out.println(md.age());\n\n                }\n            }\n            //另一种获取获取注解的方式，以获取类上面的注解为例\n            for (Method method : methods) {\n                Annotation[] as = method.getDeclaredAnnotations();\n                for (Annotation a : as) {\n                    if (a instanceof Description) {\n                        Description d = (Description) a;\n\n                        System.out.println(d.desc());\n                        System.out.println(d.author());\n                        System.out.println(d.age());\n                    }\n                }\n            }\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n首先通过反射获取类信息，然后依次获取类、方法上面的注解内容。至于属性上面的注解，可以使用`Class.getDeclaredFields()`获取所有的属性，然后进行遍历获取。可参见 [java 知识之 反射的使用](http://imtianx.cn/2016/11/25/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8/) 一文了解反射相关的知识。\n\n当你了解了自定义注解和它的解析，再去看自己项目所用框架中的注解的实现，就十分简单，自己也能实现相同的效果。\n\n\n\n\n\n\n\n\n\n\n \n \n\n\n\n\n","source":"_posts/java 知识之 注解的使用和解析.md","raw":"---\ntitle: java 知识之 注解的使用和解析\ndate: 2016-11-26 10:06:25\ncategories: [java,高级知识]\ntags: [java,注解,自定义注解]\n---\n\n\n在java中，例如重写父类方法使用的 `@Override`，就是注解。在开发中使用的框架，大部分也是用了注解。通过注解可以是代码更加简洁，更加清晰。在jdk1.5后，引入了注解。<!--more-->\n官方概念：java提供了已汇总源程序中的元素关联任何信息和任何元数据的途径和方法。\n\n\n\n## 一 、常见的注解\n在java 中主要有如下三个注解：\n\n- @Override\n 指明被注解的方法需要覆写父类中的方法，该方法在父类或接口中一定定存在，而且定义的一模一样（包括方法名、返回类型、参数），否则会报错误。\n- @Deprecated\n 表明该类被废弃，但仍然可以使用，只是使用时方法中间显示一横线。\n- @SuppressWarnings(\"deprecation\")\n 这个主要是排除因使用了被Deprecated 标记的方法而出现的警告，尽量在方法上使用来压制警告。\n\n更多java注解类的信息请查看源码 `java.lang.annotation` 包下面的注解类。\n\n**第三方注解：**\n 如果使用过Spring和Mybatis后台框架，对Spring中的@Autowired、@Service、@Repository以及Mybatis中的@InsertProvider、@UpdateProvider、@Options的使用就较为了解。\n \n \n## 二、 注解的分类\n\n按照**运行时机制**分为：\n \n- 源码注解\n注解只存在源码中，编译后的.class文件中不存在\n\n- 编译时注解\n在源码和.class中都存在，比如前面java中的 `@Override、@Deprecated、@SuppressWarnings(\"deprecation\")`\n- 运行时注解\n在运行阶段起作用，会影响运行逻辑的注解。\n\n按照**来源**分为：\n\n- 来自jdk的注解\n- 第三方注解\n- 自定义注解\n\n## 三、自定义注解\n\n在进行自定义注解时 使用 `@interface`关键字，与新建类类似。idea中新建java class时类型可以选择为`Annotation`，可以直接建立注解类。\n\n> 建立注解类时，若类中只有一个成员时，方法名必须为**value**，使用时可以忽略成员名和赋值号；\n如果没有成员，则该注解成为标识注解，如 `@Inherited`；注解中，成员的类型可以为java中的基本类型（int/float/double/...）,也可以是String、Class、Annotation,Enumeration。此外，还可以使用 `default`关键字指定默认值。\n\n如下简单注解例子：\n\n```\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited//允许子类继承\n@Documented//生成java doc时包含注解信息\npublic @interface Description {\n\n    String desc();\n\n    String author();\n\n    int age() default 18;//指定默认值\n}\n```\n上面的注解中，`@Target`指注解的作用域，包含java中的类、构造方法、属性等，具体参数如下：\n```\nElementType.METHOD  //方法声明\nElementType.TYPE     //类、接口\nElementType.CONSTRUCTOR    //构造方法声明\nElementType.TYPE.FIELD  //属性声明\nElementType.LOCAL_VARIABLE  //局部变量声明\nElementType.PACKAGE //包声明\nElementType.PARAMETER   //参数声明\n\n```\n`@Retention` 是指注解的生命周期，可以为：\n```\nRetentionPolicy.RUNTIME     // 运行时，可以通过反射获取；\nRetentionPolicy.SOURCE      //源码中显示，编译后丢弃；\nRetentionPolicy.CLASS       //编译时记录到class中，运行时忽略\n```\n\n`@Inherited` 表示允许子类继承，这个只能用与类，而且子类只能继承父类的类注解，不能继承方法上的注解。\n`@Documented` 表示生成javadoc时包含注解信息\n\n在注解类名之前的注解称为元注解。\n\n**自定义注解的使用语法：\n@注解名(成员名1=XXX,成员名2=XXX,...)；**\n对于只有一个成员的注解，直接用**@注解名(XXX)**\n\n上面的注解可以使用在类和方法上，如下为在方法上的使用：\n```\n@Description(desc = \"run\",author = \"imtianx\",age = 20)\npublic void run() {\n\n}\n```\n## 四、解析注解\n对于注解的解析，主要用到了反射技术。\n通过反射获取类、函数或成员上的运行时注解信息，实现动态的控制程序的逻辑。\n\n这里介绍下注解内容的获取，首先在使用注解到需要的类上：\n```\n@Description(desc = \"student\",author = \"imtianx\",age = 20)\npublic class Student implements Person {\n\n    public String name;\n\n    @Description(desc = \"run-M\",author = \"imtianx-M\",age = 21)\n    public void run() {\n    }\n\n    @Override\n    public void sign() {\n\n    }\n}\n```\n测试获取注解内容：\n```\npublic class TestDemo01 {\n\n    public static void main(String[] args) {\n\n        try {\n            //1.反射获取类信息\n            Class c = Class.forName(\"Student\");\n\n            //2.获取类上面的注解\n            boolean hasCAnno = c.isAnnotationPresent(Description.class);\n            if (hasCAnno) {\n                Description d = (Description) c.getAnnotation(Description.class);\n                System.out.println(d.desc());\n                System.out.println(d.author());\n                System.out.println(d.age());\n\n            }\n            //3.获取方法上的注解\n            Method[] methods = c.getMethods();\n            for (Method method : methods) {\n                boolean isMAnno = method.isAnnotationPresent(Description.class);\n                if (isMAnno) {\n                    Description md = method.getAnnotation(Description.class);\n                    System.out.println(md.desc());\n                    System.out.println(md.author());\n                    System.out.println(md.age());\n\n                }\n            }\n            //另一种获取获取注解的方式，以获取类上面的注解为例\n            for (Method method : methods) {\n                Annotation[] as = method.getDeclaredAnnotations();\n                for (Annotation a : as) {\n                    if (a instanceof Description) {\n                        Description d = (Description) a;\n\n                        System.out.println(d.desc());\n                        System.out.println(d.author());\n                        System.out.println(d.age());\n                    }\n                }\n            }\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n首先通过反射获取类信息，然后依次获取类、方法上面的注解内容。至于属性上面的注解，可以使用`Class.getDeclaredFields()`获取所有的属性，然后进行遍历获取。可参见 [java 知识之 反射的使用](http://imtianx.cn/2016/11/25/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8/) 一文了解反射相关的知识。\n\n当你了解了自定义注解和它的解析，再去看自己项目所用框架中的注解的实现，就十分简单，自己也能实现相同的效果。\n\n\n\n\n\n\n\n\n\n\n \n \n\n\n\n\n","slug":"java 知识之 注解的使用和解析","published":1,"updated":"2016-11-26T02:47:14.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucir002wg0g5kp0vbonu","content":"<p>在java中，例如重写父类方法使用的 <code>@Override</code>，就是注解。在开发中使用的框架，大部分也是用了注解。通过注解可以是代码更加简洁，更加清晰。在jdk1.5后，引入了注解。<a id=\"more\"></a><br>官方概念：java提供了已汇总源程序中的元素关联任何信息和任何元数据的途径和方法。</p>\n<h2 id=\"一-、常见的注解\"><a href=\"#一-、常见的注解\" class=\"headerlink\" title=\"一 、常见的注解\"></a>一 、常见的注解</h2><p>在java 中主要有如下三个注解：</p>\n<ul>\n<li>@Override<br>指明被注解的方法需要覆写父类中的方法，该方法在父类或接口中一定定存在，而且定义的一模一样（包括方法名、返回类型、参数），否则会报错误。</li>\n<li>@Deprecated<br>表明该类被废弃，但仍然可以使用，只是使用时方法中间显示一横线。</li>\n<li>@SuppressWarnings(“deprecation”)<br>这个主要是排除因使用了被Deprecated 标记的方法而出现的警告，尽量在方法上使用来压制警告。</li>\n</ul>\n<p>更多java注解类的信息请查看源码 <code>java.lang.annotation</code> 包下面的注解类。</p>\n<p><strong>第三方注解：</strong><br> 如果使用过Spring和Mybatis后台框架，对Spring中的@Autowired、@Service、@Repository以及Mybatis中的@InsertProvider、@UpdateProvider、@Options的使用就较为了解。</p>\n<h2 id=\"二、-注解的分类\"><a href=\"#二、-注解的分类\" class=\"headerlink\" title=\"二、 注解的分类\"></a>二、 注解的分类</h2><p>按照<strong>运行时机制</strong>分为：</p>\n<ul>\n<li><p>源码注解<br>注解只存在源码中，编译后的.class文件中不存在</p>\n</li>\n<li><p>编译时注解<br>在源码和.class中都存在，比如前面java中的 <code>@Override、@Deprecated、@SuppressWarnings(&quot;deprecation&quot;)</code></p>\n</li>\n<li>运行时注解<br>在运行阶段起作用，会影响运行逻辑的注解。</li>\n</ul>\n<p>按照<strong>来源</strong>分为：</p>\n<ul>\n<li>来自jdk的注解</li>\n<li>第三方注解</li>\n<li>自定义注解</li>\n</ul>\n<h2 id=\"三、自定义注解\"><a href=\"#三、自定义注解\" class=\"headerlink\" title=\"三、自定义注解\"></a>三、自定义注解</h2><p>在进行自定义注解时 使用 <code>@interface</code>关键字，与新建类类似。idea中新建java class时类型可以选择为<code>Annotation</code>，可以直接建立注解类。</p>\n<blockquote>\n<p>建立注解类时，若类中只有一个成员时，方法名必须为<strong>value</strong>，使用时可以忽略成员名和赋值号；<br>如果没有成员，则该注解成为标识注解，如 <code>@Inherited</code>；注解中，成员的类型可以为java中的基本类型（int/float/double/…）,也可以是String、Class、Annotation,Enumeration。此外，还可以使用 <code>default</code>关键字指定默认值。</p>\n</blockquote>\n<p>如下简单注解例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Inherited//允许子类继承</span><br><span class=\"line\">@Documented//生成java doc时包含注解信息</span><br><span class=\"line\">public @interface Description &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String desc();</span><br><span class=\"line\"></span><br><span class=\"line\">    String author();</span><br><span class=\"line\"></span><br><span class=\"line\">    int age() default 18;//指定默认值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的注解中，<code>@Target</code>指注解的作用域，包含java中的类、构造方法、属性等，具体参数如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ElementType.METHOD  //方法声明</span><br><span class=\"line\">ElementType.TYPE     //类、接口</span><br><span class=\"line\">ElementType.CONSTRUCTOR    //构造方法声明</span><br><span class=\"line\">ElementType.TYPE.FIELD  //属性声明</span><br><span class=\"line\">ElementType.LOCAL_VARIABLE  //局部变量声明</span><br><span class=\"line\">ElementType.PACKAGE //包声明</span><br><span class=\"line\">ElementType.PARAMETER   //参数声明</span><br></pre></td></tr></table></figure></p>\n<p><code>@Retention</code> 是指注解的生命周期，可以为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RetentionPolicy.RUNTIME     // 运行时，可以通过反射获取；</span><br><span class=\"line\">RetentionPolicy.SOURCE      //源码中显示，编译后丢弃；</span><br><span class=\"line\">RetentionPolicy.CLASS       //编译时记录到class中，运行时忽略</span><br></pre></td></tr></table></figure></p>\n<p><code>@Inherited</code> 表示允许子类继承，这个只能用与类，而且子类只能继承父类的类注解，不能继承方法上的注解。<br><code>@Documented</code> 表示生成javadoc时包含注解信息</p>\n<p>在注解类名之前的注解称为元注解。</p>\n<p><strong>自定义注解的使用语法：<br>@注解名(成员名1=XXX,成员名2=XXX,…)；</strong><br>对于只有一个成员的注解，直接用<strong>@注解名(XXX)</strong></p>\n<p>上面的注解可以使用在类和方法上，如下为在方法上的使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Description(desc = &quot;run&quot;,author = &quot;imtianx&quot;,age = 20)</span><br><span class=\"line\">public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"四、解析注解\"><a href=\"#四、解析注解\" class=\"headerlink\" title=\"四、解析注解\"></a>四、解析注解</h2><p>对于注解的解析，主要用到了反射技术。<br>通过反射获取类、函数或成员上的运行时注解信息，实现动态的控制程序的逻辑。</p>\n<p>这里介绍下注解内容的获取，首先在使用注解到需要的类上：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Description(desc = &quot;student&quot;,author = &quot;imtianx&quot;,age = 20)</span><br><span class=\"line\">public class Student implements Person &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Description(desc = &quot;run-M&quot;,author = &quot;imtianx-M&quot;,age = 21)</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void sign() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试获取注解内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestDemo01 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //1.反射获取类信息</span><br><span class=\"line\">            Class c = Class.forName(&quot;Student&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            //2.获取类上面的注解</span><br><span class=\"line\">            boolean hasCAnno = c.isAnnotationPresent(Description.class);</span><br><span class=\"line\">            if (hasCAnno) &#123;</span><br><span class=\"line\">                Description d = (Description) c.getAnnotation(Description.class);</span><br><span class=\"line\">                System.out.println(d.desc());</span><br><span class=\"line\">                System.out.println(d.author());</span><br><span class=\"line\">                System.out.println(d.age());</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //3.获取方法上的注解</span><br><span class=\"line\">            Method[] methods = c.getMethods();</span><br><span class=\"line\">            for (Method method : methods) &#123;</span><br><span class=\"line\">                boolean isMAnno = method.isAnnotationPresent(Description.class);</span><br><span class=\"line\">                if (isMAnno) &#123;</span><br><span class=\"line\">                    Description md = method.getAnnotation(Description.class);</span><br><span class=\"line\">                    System.out.println(md.desc());</span><br><span class=\"line\">                    System.out.println(md.author());</span><br><span class=\"line\">                    System.out.println(md.age());</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //另一种获取获取注解的方式，以获取类上面的注解为例</span><br><span class=\"line\">            for (Method method : methods) &#123;</span><br><span class=\"line\">                Annotation[] as = method.getDeclaredAnnotations();</span><br><span class=\"line\">                for (Annotation a : as) &#123;</span><br><span class=\"line\">                    if (a instanceof Description) &#123;</span><br><span class=\"line\">                        Description d = (Description) a;</span><br><span class=\"line\"></span><br><span class=\"line\">                        System.out.println(d.desc());</span><br><span class=\"line\">                        System.out.println(d.author());</span><br><span class=\"line\">                        System.out.println(d.age());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先通过反射获取类信息，然后依次获取类、方法上面的注解内容。至于属性上面的注解，可以使用<code>Class.getDeclaredFields()</code>获取所有的属性，然后进行遍历获取。可参见 <a href=\"http://imtianx.cn/2016/11/25/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8/\">java 知识之 反射的使用</a> 一文了解反射相关的知识。</p>\n<p>当你了解了自定义注解和它的解析，再去看自己项目所用框架中的注解的实现，就十分简单，自己也能实现相同的效果。</p>\n","excerpt":"<p>在java中，例如重写父类方法使用的 <code>@Override</code>，就是注解。在开发中使用的框架，大部分也是用了注解。通过注解可以是代码更加简洁，更加清晰。在jdk1.5后，引入了注解。","more":"<br>官方概念：java提供了已汇总源程序中的元素关联任何信息和任何元数据的途径和方法。</p>\n<h2 id=\"一-、常见的注解\"><a href=\"#一-、常见的注解\" class=\"headerlink\" title=\"一 、常见的注解\"></a>一 、常见的注解</h2><p>在java 中主要有如下三个注解：</p>\n<ul>\n<li>@Override<br>指明被注解的方法需要覆写父类中的方法，该方法在父类或接口中一定定存在，而且定义的一模一样（包括方法名、返回类型、参数），否则会报错误。</li>\n<li>@Deprecated<br>表明该类被废弃，但仍然可以使用，只是使用时方法中间显示一横线。</li>\n<li>@SuppressWarnings(“deprecation”)<br>这个主要是排除因使用了被Deprecated 标记的方法而出现的警告，尽量在方法上使用来压制警告。</li>\n</ul>\n<p>更多java注解类的信息请查看源码 <code>java.lang.annotation</code> 包下面的注解类。</p>\n<p><strong>第三方注解：</strong><br> 如果使用过Spring和Mybatis后台框架，对Spring中的@Autowired、@Service、@Repository以及Mybatis中的@InsertProvider、@UpdateProvider、@Options的使用就较为了解。</p>\n<h2 id=\"二、-注解的分类\"><a href=\"#二、-注解的分类\" class=\"headerlink\" title=\"二、 注解的分类\"></a>二、 注解的分类</h2><p>按照<strong>运行时机制</strong>分为：</p>\n<ul>\n<li><p>源码注解<br>注解只存在源码中，编译后的.class文件中不存在</p>\n</li>\n<li><p>编译时注解<br>在源码和.class中都存在，比如前面java中的 <code>@Override、@Deprecated、@SuppressWarnings(&quot;deprecation&quot;)</code></p>\n</li>\n<li>运行时注解<br>在运行阶段起作用，会影响运行逻辑的注解。</li>\n</ul>\n<p>按照<strong>来源</strong>分为：</p>\n<ul>\n<li>来自jdk的注解</li>\n<li>第三方注解</li>\n<li>自定义注解</li>\n</ul>\n<h2 id=\"三、自定义注解\"><a href=\"#三、自定义注解\" class=\"headerlink\" title=\"三、自定义注解\"></a>三、自定义注解</h2><p>在进行自定义注解时 使用 <code>@interface</code>关键字，与新建类类似。idea中新建java class时类型可以选择为<code>Annotation</code>，可以直接建立注解类。</p>\n<blockquote>\n<p>建立注解类时，若类中只有一个成员时，方法名必须为<strong>value</strong>，使用时可以忽略成员名和赋值号；<br>如果没有成员，则该注解成为标识注解，如 <code>@Inherited</code>；注解中，成员的类型可以为java中的基本类型（int/float/double/…）,也可以是String、Class、Annotation,Enumeration。此外，还可以使用 <code>default</code>关键字指定默认值。</p>\n</blockquote>\n<p>如下简单注解例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Inherited//允许子类继承</span><br><span class=\"line\">@Documented//生成java doc时包含注解信息</span><br><span class=\"line\">public @interface Description &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String desc();</span><br><span class=\"line\"></span><br><span class=\"line\">    String author();</span><br><span class=\"line\"></span><br><span class=\"line\">    int age() default 18;//指定默认值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的注解中，<code>@Target</code>指注解的作用域，包含java中的类、构造方法、属性等，具体参数如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ElementType.METHOD  //方法声明</span><br><span class=\"line\">ElementType.TYPE     //类、接口</span><br><span class=\"line\">ElementType.CONSTRUCTOR    //构造方法声明</span><br><span class=\"line\">ElementType.TYPE.FIELD  //属性声明</span><br><span class=\"line\">ElementType.LOCAL_VARIABLE  //局部变量声明</span><br><span class=\"line\">ElementType.PACKAGE //包声明</span><br><span class=\"line\">ElementType.PARAMETER   //参数声明</span><br></pre></td></tr></table></figure></p>\n<p><code>@Retention</code> 是指注解的生命周期，可以为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RetentionPolicy.RUNTIME     // 运行时，可以通过反射获取；</span><br><span class=\"line\">RetentionPolicy.SOURCE      //源码中显示，编译后丢弃；</span><br><span class=\"line\">RetentionPolicy.CLASS       //编译时记录到class中，运行时忽略</span><br></pre></td></tr></table></figure></p>\n<p><code>@Inherited</code> 表示允许子类继承，这个只能用与类，而且子类只能继承父类的类注解，不能继承方法上的注解。<br><code>@Documented</code> 表示生成javadoc时包含注解信息</p>\n<p>在注解类名之前的注解称为元注解。</p>\n<p><strong>自定义注解的使用语法：<br>@注解名(成员名1=XXX,成员名2=XXX,…)；</strong><br>对于只有一个成员的注解，直接用<strong>@注解名(XXX)</strong></p>\n<p>上面的注解可以使用在类和方法上，如下为在方法上的使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Description(desc = &quot;run&quot;,author = &quot;imtianx&quot;,age = 20)</span><br><span class=\"line\">public void run() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"四、解析注解\"><a href=\"#四、解析注解\" class=\"headerlink\" title=\"四、解析注解\"></a>四、解析注解</h2><p>对于注解的解析，主要用到了反射技术。<br>通过反射获取类、函数或成员上的运行时注解信息，实现动态的控制程序的逻辑。</p>\n<p>这里介绍下注解内容的获取，首先在使用注解到需要的类上：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Description(desc = &quot;student&quot;,author = &quot;imtianx&quot;,age = 20)</span><br><span class=\"line\">public class Student implements Person &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Description(desc = &quot;run-M&quot;,author = &quot;imtianx-M&quot;,age = 21)</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void sign() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试获取注解内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestDemo01 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //1.反射获取类信息</span><br><span class=\"line\">            Class c = Class.forName(&quot;Student&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            //2.获取类上面的注解</span><br><span class=\"line\">            boolean hasCAnno = c.isAnnotationPresent(Description.class);</span><br><span class=\"line\">            if (hasCAnno) &#123;</span><br><span class=\"line\">                Description d = (Description) c.getAnnotation(Description.class);</span><br><span class=\"line\">                System.out.println(d.desc());</span><br><span class=\"line\">                System.out.println(d.author());</span><br><span class=\"line\">                System.out.println(d.age());</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //3.获取方法上的注解</span><br><span class=\"line\">            Method[] methods = c.getMethods();</span><br><span class=\"line\">            for (Method method : methods) &#123;</span><br><span class=\"line\">                boolean isMAnno = method.isAnnotationPresent(Description.class);</span><br><span class=\"line\">                if (isMAnno) &#123;</span><br><span class=\"line\">                    Description md = method.getAnnotation(Description.class);</span><br><span class=\"line\">                    System.out.println(md.desc());</span><br><span class=\"line\">                    System.out.println(md.author());</span><br><span class=\"line\">                    System.out.println(md.age());</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //另一种获取获取注解的方式，以获取类上面的注解为例</span><br><span class=\"line\">            for (Method method : methods) &#123;</span><br><span class=\"line\">                Annotation[] as = method.getDeclaredAnnotations();</span><br><span class=\"line\">                for (Annotation a : as) &#123;</span><br><span class=\"line\">                    if (a instanceof Description) &#123;</span><br><span class=\"line\">                        Description d = (Description) a;</span><br><span class=\"line\"></span><br><span class=\"line\">                        System.out.println(d.desc());</span><br><span class=\"line\">                        System.out.println(d.author());</span><br><span class=\"line\">                        System.out.println(d.age());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先通过反射获取类信息，然后依次获取类、方法上面的注解内容。至于属性上面的注解，可以使用<code>Class.getDeclaredFields()</code>获取所有的属性，然后进行遍历获取。可参见 <a href=\"http://imtianx.cn/2016/11/25/java%20%E7%9F%A5%E8%AF%86%E4%B9%8B%20%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8/\">java 知识之 反射的使用</a> 一文了解反射相关的知识。</p>\n<p>当你了解了自定义注解和它的解析，再去看自己项目所用框架中的注解的实现，就十分简单，自己也能实现相同的效果。</p>"},{"title":"java知识 之 Integer自动拆装箱与缓存","date":"2016-11-27T02:06:25.000Z","_content":"\n\n在java的数据类型中，包含基本类型 (如:`int、double、...`) 和包装类型(如: `Integer、Double、...` )。\n**自动装箱指的是把基本类型的值转换为对应的包装类对象，反之则为自动拆箱。**<!--more-->\n\n如下示例代码：\n\n```\nInteger x = 100;\nint y = x;\n```\n\n第一行代码实现了自动装箱，调用了 `valueOf(int i)` 方法；第二句实现了自动拆箱，调用了 `intvalue()` 方法。这些都是编译器自动帮我们完成的不用我们自己调用。\n\n以此类推，其他的装箱拆箱机制类似。\n\n下面的代码咋一看，输出都为 `true`,但其实不然：\n\n```\nInteger a = 100 ;\nInteger b = 100 ;\nInteger c = 200 ;\nInteger d = 200 ;\nSystem.out.println(a==b);\nSystem.out.println(c==d);\n```\n\n其中 `a==b` 结果为 `true` , `c==d` 结果为 `false` 。出现这种情况，主要是在进行自动装箱时， `Integer `的缓存机制导致的。\n\n如下Integer部分源码：\n\n```\n\npublic final class Integer extends Number implements Comparable<Integer> {\n\n    @Native\n    public static final int MIN_VALUE = 0x80000000;\n    @Native\n    public static final int MAX_VALUE = 0x7fffffff;\n    \n    // ...\n\n    //缓存类 默认用数组缓存 [-128,127] 的常量\n    private static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n\n        static {\n            // high value may be configured by property\n            int h = 127;\n            //获取Jvm配置的Integer的最大值，可以手动设置\n            String integerCacheHighPropValue =\n                    sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                try {\n                    //转换成int\n                    int i = parseInt(integerCacheHighPropValue);\n                    i = Math.max(i, 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) - 1);\n                } catch (NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n            //创建缓存常量数组\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            //设置数组元素值\n            for (int k = 0; k < cache.length; k++)\n                cache[k] = new Integer(j++);\n\n            //通过断言确保数组最小范围为：[-128,127]\n            assert IntegerCache.high >= 127;\n        }\n\n        private IntegerCache() {\n        }\n    }\n    //...\n\n    /**\n     * 自动装箱\n     *\n     * int -> Integer\n     *\n     * @param i\n     * @return\n     */\n    public static Integer valueOf(int i) {\n        //如果在缓存范围内，直接从缓存中区，\n        if (i >= Integer.IntegerCache.low && i <= Integer.IntegerCache.high)\n            return Integer.IntegerCache.cache[i + (-Integer.IntegerCache.low)];\n        // 在缓存空间外，重新创建\n        return new Integer(i);\n    }\n    \n    //...\n}\n\n```\n\n在默认情况下，Integer创建的缓存常量为 [-128,127],所以在上面的例子中，`Integer a = 100` 创建 a 对象是直接从常量数组中获取的，直接找到他的引用，b也是同样的，则 `a==b` 返回true;对于 `Integer c = 200` ,在常量池中没有缓存 ，则 通过 `new Integer(200)` 创建新对象，d也是这样创建的，他们所指向的引用不同，则 `c==d` 返回为 `false` 。\n\n\n在上面的 缓存类 `IntegerCache ` 中的静态代码块中，使用 `sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");` \n获取设置jvm最大的Integer缓存池范围。可以手动指定该值，通过设置 `-XX:AutoBoxCacheMax=2000` 属性，如下命令行编译：\n\n```\n//编译生成字节码\njavac TestInteger.java\n//指定范围最最大值为2000，运行\njava -XX:AutoBoxCacheMax=2000 TestInteger\n```\n\n此时如下代码输出均为true：\n\n```\nInteger a = 100 ;\nInteger b = 100 ;\nInteger c = 200 ;\nInteger d = 200 ;\nSystem.out.println(a==b);\nSystem.out.println(c==d);\n```\n\n如果使用ide,直接设置 运行时 VM 值即可，如下图\n\n![](/img/article_img/2016/setvmintegerMax.png)\n\n此外，在上面的代码中用到了  `assert(断言)` 关键字，它主要用来保证代码的正确性。\n使用发方法为 \n\n```\nassert 表达式;\n```\n\n若表达式为 `true` ,则程序正常运行，否则 抛出异常 `java.lang.AssertionError`。编辑器默认的是将他关闭的，此时就算表达式为false也没有任何效果。\n在idea中开启断言的方式和上面设置 vm值一样，只是这里设置的 是 `-ea` 。\n\n可使用下面代码测试：\n\n```\nboolean isOpen = false;\nassert isOpen;\nSystem.out.println(isOpen);\n```\n\n开启前打印为false，开启后打印为true 。\n\n\n\n\n\n\n","source":"_posts/java知识 之 Integer自动拆装箱与缓存.md","raw":"\n---\ntitle: java知识 之 Integer自动拆装箱与缓存\ndate: 2016-11-27 10:06:25\ncategories: [java,高级知识]\ntags: [java,拆装箱,Integer缓存]\n---\n\n\n在java的数据类型中，包含基本类型 (如:`int、double、...`) 和包装类型(如: `Integer、Double、...` )。\n**自动装箱指的是把基本类型的值转换为对应的包装类对象，反之则为自动拆箱。**<!--more-->\n\n如下示例代码：\n\n```\nInteger x = 100;\nint y = x;\n```\n\n第一行代码实现了自动装箱，调用了 `valueOf(int i)` 方法；第二句实现了自动拆箱，调用了 `intvalue()` 方法。这些都是编译器自动帮我们完成的不用我们自己调用。\n\n以此类推，其他的装箱拆箱机制类似。\n\n下面的代码咋一看，输出都为 `true`,但其实不然：\n\n```\nInteger a = 100 ;\nInteger b = 100 ;\nInteger c = 200 ;\nInteger d = 200 ;\nSystem.out.println(a==b);\nSystem.out.println(c==d);\n```\n\n其中 `a==b` 结果为 `true` , `c==d` 结果为 `false` 。出现这种情况，主要是在进行自动装箱时， `Integer `的缓存机制导致的。\n\n如下Integer部分源码：\n\n```\n\npublic final class Integer extends Number implements Comparable<Integer> {\n\n    @Native\n    public static final int MIN_VALUE = 0x80000000;\n    @Native\n    public static final int MAX_VALUE = 0x7fffffff;\n    \n    // ...\n\n    //缓存类 默认用数组缓存 [-128,127] 的常量\n    private static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n\n        static {\n            // high value may be configured by property\n            int h = 127;\n            //获取Jvm配置的Integer的最大值，可以手动设置\n            String integerCacheHighPropValue =\n                    sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                try {\n                    //转换成int\n                    int i = parseInt(integerCacheHighPropValue);\n                    i = Math.max(i, 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) - 1);\n                } catch (NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n            //创建缓存常量数组\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            //设置数组元素值\n            for (int k = 0; k < cache.length; k++)\n                cache[k] = new Integer(j++);\n\n            //通过断言确保数组最小范围为：[-128,127]\n            assert IntegerCache.high >= 127;\n        }\n\n        private IntegerCache() {\n        }\n    }\n    //...\n\n    /**\n     * 自动装箱\n     *\n     * int -> Integer\n     *\n     * @param i\n     * @return\n     */\n    public static Integer valueOf(int i) {\n        //如果在缓存范围内，直接从缓存中区，\n        if (i >= Integer.IntegerCache.low && i <= Integer.IntegerCache.high)\n            return Integer.IntegerCache.cache[i + (-Integer.IntegerCache.low)];\n        // 在缓存空间外，重新创建\n        return new Integer(i);\n    }\n    \n    //...\n}\n\n```\n\n在默认情况下，Integer创建的缓存常量为 [-128,127],所以在上面的例子中，`Integer a = 100` 创建 a 对象是直接从常量数组中获取的，直接找到他的引用，b也是同样的，则 `a==b` 返回true;对于 `Integer c = 200` ,在常量池中没有缓存 ，则 通过 `new Integer(200)` 创建新对象，d也是这样创建的，他们所指向的引用不同，则 `c==d` 返回为 `false` 。\n\n\n在上面的 缓存类 `IntegerCache ` 中的静态代码块中，使用 `sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");` \n获取设置jvm最大的Integer缓存池范围。可以手动指定该值，通过设置 `-XX:AutoBoxCacheMax=2000` 属性，如下命令行编译：\n\n```\n//编译生成字节码\njavac TestInteger.java\n//指定范围最最大值为2000，运行\njava -XX:AutoBoxCacheMax=2000 TestInteger\n```\n\n此时如下代码输出均为true：\n\n```\nInteger a = 100 ;\nInteger b = 100 ;\nInteger c = 200 ;\nInteger d = 200 ;\nSystem.out.println(a==b);\nSystem.out.println(c==d);\n```\n\n如果使用ide,直接设置 运行时 VM 值即可，如下图\n\n![](/img/article_img/2016/setvmintegerMax.png)\n\n此外，在上面的代码中用到了  `assert(断言)` 关键字，它主要用来保证代码的正确性。\n使用发方法为 \n\n```\nassert 表达式;\n```\n\n若表达式为 `true` ,则程序正常运行，否则 抛出异常 `java.lang.AssertionError`。编辑器默认的是将他关闭的，此时就算表达式为false也没有任何效果。\n在idea中开启断言的方式和上面设置 vm值一样，只是这里设置的 是 `-ea` 。\n\n可使用下面代码测试：\n\n```\nboolean isOpen = false;\nassert isOpen;\nSystem.out.println(isOpen);\n```\n\n开启前打印为false，开启后打印为true 。\n\n\n\n\n\n\n","slug":"java知识 之 Integer自动拆装箱与缓存","published":1,"updated":"2016-11-27T05:57:29.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucir002zg0g5vuvfkj1w","content":"<p>在java的数据类型中，包含基本类型 (如:<code>int、double、...</code>) 和包装类型(如: <code>Integer、Double、...</code> )。<br><strong>自动装箱指的是把基本类型的值转换为对应的包装类对象，反之则为自动拆箱。</strong><a id=\"more\"></a></p>\n<p>如下示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer x = 100;</span><br><span class=\"line\">int y = x;</span><br></pre></td></tr></table></figure>\n<p>第一行代码实现了自动装箱，调用了 <code>valueOf(int i)</code> 方法；第二句实现了自动拆箱，调用了 <code>intvalue()</code> 方法。这些都是编译器自动帮我们完成的不用我们自己调用。</p>\n<p>以此类推，其他的装箱拆箱机制类似。</p>\n<p>下面的代码咋一看，输出都为 <code>true</code>,但其实不然：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = 100 ;</span><br><span class=\"line\">Integer b = 100 ;</span><br><span class=\"line\">Integer c = 200 ;</span><br><span class=\"line\">Integer d = 200 ;</span><br><span class=\"line\">System.out.println(a==b);</span><br><span class=\"line\">System.out.println(c==d);</span><br></pre></td></tr></table></figure>\n<p>其中 <code>a==b</code> 结果为 <code>true</code> , <code>c==d</code> 结果为 <code>false</code> 。出现这种情况，主要是在进行自动装箱时， <code>Integer</code>的缓存机制导致的。</p>\n<p>如下Integer部分源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public final class Integer extends Number implements Comparable&lt;Integer&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Native</span><br><span class=\"line\">    public static final int MIN_VALUE = 0x80000000;</span><br><span class=\"line\">    @Native</span><br><span class=\"line\">    public static final int MAX_VALUE = 0x7fffffff;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // ...</span><br><span class=\"line\"></span><br><span class=\"line\">    //缓存类 默认用数组缓存 [-128,127] 的常量</span><br><span class=\"line\">    private static class IntegerCache &#123;</span><br><span class=\"line\">        static final int low = -128;</span><br><span class=\"line\">        static final int high;</span><br><span class=\"line\">        static final Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">        static &#123;</span><br><span class=\"line\">            // high value may be configured by property</span><br><span class=\"line\">            int h = 127;</span><br><span class=\"line\">            //获取Jvm配置的Integer的最大值，可以手动设置</span><br><span class=\"line\">            String integerCacheHighPropValue =</span><br><span class=\"line\">                    sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class=\"line\">            if (integerCacheHighPropValue != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    //转换成int</span><br><span class=\"line\">                    int i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                    i = Math.max(i, 127);</span><br><span class=\"line\">                    // Maximum array size is Integer.MAX_VALUE</span><br><span class=\"line\">                    h = Math.min(i, Integer.MAX_VALUE - (-low) - 1);</span><br><span class=\"line\">                &#125; catch (NumberFormatException nfe) &#123;</span><br><span class=\"line\">                    // If the property cannot be parsed into an int, ignore it.</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            high = h;</span><br><span class=\"line\">            //创建缓存常量数组</span><br><span class=\"line\">            cache = new Integer[(high - low) + 1];</span><br><span class=\"line\">            int j = low;</span><br><span class=\"line\">            //设置数组元素值</span><br><span class=\"line\">            for (int k = 0; k &lt; cache.length; k++)</span><br><span class=\"line\">                cache[k] = new Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">            //通过断言确保数组最小范围为：[-128,127]</span><br><span class=\"line\">            assert IntegerCache.high &gt;= 127;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        private IntegerCache() &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //...</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 自动装箱</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * int -&gt; Integer</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param i</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static Integer valueOf(int i) &#123;</span><br><span class=\"line\">        //如果在缓存范围内，直接从缓存中区，</span><br><span class=\"line\">        if (i &gt;= Integer.IntegerCache.low &amp;&amp; i &lt;= Integer.IntegerCache.high)</span><br><span class=\"line\">            return Integer.IntegerCache.cache[i + (-Integer.IntegerCache.low)];</span><br><span class=\"line\">        // 在缓存空间外，重新创建</span><br><span class=\"line\">        return new Integer(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在默认情况下，Integer创建的缓存常量为 [-128,127],所以在上面的例子中，<code>Integer a = 100</code> 创建 a 对象是直接从常量数组中获取的，直接找到他的引用，b也是同样的，则 <code>a==b</code> 返回true;对于 <code>Integer c = 200</code> ,在常量池中没有缓存 ，则 通过 <code>new Integer(200)</code> 创建新对象，d也是这样创建的，他们所指向的引用不同，则 <code>c==d</code> 返回为 <code>false</code> 。</p>\n<p>在上面的 缓存类 <code>IntegerCache</code> 中的静态代码块中，使用 <code>sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</code><br>获取设置jvm最大的Integer缓存池范围。可以手动指定该值，通过设置 <code>-XX:AutoBoxCacheMax=2000</code> 属性，如下命令行编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译生成字节码</span><br><span class=\"line\">javac TestInteger.java</span><br><span class=\"line\">//指定范围最最大值为2000，运行</span><br><span class=\"line\">java -XX:AutoBoxCacheMax=2000 TestInteger</span><br></pre></td></tr></table></figure>\n<p>此时如下代码输出均为true：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = 100 ;</span><br><span class=\"line\">Integer b = 100 ;</span><br><span class=\"line\">Integer c = 200 ;</span><br><span class=\"line\">Integer d = 200 ;</span><br><span class=\"line\">System.out.println(a==b);</span><br><span class=\"line\">System.out.println(c==d);</span><br></pre></td></tr></table></figure>\n<p>如果使用ide,直接设置 运行时 VM 值即可，如下图</p>\n<p><img src=\"/img/article_img/2016/setvmintegerMax.png\" alt=\"\"></p>\n<p>此外，在上面的代码中用到了  <code>assert(断言)</code> 关键字，它主要用来保证代码的正确性。<br>使用发方法为 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assert 表达式;</span><br></pre></td></tr></table></figure>\n<p>若表达式为 <code>true</code> ,则程序正常运行，否则 抛出异常 <code>java.lang.AssertionError</code>。编辑器默认的是将他关闭的，此时就算表达式为false也没有任何效果。<br>在idea中开启断言的方式和上面设置 vm值一样，只是这里设置的 是 <code>-ea</code> 。</p>\n<p>可使用下面代码测试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean isOpen = false;</span><br><span class=\"line\">assert isOpen;</span><br><span class=\"line\">System.out.println(isOpen);</span><br></pre></td></tr></table></figure>\n<p>开启前打印为false，开启后打印为true 。</p>\n","excerpt":"<p>在java的数据类型中，包含基本类型 (如:<code>int、double、...</code>) 和包装类型(如: <code>Integer、Double、...</code> )。<br><strong>自动装箱指的是把基本类型的值转换为对应的包装类对象，反之则为自动拆箱。</strong>","more":"</p>\n<p>如下示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer x = 100;</span><br><span class=\"line\">int y = x;</span><br></pre></td></tr></table></figure>\n<p>第一行代码实现了自动装箱，调用了 <code>valueOf(int i)</code> 方法；第二句实现了自动拆箱，调用了 <code>intvalue()</code> 方法。这些都是编译器自动帮我们完成的不用我们自己调用。</p>\n<p>以此类推，其他的装箱拆箱机制类似。</p>\n<p>下面的代码咋一看，输出都为 <code>true</code>,但其实不然：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = 100 ;</span><br><span class=\"line\">Integer b = 100 ;</span><br><span class=\"line\">Integer c = 200 ;</span><br><span class=\"line\">Integer d = 200 ;</span><br><span class=\"line\">System.out.println(a==b);</span><br><span class=\"line\">System.out.println(c==d);</span><br></pre></td></tr></table></figure>\n<p>其中 <code>a==b</code> 结果为 <code>true</code> , <code>c==d</code> 结果为 <code>false</code> 。出现这种情况，主要是在进行自动装箱时， <code>Integer</code>的缓存机制导致的。</p>\n<p>如下Integer部分源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public final class Integer extends Number implements Comparable&lt;Integer&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Native</span><br><span class=\"line\">    public static final int MIN_VALUE = 0x80000000;</span><br><span class=\"line\">    @Native</span><br><span class=\"line\">    public static final int MAX_VALUE = 0x7fffffff;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // ...</span><br><span class=\"line\"></span><br><span class=\"line\">    //缓存类 默认用数组缓存 [-128,127] 的常量</span><br><span class=\"line\">    private static class IntegerCache &#123;</span><br><span class=\"line\">        static final int low = -128;</span><br><span class=\"line\">        static final int high;</span><br><span class=\"line\">        static final Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">        static &#123;</span><br><span class=\"line\">            // high value may be configured by property</span><br><span class=\"line\">            int h = 127;</span><br><span class=\"line\">            //获取Jvm配置的Integer的最大值，可以手动设置</span><br><span class=\"line\">            String integerCacheHighPropValue =</span><br><span class=\"line\">                    sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class=\"line\">            if (integerCacheHighPropValue != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    //转换成int</span><br><span class=\"line\">                    int i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                    i = Math.max(i, 127);</span><br><span class=\"line\">                    // Maximum array size is Integer.MAX_VALUE</span><br><span class=\"line\">                    h = Math.min(i, Integer.MAX_VALUE - (-low) - 1);</span><br><span class=\"line\">                &#125; catch (NumberFormatException nfe) &#123;</span><br><span class=\"line\">                    // If the property cannot be parsed into an int, ignore it.</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            high = h;</span><br><span class=\"line\">            //创建缓存常量数组</span><br><span class=\"line\">            cache = new Integer[(high - low) + 1];</span><br><span class=\"line\">            int j = low;</span><br><span class=\"line\">            //设置数组元素值</span><br><span class=\"line\">            for (int k = 0; k &lt; cache.length; k++)</span><br><span class=\"line\">                cache[k] = new Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">            //通过断言确保数组最小范围为：[-128,127]</span><br><span class=\"line\">            assert IntegerCache.high &gt;= 127;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        private IntegerCache() &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //...</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 自动装箱</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * int -&gt; Integer</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param i</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static Integer valueOf(int i) &#123;</span><br><span class=\"line\">        //如果在缓存范围内，直接从缓存中区，</span><br><span class=\"line\">        if (i &gt;= Integer.IntegerCache.low &amp;&amp; i &lt;= Integer.IntegerCache.high)</span><br><span class=\"line\">            return Integer.IntegerCache.cache[i + (-Integer.IntegerCache.low)];</span><br><span class=\"line\">        // 在缓存空间外，重新创建</span><br><span class=\"line\">        return new Integer(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在默认情况下，Integer创建的缓存常量为 [-128,127],所以在上面的例子中，<code>Integer a = 100</code> 创建 a 对象是直接从常量数组中获取的，直接找到他的引用，b也是同样的，则 <code>a==b</code> 返回true;对于 <code>Integer c = 200</code> ,在常量池中没有缓存 ，则 通过 <code>new Integer(200)</code> 创建新对象，d也是这样创建的，他们所指向的引用不同，则 <code>c==d</code> 返回为 <code>false</code> 。</p>\n<p>在上面的 缓存类 <code>IntegerCache</code> 中的静态代码块中，使用 <code>sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</code><br>获取设置jvm最大的Integer缓存池范围。可以手动指定该值，通过设置 <code>-XX:AutoBoxCacheMax=2000</code> 属性，如下命令行编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译生成字节码</span><br><span class=\"line\">javac TestInteger.java</span><br><span class=\"line\">//指定范围最最大值为2000，运行</span><br><span class=\"line\">java -XX:AutoBoxCacheMax=2000 TestInteger</span><br></pre></td></tr></table></figure>\n<p>此时如下代码输出均为true：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = 100 ;</span><br><span class=\"line\">Integer b = 100 ;</span><br><span class=\"line\">Integer c = 200 ;</span><br><span class=\"line\">Integer d = 200 ;</span><br><span class=\"line\">System.out.println(a==b);</span><br><span class=\"line\">System.out.println(c==d);</span><br></pre></td></tr></table></figure>\n<p>如果使用ide,直接设置 运行时 VM 值即可，如下图</p>\n<p><img src=\"/img/article_img/2016/setvmintegerMax.png\" alt=\"\"></p>\n<p>此外，在上面的代码中用到了  <code>assert(断言)</code> 关键字，它主要用来保证代码的正确性。<br>使用发方法为 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assert 表达式;</span><br></pre></td></tr></table></figure>\n<p>若表达式为 <code>true</code> ,则程序正常运行，否则 抛出异常 <code>java.lang.AssertionError</code>。编辑器默认的是将他关闭的，此时就算表达式为false也没有任何效果。<br>在idea中开启断言的方式和上面设置 vm值一样，只是这里设置的 是 <code>-ea</code> 。</p>\n<p>可使用下面代码测试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean isOpen = false;</span><br><span class=\"line\">assert isOpen;</span><br><span class=\"line\">System.out.println(isOpen);</span><br></pre></td></tr></table></figure>\n<p>开启前打印为false，开启后打印为true 。</p>"},{"title":"ScrollView嵌套ListView的解决方案","date":"2016-04-23T08:29:25.000Z","_content":"在android开发中，有时会遇到ScrollView嵌套ListView的相关问题，然而直接使用ScrollView 嵌套ListView，会导致界面卡顿无法滚动，或者listview只希显示1行（设置lisview的高度为400dp课以解决）。<!--more-->网上也有不同的解决方案，但主要有以下几种。\n### 1、不使用ScrollView\n\n这种做法是直接将scrollview中除lisview的部分单独写到一个布局文件中，将其加入到listview的头部（即：position==0 的位置）。\n```\nlistView.addHeaderView(LayoutInflater.from(getApplicationContext()).\n\t\t\t\t\tinflate(R.layout.list_top_view, null));\n或者在adapter的getview中加：\nif(position==0)\n{\n        convertView = LayoutInflater.from(context).inflate(R.layout.list_top_view, null);\n\treturn convertView;\n}\n```\n注：“这种方法不推荐使用，使用它就破会listview 使用ViewHolder的结构，不能达到优化的目的。\n### 2、动态测量ListView\n\n在执行完listView.setAdapter(myAdapter);后调用下面的方法；\n```\n\t/** 动态设置ListView的高度\n\t * @param listView\n\t */\n\tpublic  void setListViewHeightBasedOnChildren(ListView listView) {\n\t\tif(listView == null) return;\n\t\tListAdapter listAdapter = listView.getAdapter();\n\t\tif (listAdapter == null) {\n\t\t\treturn;\n\t\t}\n\t\tint totalHeight = 0;\n\t\tfor (int i = 0; i < listAdapter.getCount(); i++) {\n\t\t\tView listItem = listAdapter.getView(i, null, listView);\n\t\t\tlistItem.measure(0, 0);\n\t\t\ttotalHeight += listItem.getMeasuredHeight();\n\t\t}\n\t\tViewGroup.LayoutParams params = listView.getLayoutParams();\n\t\tparams.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1));\n\t\tlistView.setLayoutParams(params);\n\t}\n}\n```\n但是这样，界面显示的是以listview开始的，他上的内容不会显示，需手动设置ScrollView定位到顶部，或者让listview失去焦点（listView.setFocusable(false);）也可显示顶部内容。\nscrollView定位到顶部代码：\n```\nscrollView.smoothScrollTo(0, 20);\nscrollView.fullScroll(ScrollView.FOCUS_UP);//此处无效\nscrollView.scrollTo(0, 0);//此处无效\n```\n注：这种方法不用更改控件，但是它必须要求getview返回的view的布局是LinearLayout的，否则会抛出异常，而且使用时，会把所有lisview的所有item 绘制出来。\n### 3、自定义ListView\n\n自定义listview，继承自ListView，添加原有的三个构造方法，重写onMeasure() 方法，在布局文件处使用自定义的Listview，具体代码如下：\n```\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.widget.ListView;\n\npublic class MyListView extends ListView {\n\n\tpublic MyListView(Context context) {\n\t\tsuper(context);\n\t\t// TODO Auto-generated constructor stub\n\t}\n\tpublic MyListView(Context context, AttributeSet attrs) {\n\t\tsuper(context, attrs);\n\t\t// TODO Auto-generated constructor stub\n\t}\n\tpublic MyListView(Context context, AttributeSet attrs, int defStyle) {\n\t\tsuper(context, attrs, defStyle);\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\t/**\n\t * 重写原方法，使ListView适应ScrollView的效果\n\t */\n\t@Override\n\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\t\tint expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE >> 2,\n\t\t\t\tMeasureSpec.AT_MOST);\n\t\tsuper.onMeasure(widthMeasureSpec, expandSpec);\n\t}\n}\n```\n注：这种方法使用起来较为方便，它保正了lisview的所有方法，个人就是这样用的。\n除此之外，还有使用linearLayout替代lisview，个人没有进行测试，感兴趣的的可以尝试下。对上面的各种方法，个人都经过测试，进行事件的监听也不会出先问题，可以放心使用。\n","source":"_posts/listView-in-scrollView.md","raw":"---\ntitle: ScrollView嵌套ListView的解决方案\ndate: 2016-04-23 16:29:25\ncategories: [android,学习笔记]\ntags: [ScrollView,ListView]\n---\n在android开发中，有时会遇到ScrollView嵌套ListView的相关问题，然而直接使用ScrollView 嵌套ListView，会导致界面卡顿无法滚动，或者listview只希显示1行（设置lisview的高度为400dp课以解决）。<!--more-->网上也有不同的解决方案，但主要有以下几种。\n### 1、不使用ScrollView\n\n这种做法是直接将scrollview中除lisview的部分单独写到一个布局文件中，将其加入到listview的头部（即：position==0 的位置）。\n```\nlistView.addHeaderView(LayoutInflater.from(getApplicationContext()).\n\t\t\t\t\tinflate(R.layout.list_top_view, null));\n或者在adapter的getview中加：\nif(position==0)\n{\n        convertView = LayoutInflater.from(context).inflate(R.layout.list_top_view, null);\n\treturn convertView;\n}\n```\n注：“这种方法不推荐使用，使用它就破会listview 使用ViewHolder的结构，不能达到优化的目的。\n### 2、动态测量ListView\n\n在执行完listView.setAdapter(myAdapter);后调用下面的方法；\n```\n\t/** 动态设置ListView的高度\n\t * @param listView\n\t */\n\tpublic  void setListViewHeightBasedOnChildren(ListView listView) {\n\t\tif(listView == null) return;\n\t\tListAdapter listAdapter = listView.getAdapter();\n\t\tif (listAdapter == null) {\n\t\t\treturn;\n\t\t}\n\t\tint totalHeight = 0;\n\t\tfor (int i = 0; i < listAdapter.getCount(); i++) {\n\t\t\tView listItem = listAdapter.getView(i, null, listView);\n\t\t\tlistItem.measure(0, 0);\n\t\t\ttotalHeight += listItem.getMeasuredHeight();\n\t\t}\n\t\tViewGroup.LayoutParams params = listView.getLayoutParams();\n\t\tparams.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1));\n\t\tlistView.setLayoutParams(params);\n\t}\n}\n```\n但是这样，界面显示的是以listview开始的，他上的内容不会显示，需手动设置ScrollView定位到顶部，或者让listview失去焦点（listView.setFocusable(false);）也可显示顶部内容。\nscrollView定位到顶部代码：\n```\nscrollView.smoothScrollTo(0, 20);\nscrollView.fullScroll(ScrollView.FOCUS_UP);//此处无效\nscrollView.scrollTo(0, 0);//此处无效\n```\n注：这种方法不用更改控件，但是它必须要求getview返回的view的布局是LinearLayout的，否则会抛出异常，而且使用时，会把所有lisview的所有item 绘制出来。\n### 3、自定义ListView\n\n自定义listview，继承自ListView，添加原有的三个构造方法，重写onMeasure() 方法，在布局文件处使用自定义的Listview，具体代码如下：\n```\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.widget.ListView;\n\npublic class MyListView extends ListView {\n\n\tpublic MyListView(Context context) {\n\t\tsuper(context);\n\t\t// TODO Auto-generated constructor stub\n\t}\n\tpublic MyListView(Context context, AttributeSet attrs) {\n\t\tsuper(context, attrs);\n\t\t// TODO Auto-generated constructor stub\n\t}\n\tpublic MyListView(Context context, AttributeSet attrs, int defStyle) {\n\t\tsuper(context, attrs, defStyle);\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\t/**\n\t * 重写原方法，使ListView适应ScrollView的效果\n\t */\n\t@Override\n\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\t\tint expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE >> 2,\n\t\t\t\tMeasureSpec.AT_MOST);\n\t\tsuper.onMeasure(widthMeasureSpec, expandSpec);\n\t}\n}\n```\n注：这种方法使用起来较为方便，它保正了lisview的所有方法，个人就是这样用的。\n除此之外，还有使用linearLayout替代lisview，个人没有进行测试，感兴趣的的可以尝试下。对上面的各种方法，个人都经过测试，进行事件的监听也不会出先问题，可以放心使用。\n","slug":"listView-in-scrollView","published":1,"updated":"2016-04-23T10:18:09.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucir0033g0g5c0a4pfkn","content":"<p>在android开发中，有时会遇到ScrollView嵌套ListView的相关问题，然而直接使用ScrollView 嵌套ListView，会导致界面卡顿无法滚动，或者listview只希显示1行（设置lisview的高度为400dp课以解决）。<a id=\"more\"></a>网上也有不同的解决方案，但主要有以下几种。</p>\n<h3 id=\"1、不使用ScrollView\"><a href=\"#1、不使用ScrollView\" class=\"headerlink\" title=\"1、不使用ScrollView\"></a>1、不使用ScrollView</h3><p>这种做法是直接将scrollview中除lisview的部分单独写到一个布局文件中，将其加入到listview的头部（即：position==0 的位置）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listView.addHeaderView(LayoutInflater.from(getApplicationContext()).</span><br><span class=\"line\">\t\t\t\t\tinflate(R.layout.list_top_view, null));</span><br><span class=\"line\">或者在adapter的getview中加：</span><br><span class=\"line\">if(position==0)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        convertView = LayoutInflater.from(context).inflate(R.layout.list_top_view, null);</span><br><span class=\"line\">\treturn convertView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注：“这种方法不推荐使用，使用它就破会listview 使用ViewHolder的结构，不能达到优化的目的。</p>\n<h3 id=\"2、动态测量ListView\"><a href=\"#2、动态测量ListView\" class=\"headerlink\" title=\"2、动态测量ListView\"></a>2、动态测量ListView</h3><p>在执行完listView.setAdapter(myAdapter);后调用下面的方法；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t/** 动态设置ListView的高度</span><br><span class=\"line\">\t * @param listView</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic  void setListViewHeightBasedOnChildren(ListView listView) &#123;</span><br><span class=\"line\">\t\tif(listView == null) return;</span><br><span class=\"line\">\t\tListAdapter listAdapter = listView.getAdapter();</span><br><span class=\"line\">\t\tif (listAdapter == null) &#123;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint totalHeight = 0;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; listAdapter.getCount(); i++) &#123;</span><br><span class=\"line\">\t\t\tView listItem = listAdapter.getView(i, null, listView);</span><br><span class=\"line\">\t\t\tlistItem.measure(0, 0);</span><br><span class=\"line\">\t\t\ttotalHeight += listItem.getMeasuredHeight();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tViewGroup.LayoutParams params = listView.getLayoutParams();</span><br><span class=\"line\">\t\tparams.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1));</span><br><span class=\"line\">\t\tlistView.setLayoutParams(params);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是这样，界面显示的是以listview开始的，他上的内容不会显示，需手动设置ScrollView定位到顶部，或者让listview失去焦点（listView.setFocusable(false);）也可显示顶部内容。<br>scrollView定位到顶部代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollView.smoothScrollTo(0, 20);</span><br><span class=\"line\">scrollView.fullScroll(ScrollView.FOCUS_UP);//此处无效</span><br><span class=\"line\">scrollView.scrollTo(0, 0);//此处无效</span><br></pre></td></tr></table></figure></p>\n<p>注：这种方法不用更改控件，但是它必须要求getview返回的view的布局是LinearLayout的，否则会抛出异常，而且使用时，会把所有lisview的所有item 绘制出来。</p>\n<h3 id=\"3、自定义ListView\"><a href=\"#3、自定义ListView\" class=\"headerlink\" title=\"3、自定义ListView\"></a>3、自定义ListView</h3><p>自定义listview，继承自ListView，添加原有的三个构造方法，重写onMeasure() 方法，在布局文件处使用自定义的Listview，具体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.util.AttributeSet;</span><br><span class=\"line\">import android.widget.ListView;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MyListView extends ListView &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic MyListView(Context context) &#123;</span><br><span class=\"line\">\t\tsuper(context);</span><br><span class=\"line\">\t\t// TODO Auto-generated constructor stub</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic MyListView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">\t\tsuper(context, attrs);</span><br><span class=\"line\">\t\t// TODO Auto-generated constructor stub</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic MyListView(Context context, AttributeSet attrs, int defStyle) &#123;</span><br><span class=\"line\">\t\tsuper(context, attrs, defStyle);</span><br><span class=\"line\">\t\t// TODO Auto-generated constructor stub</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 重写原方法，使ListView适应ScrollView的效果</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">\t\tint expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2,</span><br><span class=\"line\">\t\t\t\tMeasureSpec.AT_MOST);</span><br><span class=\"line\">\t\tsuper.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注：这种方法使用起来较为方便，它保正了lisview的所有方法，个人就是这样用的。<br>除此之外，还有使用linearLayout替代lisview，个人没有进行测试，感兴趣的的可以尝试下。对上面的各种方法，个人都经过测试，进行事件的监听也不会出先问题，可以放心使用。</p>\n","excerpt":"<p>在android开发中，有时会遇到ScrollView嵌套ListView的相关问题，然而直接使用ScrollView 嵌套ListView，会导致界面卡顿无法滚动，或者listview只希显示1行（设置lisview的高度为400dp课以解决）。","more":"网上也有不同的解决方案，但主要有以下几种。</p>\n<h3 id=\"1、不使用ScrollView\"><a href=\"#1、不使用ScrollView\" class=\"headerlink\" title=\"1、不使用ScrollView\"></a>1、不使用ScrollView</h3><p>这种做法是直接将scrollview中除lisview的部分单独写到一个布局文件中，将其加入到listview的头部（即：position==0 的位置）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listView.addHeaderView(LayoutInflater.from(getApplicationContext()).</span><br><span class=\"line\">\t\t\t\t\tinflate(R.layout.list_top_view, null));</span><br><span class=\"line\">或者在adapter的getview中加：</span><br><span class=\"line\">if(position==0)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        convertView = LayoutInflater.from(context).inflate(R.layout.list_top_view, null);</span><br><span class=\"line\">\treturn convertView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注：“这种方法不推荐使用，使用它就破会listview 使用ViewHolder的结构，不能达到优化的目的。</p>\n<h3 id=\"2、动态测量ListView\"><a href=\"#2、动态测量ListView\" class=\"headerlink\" title=\"2、动态测量ListView\"></a>2、动态测量ListView</h3><p>在执行完listView.setAdapter(myAdapter);后调用下面的方法；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t/** 动态设置ListView的高度</span><br><span class=\"line\">\t * @param listView</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic  void setListViewHeightBasedOnChildren(ListView listView) &#123;</span><br><span class=\"line\">\t\tif(listView == null) return;</span><br><span class=\"line\">\t\tListAdapter listAdapter = listView.getAdapter();</span><br><span class=\"line\">\t\tif (listAdapter == null) &#123;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint totalHeight = 0;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; listAdapter.getCount(); i++) &#123;</span><br><span class=\"line\">\t\t\tView listItem = listAdapter.getView(i, null, listView);</span><br><span class=\"line\">\t\t\tlistItem.measure(0, 0);</span><br><span class=\"line\">\t\t\ttotalHeight += listItem.getMeasuredHeight();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tViewGroup.LayoutParams params = listView.getLayoutParams();</span><br><span class=\"line\">\t\tparams.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1));</span><br><span class=\"line\">\t\tlistView.setLayoutParams(params);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是这样，界面显示的是以listview开始的，他上的内容不会显示，需手动设置ScrollView定位到顶部，或者让listview失去焦点（listView.setFocusable(false);）也可显示顶部内容。<br>scrollView定位到顶部代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollView.smoothScrollTo(0, 20);</span><br><span class=\"line\">scrollView.fullScroll(ScrollView.FOCUS_UP);//此处无效</span><br><span class=\"line\">scrollView.scrollTo(0, 0);//此处无效</span><br></pre></td></tr></table></figure></p>\n<p>注：这种方法不用更改控件，但是它必须要求getview返回的view的布局是LinearLayout的，否则会抛出异常，而且使用时，会把所有lisview的所有item 绘制出来。</p>\n<h3 id=\"3、自定义ListView\"><a href=\"#3、自定义ListView\" class=\"headerlink\" title=\"3、自定义ListView\"></a>3、自定义ListView</h3><p>自定义listview，继承自ListView，添加原有的三个构造方法，重写onMeasure() 方法，在布局文件处使用自定义的Listview，具体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.util.AttributeSet;</span><br><span class=\"line\">import android.widget.ListView;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MyListView extends ListView &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic MyListView(Context context) &#123;</span><br><span class=\"line\">\t\tsuper(context);</span><br><span class=\"line\">\t\t// TODO Auto-generated constructor stub</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic MyListView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">\t\tsuper(context, attrs);</span><br><span class=\"line\">\t\t// TODO Auto-generated constructor stub</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic MyListView(Context context, AttributeSet attrs, int defStyle) &#123;</span><br><span class=\"line\">\t\tsuper(context, attrs, defStyle);</span><br><span class=\"line\">\t\t// TODO Auto-generated constructor stub</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 重写原方法，使ListView适应ScrollView的效果</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">\t\tint expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2,</span><br><span class=\"line\">\t\t\t\tMeasureSpec.AT_MOST);</span><br><span class=\"line\">\t\tsuper.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注：这种方法使用起来较为方便，它保正了lisview的所有方法，个人就是这样用的。<br>除此之外，还有使用linearLayout替代lisview，个人没有进行测试，感兴趣的的可以尝试下。对上面的各种方法，个人都经过测试，进行事件的监听也不会出先问题，可以放心使用。</p>"},{"title":"ListView的优化技巧","date":"2016-04-23T08:30:25.000Z","_content":"在实际的应用开发时，往往有很多地方需要使用listview,当然我们得了解它的一些技巧。<!--more-->\n### 1.ListView的优化技巧\n\n主要使用ViewHolder来提高效率，利用它的视图缓存机制，避免每次在调用方getView()方法时通过findViewById()实例化控件。使用时，只需在自定义的adapter中定义内部类ViewHolder，将ListView的item中的控件作为其成员变量。\n\n如下getView()方法：\n ```\n\t@Override\n\t   public View getView(int position, View convertView, ViewGroup parent) {\n\t     ViewHolder holder = null;\n\t       // 判断是否缓存\n\t       if (convertView == null) {\n\t           holder = new ViewHolder();\n\t           // 通过LayoutInflater实例化布局\n\t           convertView = mInflater.inflate(R.layout.notify_item, null);\n\t           holder.img = (ImageView) convertView.findViewById(R.id.imageView);\n\t           holder.title = (TextView) convertView.findViewById(R.id.textView);\n\t           convertView.setTag(holder);\n\t       } else {\n\t           // 通过tag找到缓存的布局\n\t           holder = (ViewHolder) convertView.getTag();\n\t       }\n\t       // 设置布局中控件要显示的视图\n\t       holder.img.setBackgroundResource(R.drawable.ic_launcher);\n\t       holder.title.setText(mData.get(position));\n\t       return convertView;\n\t   }\n\t//定义内部类\n\t   public final class ViewHolder {\n\t       public ImageView img;\n\t       public TextView title;\n\t   }\n    ```\n### 2.ListView的常用属性\n\n设置分割线\n```\nandroid:divider=\"@null\"\n```\n隐藏滚动条\n```\nandroid:scrollbars=\"none\"\n```\n设置要显示在第N项\n```\n//瞬间完成\nlistView.setSelection(N);\n//平滑完成\nlistView.smoothScrollBy(distance,duration);\nlistView.smoothScrollByOffset(offset);\nlistView.smoothScrollToPosition(n);\n```\n动态修改\n```\n//改变llist后调用\nmAdapter.notifyDataSetChanged();\n```\n### 3.动态改变ListView的布局\n\n如：实现聊天界面，加载连个布局的。\n主要是比普通的adapter多实现getItemViewType()和getViewType()两个方法，然后再getView()中作出相应的处理。\n如下部分主要代码：\n```\n//返回第position个item是何种类型\n    @Override\n    public int getItemViewType(int position) {\n        ChatItemListViewBean bean = mData.get(position);\n        return bean.getType();\n    }\n\n\t//返回不同布局的总数\n    @Override\n    public int getViewTypeCount() {\n        return 2;\n    }</span>\n\t\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        if (convertView == null) {\n\t\t\t//判断布局类型\n            if (getItemViewType(position) == 0) {\n                holder = new ViewHolder();\n                convertView = mInflater.inflate(\n                        R.layout.chat_item_itemin, null);\n                holder.icon = (ImageView) convertView.findViewById(\n                        R.id.icon_in);\n                holder.text = (TextView) convertView.findViewById(\n                        R.id.text_in);\n            } else {\n                holder = new ViewHolder();\n                convertView = mInflater.inflate(\n                        R.layout.chat_item_itemout, null);\n                holder.icon = (ImageView) convertView.findViewById(\n                        R.id.icon_out);\n                holder.text = (TextView) convertView.findViewById(\n                        R.id.text_out);\n            }\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        holder.icon.setImageBitmap(mData.get(position).getIcon());\n        holder.text.setText(mData.get(position).getText());\n        return convertView;\n    }\n```\n此外，ListView还能设置滑动监听，有OnTouchListener和OnScrollListener监听事件。\n\n\n\n\n\n\n","source":"_posts/listview-optimize.md","raw":"---\ntitle: ListView的优化技巧\ndate: 2016-04-23 16:30:25\ncategories: [android,学习笔记]\ntags: [Listview,性能优化]\n---\n在实际的应用开发时，往往有很多地方需要使用listview,当然我们得了解它的一些技巧。<!--more-->\n### 1.ListView的优化技巧\n\n主要使用ViewHolder来提高效率，利用它的视图缓存机制，避免每次在调用方getView()方法时通过findViewById()实例化控件。使用时，只需在自定义的adapter中定义内部类ViewHolder，将ListView的item中的控件作为其成员变量。\n\n如下getView()方法：\n ```\n\t@Override\n\t   public View getView(int position, View convertView, ViewGroup parent) {\n\t     ViewHolder holder = null;\n\t       // 判断是否缓存\n\t       if (convertView == null) {\n\t           holder = new ViewHolder();\n\t           // 通过LayoutInflater实例化布局\n\t           convertView = mInflater.inflate(R.layout.notify_item, null);\n\t           holder.img = (ImageView) convertView.findViewById(R.id.imageView);\n\t           holder.title = (TextView) convertView.findViewById(R.id.textView);\n\t           convertView.setTag(holder);\n\t       } else {\n\t           // 通过tag找到缓存的布局\n\t           holder = (ViewHolder) convertView.getTag();\n\t       }\n\t       // 设置布局中控件要显示的视图\n\t       holder.img.setBackgroundResource(R.drawable.ic_launcher);\n\t       holder.title.setText(mData.get(position));\n\t       return convertView;\n\t   }\n\t//定义内部类\n\t   public final class ViewHolder {\n\t       public ImageView img;\n\t       public TextView title;\n\t   }\n    ```\n### 2.ListView的常用属性\n\n设置分割线\n```\nandroid:divider=\"@null\"\n```\n隐藏滚动条\n```\nandroid:scrollbars=\"none\"\n```\n设置要显示在第N项\n```\n//瞬间完成\nlistView.setSelection(N);\n//平滑完成\nlistView.smoothScrollBy(distance,duration);\nlistView.smoothScrollByOffset(offset);\nlistView.smoothScrollToPosition(n);\n```\n动态修改\n```\n//改变llist后调用\nmAdapter.notifyDataSetChanged();\n```\n### 3.动态改变ListView的布局\n\n如：实现聊天界面，加载连个布局的。\n主要是比普通的adapter多实现getItemViewType()和getViewType()两个方法，然后再getView()中作出相应的处理。\n如下部分主要代码：\n```\n//返回第position个item是何种类型\n    @Override\n    public int getItemViewType(int position) {\n        ChatItemListViewBean bean = mData.get(position);\n        return bean.getType();\n    }\n\n\t//返回不同布局的总数\n    @Override\n    public int getViewTypeCount() {\n        return 2;\n    }</span>\n\t\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        if (convertView == null) {\n\t\t\t//判断布局类型\n            if (getItemViewType(position) == 0) {\n                holder = new ViewHolder();\n                convertView = mInflater.inflate(\n                        R.layout.chat_item_itemin, null);\n                holder.icon = (ImageView) convertView.findViewById(\n                        R.id.icon_in);\n                holder.text = (TextView) convertView.findViewById(\n                        R.id.text_in);\n            } else {\n                holder = new ViewHolder();\n                convertView = mInflater.inflate(\n                        R.layout.chat_item_itemout, null);\n                holder.icon = (ImageView) convertView.findViewById(\n                        R.id.icon_out);\n                holder.text = (TextView) convertView.findViewById(\n                        R.id.text_out);\n            }\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        holder.icon.setImageBitmap(mData.get(position).getIcon());\n        holder.text.setText(mData.get(position).getText());\n        return convertView;\n    }\n```\n此外，ListView还能设置滑动监听，有OnTouchListener和OnScrollListener监听事件。\n\n\n\n\n\n\n","slug":"listview-optimize","published":1,"updated":"2016-04-23T10:33:15.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucir0036g0g54g9vdvn6","content":"<p>在实际的应用开发时，往往有很多地方需要使用listview,当然我们得了解它的一些技巧。<a id=\"more\"></a></p>\n<h3 id=\"1-ListView的优化技巧\"><a href=\"#1-ListView的优化技巧\" class=\"headerlink\" title=\"1.ListView的优化技巧\"></a>1.ListView的优化技巧</h3><p>主要使用ViewHolder来提高效率，利用它的视图缓存机制，避免每次在调用方getView()方法时通过findViewById()实例化控件。使用时，只需在自定义的adapter中定义内部类ViewHolder，将ListView的item中的控件作为其成员变量。</p>\n<p>如下getView()方法：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">   public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class=\"line\">     ViewHolder holder = null;</span><br><span class=\"line\">       // 判断是否缓存</span><br><span class=\"line\">       if (convertView == null) &#123;</span><br><span class=\"line\">           holder = new ViewHolder();</span><br><span class=\"line\">           // 通过LayoutInflater实例化布局</span><br><span class=\"line\">           convertView = mInflater.inflate(R.layout.notify_item, null);</span><br><span class=\"line\">           holder.img = (ImageView) convertView.findViewById(R.id.imageView);</span><br><span class=\"line\">           holder.title = (TextView) convertView.findViewById(R.id.textView);</span><br><span class=\"line\">           convertView.setTag(holder);</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           // 通过tag找到缓存的布局</span><br><span class=\"line\">           holder = (ViewHolder) convertView.getTag();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       // 设置布局中控件要显示的视图</span><br><span class=\"line\">       holder.img.setBackgroundResource(R.drawable.ic_launcher);</span><br><span class=\"line\">       holder.title.setText(mData.get(position));</span><br><span class=\"line\">       return convertView;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">//定义内部类</span><br><span class=\"line\">   public final class ViewHolder &#123;</span><br><span class=\"line\">       public ImageView img;</span><br><span class=\"line\">       public TextView title;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-ListView的常用属性\"><a href=\"#2-ListView的常用属性\" class=\"headerlink\" title=\"2.ListView的常用属性\"></a>2.ListView的常用属性</h3><p>设置分割线<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:divider=&quot;@null&quot;</span><br></pre></td></tr></table></figure></p>\n<p>隐藏滚动条<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:scrollbars=&quot;none&quot;</span><br></pre></td></tr></table></figure></p>\n<p>设置要显示在第N项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//瞬间完成</span><br><span class=\"line\">listView.setSelection(N);</span><br><span class=\"line\">//平滑完成</span><br><span class=\"line\">listView.smoothScrollBy(distance,duration);</span><br><span class=\"line\">listView.smoothScrollByOffset(offset);</span><br><span class=\"line\">listView.smoothScrollToPosition(n);</span><br></pre></td></tr></table></figure></p>\n<p>动态修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//改变llist后调用</span><br><span class=\"line\">mAdapter.notifyDataSetChanged();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-动态改变ListView的布局\"><a href=\"#3-动态改变ListView的布局\" class=\"headerlink\" title=\"3.动态改变ListView的布局\"></a>3.动态改变ListView的布局</h3><p>如：实现聊天界面，加载连个布局的。<br>主要是比普通的adapter多实现getItemViewType()和getViewType()两个方法，然后再getView()中作出相应的处理。<br>如下部分主要代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//返回第position个item是何种类型</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getItemViewType(int position) &#123;</span><br><span class=\"line\">        ChatItemListViewBean bean = mData.get(position);</span><br><span class=\"line\">        return bean.getType();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//返回不同布局的总数</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getViewTypeCount() &#123;</span><br><span class=\"line\">        return 2;</span><br><span class=\"line\">    &#125;&lt;/span&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class=\"line\">        ViewHolder holder;</span><br><span class=\"line\">        if (convertView == null) &#123;</span><br><span class=\"line\">\t\t\t//判断布局类型</span><br><span class=\"line\">            if (getItemViewType(position) == 0) &#123;</span><br><span class=\"line\">                holder = new ViewHolder();</span><br><span class=\"line\">                convertView = mInflater.inflate(</span><br><span class=\"line\">                        R.layout.chat_item_itemin, null);</span><br><span class=\"line\">                holder.icon = (ImageView) convertView.findViewById(</span><br><span class=\"line\">                        R.id.icon_in);</span><br><span class=\"line\">                holder.text = (TextView) convertView.findViewById(</span><br><span class=\"line\">                        R.id.text_in);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                holder = new ViewHolder();</span><br><span class=\"line\">                convertView = mInflater.inflate(</span><br><span class=\"line\">                        R.layout.chat_item_itemout, null);</span><br><span class=\"line\">                holder.icon = (ImageView) convertView.findViewById(</span><br><span class=\"line\">                        R.id.icon_out);</span><br><span class=\"line\">                holder.text = (TextView) convertView.findViewById(</span><br><span class=\"line\">                        R.id.text_out);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            convertView.setTag(holder);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            holder = (ViewHolder) convertView.getTag();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        holder.icon.setImageBitmap(mData.get(position).getIcon());</span><br><span class=\"line\">        holder.text.setText(mData.get(position).getText());</span><br><span class=\"line\">        return convertView;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>此外，ListView还能设置滑动监听，有OnTouchListener和OnScrollListener监听事件。</p>\n","excerpt":"<p>在实际的应用开发时，往往有很多地方需要使用listview,当然我们得了解它的一些技巧。","more":"</p>\n<h3 id=\"1-ListView的优化技巧\"><a href=\"#1-ListView的优化技巧\" class=\"headerlink\" title=\"1.ListView的优化技巧\"></a>1.ListView的优化技巧</h3><p>主要使用ViewHolder来提高效率，利用它的视图缓存机制，避免每次在调用方getView()方法时通过findViewById()实例化控件。使用时，只需在自定义的adapter中定义内部类ViewHolder，将ListView的item中的控件作为其成员变量。</p>\n<p>如下getView()方法：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">   public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class=\"line\">     ViewHolder holder = null;</span><br><span class=\"line\">       // 判断是否缓存</span><br><span class=\"line\">       if (convertView == null) &#123;</span><br><span class=\"line\">           holder = new ViewHolder();</span><br><span class=\"line\">           // 通过LayoutInflater实例化布局</span><br><span class=\"line\">           convertView = mInflater.inflate(R.layout.notify_item, null);</span><br><span class=\"line\">           holder.img = (ImageView) convertView.findViewById(R.id.imageView);</span><br><span class=\"line\">           holder.title = (TextView) convertView.findViewById(R.id.textView);</span><br><span class=\"line\">           convertView.setTag(holder);</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           // 通过tag找到缓存的布局</span><br><span class=\"line\">           holder = (ViewHolder) convertView.getTag();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       // 设置布局中控件要显示的视图</span><br><span class=\"line\">       holder.img.setBackgroundResource(R.drawable.ic_launcher);</span><br><span class=\"line\">       holder.title.setText(mData.get(position));</span><br><span class=\"line\">       return convertView;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">//定义内部类</span><br><span class=\"line\">   public final class ViewHolder &#123;</span><br><span class=\"line\">       public ImageView img;</span><br><span class=\"line\">       public TextView title;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-ListView的常用属性\"><a href=\"#2-ListView的常用属性\" class=\"headerlink\" title=\"2.ListView的常用属性\"></a>2.ListView的常用属性</h3><p>设置分割线<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:divider=&quot;@null&quot;</span><br></pre></td></tr></table></figure></p>\n<p>隐藏滚动条<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:scrollbars=&quot;none&quot;</span><br></pre></td></tr></table></figure></p>\n<p>设置要显示在第N项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//瞬间完成</span><br><span class=\"line\">listView.setSelection(N);</span><br><span class=\"line\">//平滑完成</span><br><span class=\"line\">listView.smoothScrollBy(distance,duration);</span><br><span class=\"line\">listView.smoothScrollByOffset(offset);</span><br><span class=\"line\">listView.smoothScrollToPosition(n);</span><br></pre></td></tr></table></figure></p>\n<p>动态修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//改变llist后调用</span><br><span class=\"line\">mAdapter.notifyDataSetChanged();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-动态改变ListView的布局\"><a href=\"#3-动态改变ListView的布局\" class=\"headerlink\" title=\"3.动态改变ListView的布局\"></a>3.动态改变ListView的布局</h3><p>如：实现聊天界面，加载连个布局的。<br>主要是比普通的adapter多实现getItemViewType()和getViewType()两个方法，然后再getView()中作出相应的处理。<br>如下部分主要代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//返回第position个item是何种类型</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getItemViewType(int position) &#123;</span><br><span class=\"line\">        ChatItemListViewBean bean = mData.get(position);</span><br><span class=\"line\">        return bean.getType();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//返回不同布局的总数</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getViewTypeCount() &#123;</span><br><span class=\"line\">        return 2;</span><br><span class=\"line\">    &#125;&lt;/span&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class=\"line\">        ViewHolder holder;</span><br><span class=\"line\">        if (convertView == null) &#123;</span><br><span class=\"line\">\t\t\t//判断布局类型</span><br><span class=\"line\">            if (getItemViewType(position) == 0) &#123;</span><br><span class=\"line\">                holder = new ViewHolder();</span><br><span class=\"line\">                convertView = mInflater.inflate(</span><br><span class=\"line\">                        R.layout.chat_item_itemin, null);</span><br><span class=\"line\">                holder.icon = (ImageView) convertView.findViewById(</span><br><span class=\"line\">                        R.id.icon_in);</span><br><span class=\"line\">                holder.text = (TextView) convertView.findViewById(</span><br><span class=\"line\">                        R.id.text_in);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                holder = new ViewHolder();</span><br><span class=\"line\">                convertView = mInflater.inflate(</span><br><span class=\"line\">                        R.layout.chat_item_itemout, null);</span><br><span class=\"line\">                holder.icon = (ImageView) convertView.findViewById(</span><br><span class=\"line\">                        R.id.icon_out);</span><br><span class=\"line\">                holder.text = (TextView) convertView.findViewById(</span><br><span class=\"line\">                        R.id.text_out);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            convertView.setTag(holder);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            holder = (ViewHolder) convertView.getTag();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        holder.icon.setImageBitmap(mData.get(position).getIcon());</span><br><span class=\"line\">        holder.text.setText(mData.get(position).getText());</span><br><span class=\"line\">        return convertView;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>此外，ListView还能设置滑动监听，有OnTouchListener和OnScrollListener监听事件。</p>"},{"title":"android 打开其他应用","date":"2016-04-23T08:10:25.000Z","_content":"在开发中，有时需要在自己的应用中打开其他应用，自己写了两个方法来获取手机上安装的所有应用。这里主要以打开支付宝为例。<!--more-->\n（1）、获取手机上的所有应用，将其放在一个list中。\n```\nprivate List<PackageInfo> getAllApps() {     \n\tList<PackageInfo> apps = new ArrayList<PackageInfo>();     \n\tPackageManager packageManager = this.getPackageManager();     \n\t//获取手机内所有应用     \n\tList<PackageInfo> paklist = packageManager.getInstalledPackages(0);     \n\tfor (int i = 0; i < paklist.size(); i++) {     \n\t\tPackageInfo pak = (PackageInfo) paklist.get(i);     \n\t\t//判断是否为非系统预装的应用  (大于0为系统预装应用，小于等于0为非系统应用)   \n\t\tif ((pak.applicationInfo.flags & pak.applicationInfo.FLAG_SYSTEM) <= 0) {     \n\t\t\tapps.add(pak);     \n\t\t}     \n\t}     \n\treturn apps;     \n}  \n```\n（2）、打开指定的app(这里打开的是支付宝)。下面的方法是在知道支付宝app的包名的情况下进行判断的，通常情况下不知道包名，可以通过appLabel可以获取应用的名称，以此来匹配。在不存在的情况下，使用手机自带浏览器打开指定的网页。\n```\nprivate static final String PAY_PACKAGE_NAME = \"com.eg.android.AlipayGphone\";\nprivate static final String PAY_WEB_URL = \"https://auth.alipay.com/login/index.htm\";\n\t\nprivate void launchApp() {   \n\tPackageManager packageManager = this.getPackageManager();   \n\tList<PackageInfo> packages = getAllApps();   \n\tPackageInfo pa = null;   \n\tfor(int i=0;i<packages.size();i++){   \n\t\tpa = packages.get(i);   \n\t\t//获得应用名   \n\t\tString appLabel = packageManager.getApplicationLabel(pa.applicationInfo).toString();   \n\t\t//获得包名   \n\t\tString appPackage = pa.packageName; \n\t\tLog.e(\"test\", \"\"+i+\"----\"+appLabel+\"  \"+appPackage);   \n\t\t\n\t\t//安装支付宝，打开支付宝\n\t\tif(appPackage.equals(PAY_PACKAGE_NAME)){\n\t\t\tmIntent = packageManager.getLaunchIntentForPackage(PAY_PACKAGE_NAME);\n\t\t\tstartActivity(mIntent); \n\t\t\treturn;\n\t\t}\n\t} \n\t//为安装支付宝，打开支付宝登陆的网页\n\tmIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(PAY_WEB_URL));\n\tmIntent.setClassName(\"com.android.browser\", \"com.android.browser.BrowserActivity\");\n\tstartActivity(mIntent);\n}   \n```\n最后，注意添加网络访问的权限。","source":"_posts/open-other-app.md","raw":"---\ntitle: android 打开其他应用\ndate: 2016-04-23 16:10:25\ncategories: [android,学习笔记]\ntags: [android,打开应用]\n---\n在开发中，有时需要在自己的应用中打开其他应用，自己写了两个方法来获取手机上安装的所有应用。这里主要以打开支付宝为例。<!--more-->\n（1）、获取手机上的所有应用，将其放在一个list中。\n```\nprivate List<PackageInfo> getAllApps() {     \n\tList<PackageInfo> apps = new ArrayList<PackageInfo>();     \n\tPackageManager packageManager = this.getPackageManager();     \n\t//获取手机内所有应用     \n\tList<PackageInfo> paklist = packageManager.getInstalledPackages(0);     \n\tfor (int i = 0; i < paklist.size(); i++) {     \n\t\tPackageInfo pak = (PackageInfo) paklist.get(i);     \n\t\t//判断是否为非系统预装的应用  (大于0为系统预装应用，小于等于0为非系统应用)   \n\t\tif ((pak.applicationInfo.flags & pak.applicationInfo.FLAG_SYSTEM) <= 0) {     \n\t\t\tapps.add(pak);     \n\t\t}     \n\t}     \n\treturn apps;     \n}  \n```\n（2）、打开指定的app(这里打开的是支付宝)。下面的方法是在知道支付宝app的包名的情况下进行判断的，通常情况下不知道包名，可以通过appLabel可以获取应用的名称，以此来匹配。在不存在的情况下，使用手机自带浏览器打开指定的网页。\n```\nprivate static final String PAY_PACKAGE_NAME = \"com.eg.android.AlipayGphone\";\nprivate static final String PAY_WEB_URL = \"https://auth.alipay.com/login/index.htm\";\n\t\nprivate void launchApp() {   \n\tPackageManager packageManager = this.getPackageManager();   \n\tList<PackageInfo> packages = getAllApps();   \n\tPackageInfo pa = null;   \n\tfor(int i=0;i<packages.size();i++){   \n\t\tpa = packages.get(i);   \n\t\t//获得应用名   \n\t\tString appLabel = packageManager.getApplicationLabel(pa.applicationInfo).toString();   \n\t\t//获得包名   \n\t\tString appPackage = pa.packageName; \n\t\tLog.e(\"test\", \"\"+i+\"----\"+appLabel+\"  \"+appPackage);   \n\t\t\n\t\t//安装支付宝，打开支付宝\n\t\tif(appPackage.equals(PAY_PACKAGE_NAME)){\n\t\t\tmIntent = packageManager.getLaunchIntentForPackage(PAY_PACKAGE_NAME);\n\t\t\tstartActivity(mIntent); \n\t\t\treturn;\n\t\t}\n\t} \n\t//为安装支付宝，打开支付宝登陆的网页\n\tmIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(PAY_WEB_URL));\n\tmIntent.setClassName(\"com.android.browser\", \"com.android.browser.BrowserActivity\");\n\tstartActivity(mIntent);\n}   \n```\n最后，注意添加网络访问的权限。","slug":"open-other-app","published":1,"updated":"2016-04-23T09:17:14.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucj7003bg0g52rkgz8hm","content":"<p>在开发中，有时需要在自己的应用中打开其他应用，自己写了两个方法来获取手机上安装的所有应用。这里主要以打开支付宝为例。<a id=\"more\"></a><br>（1）、获取手机上的所有应用，将其放在一个list中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;PackageInfo&gt; getAllApps() &#123;     </span><br><span class=\"line\">\tList&lt;PackageInfo&gt; apps = new ArrayList&lt;PackageInfo&gt;();     </span><br><span class=\"line\">\tPackageManager packageManager = this.getPackageManager();     </span><br><span class=\"line\">\t//获取手机内所有应用     </span><br><span class=\"line\">\tList&lt;PackageInfo&gt; paklist = packageManager.getInstalledPackages(0);     </span><br><span class=\"line\">\tfor (int i = 0; i &lt; paklist.size(); i++) &#123;     </span><br><span class=\"line\">\t\tPackageInfo pak = (PackageInfo) paklist.get(i);     </span><br><span class=\"line\">\t\t//判断是否为非系统预装的应用  (大于0为系统预装应用，小于等于0为非系统应用)   </span><br><span class=\"line\">\t\tif ((pak.applicationInfo.flags &amp; pak.applicationInfo.FLAG_SYSTEM) &lt;= 0) &#123;     </span><br><span class=\"line\">\t\t\tapps.add(pak);     </span><br><span class=\"line\">\t\t&#125;     </span><br><span class=\"line\">\t&#125;     </span><br><span class=\"line\">\treturn apps;     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>（2）、打开指定的app(这里打开的是支付宝)。下面的方法是在知道支付宝app的包名的情况下进行判断的，通常情况下不知道包名，可以通过appLabel可以获取应用的名称，以此来匹配。在不存在的情况下，使用手机自带浏览器打开指定的网页。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final String PAY_PACKAGE_NAME = &quot;com.eg.android.AlipayGphone&quot;;</span><br><span class=\"line\">private static final String PAY_WEB_URL = &quot;https://auth.alipay.com/login/index.htm&quot;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">private void launchApp() &#123;   </span><br><span class=\"line\">\tPackageManager packageManager = this.getPackageManager();   </span><br><span class=\"line\">\tList&lt;PackageInfo&gt; packages = getAllApps();   </span><br><span class=\"line\">\tPackageInfo pa = null;   </span><br><span class=\"line\">\tfor(int i=0;i&lt;packages.size();i++)&#123;   </span><br><span class=\"line\">\t\tpa = packages.get(i);   </span><br><span class=\"line\">\t\t//获得应用名   </span><br><span class=\"line\">\t\tString appLabel = packageManager.getApplicationLabel(pa.applicationInfo).toString();   </span><br><span class=\"line\">\t\t//获得包名   </span><br><span class=\"line\">\t\tString appPackage = pa.packageName; </span><br><span class=\"line\">\t\tLog.e(&quot;test&quot;, &quot;&quot;+i+&quot;----&quot;+appLabel+&quot;  &quot;+appPackage);   </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//安装支付宝，打开支付宝</span><br><span class=\"line\">\t\tif(appPackage.equals(PAY_PACKAGE_NAME))&#123;</span><br><span class=\"line\">\t\t\tmIntent = packageManager.getLaunchIntentForPackage(PAY_PACKAGE_NAME);</span><br><span class=\"line\">\t\t\tstartActivity(mIntent); </span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t//为安装支付宝，打开支付宝登陆的网页</span><br><span class=\"line\">\tmIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(PAY_WEB_URL));</span><br><span class=\"line\">\tmIntent.setClassName(&quot;com.android.browser&quot;, &quot;com.android.browser.BrowserActivity&quot;);</span><br><span class=\"line\">\tstartActivity(mIntent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后，注意添加网络访问的权限。</p>\n","excerpt":"<p>在开发中，有时需要在自己的应用中打开其他应用，自己写了两个方法来获取手机上安装的所有应用。这里主要以打开支付宝为例。","more":"<br>（1）、获取手机上的所有应用，将其放在一个list中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;PackageInfo&gt; getAllApps() &#123;     </span><br><span class=\"line\">\tList&lt;PackageInfo&gt; apps = new ArrayList&lt;PackageInfo&gt;();     </span><br><span class=\"line\">\tPackageManager packageManager = this.getPackageManager();     </span><br><span class=\"line\">\t//获取手机内所有应用     </span><br><span class=\"line\">\tList&lt;PackageInfo&gt; paklist = packageManager.getInstalledPackages(0);     </span><br><span class=\"line\">\tfor (int i = 0; i &lt; paklist.size(); i++) &#123;     </span><br><span class=\"line\">\t\tPackageInfo pak = (PackageInfo) paklist.get(i);     </span><br><span class=\"line\">\t\t//判断是否为非系统预装的应用  (大于0为系统预装应用，小于等于0为非系统应用)   </span><br><span class=\"line\">\t\tif ((pak.applicationInfo.flags &amp; pak.applicationInfo.FLAG_SYSTEM) &lt;= 0) &#123;     </span><br><span class=\"line\">\t\t\tapps.add(pak);     </span><br><span class=\"line\">\t\t&#125;     </span><br><span class=\"line\">\t&#125;     </span><br><span class=\"line\">\treturn apps;     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>（2）、打开指定的app(这里打开的是支付宝)。下面的方法是在知道支付宝app的包名的情况下进行判断的，通常情况下不知道包名，可以通过appLabel可以获取应用的名称，以此来匹配。在不存在的情况下，使用手机自带浏览器打开指定的网页。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final String PAY_PACKAGE_NAME = &quot;com.eg.android.AlipayGphone&quot;;</span><br><span class=\"line\">private static final String PAY_WEB_URL = &quot;https://auth.alipay.com/login/index.htm&quot;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">private void launchApp() &#123;   </span><br><span class=\"line\">\tPackageManager packageManager = this.getPackageManager();   </span><br><span class=\"line\">\tList&lt;PackageInfo&gt; packages = getAllApps();   </span><br><span class=\"line\">\tPackageInfo pa = null;   </span><br><span class=\"line\">\tfor(int i=0;i&lt;packages.size();i++)&#123;   </span><br><span class=\"line\">\t\tpa = packages.get(i);   </span><br><span class=\"line\">\t\t//获得应用名   </span><br><span class=\"line\">\t\tString appLabel = packageManager.getApplicationLabel(pa.applicationInfo).toString();   </span><br><span class=\"line\">\t\t//获得包名   </span><br><span class=\"line\">\t\tString appPackage = pa.packageName; </span><br><span class=\"line\">\t\tLog.e(&quot;test&quot;, &quot;&quot;+i+&quot;----&quot;+appLabel+&quot;  &quot;+appPackage);   </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t//安装支付宝，打开支付宝</span><br><span class=\"line\">\t\tif(appPackage.equals(PAY_PACKAGE_NAME))&#123;</span><br><span class=\"line\">\t\t\tmIntent = packageManager.getLaunchIntentForPackage(PAY_PACKAGE_NAME);</span><br><span class=\"line\">\t\t\tstartActivity(mIntent); </span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t//为安装支付宝，打开支付宝登陆的网页</span><br><span class=\"line\">\tmIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(PAY_WEB_URL));</span><br><span class=\"line\">\tmIntent.setClassName(&quot;com.android.browser&quot;, &quot;com.android.browser.BrowserActivity&quot;);</span><br><span class=\"line\">\tstartActivity(mIntent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后，注意添加网络访问的权限。</p>"},{"title":"收集的Android开源框架及其地址","date":"2016-04-23T08:01:25.000Z","_content":"### 1、volley \n项目地址 https://github.com/smanikandan14/Volley-demo\nJSON，图像等的异步下载；\n网络请求的排序（scheduling）\n网络请求的优先级处理\n缓存\n多级别取消请求和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）\n<!--more-->\n### 2、android-async-http\n\n项目地址：https://github.com/loopj/android-async-http，文档介绍：http://loopj.com/android-async-http/ \n\n在匿名回调中处理请求结果\n在UI线程外进行http请求\n文件断点上传\n智能重试\n默认gzip压缩\n支持解析成Json格式\n可将Cookies持久化到SharedPreferences\n### 3、Afinal框架\n\n项目地址：https://github.com/yangfuhai/afinal\n\n主要有四大模块：\n\n数据库模块：Android中的orm框架，使用了线程池对sqlite进行操作。\n注解模块：Android中的ioc框架，完全注解方式就可以进行UI绑定和事件绑定。无需findViewById和setClickListener等。\n网络模块：通过httpclient进行封装http数据请求，支持Ajax方式加载，支持下载、上传文件功能。\n图片缓存模块：通过FinalBitmap，imageview加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。\n　　FinalBitmap可以配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。FinalBitmap的内存管理使用lru算法，没有使用弱引用（Android2.3以后Google已经不建议使用弱引用，Android2.3后强行回收软引用和弱引用，详情查看Android官方文档），更好的管理bitmap内存。FinalBitmap可以自定义下载器，用来扩展其他协议显示网络图片，比如ftp等。同时可以自定义bitmap显示器，\n\n　　在imageview显示图片的时候播放动画等（默认是渐变动画显示）。\n\n### 4、xUtils框架\n\n项目地址：https://github.com/wyouflf/xUtils，主要有四大模块：\n**数据库模块：**\nAndroid 中的 orm 框架，一行代码就可以进行增删改查；\n支持事务，默认关闭；\n可通过注解自定义表名，列名，外键，唯一性约束，NOT NULL约束，CHECK约束等（需要混淆的时候请注解表名和列名）；\n支持绑定外键，保存实体时外键关联实体自动保存或更新；\n自动加载外键关联实体，支持延时加载；\n支持链式表达查询，更直观的查询语义，参考下面的介绍或sample中的例子。          \n**注解模块：**\n\nAndroid中的 ioc 框架，完全注解方式就可以进行 UI，资源和事件绑定；\n新的事件绑定方式，使用混淆工具混淆后仍可正常工作；\n目前支持常用的20种事件绑定，参见 View Common Event Listener 类和包com.lidroid.xutils.view.annotation.event。\n**网络模块：**\n\n支持同步，异步方式的请求；\n支持大文件上传，上传大文件不会oom；\n支持GET，POST，PUT，MOVE，COPY，DELETE，HEAD，OPTIONS，TRACE，CONNECT请求；\n下载支持301/302重定向，支持设置是否根据Content-Disposition重命名下载的文件；\n返回文本内容的请求（默认只启用了GET请求）支持缓存，可设置默认过期时间和针对当前请求的过期时间。\n**图片缓存模块：**\n\n加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象；\n支持加载网络图片和本地图片；\n内存管理使用lru算法，更好的管理bitmap内存；\n可配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。\n### 5、ThinkAndroid\n\n项目地址：https://github.com/white-cat/ThinkAndroid\n\n主要有以下模块：\n\n**MVC模块：**实现视图与模型的分离。\n**ioc模块：** Android中的ioc模块，完全注解方式就可以进行UI绑定、res中的资源的读取、以及对象的初始化。 \n**数据库模块：** Android中的orm框架，使用了线程池对sqlite进行操作。  \n**http模块：** 通过httpclient进行封装http数据请求，支持异步及同步方式加载。\n**缓存模块：** 通过简单的配置及设计可以很好的实现缓存，对缓存可以随意的配置\n**图片缓存模块：** i mageview加载图片的时候无需考虑图片加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。\n**配置器模块：** 可以对简易的实现配对配置的操作，目前配置文件可以支持Preference、Properties对配置进行存取。\n**日志打印模块**：可以较快的轻易的是实现日志打印，支持日志打印的扩展，目前支持对sdcard写入本地打印、以及控制台打印\n**下载器模块**：可以简单的实现多线程下载、后台下载、断点续传、对下载进行控制、如开始、暂停、删除等等。\n**网络状态检测模块**：当网络状态改变时，对其进行检。\n### 6、LoonAndroid\n\n项目地址：https://github.com/gdpancheng/LoonAndroid\n\n主要有以下模块：\n自动注入框架（只需要继承框架内的APP既可）\n图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性）\n网络请求模块（继承了基本上现在所有的http请求）\neventbus（集成一个开源的框架）\n验证框架（集成开源框架）\nJson解析（支持解析成集合或者对象）\n数据库（不知道是哪位写的 忘记了）\n多线程断点下载（自动判断是否支持多线程，判断是否是重定向）\n自动更新模块\n一系列工具类\n\n### 7、图片加载：\n Universal Image Loader - https://github.com/onlyTan/Android-Universal-Image-Loader\n\n用法参考 -http://blog.csdn.net/xiaanming/article/details/26810303\n\n\n### 8、动画框架：\n  nineoldandroids -  https://github.com/JakeWharton/NineOldAndroids\n用法参考 -http://blog.csdn.net/lmj623565791/article/details/38067475\n\n\n### 9、进程间通信框架：\n   eventBus -  https://github.com/greenrobot/EventBus\n用法参考 - http://blog.csdn.net/lmj623565791/article/details/40794879\n\n\n### 10、SQLite数据库：\nLitePal - \n\nhttps://github.com/LitePalFramework/LitePal\n\n\n\n### 11、百分比布局：\nandroid-percent-support-extend  -  \n\nhttps://github.com/hongyangAndroid/android-percent-support-extend\n\n百分比布局：\nandroid-percent-support-extend  -  \n\nhttps://github.com/hongyangAndroid/android-percent-support-extend","source":"_posts/open-source-frame.md","raw":"---\ntitle: 收集的Android开源框架及其地址\ndate: 2016-04-23 16:01:25\ncategories: [android,学习笔记]\ntags: [android,开源框架]\n---\n### 1、volley \n项目地址 https://github.com/smanikandan14/Volley-demo\nJSON，图像等的异步下载；\n网络请求的排序（scheduling）\n网络请求的优先级处理\n缓存\n多级别取消请求和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）\n<!--more-->\n### 2、android-async-http\n\n项目地址：https://github.com/loopj/android-async-http，文档介绍：http://loopj.com/android-async-http/ \n\n在匿名回调中处理请求结果\n在UI线程外进行http请求\n文件断点上传\n智能重试\n默认gzip压缩\n支持解析成Json格式\n可将Cookies持久化到SharedPreferences\n### 3、Afinal框架\n\n项目地址：https://github.com/yangfuhai/afinal\n\n主要有四大模块：\n\n数据库模块：Android中的orm框架，使用了线程池对sqlite进行操作。\n注解模块：Android中的ioc框架，完全注解方式就可以进行UI绑定和事件绑定。无需findViewById和setClickListener等。\n网络模块：通过httpclient进行封装http数据请求，支持Ajax方式加载，支持下载、上传文件功能。\n图片缓存模块：通过FinalBitmap，imageview加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。\n　　FinalBitmap可以配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。FinalBitmap的内存管理使用lru算法，没有使用弱引用（Android2.3以后Google已经不建议使用弱引用，Android2.3后强行回收软引用和弱引用，详情查看Android官方文档），更好的管理bitmap内存。FinalBitmap可以自定义下载器，用来扩展其他协议显示网络图片，比如ftp等。同时可以自定义bitmap显示器，\n\n　　在imageview显示图片的时候播放动画等（默认是渐变动画显示）。\n\n### 4、xUtils框架\n\n项目地址：https://github.com/wyouflf/xUtils，主要有四大模块：\n**数据库模块：**\nAndroid 中的 orm 框架，一行代码就可以进行增删改查；\n支持事务，默认关闭；\n可通过注解自定义表名，列名，外键，唯一性约束，NOT NULL约束，CHECK约束等（需要混淆的时候请注解表名和列名）；\n支持绑定外键，保存实体时外键关联实体自动保存或更新；\n自动加载外键关联实体，支持延时加载；\n支持链式表达查询，更直观的查询语义，参考下面的介绍或sample中的例子。          \n**注解模块：**\n\nAndroid中的 ioc 框架，完全注解方式就可以进行 UI，资源和事件绑定；\n新的事件绑定方式，使用混淆工具混淆后仍可正常工作；\n目前支持常用的20种事件绑定，参见 View Common Event Listener 类和包com.lidroid.xutils.view.annotation.event。\n**网络模块：**\n\n支持同步，异步方式的请求；\n支持大文件上传，上传大文件不会oom；\n支持GET，POST，PUT，MOVE，COPY，DELETE，HEAD，OPTIONS，TRACE，CONNECT请求；\n下载支持301/302重定向，支持设置是否根据Content-Disposition重命名下载的文件；\n返回文本内容的请求（默认只启用了GET请求）支持缓存，可设置默认过期时间和针对当前请求的过期时间。\n**图片缓存模块：**\n\n加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象；\n支持加载网络图片和本地图片；\n内存管理使用lru算法，更好的管理bitmap内存；\n可配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。\n### 5、ThinkAndroid\n\n项目地址：https://github.com/white-cat/ThinkAndroid\n\n主要有以下模块：\n\n**MVC模块：**实现视图与模型的分离。\n**ioc模块：** Android中的ioc模块，完全注解方式就可以进行UI绑定、res中的资源的读取、以及对象的初始化。 \n**数据库模块：** Android中的orm框架，使用了线程池对sqlite进行操作。  \n**http模块：** 通过httpclient进行封装http数据请求，支持异步及同步方式加载。\n**缓存模块：** 通过简单的配置及设计可以很好的实现缓存，对缓存可以随意的配置\n**图片缓存模块：** i mageview加载图片的时候无需考虑图片加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。\n**配置器模块：** 可以对简易的实现配对配置的操作，目前配置文件可以支持Preference、Properties对配置进行存取。\n**日志打印模块**：可以较快的轻易的是实现日志打印，支持日志打印的扩展，目前支持对sdcard写入本地打印、以及控制台打印\n**下载器模块**：可以简单的实现多线程下载、后台下载、断点续传、对下载进行控制、如开始、暂停、删除等等。\n**网络状态检测模块**：当网络状态改变时，对其进行检。\n### 6、LoonAndroid\n\n项目地址：https://github.com/gdpancheng/LoonAndroid\n\n主要有以下模块：\n自动注入框架（只需要继承框架内的APP既可）\n图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性）\n网络请求模块（继承了基本上现在所有的http请求）\neventbus（集成一个开源的框架）\n验证框架（集成开源框架）\nJson解析（支持解析成集合或者对象）\n数据库（不知道是哪位写的 忘记了）\n多线程断点下载（自动判断是否支持多线程，判断是否是重定向）\n自动更新模块\n一系列工具类\n\n### 7、图片加载：\n Universal Image Loader - https://github.com/onlyTan/Android-Universal-Image-Loader\n\n用法参考 -http://blog.csdn.net/xiaanming/article/details/26810303\n\n\n### 8、动画框架：\n  nineoldandroids -  https://github.com/JakeWharton/NineOldAndroids\n用法参考 -http://blog.csdn.net/lmj623565791/article/details/38067475\n\n\n### 9、进程间通信框架：\n   eventBus -  https://github.com/greenrobot/EventBus\n用法参考 - http://blog.csdn.net/lmj623565791/article/details/40794879\n\n\n### 10、SQLite数据库：\nLitePal - \n\nhttps://github.com/LitePalFramework/LitePal\n\n\n\n### 11、百分比布局：\nandroid-percent-support-extend  -  \n\nhttps://github.com/hongyangAndroid/android-percent-support-extend\n\n百分比布局：\nandroid-percent-support-extend  -  \n\nhttps://github.com/hongyangAndroid/android-percent-support-extend","slug":"open-source-frame","published":1,"updated":"2016-04-23T08:02:13.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucj7003dg0g55sal9vmf","content":"<h3 id=\"1、volley\"><a href=\"#1、volley\" class=\"headerlink\" title=\"1、volley\"></a>1、volley</h3><p>项目地址 <a href=\"https://github.com/smanikandan14/Volley-demo\" target=\"_blank\" rel=\"external\">https://github.com/smanikandan14/Volley-demo</a><br>JSON，图像等的异步下载；<br>网络请求的排序（scheduling）<br>网络请求的优先级处理<br>缓存<br>多级别取消请求和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）<br><a id=\"more\"></a></p>\n<h3 id=\"2、android-async-http\"><a href=\"#2、android-async-http\" class=\"headerlink\" title=\"2、android-async-http\"></a>2、android-async-http</h3><p>项目地址：<a href=\"https://github.com/loopj/android-async-http，文档介绍：http://loopj.com/android-async-http/\" target=\"_blank\" rel=\"external\">https://github.com/loopj/android-async-http，文档介绍：http://loopj.com/android-async-http/</a> </p>\n<p>在匿名回调中处理请求结果<br>在UI线程外进行http请求<br>文件断点上传<br>智能重试<br>默认gzip压缩<br>支持解析成Json格式<br>可将Cookies持久化到SharedPreferences</p>\n<h3 id=\"3、Afinal框架\"><a href=\"#3、Afinal框架\" class=\"headerlink\" title=\"3、Afinal框架\"></a>3、Afinal框架</h3><p>项目地址：<a href=\"https://github.com/yangfuhai/afinal\" target=\"_blank\" rel=\"external\">https://github.com/yangfuhai/afinal</a></p>\n<p>主要有四大模块：</p>\n<p>数据库模块：Android中的orm框架，使用了线程池对sqlite进行操作。<br>注解模块：Android中的ioc框架，完全注解方式就可以进行UI绑定和事件绑定。无需findViewById和setClickListener等。<br>网络模块：通过httpclient进行封装http数据请求，支持Ajax方式加载，支持下载、上传文件功能。<br>图片缓存模块：通过FinalBitmap，imageview加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。<br>　　FinalBitmap可以配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。FinalBitmap的内存管理使用lru算法，没有使用弱引用（Android2.3以后Google已经不建议使用弱引用，Android2.3后强行回收软引用和弱引用，详情查看Android官方文档），更好的管理bitmap内存。FinalBitmap可以自定义下载器，用来扩展其他协议显示网络图片，比如ftp等。同时可以自定义bitmap显示器，</p>\n<p>　　在imageview显示图片的时候播放动画等（默认是渐变动画显示）。</p>\n<h3 id=\"4、xUtils框架\"><a href=\"#4、xUtils框架\" class=\"headerlink\" title=\"4、xUtils框架\"></a>4、xUtils框架</h3><p>项目地址：<a href=\"https://github.com/wyouflf/xUtils，主要有四大模块：\" target=\"_blank\" rel=\"external\">https://github.com/wyouflf/xUtils，主要有四大模块：</a><br><strong>数据库模块：</strong><br>Android 中的 orm 框架，一行代码就可以进行增删改查；<br>支持事务，默认关闭；<br>可通过注解自定义表名，列名，外键，唯一性约束，NOT NULL约束，CHECK约束等（需要混淆的时候请注解表名和列名）；<br>支持绑定外键，保存实体时外键关联实体自动保存或更新；<br>自动加载外键关联实体，支持延时加载；<br>支持链式表达查询，更直观的查询语义，参考下面的介绍或sample中的例子。<br><strong>注解模块：</strong></p>\n<p>Android中的 ioc 框架，完全注解方式就可以进行 UI，资源和事件绑定；<br>新的事件绑定方式，使用混淆工具混淆后仍可正常工作；<br>目前支持常用的20种事件绑定，参见 View Common Event Listener 类和包com.lidroid.xutils.view.annotation.event。<br><strong>网络模块：</strong></p>\n<p>支持同步，异步方式的请求；<br>支持大文件上传，上传大文件不会oom；<br>支持GET，POST，PUT，MOVE，COPY，DELETE，HEAD，OPTIONS，TRACE，CONNECT请求；<br>下载支持301/302重定向，支持设置是否根据Content-Disposition重命名下载的文件；<br>返回文本内容的请求（默认只启用了GET请求）支持缓存，可设置默认过期时间和针对当前请求的过期时间。<br><strong>图片缓存模块：</strong></p>\n<p>加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象；<br>支持加载网络图片和本地图片；<br>内存管理使用lru算法，更好的管理bitmap内存；<br>可配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。</p>\n<h3 id=\"5、ThinkAndroid\"><a href=\"#5、ThinkAndroid\" class=\"headerlink\" title=\"5、ThinkAndroid\"></a>5、ThinkAndroid</h3><p>项目地址：<a href=\"https://github.com/white-cat/ThinkAndroid\" target=\"_blank\" rel=\"external\">https://github.com/white-cat/ThinkAndroid</a></p>\n<p>主要有以下模块：</p>\n<p><strong>MVC模块：</strong>实现视图与模型的分离。<br><strong>ioc模块：</strong> Android中的ioc模块，完全注解方式就可以进行UI绑定、res中的资源的读取、以及对象的初始化。<br><strong>数据库模块：</strong> Android中的orm框架，使用了线程池对sqlite进行操作。<br><strong>http模块：</strong> 通过httpclient进行封装http数据请求，支持异步及同步方式加载。<br><strong>缓存模块：</strong> 通过简单的配置及设计可以很好的实现缓存，对缓存可以随意的配置<br><strong>图片缓存模块：</strong> i mageview加载图片的时候无需考虑图片加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。<br><strong>配置器模块：</strong> 可以对简易的实现配对配置的操作，目前配置文件可以支持Preference、Properties对配置进行存取。<br><strong>日志打印模块</strong>：可以较快的轻易的是实现日志打印，支持日志打印的扩展，目前支持对sdcard写入本地打印、以及控制台打印<br><strong>下载器模块</strong>：可以简单的实现多线程下载、后台下载、断点续传、对下载进行控制、如开始、暂停、删除等等。<br><strong>网络状态检测模块</strong>：当网络状态改变时，对其进行检。</p>\n<h3 id=\"6、LoonAndroid\"><a href=\"#6、LoonAndroid\" class=\"headerlink\" title=\"6、LoonAndroid\"></a>6、LoonAndroid</h3><p>项目地址：<a href=\"https://github.com/gdpancheng/LoonAndroid\" target=\"_blank\" rel=\"external\">https://github.com/gdpancheng/LoonAndroid</a></p>\n<p>主要有以下模块：<br>自动注入框架（只需要继承框架内的APP既可）<br>图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性）<br>网络请求模块（继承了基本上现在所有的http请求）<br>eventbus（集成一个开源的框架）<br>验证框架（集成开源框架）<br>Json解析（支持解析成集合或者对象）<br>数据库（不知道是哪位写的 忘记了）<br>多线程断点下载（自动判断是否支持多线程，判断是否是重定向）<br>自动更新模块<br>一系列工具类</p>\n<h3 id=\"7、图片加载：\"><a href=\"#7、图片加载：\" class=\"headerlink\" title=\"7、图片加载：\"></a>7、图片加载：</h3><p> Universal Image Loader - <a href=\"https://github.com/onlyTan/Android-Universal-Image-Loader\" target=\"_blank\" rel=\"external\">https://github.com/onlyTan/Android-Universal-Image-Loader</a></p>\n<p>用法参考 -<a href=\"http://blog.csdn.net/xiaanming/article/details/26810303\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/xiaanming/article/details/26810303</a></p>\n<h3 id=\"8、动画框架：\"><a href=\"#8、动画框架：\" class=\"headerlink\" title=\"8、动画框架：\"></a>8、动画框架：</h3><p>  nineoldandroids -  <a href=\"https://github.com/JakeWharton/NineOldAndroids\" target=\"_blank\" rel=\"external\">https://github.com/JakeWharton/NineOldAndroids</a><br>用法参考 -<a href=\"http://blog.csdn.net/lmj623565791/article/details/38067475\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lmj623565791/article/details/38067475</a></p>\n<h3 id=\"9、进程间通信框架：\"><a href=\"#9、进程间通信框架：\" class=\"headerlink\" title=\"9、进程间通信框架：\"></a>9、进程间通信框架：</h3><p>   eventBus -  <a href=\"https://github.com/greenrobot/EventBus\" target=\"_blank\" rel=\"external\">https://github.com/greenrobot/EventBus</a><br>用法参考 - <a href=\"http://blog.csdn.net/lmj623565791/article/details/40794879\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lmj623565791/article/details/40794879</a></p>\n<h3 id=\"10、SQLite数据库：\"><a href=\"#10、SQLite数据库：\" class=\"headerlink\" title=\"10、SQLite数据库：\"></a>10、SQLite数据库：</h3><p>LitePal - </p>\n<p><a href=\"https://github.com/LitePalFramework/LitePal\" target=\"_blank\" rel=\"external\">https://github.com/LitePalFramework/LitePal</a></p>\n<h3 id=\"11、百分比布局：\"><a href=\"#11、百分比布局：\" class=\"headerlink\" title=\"11、百分比布局：\"></a>11、百分比布局：</h3><p>android-percent-support-extend  -  </p>\n<p><a href=\"https://github.com/hongyangAndroid/android-percent-support-extend\" target=\"_blank\" rel=\"external\">https://github.com/hongyangAndroid/android-percent-support-extend</a></p>\n<p>百分比布局：<br>android-percent-support-extend  -  </p>\n<p><a href=\"https://github.com/hongyangAndroid/android-percent-support-extend\" target=\"_blank\" rel=\"external\">https://github.com/hongyangAndroid/android-percent-support-extend</a></p>\n","excerpt":"<h3 id=\"1、volley\"><a href=\"#1、volley\" class=\"headerlink\" title=\"1、volley\"></a>1、volley</h3><p>项目地址 <a href=\"https://github.com/smanikandan14/Volley-demo\">https://github.com/smanikandan14/Volley-demo</a><br>JSON，图像等的异步下载；<br>网络请求的排序（scheduling）<br>网络请求的优先级处理<br>缓存<br>多级别取消请求和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）<br>","more":"</p>\n<h3 id=\"2、android-async-http\"><a href=\"#2、android-async-http\" class=\"headerlink\" title=\"2、android-async-http\"></a>2、android-async-http</h3><p>项目地址：<a href=\"https://github.com/loopj/android-async-http，文档介绍：http://loopj.com/android-async-http/\">https://github.com/loopj/android-async-http，文档介绍：http://loopj.com/android-async-http/</a> </p>\n<p>在匿名回调中处理请求结果<br>在UI线程外进行http请求<br>文件断点上传<br>智能重试<br>默认gzip压缩<br>支持解析成Json格式<br>可将Cookies持久化到SharedPreferences</p>\n<h3 id=\"3、Afinal框架\"><a href=\"#3、Afinal框架\" class=\"headerlink\" title=\"3、Afinal框架\"></a>3、Afinal框架</h3><p>项目地址：<a href=\"https://github.com/yangfuhai/afinal\">https://github.com/yangfuhai/afinal</a></p>\n<p>主要有四大模块：</p>\n<p>数据库模块：Android中的orm框架，使用了线程池对sqlite进行操作。<br>注解模块：Android中的ioc框架，完全注解方式就可以进行UI绑定和事件绑定。无需findViewById和setClickListener等。<br>网络模块：通过httpclient进行封装http数据请求，支持Ajax方式加载，支持下载、上传文件功能。<br>图片缓存模块：通过FinalBitmap，imageview加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。<br>　　FinalBitmap可以配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。FinalBitmap的内存管理使用lru算法，没有使用弱引用（Android2.3以后Google已经不建议使用弱引用，Android2.3后强行回收软引用和弱引用，详情查看Android官方文档），更好的管理bitmap内存。FinalBitmap可以自定义下载器，用来扩展其他协议显示网络图片，比如ftp等。同时可以自定义bitmap显示器，</p>\n<p>　　在imageview显示图片的时候播放动画等（默认是渐变动画显示）。</p>\n<h3 id=\"4、xUtils框架\"><a href=\"#4、xUtils框架\" class=\"headerlink\" title=\"4、xUtils框架\"></a>4、xUtils框架</h3><p>项目地址：<a href=\"https://github.com/wyouflf/xUtils，主要有四大模块：\">https://github.com/wyouflf/xUtils，主要有四大模块：</a><br><strong>数据库模块：</strong><br>Android 中的 orm 框架，一行代码就可以进行增删改查；<br>支持事务，默认关闭；<br>可通过注解自定义表名，列名，外键，唯一性约束，NOT NULL约束，CHECK约束等（需要混淆的时候请注解表名和列名）；<br>支持绑定外键，保存实体时外键关联实体自动保存或更新；<br>自动加载外键关联实体，支持延时加载；<br>支持链式表达查询，更直观的查询语义，参考下面的介绍或sample中的例子。<br><strong>注解模块：</strong></p>\n<p>Android中的 ioc 框架，完全注解方式就可以进行 UI，资源和事件绑定；<br>新的事件绑定方式，使用混淆工具混淆后仍可正常工作；<br>目前支持常用的20种事件绑定，参见 View Common Event Listener 类和包com.lidroid.xutils.view.annotation.event。<br><strong>网络模块：</strong></p>\n<p>支持同步，异步方式的请求；<br>支持大文件上传，上传大文件不会oom；<br>支持GET，POST，PUT，MOVE，COPY，DELETE，HEAD，OPTIONS，TRACE，CONNECT请求；<br>下载支持301/302重定向，支持设置是否根据Content-Disposition重命名下载的文件；<br>返回文本内容的请求（默认只启用了GET请求）支持缓存，可设置默认过期时间和针对当前请求的过期时间。<br><strong>图片缓存模块：</strong></p>\n<p>加载bitmap的时候无需考虑bitmap加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象；<br>支持加载网络图片和本地图片；<br>内存管理使用lru算法，更好的管理bitmap内存；<br>可配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。</p>\n<h3 id=\"5、ThinkAndroid\"><a href=\"#5、ThinkAndroid\" class=\"headerlink\" title=\"5、ThinkAndroid\"></a>5、ThinkAndroid</h3><p>项目地址：<a href=\"https://github.com/white-cat/ThinkAndroid\">https://github.com/white-cat/ThinkAndroid</a></p>\n<p>主要有以下模块：</p>\n<p><strong>MVC模块：</strong>实现视图与模型的分离。<br><strong>ioc模块：</strong> Android中的ioc模块，完全注解方式就可以进行UI绑定、res中的资源的读取、以及对象的初始化。<br><strong>数据库模块：</strong> Android中的orm框架，使用了线程池对sqlite进行操作。<br><strong>http模块：</strong> 通过httpclient进行封装http数据请求，支持异步及同步方式加载。<br><strong>缓存模块：</strong> 通过简单的配置及设计可以很好的实现缓存，对缓存可以随意的配置<br><strong>图片缓存模块：</strong> i mageview加载图片的时候无需考虑图片加载过程中出现的oom和Android容器快速滑动时候出现的图片错位等现象。<br><strong>配置器模块：</strong> 可以对简易的实现配对配置的操作，目前配置文件可以支持Preference、Properties对配置进行存取。<br><strong>日志打印模块</strong>：可以较快的轻易的是实现日志打印，支持日志打印的扩展，目前支持对sdcard写入本地打印、以及控制台打印<br><strong>下载器模块</strong>：可以简单的实现多线程下载、后台下载、断点续传、对下载进行控制、如开始、暂停、删除等等。<br><strong>网络状态检测模块</strong>：当网络状态改变时，对其进行检。</p>\n<h3 id=\"6、LoonAndroid\"><a href=\"#6、LoonAndroid\" class=\"headerlink\" title=\"6、LoonAndroid\"></a>6、LoonAndroid</h3><p>项目地址：<a href=\"https://github.com/gdpancheng/LoonAndroid\">https://github.com/gdpancheng/LoonAndroid</a></p>\n<p>主要有以下模块：<br>自动注入框架（只需要继承框架内的APP既可）<br>图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性）<br>网络请求模块（继承了基本上现在所有的http请求）<br>eventbus（集成一个开源的框架）<br>验证框架（集成开源框架）<br>Json解析（支持解析成集合或者对象）<br>数据库（不知道是哪位写的 忘记了）<br>多线程断点下载（自动判断是否支持多线程，判断是否是重定向）<br>自动更新模块<br>一系列工具类</p>\n<h3 id=\"7、图片加载：\"><a href=\"#7、图片加载：\" class=\"headerlink\" title=\"7、图片加载：\"></a>7、图片加载：</h3><p> Universal Image Loader - <a href=\"https://github.com/onlyTan/Android-Universal-Image-Loader\">https://github.com/onlyTan/Android-Universal-Image-Loader</a></p>\n<p>用法参考 -<a href=\"http://blog.csdn.net/xiaanming/article/details/26810303\">http://blog.csdn.net/xiaanming/article/details/26810303</a></p>\n<h3 id=\"8、动画框架：\"><a href=\"#8、动画框架：\" class=\"headerlink\" title=\"8、动画框架：\"></a>8、动画框架：</h3><p>  nineoldandroids -  <a href=\"https://github.com/JakeWharton/NineOldAndroids\">https://github.com/JakeWharton/NineOldAndroids</a><br>用法参考 -<a href=\"http://blog.csdn.net/lmj623565791/article/details/38067475\">http://blog.csdn.net/lmj623565791/article/details/38067475</a></p>\n<h3 id=\"9、进程间通信框架：\"><a href=\"#9、进程间通信框架：\" class=\"headerlink\" title=\"9、进程间通信框架：\"></a>9、进程间通信框架：</h3><p>   eventBus -  <a href=\"https://github.com/greenrobot/EventBus\">https://github.com/greenrobot/EventBus</a><br>用法参考 - <a href=\"http://blog.csdn.net/lmj623565791/article/details/40794879\">http://blog.csdn.net/lmj623565791/article/details/40794879</a></p>\n<h3 id=\"10、SQLite数据库：\"><a href=\"#10、SQLite数据库：\" class=\"headerlink\" title=\"10、SQLite数据库：\"></a>10、SQLite数据库：</h3><p>LitePal - </p>\n<p><a href=\"https://github.com/LitePalFramework/LitePal\">https://github.com/LitePalFramework/LitePal</a></p>\n<h3 id=\"11、百分比布局：\"><a href=\"#11、百分比布局：\" class=\"headerlink\" title=\"11、百分比布局：\"></a>11、百分比布局：</h3><p>android-percent-support-extend  -  </p>\n<p><a href=\"https://github.com/hongyangAndroid/android-percent-support-extend\">https://github.com/hongyangAndroid/android-percent-support-extend</a></p>\n<p>百分比布局：<br>android-percent-support-extend  -  </p>\n<p><a href=\"https://github.com/hongyangAndroid/android-percent-support-extend\">https://github.com/hongyangAndroid/android-percent-support-extend</a></p>"},{"title":"Android 开源项目分类汇总","date":"2016-04-23T08:03:25.000Z","_content":"在github上看见的开源android 代码，十分全面，内容如下：\n\n目前包括：\nAndroid 开源项目第一篇——个性化控件(View)篇\n  包括ListView、ActionBar、Menu、ViewPager、Gallery、GridView、ImageView<!--more-->、ProgressBar、TextView、ScrollView、TimeView、TipView、FlipView、ColorPickView、GraphView、UI Style、其他\nAndroid 开源项目第二篇——工具库篇\n  包括依赖注入、图片缓存、网络请求、数据库 ORM 工具包、Android 公共库、高版本向低版本兼容库、多媒体、事件总线、传感器、安全、插件化、文件、其他\nAndroid 开源项目第三篇——优秀项目篇\n  比较有意思的完整的 Android 项目\nAndroid 开源项目第四篇——开发及测试工具篇\n  包括开发效率工具、开发自测相关、测试工具、开发及编译环境、其他\nAndroid 开源项目第五篇——优秀个人和团体篇\n  乐于分享并且有一些很不错的开源项目的个人和组织，包括 JakeWharton、Chris Banes、Koushik Dutta 等大牛\ngithub地址：https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6view\n希望对大家有帮助。\n","source":"_posts/open-source.md","raw":"---\ntitle: Android 开源项目分类汇总\ndate: 2016-04-23 16:03:25\ncategories: [android,学习笔记]\ntags: [android,开源框架]\n---\n在github上看见的开源android 代码，十分全面，内容如下：\n\n目前包括：\nAndroid 开源项目第一篇——个性化控件(View)篇\n  包括ListView、ActionBar、Menu、ViewPager、Gallery、GridView、ImageView<!--more-->、ProgressBar、TextView、ScrollView、TimeView、TipView、FlipView、ColorPickView、GraphView、UI Style、其他\nAndroid 开源项目第二篇——工具库篇\n  包括依赖注入、图片缓存、网络请求、数据库 ORM 工具包、Android 公共库、高版本向低版本兼容库、多媒体、事件总线、传感器、安全、插件化、文件、其他\nAndroid 开源项目第三篇——优秀项目篇\n  比较有意思的完整的 Android 项目\nAndroid 开源项目第四篇——开发及测试工具篇\n  包括开发效率工具、开发自测相关、测试工具、开发及编译环境、其他\nAndroid 开源项目第五篇——优秀个人和团体篇\n  乐于分享并且有一些很不错的开源项目的个人和组织，包括 JakeWharton、Chris Banes、Koushik Dutta 等大牛\ngithub地址：https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6view\n希望对大家有帮助。\n","slug":"open-source","published":1,"updated":"2016-04-23T08:54:01.896Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucj7003hg0g56fg3d1j9","content":"<p>在github上看见的开源android 代码，十分全面，内容如下：</p>\n<p>目前包括：<br>Android 开源项目第一篇——个性化控件(View)篇<br>  包括ListView、ActionBar、Menu、ViewPager、Gallery、GridView、ImageView<a id=\"more\"></a>、ProgressBar、TextView、ScrollView、TimeView、TipView、FlipView、ColorPickView、GraphView、UI Style、其他<br>Android 开源项目第二篇——工具库篇<br>  包括依赖注入、图片缓存、网络请求、数据库 ORM 工具包、Android 公共库、高版本向低版本兼容库、多媒体、事件总线、传感器、安全、插件化、文件、其他<br>Android 开源项目第三篇——优秀项目篇<br>  比较有意思的完整的 Android 项目<br>Android 开源项目第四篇——开发及测试工具篇<br>  包括开发效率工具、开发自测相关、测试工具、开发及编译环境、其他<br>Android 开源项目第五篇——优秀个人和团体篇<br>  乐于分享并且有一些很不错的开源项目的个人和组织，包括 JakeWharton、Chris Banes、Koushik Dutta 等大牛<br>github地址：<a href=\"https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6view\" target=\"_blank\" rel=\"external\">https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6view</a><br>希望对大家有帮助。</p>\n","excerpt":"<p>在github上看见的开源android 代码，十分全面，内容如下：</p>\n<p>目前包括：<br>Android 开源项目第一篇——个性化控件(View)篇<br>  包括ListView、ActionBar、Menu、ViewPager、Gallery、GridView、ImageView","more":"、ProgressBar、TextView、ScrollView、TimeView、TipView、FlipView、ColorPickView、GraphView、UI Style、其他<br>Android 开源项目第二篇——工具库篇<br>  包括依赖注入、图片缓存、网络请求、数据库 ORM 工具包、Android 公共库、高版本向低版本兼容库、多媒体、事件总线、传感器、安全、插件化、文件、其他<br>Android 开源项目第三篇——优秀项目篇<br>  比较有意思的完整的 Android 项目<br>Android 开源项目第四篇——开发及测试工具篇<br>  包括开发效率工具、开发自测相关、测试工具、开发及编译环境、其他<br>Android 开源项目第五篇——优秀个人和团体篇<br>  乐于分享并且有一些很不错的开源项目的个人和组织，包括 JakeWharton、Chris Banes、Koushik Dutta 等大牛<br>github地址：<a href=\"https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6view\">https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6view</a><br>希望对大家有帮助。</p>"},{"title":"PLSQL安装、连接服务器及字符编码更改","date":"2016-04-23T08:16:25.000Z","_content":"在学习时用oracle时，使用PLSQL客户端来操作数据库，这里简单介绍了它安装相关问题。<!--more-->\n### 一、下载PLSQL并破解\n（看不惯英文的可以安装汉化文件）,下载地址：[PLSQL+instantclient](http://download.csdn.net/detail/txadf/9259051)\n### 二、解压开始安装，\n如下图介绍；并将instantclient放到自己安装的文件位置，便于之后使用。\n\n![](http://img.blog.csdn.net/20151110212717528?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n### 三、破解软件\n填写instantclient文件的位置； \n   （1）、安装完成后运行PLSQL，在弹出的登陆界面直接点击取消，进入；\n   （2）、帮助--->注册，运行破解文件，将产品编号、序列和口令（密码）对应的填入；\n   （3）、工具--->首选项，如下图，在‘1’处填      入：D:\\software_Study\\oracle\\instantclient_11_2\\network\\admin；在‘2’处填入：D:\\software_Study\\oracle\\instantclient_11_2\\oci.dll\n注：如果连接的是服务器端的oracle，需要将‘1’文件夹下的'tnsnames.ora',用记事本打开，更改第二行的host的值为服务器的ip地址。\n\n### 四、配置环境变量（可选操作）\n完成上述步骤后，退出登陆，这里使用在服务器端创建的用户名和密码，数据库选择‘XE’，连接为‘Normal’，便可登陆。\n如果需要更改字符编码，需配置环境变量，\n查看服务器编码：select userenv('language') from dual;\n查看PLSQL客户端编码：select * from V$NLS_PARAMETERS; 看NLS_LANGUAGE值与上一语句值是否相等；\n我们服务器编码是utf-8，这里不匹配，添加如下环境变量：\n\n变量名：NLS_LANG\n值：AMERICAN_AMERICA.AL32UTF8\n\n","source":"_posts/plsql-install-config.md","raw":"---\ntitle: PLSQL安装、连接服务器及字符编码更改\ndate: 2016-04-23 16:16:25\ncategories: [工具软件,PL/SQL]\ntags: [oracle,PL/SQL]\n---\n在学习时用oracle时，使用PLSQL客户端来操作数据库，这里简单介绍了它安装相关问题。<!--more-->\n### 一、下载PLSQL并破解\n（看不惯英文的可以安装汉化文件）,下载地址：[PLSQL+instantclient](http://download.csdn.net/detail/txadf/9259051)\n### 二、解压开始安装，\n如下图介绍；并将instantclient放到自己安装的文件位置，便于之后使用。\n\n![](http://img.blog.csdn.net/20151110212717528?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n### 三、破解软件\n填写instantclient文件的位置； \n   （1）、安装完成后运行PLSQL，在弹出的登陆界面直接点击取消，进入；\n   （2）、帮助--->注册，运行破解文件，将产品编号、序列和口令（密码）对应的填入；\n   （3）、工具--->首选项，如下图，在‘1’处填      入：D:\\software_Study\\oracle\\instantclient_11_2\\network\\admin；在‘2’处填入：D:\\software_Study\\oracle\\instantclient_11_2\\oci.dll\n注：如果连接的是服务器端的oracle，需要将‘1’文件夹下的'tnsnames.ora',用记事本打开，更改第二行的host的值为服务器的ip地址。\n\n### 四、配置环境变量（可选操作）\n完成上述步骤后，退出登陆，这里使用在服务器端创建的用户名和密码，数据库选择‘XE’，连接为‘Normal’，便可登陆。\n如果需要更改字符编码，需配置环境变量，\n查看服务器编码：select userenv('language') from dual;\n查看PLSQL客户端编码：select * from V$NLS_PARAMETERS; 看NLS_LANGUAGE值与上一语句值是否相等；\n我们服务器编码是utf-8，这里不匹配，添加如下环境变量：\n\n变量名：NLS_LANG\n值：AMERICAN_AMERICA.AL32UTF8\n\n","slug":"plsql-install-config","published":1,"updated":"2016-04-23T09:37:39.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucj7003kg0g55x9e137d","content":"<p>在学习时用oracle时，使用PLSQL客户端来操作数据库，这里简单介绍了它安装相关问题。<a id=\"more\"></a></p>\n<h3 id=\"一、下载PLSQL并破解\"><a href=\"#一、下载PLSQL并破解\" class=\"headerlink\" title=\"一、下载PLSQL并破解\"></a>一、下载PLSQL并破解</h3><p>（看不惯英文的可以安装汉化文件）,下载地址：<a href=\"http://download.csdn.net/detail/txadf/9259051\" target=\"_blank\" rel=\"external\">PLSQL+instantclient</a></p>\n<h3 id=\"二、解压开始安装，\"><a href=\"#二、解压开始安装，\" class=\"headerlink\" title=\"二、解压开始安装，\"></a>二、解压开始安装，</h3><p>如下图介绍；并将instantclient放到自己安装的文件位置，便于之后使用。</p>\n<p><img src=\"http://img.blog.csdn.net/20151110212717528?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h3 id=\"三、破解软件\"><a href=\"#三、破解软件\" class=\"headerlink\" title=\"三、破解软件\"></a>三、破解软件</h3><p>填写instantclient文件的位置；<br>   （1）、安装完成后运行PLSQL，在弹出的登陆界面直接点击取消，进入；<br>   （2）、帮助—&gt;注册，运行破解文件，将产品编号、序列和口令（密码）对应的填入；<br>   （3）、工具—&gt;首选项，如下图，在‘1’处填      入：D:\\software_Study\\oracle\\instantclient_11_2\\network\\admin；在‘2’处填入：D:\\software_Study\\oracle\\instantclient_11_2\\oci.dll<br>注：如果连接的是服务器端的oracle，需要将‘1’文件夹下的’tnsnames.ora’,用记事本打开，更改第二行的host的值为服务器的ip地址。</p>\n<h3 id=\"四、配置环境变量（可选操作）\"><a href=\"#四、配置环境变量（可选操作）\" class=\"headerlink\" title=\"四、配置环境变量（可选操作）\"></a>四、配置环境变量（可选操作）</h3><p>完成上述步骤后，退出登陆，这里使用在服务器端创建的用户名和密码，数据库选择‘XE’，连接为‘Normal’，便可登陆。<br>如果需要更改字符编码，需配置环境变量，<br>查看服务器编码：select userenv(‘language’) from dual;<br>查看PLSQL客户端编码：select * from V$NLS_PARAMETERS; 看NLS_LANGUAGE值与上一语句值是否相等；<br>我们服务器编码是utf-8，这里不匹配，添加如下环境变量：</p>\n<p>变量名：NLS_LANG<br>值：AMERICAN_AMERICA.AL32UTF8</p>\n","excerpt":"<p>在学习时用oracle时，使用PLSQL客户端来操作数据库，这里简单介绍了它安装相关问题。","more":"</p>\n<h3 id=\"一、下载PLSQL并破解\"><a href=\"#一、下载PLSQL并破解\" class=\"headerlink\" title=\"一、下载PLSQL并破解\"></a>一、下载PLSQL并破解</h3><p>（看不惯英文的可以安装汉化文件）,下载地址：<a href=\"http://download.csdn.net/detail/txadf/9259051\">PLSQL+instantclient</a></p>\n<h3 id=\"二、解压开始安装，\"><a href=\"#二、解压开始安装，\" class=\"headerlink\" title=\"二、解压开始安装，\"></a>二、解压开始安装，</h3><p>如下图介绍；并将instantclient放到自己安装的文件位置，便于之后使用。</p>\n<p><img src=\"http://img.blog.csdn.net/20151110212717528?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h3 id=\"三、破解软件\"><a href=\"#三、破解软件\" class=\"headerlink\" title=\"三、破解软件\"></a>三、破解软件</h3><p>填写instantclient文件的位置；<br>   （1）、安装完成后运行PLSQL，在弹出的登陆界面直接点击取消，进入；<br>   （2）、帮助—&gt;注册，运行破解文件，将产品编号、序列和口令（密码）对应的填入；<br>   （3）、工具—&gt;首选项，如下图，在‘1’处填      入：D:\\software_Study\\oracle\\instantclient_11_2\\network\\admin；在‘2’处填入：D:\\software_Study\\oracle\\instantclient_11_2\\oci.dll<br>注：如果连接的是服务器端的oracle，需要将‘1’文件夹下的’tnsnames.ora’,用记事本打开，更改第二行的host的值为服务器的ip地址。</p>\n<h3 id=\"四、配置环境变量（可选操作）\"><a href=\"#四、配置环境变量（可选操作）\" class=\"headerlink\" title=\"四、配置环境变量（可选操作）\"></a>四、配置环境变量（可选操作）</h3><p>完成上述步骤后，退出登陆，这里使用在服务器端创建的用户名和密码，数据库选择‘XE’，连接为‘Normal’，便可登陆。<br>如果需要更改字符编码，需配置环境变量，<br>查看服务器编码：select userenv(‘language’) from dual;<br>查看PLSQL客户端编码：select * from V$NLS_PARAMETERS; 看NLS_LANGUAGE值与上一语句值是否相等；<br>我们服务器编码是utf-8，这里不匹配，添加如下环境变量：</p>\n<p>变量名：NLS_LANG<br>值：AMERICAN_AMERICA.AL32UTF8</p>"},{"title":"使用Gradle发布项目到JCenter仓库","date":"2016-04-23T08:32:25.000Z","_content":"原文：[使用Gradle发布项目到JCenter仓库](http://zhengxiaopeng.com/2015/02/02/%E4%BD%BF%E7%94%A8Gradle%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0JCenter%E4%BB%93%E5%BA%93/) \n这里介绍了使用gradle发布项目到jcenter的具体流程，方便项目的依赖。\n<!--more-->\n### 申请Bintray账号\nBintray的基本功能类似于Maven Central，一样的我们需要一个账号，[Bintray传送门](https://bintray.com/)，注册完成后第一步算完成了。\n\n### 生成项目的JavaDoc和source JARs\n简单的说生成的这两样东西就是我们在下一步中上传到远程仓库JCenter上的文件了。这一步需要android-maven-plugin插件，所以我们需要在项目的build.gradle（Top-level build file，项目最外层的build.gradle文件）中添加这个构建依赖，如下：\n```\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.0.0'\n        classpath 'com.github.dcendents:android-maven-plugin:1.2'\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\n```\n注：如果编译出现问题 ，可将maven 的依赖改为1.3，如下：\n```\nclasspath 'com.github.dcendents:android-maven-plugin:1.3'\n```\n然后在你需要发布的那个module（我这里的即是library）的build.gradle里配置如下内容：\n```\napply plugin: 'com.android.library'\napply plugin: 'com.github.dcendents.android-maven'\napply plugin: 'com.jfrog.bintray'\n// This is the library version used when deploying the artifact\nversion = \"1.0.0\"\nandroid {\n    compileSdkVersion 21\n    buildToolsVersion \"21.1.2\"\n    resourcePrefix \"bounceprogressbar__\"    //这个随便填\n    defaultConfig {\n        minSdkVersion 9\n        targetSdkVersion 21\n        versionCode 1\n        versionName version\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    compile 'com.nineoldandroids:library:2.4.0+'\n}\ndef siteUrl = 'https://github.com/zhengxiaopeng/BounceProgressBar' // 项目的主页\ndef gitUrl = 'https://github.com/zhengxiaopeng/BounceProgressBar.git' // Git仓库的url\ngroup = \"org.rocko.bpb\" // Maven Group ID for the artifact，一般填你唯一的包名\ninstall {\n    repositories.mavenInstaller {\n        // This generates POM.xml with proper parameters\n        pom {\n        project {\n        packaging 'aar'\n        // Add your description here\n        name 'Android BounceProgressBar Widget' //项目描述\n        url siteUrl\n        // Set your license\n        licenses {\n            license {\n            name 'The Apache Software License, Version 2.0'\n            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'\n            }\n        }\n        developers {\n        developer {\n        id 'zhengxiaopeng'    //填写的一些基本信息\n        name 'Rocko'\n        email 'zhengxiaopeng.china@gmail.com'\n        }\n        }\n        scm {\n        connection gitUrl\n        developerConnection gitUrl\n        url siteUrl\n        }\n        }\n        }\n    }\n}\ntask sourcesJar(type: Jar) {\n    from android.sourceSets.main.java.srcDirs\n    classifier = 'sources'\n}\ntask javadoc(type: Javadoc) {\n    source = android.sourceSets.main.java.srcDirs\n    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))\n}\ntask javadocJar(type: Jar, dependsOn: javadoc) {\n    classifier = 'javadoc'\n    from javadoc.destinationDir\n}\nartifacts {\n    archives javadocJar\n    archives sourcesJar\n}\nProperties properties = new Properties()\nproperties.load(project.rootProject.file('local.properties').newDataInputStream())\nbintray {\n    user = properties.getProperty(\"bintray.user\")\n    key = properties.getProperty(\"bintray.apikey\")\n    configurations = ['archives']\n    pkg {\n        repo = \"maven\"    \n        name = \"BounceProgressBar\"    //发布到JCenter上的项目名字\n        websiteUrl = siteUrl\n        vcsUrl = gitUrl\n        licenses = [\"Apache-2.0\"]\n        publish = true\n    }\n}\n```\n配置好上述后需要在你的项目的根目录上的local.properties文件里（一般这文件需gitignore，防止泄露账户信息）配置你的bintray账号信息，your_user_name为你的用户名，your_apikey为你的账户的apikey，可以点击进入你的账户信息里再点击Edit即有查看API Key的选项，把他复制下来。\n```\nbintray.user=your_user_name\nbintray.apikey=your_apikey\n```\nRebuild一下项目，顺利的话，就可以在module里的build文件夹里生成相关文件了。这一步为止，就可以把你项目生成到本地的仓库中了，Android Studio中默认即在Android\\sdk\\extras\\android\\m2repository这里，所以我们可以通过如下命令(Windows中，可能还需要下载一遍Gradle，之后就不需要了)执行生成:\n```\ngradlew install\n```\n### 上传到Bintray\n上传到Bintray需要gradle-bintray-plugin的支持，所以在最外层的build.gradle里添加构建依赖：\n```\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.0.0'\n        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'\n        classpath 'com.github.dcendents:android-maven-plugin:1.2'\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\n```\nRebuild一下，然后执行如下命令(Windows中)完成上传：\n```\ngradlew bintrayUpload\n```\n上传完成即可在Bintray网站上找到你的Repo，我们需要完成最后一步工作，**申请你的Repo添加到JCenter**。可以进入这个页面,输入你的项目名字点击匹配到的项目，然后写一写Comments再send即可，然后就等管理员批准了，我是大概等了40分钟，然后网站上会给你一条通过信息，然后就OK了，大功告成。在bintray的maven厂库中即可查看。此外，如果添加其他版本的，可以按照上述步骤操作，注意改版本号。\n如下bintray厂库详情：\n![](http://img.blog.csdn.net/20160404173839075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n### 使用\n最后在其他项目中引用：\n\n1.使用Gradle：\n```\ndependencies {\n    compile 'org.rocko.bpb:library:1.0.0'\n}\n```\n2.使用maven：\n按图中操作。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/put-libary-to-jcenter.md","raw":"---\ntitle: 使用Gradle发布项目到JCenter仓库\ndate: 2016-04-23 16:32:25\ncategories: [android,学习笔记]\ntags: [gradle,jcenter]\n---\n原文：[使用Gradle发布项目到JCenter仓库](http://zhengxiaopeng.com/2015/02/02/%E4%BD%BF%E7%94%A8Gradle%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0JCenter%E4%BB%93%E5%BA%93/) \n这里介绍了使用gradle发布项目到jcenter的具体流程，方便项目的依赖。\n<!--more-->\n### 申请Bintray账号\nBintray的基本功能类似于Maven Central，一样的我们需要一个账号，[Bintray传送门](https://bintray.com/)，注册完成后第一步算完成了。\n\n### 生成项目的JavaDoc和source JARs\n简单的说生成的这两样东西就是我们在下一步中上传到远程仓库JCenter上的文件了。这一步需要android-maven-plugin插件，所以我们需要在项目的build.gradle（Top-level build file，项目最外层的build.gradle文件）中添加这个构建依赖，如下：\n```\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.0.0'\n        classpath 'com.github.dcendents:android-maven-plugin:1.2'\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\n```\n注：如果编译出现问题 ，可将maven 的依赖改为1.3，如下：\n```\nclasspath 'com.github.dcendents:android-maven-plugin:1.3'\n```\n然后在你需要发布的那个module（我这里的即是library）的build.gradle里配置如下内容：\n```\napply plugin: 'com.android.library'\napply plugin: 'com.github.dcendents.android-maven'\napply plugin: 'com.jfrog.bintray'\n// This is the library version used when deploying the artifact\nversion = \"1.0.0\"\nandroid {\n    compileSdkVersion 21\n    buildToolsVersion \"21.1.2\"\n    resourcePrefix \"bounceprogressbar__\"    //这个随便填\n    defaultConfig {\n        minSdkVersion 9\n        targetSdkVersion 21\n        versionCode 1\n        versionName version\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    compile 'com.nineoldandroids:library:2.4.0+'\n}\ndef siteUrl = 'https://github.com/zhengxiaopeng/BounceProgressBar' // 项目的主页\ndef gitUrl = 'https://github.com/zhengxiaopeng/BounceProgressBar.git' // Git仓库的url\ngroup = \"org.rocko.bpb\" // Maven Group ID for the artifact，一般填你唯一的包名\ninstall {\n    repositories.mavenInstaller {\n        // This generates POM.xml with proper parameters\n        pom {\n        project {\n        packaging 'aar'\n        // Add your description here\n        name 'Android BounceProgressBar Widget' //项目描述\n        url siteUrl\n        // Set your license\n        licenses {\n            license {\n            name 'The Apache Software License, Version 2.0'\n            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'\n            }\n        }\n        developers {\n        developer {\n        id 'zhengxiaopeng'    //填写的一些基本信息\n        name 'Rocko'\n        email 'zhengxiaopeng.china@gmail.com'\n        }\n        }\n        scm {\n        connection gitUrl\n        developerConnection gitUrl\n        url siteUrl\n        }\n        }\n        }\n    }\n}\ntask sourcesJar(type: Jar) {\n    from android.sourceSets.main.java.srcDirs\n    classifier = 'sources'\n}\ntask javadoc(type: Javadoc) {\n    source = android.sourceSets.main.java.srcDirs\n    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))\n}\ntask javadocJar(type: Jar, dependsOn: javadoc) {\n    classifier = 'javadoc'\n    from javadoc.destinationDir\n}\nartifacts {\n    archives javadocJar\n    archives sourcesJar\n}\nProperties properties = new Properties()\nproperties.load(project.rootProject.file('local.properties').newDataInputStream())\nbintray {\n    user = properties.getProperty(\"bintray.user\")\n    key = properties.getProperty(\"bintray.apikey\")\n    configurations = ['archives']\n    pkg {\n        repo = \"maven\"    \n        name = \"BounceProgressBar\"    //发布到JCenter上的项目名字\n        websiteUrl = siteUrl\n        vcsUrl = gitUrl\n        licenses = [\"Apache-2.0\"]\n        publish = true\n    }\n}\n```\n配置好上述后需要在你的项目的根目录上的local.properties文件里（一般这文件需gitignore，防止泄露账户信息）配置你的bintray账号信息，your_user_name为你的用户名，your_apikey为你的账户的apikey，可以点击进入你的账户信息里再点击Edit即有查看API Key的选项，把他复制下来。\n```\nbintray.user=your_user_name\nbintray.apikey=your_apikey\n```\nRebuild一下项目，顺利的话，就可以在module里的build文件夹里生成相关文件了。这一步为止，就可以把你项目生成到本地的仓库中了，Android Studio中默认即在Android\\sdk\\extras\\android\\m2repository这里，所以我们可以通过如下命令(Windows中，可能还需要下载一遍Gradle，之后就不需要了)执行生成:\n```\ngradlew install\n```\n### 上传到Bintray\n上传到Bintray需要gradle-bintray-plugin的支持，所以在最外层的build.gradle里添加构建依赖：\n```\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.0.0'\n        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'\n        classpath 'com.github.dcendents:android-maven-plugin:1.2'\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\n```\nRebuild一下，然后执行如下命令(Windows中)完成上传：\n```\ngradlew bintrayUpload\n```\n上传完成即可在Bintray网站上找到你的Repo，我们需要完成最后一步工作，**申请你的Repo添加到JCenter**。可以进入这个页面,输入你的项目名字点击匹配到的项目，然后写一写Comments再send即可，然后就等管理员批准了，我是大概等了40分钟，然后网站上会给你一条通过信息，然后就OK了，大功告成。在bintray的maven厂库中即可查看。此外，如果添加其他版本的，可以按照上述步骤操作，注意改版本号。\n如下bintray厂库详情：\n![](http://img.blog.csdn.net/20160404173839075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n### 使用\n最后在其他项目中引用：\n\n1.使用Gradle：\n```\ndependencies {\n    compile 'org.rocko.bpb:library:1.0.0'\n}\n```\n2.使用maven：\n按图中操作。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"put-libary-to-jcenter","published":1,"updated":"2016-04-25T03:14:55.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucjm003pg0g5m0kn1cbu","content":"<p>原文：<a href=\"http://zhengxiaopeng.com/2015/02/02/%E4%BD%BF%E7%94%A8Gradle%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0JCenter%E4%BB%93%E5%BA%93/\" target=\"_blank\" rel=\"external\">使用Gradle发布项目到JCenter仓库</a><br>这里介绍了使用gradle发布项目到jcenter的具体流程，方便项目的依赖。<br><a id=\"more\"></a></p>\n<h3 id=\"申请Bintray账号\"><a href=\"#申请Bintray账号\" class=\"headerlink\" title=\"申请Bintray账号\"></a>申请Bintray账号</h3><p>Bintray的基本功能类似于Maven Central，一样的我们需要一个账号，<a href=\"https://bintray.com/\" target=\"_blank\" rel=\"external\">Bintray传送门</a>，注册完成后第一步算完成了。</p>\n<h3 id=\"生成项目的JavaDoc和source-JARs\"><a href=\"#生成项目的JavaDoc和source-JARs\" class=\"headerlink\" title=\"生成项目的JavaDoc和source JARs\"></a>生成项目的JavaDoc和source JARs</h3><p>简单的说生成的这两样东西就是我们在下一步中上传到远程仓库JCenter上的文件了。这一步需要android-maven-plugin插件，所以我们需要在项目的build.gradle（Top-level build file，项目最外层的build.gradle文件）中添加这个构建依赖，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath &apos;com.android.tools.build:gradle:1.0.0&apos;</span><br><span class=\"line\">        classpath &apos;com.github.dcendents:android-maven-plugin:1.2&apos;</span><br><span class=\"line\">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class=\"line\">        // in the individual module build.gradle files</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注：如果编译出现问题 ，可将maven 的依赖改为1.3，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classpath &apos;com.github.dcendents:android-maven-plugin:1.3&apos;</span><br></pre></td></tr></table></figure></p>\n<p>然后在你需要发布的那个module（我这里的即是library）的build.gradle里配置如下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;com.android.library&apos;</span><br><span class=\"line\">apply plugin: &apos;com.github.dcendents.android-maven&apos;</span><br><span class=\"line\">apply plugin: &apos;com.jfrog.bintray&apos;</span><br><span class=\"line\">// This is the library version used when deploying the artifact</span><br><span class=\"line\">version = &quot;1.0.0&quot;</span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion 21</span><br><span class=\"line\">    buildToolsVersion &quot;21.1.2&quot;</span><br><span class=\"line\">    resourcePrefix &quot;bounceprogressbar__&quot;    //这个随便填</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion 9</span><br><span class=\"line\">        targetSdkVersion 21</span><br><span class=\"line\">        versionCode 1</span><br><span class=\"line\">        versionName version</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled false</span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class=\"line\">    compile &apos;com.nineoldandroids:library:2.4.0+&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">def siteUrl = &apos;https://github.com/zhengxiaopeng/BounceProgressBar&apos; // 项目的主页</span><br><span class=\"line\">def gitUrl = &apos;https://github.com/zhengxiaopeng/BounceProgressBar.git&apos; // Git仓库的url</span><br><span class=\"line\">group = &quot;org.rocko.bpb&quot; // Maven Group ID for the artifact，一般填你唯一的包名</span><br><span class=\"line\">install &#123;</span><br><span class=\"line\">    repositories.mavenInstaller &#123;</span><br><span class=\"line\">        // This generates POM.xml with proper parameters</span><br><span class=\"line\">        pom &#123;</span><br><span class=\"line\">        project &#123;</span><br><span class=\"line\">        packaging &apos;aar&apos;</span><br><span class=\"line\">        // Add your description here</span><br><span class=\"line\">        name &apos;Android BounceProgressBar Widget&apos; //项目描述</span><br><span class=\"line\">        url siteUrl</span><br><span class=\"line\">        // Set your license</span><br><span class=\"line\">        licenses &#123;</span><br><span class=\"line\">            license &#123;</span><br><span class=\"line\">            name &apos;The Apache Software License, Version 2.0&apos;</span><br><span class=\"line\">            url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        developers &#123;</span><br><span class=\"line\">        developer &#123;</span><br><span class=\"line\">        id &apos;zhengxiaopeng&apos;    //填写的一些基本信息</span><br><span class=\"line\">        name &apos;Rocko&apos;</span><br><span class=\"line\">        email &apos;zhengxiaopeng.china@gmail.com&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        scm &#123;</span><br><span class=\"line\">        connection gitUrl</span><br><span class=\"line\">        developerConnection gitUrl</span><br><span class=\"line\">        url siteUrl</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task sourcesJar(type: Jar) &#123;</span><br><span class=\"line\">    from android.sourceSets.main.java.srcDirs</span><br><span class=\"line\">    classifier = &apos;sources&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task javadoc(type: Javadoc) &#123;</span><br><span class=\"line\">    source = android.sourceSets.main.java.srcDirs</span><br><span class=\"line\">    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task javadocJar(type: Jar, dependsOn: javadoc) &#123;</span><br><span class=\"line\">    classifier = &apos;javadoc&apos;</span><br><span class=\"line\">    from javadoc.destinationDir</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">artifacts &#123;</span><br><span class=\"line\">    archives javadocJar</span><br><span class=\"line\">    archives sourcesJar</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Properties properties = new Properties()</span><br><span class=\"line\">properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())</span><br><span class=\"line\">bintray &#123;</span><br><span class=\"line\">    user = properties.getProperty(&quot;bintray.user&quot;)</span><br><span class=\"line\">    key = properties.getProperty(&quot;bintray.apikey&quot;)</span><br><span class=\"line\">    configurations = [&apos;archives&apos;]</span><br><span class=\"line\">    pkg &#123;</span><br><span class=\"line\">        repo = &quot;maven&quot;    </span><br><span class=\"line\">        name = &quot;BounceProgressBar&quot;    //发布到JCenter上的项目名字</span><br><span class=\"line\">        websiteUrl = siteUrl</span><br><span class=\"line\">        vcsUrl = gitUrl</span><br><span class=\"line\">        licenses = [&quot;Apache-2.0&quot;]</span><br><span class=\"line\">        publish = true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>配置好上述后需要在你的项目的根目录上的local.properties文件里（一般这文件需gitignore，防止泄露账户信息）配置你的bintray账号信息，your_user_name为你的用户名，your_apikey为你的账户的apikey，可以点击进入你的账户信息里再点击Edit即有查看API Key的选项，把他复制下来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bintray.user=your_user_name</span><br><span class=\"line\">bintray.apikey=your_apikey</span><br></pre></td></tr></table></figure></p>\n<p>Rebuild一下项目，顺利的话，就可以在module里的build文件夹里生成相关文件了。这一步为止，就可以把你项目生成到本地的仓库中了，Android Studio中默认即在Android\\sdk\\extras\\android\\m2repository这里，所以我们可以通过如下命令(Windows中，可能还需要下载一遍Gradle，之后就不需要了)执行生成:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gradlew install</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"上传到Bintray\"><a href=\"#上传到Bintray\" class=\"headerlink\" title=\"上传到Bintray\"></a>上传到Bintray</h3><p>上传到Bintray需要gradle-bintray-plugin的支持，所以在最外层的build.gradle里添加构建依赖：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath &apos;com.android.tools.build:gradle:1.0.0&apos;</span><br><span class=\"line\">        classpath &apos;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0&apos;</span><br><span class=\"line\">        classpath &apos;com.github.dcendents:android-maven-plugin:1.2&apos;</span><br><span class=\"line\">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class=\"line\">        // in the individual module build.gradle files</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Rebuild一下，然后执行如下命令(Windows中)完成上传：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gradlew bintrayUpload</span><br></pre></td></tr></table></figure></p>\n<p>上传完成即可在Bintray网站上找到你的Repo，我们需要完成最后一步工作，<strong>申请你的Repo添加到JCenter</strong>。可以进入这个页面,输入你的项目名字点击匹配到的项目，然后写一写Comments再send即可，然后就等管理员批准了，我是大概等了40分钟，然后网站上会给你一条通过信息，然后就OK了，大功告成。在bintray的maven厂库中即可查看。此外，如果添加其他版本的，可以按照上述步骤操作，注意改版本号。<br>如下bintray厂库详情：<br><img src=\"http://img.blog.csdn.net/20160404173839075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>最后在其他项目中引用：</p>\n<p>1.使用Gradle：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile &apos;org.rocko.bpb:library:1.0.0&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.使用maven：<br>按图中操作。</p>\n","excerpt":"<p>原文：<a href=\"http://zhengxiaopeng.com/2015/02/02/%E4%BD%BF%E7%94%A8Gradle%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0JCenter%E4%BB%93%E5%BA%93/\">使用Gradle发布项目到JCenter仓库</a><br>这里介绍了使用gradle发布项目到jcenter的具体流程，方便项目的依赖。<br>","more":"</p>\n<h3 id=\"申请Bintray账号\"><a href=\"#申请Bintray账号\" class=\"headerlink\" title=\"申请Bintray账号\"></a>申请Bintray账号</h3><p>Bintray的基本功能类似于Maven Central，一样的我们需要一个账号，<a href=\"https://bintray.com/\">Bintray传送门</a>，注册完成后第一步算完成了。</p>\n<h3 id=\"生成项目的JavaDoc和source-JARs\"><a href=\"#生成项目的JavaDoc和source-JARs\" class=\"headerlink\" title=\"生成项目的JavaDoc和source JARs\"></a>生成项目的JavaDoc和source JARs</h3><p>简单的说生成的这两样东西就是我们在下一步中上传到远程仓库JCenter上的文件了。这一步需要android-maven-plugin插件，所以我们需要在项目的build.gradle（Top-level build file，项目最外层的build.gradle文件）中添加这个构建依赖，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath &apos;com.android.tools.build:gradle:1.0.0&apos;</span><br><span class=\"line\">        classpath &apos;com.github.dcendents:android-maven-plugin:1.2&apos;</span><br><span class=\"line\">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class=\"line\">        // in the individual module build.gradle files</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注：如果编译出现问题 ，可将maven 的依赖改为1.3，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classpath &apos;com.github.dcendents:android-maven-plugin:1.3&apos;</span><br></pre></td></tr></table></figure></p>\n<p>然后在你需要发布的那个module（我这里的即是library）的build.gradle里配置如下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &apos;com.android.library&apos;</span><br><span class=\"line\">apply plugin: &apos;com.github.dcendents.android-maven&apos;</span><br><span class=\"line\">apply plugin: &apos;com.jfrog.bintray&apos;</span><br><span class=\"line\">// This is the library version used when deploying the artifact</span><br><span class=\"line\">version = &quot;1.0.0&quot;</span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion 21</span><br><span class=\"line\">    buildToolsVersion &quot;21.1.2&quot;</span><br><span class=\"line\">    resourcePrefix &quot;bounceprogressbar__&quot;    //这个随便填</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        minSdkVersion 9</span><br><span class=\"line\">        targetSdkVersion 21</span><br><span class=\"line\">        versionCode 1</span><br><span class=\"line\">        versionName version</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled false</span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class=\"line\">    compile &apos;com.nineoldandroids:library:2.4.0+&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">def siteUrl = &apos;https://github.com/zhengxiaopeng/BounceProgressBar&apos; // 项目的主页</span><br><span class=\"line\">def gitUrl = &apos;https://github.com/zhengxiaopeng/BounceProgressBar.git&apos; // Git仓库的url</span><br><span class=\"line\">group = &quot;org.rocko.bpb&quot; // Maven Group ID for the artifact，一般填你唯一的包名</span><br><span class=\"line\">install &#123;</span><br><span class=\"line\">    repositories.mavenInstaller &#123;</span><br><span class=\"line\">        // This generates POM.xml with proper parameters</span><br><span class=\"line\">        pom &#123;</span><br><span class=\"line\">        project &#123;</span><br><span class=\"line\">        packaging &apos;aar&apos;</span><br><span class=\"line\">        // Add your description here</span><br><span class=\"line\">        name &apos;Android BounceProgressBar Widget&apos; //项目描述</span><br><span class=\"line\">        url siteUrl</span><br><span class=\"line\">        // Set your license</span><br><span class=\"line\">        licenses &#123;</span><br><span class=\"line\">            license &#123;</span><br><span class=\"line\">            name &apos;The Apache Software License, Version 2.0&apos;</span><br><span class=\"line\">            url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        developers &#123;</span><br><span class=\"line\">        developer &#123;</span><br><span class=\"line\">        id &apos;zhengxiaopeng&apos;    //填写的一些基本信息</span><br><span class=\"line\">        name &apos;Rocko&apos;</span><br><span class=\"line\">        email &apos;zhengxiaopeng.china@gmail.com&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        scm &#123;</span><br><span class=\"line\">        connection gitUrl</span><br><span class=\"line\">        developerConnection gitUrl</span><br><span class=\"line\">        url siteUrl</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task sourcesJar(type: Jar) &#123;</span><br><span class=\"line\">    from android.sourceSets.main.java.srcDirs</span><br><span class=\"line\">    classifier = &apos;sources&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task javadoc(type: Javadoc) &#123;</span><br><span class=\"line\">    source = android.sourceSets.main.java.srcDirs</span><br><span class=\"line\">    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task javadocJar(type: Jar, dependsOn: javadoc) &#123;</span><br><span class=\"line\">    classifier = &apos;javadoc&apos;</span><br><span class=\"line\">    from javadoc.destinationDir</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">artifacts &#123;</span><br><span class=\"line\">    archives javadocJar</span><br><span class=\"line\">    archives sourcesJar</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Properties properties = new Properties()</span><br><span class=\"line\">properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())</span><br><span class=\"line\">bintray &#123;</span><br><span class=\"line\">    user = properties.getProperty(&quot;bintray.user&quot;)</span><br><span class=\"line\">    key = properties.getProperty(&quot;bintray.apikey&quot;)</span><br><span class=\"line\">    configurations = [&apos;archives&apos;]</span><br><span class=\"line\">    pkg &#123;</span><br><span class=\"line\">        repo = &quot;maven&quot;    </span><br><span class=\"line\">        name = &quot;BounceProgressBar&quot;    //发布到JCenter上的项目名字</span><br><span class=\"line\">        websiteUrl = siteUrl</span><br><span class=\"line\">        vcsUrl = gitUrl</span><br><span class=\"line\">        licenses = [&quot;Apache-2.0&quot;]</span><br><span class=\"line\">        publish = true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>配置好上述后需要在你的项目的根目录上的local.properties文件里（一般这文件需gitignore，防止泄露账户信息）配置你的bintray账号信息，your_user_name为你的用户名，your_apikey为你的账户的apikey，可以点击进入你的账户信息里再点击Edit即有查看API Key的选项，把他复制下来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bintray.user=your_user_name</span><br><span class=\"line\">bintray.apikey=your_apikey</span><br></pre></td></tr></table></figure></p>\n<p>Rebuild一下项目，顺利的话，就可以在module里的build文件夹里生成相关文件了。这一步为止，就可以把你项目生成到本地的仓库中了，Android Studio中默认即在Android\\sdk\\extras\\android\\m2repository这里，所以我们可以通过如下命令(Windows中，可能还需要下载一遍Gradle，之后就不需要了)执行生成:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gradlew install</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"上传到Bintray\"><a href=\"#上传到Bintray\" class=\"headerlink\" title=\"上传到Bintray\"></a>上传到Bintray</h3><p>上传到Bintray需要gradle-bintray-plugin的支持，所以在最外层的build.gradle里添加构建依赖：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath &apos;com.android.tools.build:gradle:1.0.0&apos;</span><br><span class=\"line\">        classpath &apos;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0&apos;</span><br><span class=\"line\">        classpath &apos;com.github.dcendents:android-maven-plugin:1.2&apos;</span><br><span class=\"line\">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class=\"line\">        // in the individual module build.gradle files</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Rebuild一下，然后执行如下命令(Windows中)完成上传：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gradlew bintrayUpload</span><br></pre></td></tr></table></figure></p>\n<p>上传完成即可在Bintray网站上找到你的Repo，我们需要完成最后一步工作，<strong>申请你的Repo添加到JCenter</strong>。可以进入这个页面,输入你的项目名字点击匹配到的项目，然后写一写Comments再send即可，然后就等管理员批准了，我是大概等了40分钟，然后网站上会给你一条通过信息，然后就OK了，大功告成。在bintray的maven厂库中即可查看。此外，如果添加其他版本的，可以按照上述步骤操作，注意改版本号。<br>如下bintray厂库详情：<br><img src=\"http://img.blog.csdn.net/20160404173839075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>最后在其他项目中引用：</p>\n<p>1.使用Gradle：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile &apos;org.rocko.bpb:library:1.0.0&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.使用maven：<br>按图中操作。</p>"},{"title":"Android 屏幕适配dp,sp","date":"2016-04-23T07:29:25.000Z","_content":"\n相关的概念：\n#### **dp**\n即dip，设备独立像素，device independent pixels的缩写，密度无关像素，Android特有的单位，在屏幕密度dpi= 160屏幕上，1dp = 1px。1dp 在屏幕上总是1/160 英寸。\n它常用在设置镖局，内边距或任何不打算按照像素值指定尺寸的情况下。 \n<!--more-->\n#### **sp**\n和dp很类似，英文为：scale-independent pixel ，缩放无关像素，与密度无关。一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。\n#### **px**\n是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素。\n 在设计领域中，像素是用来计算数码影像的最小单位。计算机中显示的图像并非连续的线条组成，而是由许多肉眼看不见的小点组成。如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小点所组成，这些小点就是构成影像的最小单位“像素”。由于是最小的独立显示单位，px均为整数，不会出现0.5px的情况。\n####  **dpi**\ndpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。比如320X480分辨率的手机，宽2英寸，高3英寸, 每英寸包含的像素点的数量为320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi，横向和纵向的这个值都是相同的，原因是大部分手机屏幕使用正方形的像素点。\n \n#### **Android Drawable**\n我们新建一个Android项目后应该可以看到很多drawable文件夹，分别对应不同的dpi\n \n\tdrawable-ldpi (dpi=120, density=0.75)\n\t \n\tdrawable-mdpi (dpi=160, density=1)\n\t \n\tdrawable-hdpi (dpi=240, density=1.5)\n\t \n\tdrawable-xhdpi (dpi=320, density=2)\n\t \n\tdrawable-xxhdpi (dpi=480, density=3)\n\t \n首先必须清楚一个自动渲染的概念，Android SDK会自动屏幕尺寸选择对应的资源文件进行渲染，如SDK检测到你手机dpi是160的话会优先到drawable-mdpi文件夹下找对应的图片资源，注意只是优先，假设你手机dpi是160，但是你只在xhpdi文件夹下有对应的图片资源文件，程序一样可以正常运行。所以理论上来说只需要提供一种规格的图片资源就ok了，如果只提供ldpi规格的图片，对于大分辨率的手机如果把图片放大就会不清晰，所以需要提供一套你需要支持的最大dpi的图片，这样即使用户的手机分辨率很小，这样图片缩小依然很清晰。\n \n**xhdpi成为首选**\n上面说了只需要提供一套大的dpi的图片就ok了，现在市面手机分辨率最大可达到1080X1920的分辨率，如Nexus5，dpi属于xxhdpi，但是毕竟还没普及，目前市面上最普遍的高端机的分辨率还多集中在720X1080范围，也就是多集中在xhdpi，所以目前来看xhpdi规则的图片成为了首选。当然随着技术规格的提高以后发展，以后可能市场上xxdpi的手机会越来越普遍，但这是后话。\n","source":"_posts/screen-adaptation-dp_sp.md","raw":"---\ntitle: Android 屏幕适配dp,sp\ndate: 2016-04-23 15:29:25\ncategories: [android,学习笔记]\ntags: [android,屏幕适配]\n---\n\n相关的概念：\n#### **dp**\n即dip，设备独立像素，device independent pixels的缩写，密度无关像素，Android特有的单位，在屏幕密度dpi= 160屏幕上，1dp = 1px。1dp 在屏幕上总是1/160 英寸。\n它常用在设置镖局，内边距或任何不打算按照像素值指定尺寸的情况下。 \n<!--more-->\n#### **sp**\n和dp很类似，英文为：scale-independent pixel ，缩放无关像素，与密度无关。一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。\n#### **px**\n是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素。\n 在设计领域中，像素是用来计算数码影像的最小单位。计算机中显示的图像并非连续的线条组成，而是由许多肉眼看不见的小点组成。如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小点所组成，这些小点就是构成影像的最小单位“像素”。由于是最小的独立显示单位，px均为整数，不会出现0.5px的情况。\n####  **dpi**\ndpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。比如320X480分辨率的手机，宽2英寸，高3英寸, 每英寸包含的像素点的数量为320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi，横向和纵向的这个值都是相同的，原因是大部分手机屏幕使用正方形的像素点。\n \n#### **Android Drawable**\n我们新建一个Android项目后应该可以看到很多drawable文件夹，分别对应不同的dpi\n \n\tdrawable-ldpi (dpi=120, density=0.75)\n\t \n\tdrawable-mdpi (dpi=160, density=1)\n\t \n\tdrawable-hdpi (dpi=240, density=1.5)\n\t \n\tdrawable-xhdpi (dpi=320, density=2)\n\t \n\tdrawable-xxhdpi (dpi=480, density=3)\n\t \n首先必须清楚一个自动渲染的概念，Android SDK会自动屏幕尺寸选择对应的资源文件进行渲染，如SDK检测到你手机dpi是160的话会优先到drawable-mdpi文件夹下找对应的图片资源，注意只是优先，假设你手机dpi是160，但是你只在xhpdi文件夹下有对应的图片资源文件，程序一样可以正常运行。所以理论上来说只需要提供一种规格的图片资源就ok了，如果只提供ldpi规格的图片，对于大分辨率的手机如果把图片放大就会不清晰，所以需要提供一套你需要支持的最大dpi的图片，这样即使用户的手机分辨率很小，这样图片缩小依然很清晰。\n \n**xhdpi成为首选**\n上面说了只需要提供一套大的dpi的图片就ok了，现在市面手机分辨率最大可达到1080X1920的分辨率，如Nexus5，dpi属于xxhdpi，但是毕竟还没普及，目前市面上最普遍的高端机的分辨率还多集中在720X1080范围，也就是多集中在xhdpi，所以目前来看xhpdi规则的图片成为了首选。当然随着技术规格的提高以后发展，以后可能市场上xxdpi的手机会越来越普遍，但这是后话。\n","slug":"screen-adaptation-dp_sp","published":1,"updated":"2016-04-23T07:39:21.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucjm003sg0g5zfoct8a2","content":"<p>相关的概念：</p>\n<h4 id=\"dp\"><a href=\"#dp\" class=\"headerlink\" title=\"dp\"></a><strong>dp</strong></h4><p>即dip，设备独立像素，device independent pixels的缩写，密度无关像素，Android特有的单位，在屏幕密度dpi= 160屏幕上，1dp = 1px。1dp 在屏幕上总是1/160 英寸。<br>它常用在设置镖局，内边距或任何不打算按照像素值指定尺寸的情况下。<br><a id=\"more\"></a></p>\n<h4 id=\"sp\"><a href=\"#sp\" class=\"headerlink\" title=\"sp\"></a><strong>sp</strong></h4><p>和dp很类似，英文为：scale-independent pixel ，缩放无关像素，与密度无关。一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。</p>\n<h4 id=\"px\"><a href=\"#px\" class=\"headerlink\" title=\"px\"></a><strong>px</strong></h4><p>是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素。<br> 在设计领域中，像素是用来计算数码影像的最小单位。计算机中显示的图像并非连续的线条组成，而是由许多肉眼看不见的小点组成。如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小点所组成，这些小点就是构成影像的最小单位“像素”。由于是最小的独立显示单位，px均为整数，不会出现0.5px的情况。</p>\n<h4 id=\"dpi\"><a href=\"#dpi\" class=\"headerlink\" title=\"dpi\"></a><strong>dpi</strong></h4><p>dpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。比如320X480分辨率的手机，宽2英寸，高3英寸, 每英寸包含的像素点的数量为320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi，横向和纵向的这个值都是相同的，原因是大部分手机屏幕使用正方形的像素点。</p>\n<h4 id=\"Android-Drawable\"><a href=\"#Android-Drawable\" class=\"headerlink\" title=\"Android Drawable\"></a><strong>Android Drawable</strong></h4><p>我们新建一个Android项目后应该可以看到很多drawable文件夹，分别对应不同的dpi</p>\n<pre><code>drawable-ldpi (dpi=120, density=0.75)\n\ndrawable-mdpi (dpi=160, density=1)\n\ndrawable-hdpi (dpi=240, density=1.5)\n\ndrawable-xhdpi (dpi=320, density=2)\n\ndrawable-xxhdpi (dpi=480, density=3)\n</code></pre><p>首先必须清楚一个自动渲染的概念，Android SDK会自动屏幕尺寸选择对应的资源文件进行渲染，如SDK检测到你手机dpi是160的话会优先到drawable-mdpi文件夹下找对应的图片资源，注意只是优先，假设你手机dpi是160，但是你只在xhpdi文件夹下有对应的图片资源文件，程序一样可以正常运行。所以理论上来说只需要提供一种规格的图片资源就ok了，如果只提供ldpi规格的图片，对于大分辨率的手机如果把图片放大就会不清晰，所以需要提供一套你需要支持的最大dpi的图片，这样即使用户的手机分辨率很小，这样图片缩小依然很清晰。</p>\n<p><strong>xhdpi成为首选</strong><br>上面说了只需要提供一套大的dpi的图片就ok了，现在市面手机分辨率最大可达到1080X1920的分辨率，如Nexus5，dpi属于xxhdpi，但是毕竟还没普及，目前市面上最普遍的高端机的分辨率还多集中在720X1080范围，也就是多集中在xhdpi，所以目前来看xhpdi规则的图片成为了首选。当然随着技术规格的提高以后发展，以后可能市场上xxdpi的手机会越来越普遍，但这是后话。</p>\n","excerpt":"<p>相关的概念：</p>\n<h4 id=\"dp\"><a href=\"#dp\" class=\"headerlink\" title=\"dp\"></a><strong>dp</strong></h4><p>即dip，设备独立像素，device independent pixels的缩写，密度无关像素，Android特有的单位，在屏幕密度dpi= 160屏幕上，1dp = 1px。1dp 在屏幕上总是1/160 英寸。<br>它常用在设置镖局，内边距或任何不打算按照像素值指定尺寸的情况下。<br>","more":"</p>\n<h4 id=\"sp\"><a href=\"#sp\" class=\"headerlink\" title=\"sp\"></a><strong>sp</strong></h4><p>和dp很类似，英文为：scale-independent pixel ，缩放无关像素，与密度无关。一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。</p>\n<h4 id=\"px\"><a href=\"#px\" class=\"headerlink\" title=\"px\"></a><strong>px</strong></h4><p>是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素。<br> 在设计领域中，像素是用来计算数码影像的最小单位。计算机中显示的图像并非连续的线条组成，而是由许多肉眼看不见的小点组成。如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小点所组成，这些小点就是构成影像的最小单位“像素”。由于是最小的独立显示单位，px均为整数，不会出现0.5px的情况。</p>\n<h4 id=\"dpi\"><a href=\"#dpi\" class=\"headerlink\" title=\"dpi\"></a><strong>dpi</strong></h4><p>dpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。比如320X480分辨率的手机，宽2英寸，高3英寸, 每英寸包含的像素点的数量为320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi，横向和纵向的这个值都是相同的，原因是大部分手机屏幕使用正方形的像素点。</p>\n<h4 id=\"Android-Drawable\"><a href=\"#Android-Drawable\" class=\"headerlink\" title=\"Android Drawable\"></a><strong>Android Drawable</strong></h4><p>我们新建一个Android项目后应该可以看到很多drawable文件夹，分别对应不同的dpi</p>\n<pre><code>drawable-ldpi (dpi=120, density=0.75)\n\ndrawable-mdpi (dpi=160, density=1)\n\ndrawable-hdpi (dpi=240, density=1.5)\n\ndrawable-xhdpi (dpi=320, density=2)\n\ndrawable-xxhdpi (dpi=480, density=3)\n</code></pre><p>首先必须清楚一个自动渲染的概念，Android SDK会自动屏幕尺寸选择对应的资源文件进行渲染，如SDK检测到你手机dpi是160的话会优先到drawable-mdpi文件夹下找对应的图片资源，注意只是优先，假设你手机dpi是160，但是你只在xhpdi文件夹下有对应的图片资源文件，程序一样可以正常运行。所以理论上来说只需要提供一种规格的图片资源就ok了，如果只提供ldpi规格的图片，对于大分辨率的手机如果把图片放大就会不清晰，所以需要提供一套你需要支持的最大dpi的图片，这样即使用户的手机分辨率很小，这样图片缩小依然很清晰。</p>\n<p><strong>xhdpi成为首选</strong><br>上面说了只需要提供一套大的dpi的图片就ok了，现在市面手机分辨率最大可达到1080X1920的分辨率，如Nexus5，dpi属于xxhdpi，但是毕竟还没普及，目前市面上最普遍的高端机的分辨率还多集中在720X1080范围，也就是多集中在xhdpi，所以目前来看xhpdi规则的图片成为了首选。当然随着技术规格的提高以后发展，以后可能市场上xxdpi的手机会越来越普遍，但这是后话。</p>"},{"title":"2015年终总结及android学习路线","date":"2016-04-23T08:28:25.000Z","_content":"转眼间，一年又过去了，距离毕业也越来越近了。回想过去，感觉自己什么都还不会，顿时感到紧迫感。那么，在接下来的日子里，就要充分利用每分每秒，学习充实自己。我们搞it的就得时刻记着：活到老，学到老。<!--more-->\n回想这一年，自己独自学习android，从开始安装配置开发环境，到后来的指导别人并参加实际的项目开发，经历了各种酸甜苦辣。在此，总结下学习的经历。对于android，是个开发上手入门很快的语言，但后期在其他方面需要注意和学习的事情还有很多很多。自己在android学习之路上还有伸长的路要走，但不管怎么样，还是要脚踏实地，一点点的学习，不可骄傲浮躁。下面谈谈android的学习路线(来自网络)：\n### 初级\n\n基本知识点：比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术等。\n参考书籍：《第一行代码 Android》、《疯狂Android》\n### 中级\n\n稍微深入的知识点：AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义View、消息队列等。\n- AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别；\n- Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用；\n- 多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等；\n- 事件分发：弹性滑动、滑动冲突等；\n- 玩转View：View的绘制原理、各种自定义View；\n- 动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理；\n- 懂性能优化、熟悉mat等工具\n- 懂点常见的设计模式\n学习方法\n阅读进阶书籍，阅读Android源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有2个点是比较困扰大家的，一个是阅读源码，另一个是自定义View以及滑动冲突。\n学习view需要注意的地方：\n- 搞懂view的滑动原理\n- 搞懂如何实现弹性滑动\n- 搞懂view的滑动冲突\n- 搞懂view的measure、layout和draw\n然后再学习几个已有的自定义view的例子，最后就可以搞定自定义view了，所谓万变不离其宗。\n书籍推荐：《Android开发艺术探索》、《Android群英传》\n\n### 高级\n\n需要懂的知识：\n- 了解系统核心机制：\n1. 了解SystemServer的启动过程\n2. 了解主线程的消息循环模型\n3. 了解AMS和PMS的工作原理\n4. 能够回答问题”一个应用存在多少个Window？“\n5. 了解四大组件的大概工作流程\n6. …\n- 基本知识点的细节\n1. Activity的启动模式以及异常情况下不同Activity的表现\n2. Service的onBind和onReBind的关联\n3. onServiceDisconnected(ComponentName className)和binderDied的区别\n4. AsyncTask在不同版本上的表现细节\n5. 线程池的细节和参数配置\n6. …\n- 熟悉设计模式，有架构意识\n\n 书籍推荐\n《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》\n\n除此之外，还可以学习一些好的开源框架的使用（如：Eventbuss），还有第三方sdk的接入使用（如:百度地图）；总之，不管怎么说，需要我们不断地学习，接受新知识，愿在新的一年里不断提高。\n","source":"_posts/sum-up-2015.md","raw":"---\ntitle: 2015年终总结及android学习路线\ndate: 2016-04-23 16:28:25\ncategories: [android,学习笔记]\ntags: [学习路线,总结]\n---\n转眼间，一年又过去了，距离毕业也越来越近了。回想过去，感觉自己什么都还不会，顿时感到紧迫感。那么，在接下来的日子里，就要充分利用每分每秒，学习充实自己。我们搞it的就得时刻记着：活到老，学到老。<!--more-->\n回想这一年，自己独自学习android，从开始安装配置开发环境，到后来的指导别人并参加实际的项目开发，经历了各种酸甜苦辣。在此，总结下学习的经历。对于android，是个开发上手入门很快的语言，但后期在其他方面需要注意和学习的事情还有很多很多。自己在android学习之路上还有伸长的路要走，但不管怎么样，还是要脚踏实地，一点点的学习，不可骄傲浮躁。下面谈谈android的学习路线(来自网络)：\n### 初级\n\n基本知识点：比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术等。\n参考书籍：《第一行代码 Android》、《疯狂Android》\n### 中级\n\n稍微深入的知识点：AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义View、消息队列等。\n- AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别；\n- Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用；\n- 多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等；\n- 事件分发：弹性滑动、滑动冲突等；\n- 玩转View：View的绘制原理、各种自定义View；\n- 动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理；\n- 懂性能优化、熟悉mat等工具\n- 懂点常见的设计模式\n学习方法\n阅读进阶书籍，阅读Android源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有2个点是比较困扰大家的，一个是阅读源码，另一个是自定义View以及滑动冲突。\n学习view需要注意的地方：\n- 搞懂view的滑动原理\n- 搞懂如何实现弹性滑动\n- 搞懂view的滑动冲突\n- 搞懂view的measure、layout和draw\n然后再学习几个已有的自定义view的例子，最后就可以搞定自定义view了，所谓万变不离其宗。\n书籍推荐：《Android开发艺术探索》、《Android群英传》\n\n### 高级\n\n需要懂的知识：\n- 了解系统核心机制：\n1. 了解SystemServer的启动过程\n2. 了解主线程的消息循环模型\n3. 了解AMS和PMS的工作原理\n4. 能够回答问题”一个应用存在多少个Window？“\n5. 了解四大组件的大概工作流程\n6. …\n- 基本知识点的细节\n1. Activity的启动模式以及异常情况下不同Activity的表现\n2. Service的onBind和onReBind的关联\n3. onServiceDisconnected(ComponentName className)和binderDied的区别\n4. AsyncTask在不同版本上的表现细节\n5. 线程池的细节和参数配置\n6. …\n- 熟悉设计模式，有架构意识\n\n 书籍推荐\n《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》\n\n除此之外，还可以学习一些好的开源框架的使用（如：Eventbuss），还有第三方sdk的接入使用（如:百度地图）；总之，不管怎么说，需要我们不断地学习，接受新知识，愿在新的一年里不断提高。\n","slug":"sum-up-2015","published":1,"updated":"2016-04-23T10:11:10.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opucjm003xg0g55w5wcb2v","content":"<p>转眼间，一年又过去了，距离毕业也越来越近了。回想过去，感觉自己什么都还不会，顿时感到紧迫感。那么，在接下来的日子里，就要充分利用每分每秒，学习充实自己。我们搞it的就得时刻记着：活到老，学到老。<a id=\"more\"></a><br>回想这一年，自己独自学习android，从开始安装配置开发环境，到后来的指导别人并参加实际的项目开发，经历了各种酸甜苦辣。在此，总结下学习的经历。对于android，是个开发上手入门很快的语言，但后期在其他方面需要注意和学习的事情还有很多很多。自己在android学习之路上还有伸长的路要走，但不管怎么样，还是要脚踏实地，一点点的学习，不可骄傲浮躁。下面谈谈android的学习路线(来自网络)：</p>\n<h3 id=\"初级\"><a href=\"#初级\" class=\"headerlink\" title=\"初级\"></a>初级</h3><p>基本知识点：比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术等。<br>参考书籍：《第一行代码 Android》、《疯狂Android》</p>\n<h3 id=\"中级\"><a href=\"#中级\" class=\"headerlink\" title=\"中级\"></a>中级</h3><p>稍微深入的知识点：AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义View、消息队列等。</p>\n<ul>\n<li>AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别；</li>\n<li>Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用；</li>\n<li>多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等；</li>\n<li>事件分发：弹性滑动、滑动冲突等；</li>\n<li>玩转View：View的绘制原理、各种自定义View；</li>\n<li>动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理；</li>\n<li>懂性能优化、熟悉mat等工具</li>\n<li>懂点常见的设计模式<br>学习方法<br>阅读进阶书籍，阅读Android源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有2个点是比较困扰大家的，一个是阅读源码，另一个是自定义View以及滑动冲突。<br>学习view需要注意的地方：</li>\n<li>搞懂view的滑动原理</li>\n<li>搞懂如何实现弹性滑动</li>\n<li>搞懂view的滑动冲突</li>\n<li>搞懂view的measure、layout和draw<br>然后再学习几个已有的自定义view的例子，最后就可以搞定自定义view了，所谓万变不离其宗。<br>书籍推荐：《Android开发艺术探索》、《Android群英传》</li>\n</ul>\n<h3 id=\"高级\"><a href=\"#高级\" class=\"headerlink\" title=\"高级\"></a>高级</h3><p>需要懂的知识：</p>\n<ul>\n<li>了解系统核心机制：</li>\n</ul>\n<ol>\n<li>了解SystemServer的启动过程</li>\n<li>了解主线程的消息循环模型</li>\n<li>了解AMS和PMS的工作原理</li>\n<li>能够回答问题”一个应用存在多少个Window？“</li>\n<li>了解四大组件的大概工作流程</li>\n<li>…</li>\n</ol>\n<ul>\n<li>基本知识点的细节</li>\n</ul>\n<ol>\n<li>Activity的启动模式以及异常情况下不同Activity的表现</li>\n<li>Service的onBind和onReBind的关联</li>\n<li>onServiceDisconnected(ComponentName className)和binderDied的区别</li>\n<li>AsyncTask在不同版本上的表现细节</li>\n<li>线程池的细节和参数配置</li>\n<li>…</li>\n</ol>\n<ul>\n<li><p>熟悉设计模式，有架构意识</p>\n<p>书籍推荐<br>《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》</p>\n</li>\n</ul>\n<p>除此之外，还可以学习一些好的开源框架的使用（如：Eventbuss），还有第三方sdk的接入使用（如:百度地图）；总之，不管怎么说，需要我们不断地学习，接受新知识，愿在新的一年里不断提高。</p>\n","excerpt":"<p>转眼间，一年又过去了，距离毕业也越来越近了。回想过去，感觉自己什么都还不会，顿时感到紧迫感。那么，在接下来的日子里，就要充分利用每分每秒，学习充实自己。我们搞it的就得时刻记着：活到老，学到老。","more":"<br>回想这一年，自己独自学习android，从开始安装配置开发环境，到后来的指导别人并参加实际的项目开发，经历了各种酸甜苦辣。在此，总结下学习的经历。对于android，是个开发上手入门很快的语言，但后期在其他方面需要注意和学习的事情还有很多很多。自己在android学习之路上还有伸长的路要走，但不管怎么样，还是要脚踏实地，一点点的学习，不可骄傲浮躁。下面谈谈android的学习路线(来自网络)：</p>\n<h3 id=\"初级\"><a href=\"#初级\" class=\"headerlink\" title=\"初级\"></a>初级</h3><p>基本知识点：比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术等。<br>参考书籍：《第一行代码 Android》、《疯狂Android》</p>\n<h3 id=\"中级\"><a href=\"#中级\" class=\"headerlink\" title=\"中级\"></a>中级</h3><p>稍微深入的知识点：AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义View、消息队列等。</p>\n<ul>\n<li>AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别；</li>\n<li>Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用；</li>\n<li>多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等；</li>\n<li>事件分发：弹性滑动、滑动冲突等；</li>\n<li>玩转View：View的绘制原理、各种自定义View；</li>\n<li>动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理；</li>\n<li>懂性能优化、熟悉mat等工具</li>\n<li>懂点常见的设计模式<br>学习方法<br>阅读进阶书籍，阅读Android源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有2个点是比较困扰大家的，一个是阅读源码，另一个是自定义View以及滑动冲突。<br>学习view需要注意的地方：</li>\n<li>搞懂view的滑动原理</li>\n<li>搞懂如何实现弹性滑动</li>\n<li>搞懂view的滑动冲突</li>\n<li>搞懂view的measure、layout和draw<br>然后再学习几个已有的自定义view的例子，最后就可以搞定自定义view了，所谓万变不离其宗。<br>书籍推荐：《Android开发艺术探索》、《Android群英传》</li>\n</ul>\n<h3 id=\"高级\"><a href=\"#高级\" class=\"headerlink\" title=\"高级\"></a>高级</h3><p>需要懂的知识：</p>\n<ul>\n<li>了解系统核心机制：</li>\n</ul>\n<ol>\n<li>了解SystemServer的启动过程</li>\n<li>了解主线程的消息循环模型</li>\n<li>了解AMS和PMS的工作原理</li>\n<li>能够回答问题”一个应用存在多少个Window？“</li>\n<li>了解四大组件的大概工作流程</li>\n<li>…</li>\n</ol>\n<ul>\n<li>基本知识点的细节</li>\n</ul>\n<ol>\n<li>Activity的启动模式以及异常情况下不同Activity的表现</li>\n<li>Service的onBind和onReBind的关联</li>\n<li>onServiceDisconnected(ComponentName className)和binderDied的区别</li>\n<li>AsyncTask在不同版本上的表现细节</li>\n<li>线程池的细节和参数配置</li>\n<li>…</li>\n</ol>\n<ul>\n<li><p>熟悉设计模式，有架构意识</p>\n<p>书籍推荐<br>《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》</p>\n</li>\n</ul>\n<p>除此之外，还可以学习一些好的开源框架的使用（如：Eventbuss），还有第三方sdk的接入使用（如:百度地图）；总之，不管怎么说，需要我们不断地学习，接受新知识，愿在新的一年里不断提高。</p>"},{"title":"数据绑定库DataBinding的使用","date":"2016-09-10T08:06:25.000Z","_content":"\n`Data Binding` 是谷歌提供的 android 数据绑定库，为了而方便开发者实现 MVVM 的架构模式，使用它可以避免我们写大量的`findViewByID`，降低代码的耦合性。\n[官方介绍](https://developer.android.com/topic/libraries/data-binding/index.html)(需翻墙)\n\n### 一、使用环境要求\n通过查看官方文档，改数据绑定库的使用环境要求如下：\n\n- 下载 SDK Manager 中的支持库： Support repository；<!--more-->\n- android studio 版本在1.3之后；\n- gradle 版本在1.5.0-alpha1之后；\n- android sdk在android 2.1（API level7 +）以后。\n\n### 二、具体的使用\n#### 2.1、配置 data binding.\n在 model 的gradle中的 `android` 节点下添加如下代码：\n```\ndataBinding{\n    enabled = true\n}\n```\n\n#### 2.2、 建立数据对象\n添加一个POJO类，这里定义的是 User类，添加3个变量（uname，usex，uage）及相应的get,set方法，方便接下来与布局文件惊醒绑定。\n\n#### 2.3、 修改布局文件\n使用databinding后，布局文件根节点不在是简单的LinearLayout，RelativeLayout等ViewGroup,而是 `Layout`，同时还增加了 `data` 元素，来为ui控件提供数据。基本局如下：\n```\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <data>\n    </data>\n    <!--原先的根节点-->\n    <LinearLayout>\n    ....\n    </LinearLayout>\n</layout>\n```\n下面简单举例说明，显示用户信息，包括用户名，性别和年龄，布局文件名为`activity_main`，使用 databinding 的布局代码如下：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <data>\n        <variable\n            name=\"user\"\n            type=\"cn.imtianx.databindingdemo.bean.User\">\n        </variable>\n    </data>\n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{user.uname}\"/>\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{user.usex}\"/>\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{user.uage}\"/>\n    </LinearLayout>\n</layout>\n```\n该布局主要是三个TextView，来显示信息，在`data`标签中添加了变量`variable`,其中`name`是变量名,`type`使我们定义的java类（注：需要写完整的包名），通过`@{}`来为 TextView设置显示的文本。\n此外，这里的`data`也可以用`import`进行导入，如下：\n```\n <data>\n    <import type=\"cn.imtianx.databindingdemo.bean.User\"/>\n    <variable\n        name=\"user\"\n        type=\"User\"/>\n</data>\n```\n如果要使用`String`等`java.lang.*`下的类，则可以直接使用。\n\n#### 2.4、绑定变量数据\n编译项目即可根据布局文件名生成相关的Binding类，生成规则是按布局文件名，去掉’_‘，按驼峰法则，并在末尾添加`Binding`。如，这里的布局文件名为`activity_main`,则生成的数据绑定类为`ActivityMainBinding`，它存放在`包名.databinding`下，然后再 **activity**  的**onCreate**方法中设置变量，代码如如下：\n```\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    ActivityMainBinding mainBinding = DataBindingUtil\n            .setContentView(this, R.layout.activity_main);\n    User user = new User(\"imtianx\", \"男\", \"20\");\n    mainBinding.setUser(user);\n\n}\n```\n**注意：** 这里的 ActivityMainBinding 类会根据布局文件中的 variable 生成相应的 `set`方法。\n至此，一个简单的数据绑定就实现了，运行程序，会依次显示user中设置的三个字段的值。\n\n### 三、设置见监听事件\n这里可以通过两种方式进行绑定事件：**方法引用**和**监听器引用**。如下代码：\n```\npublic class Presenter {\n\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n        mUserBean.setName(s.toString());\n        mBinding.setUser(mUserBean);\n    }\n\n    public void onClick(View view) {\n        Toast.makeText(MainActivity.this, \"点击了名字\", Toast.LENGTH_SHORT).show();\n    }\n\n    public void onClickListenerBinding(UserBean bean) {\n        Toast.makeText(MainActivity.this, bean.getSex(), Toast.LENGTH_SHORT).show();\n    }\n\n}\n```\n使用时首先在xml的data标签下添加变量\n```\n<variable\n    name=\"presenter\"\n    type=\"cn.imtianx.databindingdemo.MainActivity.Presenter\">\n</variable>\n```\n#### 3.1 方法引用\n必须使用android 已有的监听的方法名及其参数，如上面的onTextChanged，onClick方法，具体的调用如下：\n```\n android:onClick=\"@{presenter.onClick}\"\n```\n#### 3.2 监听器引用\n可以方便的丛xml中向java代码中传递数据，可使用lambda表达式,如onClickListenerBinding，具体调用如下：\n```\nandroid:onClick=\"@{()->presenter.onClickListenerBinding(user)}\"\n```\n采用了lambda表达式的格式。\n\n### 四、在Fragment中的用法\n布局文件与上一个一样，在 Fragment 的 onCreateView 中设置相关的属性，具体代码如下：\n```\nprivate ActivityMainBinding mMainBinding;\n    private User user;\n\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.activity_main, container, false);\n        // 方式1,直接用默认生成的Binding类绑定\n        mMainBinding = ActivityMainBinding.bind(view);\n\n        // 方式2，向上转成ViewDataBinding类型\n//        ViewDataBinding viewDataBinding = ActivityMainBinding.bind(view);\n//        mMainBinding = (ActivityMainBinding) viewDataBinding;\n\n        //方式3，使用生成的Binding的inflater，\n//        mMainBinding = ActivityMainBinding.inflate(inflater);\n\n        //方式4，使用生成的Binding的inflater,类似Inflater api\n//        mMainBinding = ActivityMainBinding.inflate(inflater, container, false);\n\n        //方式5，某种情况无法生存默认Binding的情况下，并且把对应的layout传入\n//        ViewDataBinding viewDataBinding = DataBindingUtil.inflate(inflater, R.layout.activity_main, container, false);\n//        mMainBinding = (ActivityMainBinding) viewDataBinding;\n\n        //方式6，某种情况无法生存默认Binding的情况下\n//        ViewDataBinding viewDataBinding = DataBindingUtil.bind(view);\n\n        user = new User(\"imtianx\", \"男\", \"20\");\n        mMainBinding.setUser(user);\n        return view;\n    }\n```\n总之，它都需要初始化Binding类，初始化model类和数据绑定。\n\n\n### 五 、高级用法\n#### 5.1. 使用类方法\n首先在布局文件的`data` 使用`import`导入方法所在的类的全路径，然后再选要的地方调用，具体使用和java一样。\n\n#### 5.2. 类型别名\n在开发中可能会遇到两个用名的类，如果在`data`下同时导入他们，改如何解决？这里不用担心，可以在`import`节点下添加`alias`属性,来区别。如下示例：\n```\n <data>\n    <import type=\"cn.imtianx.databindingdemo.bean.User\" alias=\"User1\"/>\n    <import type=\"cn.imtianx.databindingdemo.model.User\" />\n    <variable\n        name=\"user\"\n        type=\"User1\"/>\n    <variable\n        name=\"user2\"\n        type=\"User\"/>\n</data>\n```\n#### 5.3. Null Coalescing 运算符\n这个和java中的三木表达式一样\n```\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"@{user.uage ??user.uage}\"/>\n```\n它等价于：\n```\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"@{user.uage!=null?user.uage:0}\"/>\n```\n#### 5.4. 属性值\n使用`@{}`在xml中使用java 中定义的一些属性值,如下给visibility 设置值，注意需要到如View类，\n```\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:visibility=\"@{user.display? View.VISIBLE:View.GONE}\"\n    android:text=\"@{user.uage\"/>\n```\n#### 5.5. 使用资源数据\n设置`padding`的值，需要的dime文件中添加largePadding和smallPadding的item。对于引用 `String、drawable`等资源类似。\n```\n <TextView\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:padding=\"@{user.display?(int)@dimen/largePadding : (int)@dimen/smallPadding}\"\n    android:text=\"@{user.uage}\"/>\n```\n#### 5.6. 使用include\n使用命名空间来传递variable，将当前 variable 的值传递给 include 进来 的布局中。\n为 layout 添加命名空间：\n```\nxmlns:bind=\"http://schemas.android.com/apk/res-auto\"\n```\n在`include`中使用：\n```\n<include\n    layout=\"@layout/layout_user\"\n    bind:user=\"@{user}\">\n```\n注意在 `layout_user.xml`中也要在 variable 中 定义添加 user 变量。\n\n#### 5.7. 使用表达式\njava 中的表达式，在这里也是支持的，\n\n - 数学 + - / * %\n - 字符串连接 +\n - 逻辑 && ||\n - 二进制 & | ^\n - 一元运算 + - ! ~\n - 移位 >> >>> <<\n - 比较 == > < >= <=\n - instanceof\n....\nData Binding代码生成时自动检查是否为null来避免出现`null pointer exceptions`错误,`String` 类型默认值是` null` ,`int`类型默认值是 `0`，`boolean` 类型默认值是 `false`。\n\n\n#### 5.8. 集合\n常用的集合：arrays、lists、sparse，lists以及maps，为了简便都可以使用`[]`来访问。注意,在使用泛型时`<`需要转义，用`&lt;`代替，否则会报错。\n```\n<data>\n  <import type=\"android.util.SparseArray\"/>\n  <import type=\"java.util.Map\"/>\n  <import type=\"java.util.List\"/>\n  <variable name=\"list\" type=\"List&lt;String>\"/>\n  <variable name=\"sparse\" type=\"SparseArray&lt;String>\"/>\n  <variable name=\"map\" type=\"Map&lt;String, String>\"/>\n  <variable name=\"index\" type=\"int\"/>\n  <variable name=\"key\" type=\"String\"/>\n</data>\n…\nandroid:text=\"@{list[index]}\"\n…\nandroid:text=\"@{sparse[index]}\"\n…\nandroid:text=\"@{map[key]}\"\n```\n#### 5.9.Data对象（数据绑定）\nData Binding 的强大之处主要在于双向数据绑定，当POJO对象发生变化时，通知改变Data对象，已达到更新UI的效果。有三种不同的数据变化通知机制：`Observable`对象、`ObservableFields`以及`observable  collections`。\n这里以 Observable 为例，更改User类。使其继承`BaseObservable`,在`getter`方法前添加`Bindable`注解，在`setter`方法中调用`notifyPropertyChanged`进行更新数据。如果只更新某一字段，只需将该字段设置为`ObservableFields`类型的，如boolean,可用ObservableBoolean代替，但对其的使用需要通过get和set方法。具体代码如下：\n```\npublic class User extends BaseObservable{\n    private String uname;\n    private String usex;\n    private String uage;\n    private boolean isDisplay;\n\n    public User() {\n    }\n\n    public User(String uname, String usex, String uage, boolean isDisplay) {\n        this.uname = uname;\n        this.usex = usex;\n        this.uage = uage;\n        this.isDisplay = isDisplay;\n    }\n    @Bindable\n    public String getUname() {\n        return uname;\n    }\n\n    public void setUname(String uname) {\n        this.uname = uname;\n        notifyPropertyChanged(BR.uname);\n    }\n\n    @Bindable\n    public String getUsex() {\n        return usex;\n    }\n\n    public void setUsex(String usex) {\n        this.usex = usex;\n        notifyPropertyChanged(BR.usex);\n    }\n\n    @Bindable\n    public String getUage() {\n        return uage;\n    }\n\n    public void setUage(String uage) {\n        this.uage = uage;\n        notifyPropertyChanged(BR.uage);\n    }\n\n    @Bindable\n    public boolean isDisplay() {\n        return isDisplay;\n    }\n\n    public void setDisplay(boolean display) {\n        isDisplay = display;\n        notifyPropertyChanged(BR.display);\n    }\n```\n在编译期间，Bindable注解在BR(与R文件类似)类文件中生成一个Entry。BR类文件会在模块包内生成。如果用于Data类的基类不能改变，Observable接口通过方便的PropertyChangeRegistry来实现用于储存和有效地通知监听器。\n\nData Binding的基本用法已经介绍完了，但它 的使用知识点较多，暂且写到这里,对于它在ListView/RecyclerView中的用法、事件处理等稍后再做介绍。\n<br>\n\n\n文中部分资料来源于页底的参考资料。\n\n> 参考资料：\n1. https://github.com/LyndonChin/MasteringAndroidDataBinding\n2. http://www.jianshu.com/p/b1df61a4df77\n3. https://realm.io/cn/news/data-binding-android-boyar-mount/?utm_source=tuicool&utm_medium=referral\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/using-DataBinding.md","raw":"---\ntitle: 数据绑定库DataBinding的使用\ndate: 2016-09-10 16:06:25\ncategories: [android,学习笔记]\ntags: [DataBinding,数据绑定]\n---\n\n`Data Binding` 是谷歌提供的 android 数据绑定库，为了而方便开发者实现 MVVM 的架构模式，使用它可以避免我们写大量的`findViewByID`，降低代码的耦合性。\n[官方介绍](https://developer.android.com/topic/libraries/data-binding/index.html)(需翻墙)\n\n### 一、使用环境要求\n通过查看官方文档，改数据绑定库的使用环境要求如下：\n\n- 下载 SDK Manager 中的支持库： Support repository；<!--more-->\n- android studio 版本在1.3之后；\n- gradle 版本在1.5.0-alpha1之后；\n- android sdk在android 2.1（API level7 +）以后。\n\n### 二、具体的使用\n#### 2.1、配置 data binding.\n在 model 的gradle中的 `android` 节点下添加如下代码：\n```\ndataBinding{\n    enabled = true\n}\n```\n\n#### 2.2、 建立数据对象\n添加一个POJO类，这里定义的是 User类，添加3个变量（uname，usex，uage）及相应的get,set方法，方便接下来与布局文件惊醒绑定。\n\n#### 2.3、 修改布局文件\n使用databinding后，布局文件根节点不在是简单的LinearLayout，RelativeLayout等ViewGroup,而是 `Layout`，同时还增加了 `data` 元素，来为ui控件提供数据。基本局如下：\n```\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <data>\n    </data>\n    <!--原先的根节点-->\n    <LinearLayout>\n    ....\n    </LinearLayout>\n</layout>\n```\n下面简单举例说明，显示用户信息，包括用户名，性别和年龄，布局文件名为`activity_main`，使用 databinding 的布局代码如下：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <data>\n        <variable\n            name=\"user\"\n            type=\"cn.imtianx.databindingdemo.bean.User\">\n        </variable>\n    </data>\n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{user.uname}\"/>\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{user.usex}\"/>\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{user.uage}\"/>\n    </LinearLayout>\n</layout>\n```\n该布局主要是三个TextView，来显示信息，在`data`标签中添加了变量`variable`,其中`name`是变量名,`type`使我们定义的java类（注：需要写完整的包名），通过`@{}`来为 TextView设置显示的文本。\n此外，这里的`data`也可以用`import`进行导入，如下：\n```\n <data>\n    <import type=\"cn.imtianx.databindingdemo.bean.User\"/>\n    <variable\n        name=\"user\"\n        type=\"User\"/>\n</data>\n```\n如果要使用`String`等`java.lang.*`下的类，则可以直接使用。\n\n#### 2.4、绑定变量数据\n编译项目即可根据布局文件名生成相关的Binding类，生成规则是按布局文件名，去掉’_‘，按驼峰法则，并在末尾添加`Binding`。如，这里的布局文件名为`activity_main`,则生成的数据绑定类为`ActivityMainBinding`，它存放在`包名.databinding`下，然后再 **activity**  的**onCreate**方法中设置变量，代码如如下：\n```\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    ActivityMainBinding mainBinding = DataBindingUtil\n            .setContentView(this, R.layout.activity_main);\n    User user = new User(\"imtianx\", \"男\", \"20\");\n    mainBinding.setUser(user);\n\n}\n```\n**注意：** 这里的 ActivityMainBinding 类会根据布局文件中的 variable 生成相应的 `set`方法。\n至此，一个简单的数据绑定就实现了，运行程序，会依次显示user中设置的三个字段的值。\n\n### 三、设置见监听事件\n这里可以通过两种方式进行绑定事件：**方法引用**和**监听器引用**。如下代码：\n```\npublic class Presenter {\n\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n        mUserBean.setName(s.toString());\n        mBinding.setUser(mUserBean);\n    }\n\n    public void onClick(View view) {\n        Toast.makeText(MainActivity.this, \"点击了名字\", Toast.LENGTH_SHORT).show();\n    }\n\n    public void onClickListenerBinding(UserBean bean) {\n        Toast.makeText(MainActivity.this, bean.getSex(), Toast.LENGTH_SHORT).show();\n    }\n\n}\n```\n使用时首先在xml的data标签下添加变量\n```\n<variable\n    name=\"presenter\"\n    type=\"cn.imtianx.databindingdemo.MainActivity.Presenter\">\n</variable>\n```\n#### 3.1 方法引用\n必须使用android 已有的监听的方法名及其参数，如上面的onTextChanged，onClick方法，具体的调用如下：\n```\n android:onClick=\"@{presenter.onClick}\"\n```\n#### 3.2 监听器引用\n可以方便的丛xml中向java代码中传递数据，可使用lambda表达式,如onClickListenerBinding，具体调用如下：\n```\nandroid:onClick=\"@{()->presenter.onClickListenerBinding(user)}\"\n```\n采用了lambda表达式的格式。\n\n### 四、在Fragment中的用法\n布局文件与上一个一样，在 Fragment 的 onCreateView 中设置相关的属性，具体代码如下：\n```\nprivate ActivityMainBinding mMainBinding;\n    private User user;\n\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.activity_main, container, false);\n        // 方式1,直接用默认生成的Binding类绑定\n        mMainBinding = ActivityMainBinding.bind(view);\n\n        // 方式2，向上转成ViewDataBinding类型\n//        ViewDataBinding viewDataBinding = ActivityMainBinding.bind(view);\n//        mMainBinding = (ActivityMainBinding) viewDataBinding;\n\n        //方式3，使用生成的Binding的inflater，\n//        mMainBinding = ActivityMainBinding.inflate(inflater);\n\n        //方式4，使用生成的Binding的inflater,类似Inflater api\n//        mMainBinding = ActivityMainBinding.inflate(inflater, container, false);\n\n        //方式5，某种情况无法生存默认Binding的情况下，并且把对应的layout传入\n//        ViewDataBinding viewDataBinding = DataBindingUtil.inflate(inflater, R.layout.activity_main, container, false);\n//        mMainBinding = (ActivityMainBinding) viewDataBinding;\n\n        //方式6，某种情况无法生存默认Binding的情况下\n//        ViewDataBinding viewDataBinding = DataBindingUtil.bind(view);\n\n        user = new User(\"imtianx\", \"男\", \"20\");\n        mMainBinding.setUser(user);\n        return view;\n    }\n```\n总之，它都需要初始化Binding类，初始化model类和数据绑定。\n\n\n### 五 、高级用法\n#### 5.1. 使用类方法\n首先在布局文件的`data` 使用`import`导入方法所在的类的全路径，然后再选要的地方调用，具体使用和java一样。\n\n#### 5.2. 类型别名\n在开发中可能会遇到两个用名的类，如果在`data`下同时导入他们，改如何解决？这里不用担心，可以在`import`节点下添加`alias`属性,来区别。如下示例：\n```\n <data>\n    <import type=\"cn.imtianx.databindingdemo.bean.User\" alias=\"User1\"/>\n    <import type=\"cn.imtianx.databindingdemo.model.User\" />\n    <variable\n        name=\"user\"\n        type=\"User1\"/>\n    <variable\n        name=\"user2\"\n        type=\"User\"/>\n</data>\n```\n#### 5.3. Null Coalescing 运算符\n这个和java中的三木表达式一样\n```\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"@{user.uage ??user.uage}\"/>\n```\n它等价于：\n```\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"@{user.uage!=null?user.uage:0}\"/>\n```\n#### 5.4. 属性值\n使用`@{}`在xml中使用java 中定义的一些属性值,如下给visibility 设置值，注意需要到如View类，\n```\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:visibility=\"@{user.display? View.VISIBLE:View.GONE}\"\n    android:text=\"@{user.uage\"/>\n```\n#### 5.5. 使用资源数据\n设置`padding`的值，需要的dime文件中添加largePadding和smallPadding的item。对于引用 `String、drawable`等资源类似。\n```\n <TextView\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:padding=\"@{user.display?(int)@dimen/largePadding : (int)@dimen/smallPadding}\"\n    android:text=\"@{user.uage}\"/>\n```\n#### 5.6. 使用include\n使用命名空间来传递variable，将当前 variable 的值传递给 include 进来 的布局中。\n为 layout 添加命名空间：\n```\nxmlns:bind=\"http://schemas.android.com/apk/res-auto\"\n```\n在`include`中使用：\n```\n<include\n    layout=\"@layout/layout_user\"\n    bind:user=\"@{user}\">\n```\n注意在 `layout_user.xml`中也要在 variable 中 定义添加 user 变量。\n\n#### 5.7. 使用表达式\njava 中的表达式，在这里也是支持的，\n\n - 数学 + - / * %\n - 字符串连接 +\n - 逻辑 && ||\n - 二进制 & | ^\n - 一元运算 + - ! ~\n - 移位 >> >>> <<\n - 比较 == > < >= <=\n - instanceof\n....\nData Binding代码生成时自动检查是否为null来避免出现`null pointer exceptions`错误,`String` 类型默认值是` null` ,`int`类型默认值是 `0`，`boolean` 类型默认值是 `false`。\n\n\n#### 5.8. 集合\n常用的集合：arrays、lists、sparse，lists以及maps，为了简便都可以使用`[]`来访问。注意,在使用泛型时`<`需要转义，用`&lt;`代替，否则会报错。\n```\n<data>\n  <import type=\"android.util.SparseArray\"/>\n  <import type=\"java.util.Map\"/>\n  <import type=\"java.util.List\"/>\n  <variable name=\"list\" type=\"List&lt;String>\"/>\n  <variable name=\"sparse\" type=\"SparseArray&lt;String>\"/>\n  <variable name=\"map\" type=\"Map&lt;String, String>\"/>\n  <variable name=\"index\" type=\"int\"/>\n  <variable name=\"key\" type=\"String\"/>\n</data>\n…\nandroid:text=\"@{list[index]}\"\n…\nandroid:text=\"@{sparse[index]}\"\n…\nandroid:text=\"@{map[key]}\"\n```\n#### 5.9.Data对象（数据绑定）\nData Binding 的强大之处主要在于双向数据绑定，当POJO对象发生变化时，通知改变Data对象，已达到更新UI的效果。有三种不同的数据变化通知机制：`Observable`对象、`ObservableFields`以及`observable  collections`。\n这里以 Observable 为例，更改User类。使其继承`BaseObservable`,在`getter`方法前添加`Bindable`注解，在`setter`方法中调用`notifyPropertyChanged`进行更新数据。如果只更新某一字段，只需将该字段设置为`ObservableFields`类型的，如boolean,可用ObservableBoolean代替，但对其的使用需要通过get和set方法。具体代码如下：\n```\npublic class User extends BaseObservable{\n    private String uname;\n    private String usex;\n    private String uage;\n    private boolean isDisplay;\n\n    public User() {\n    }\n\n    public User(String uname, String usex, String uage, boolean isDisplay) {\n        this.uname = uname;\n        this.usex = usex;\n        this.uage = uage;\n        this.isDisplay = isDisplay;\n    }\n    @Bindable\n    public String getUname() {\n        return uname;\n    }\n\n    public void setUname(String uname) {\n        this.uname = uname;\n        notifyPropertyChanged(BR.uname);\n    }\n\n    @Bindable\n    public String getUsex() {\n        return usex;\n    }\n\n    public void setUsex(String usex) {\n        this.usex = usex;\n        notifyPropertyChanged(BR.usex);\n    }\n\n    @Bindable\n    public String getUage() {\n        return uage;\n    }\n\n    public void setUage(String uage) {\n        this.uage = uage;\n        notifyPropertyChanged(BR.uage);\n    }\n\n    @Bindable\n    public boolean isDisplay() {\n        return isDisplay;\n    }\n\n    public void setDisplay(boolean display) {\n        isDisplay = display;\n        notifyPropertyChanged(BR.display);\n    }\n```\n在编译期间，Bindable注解在BR(与R文件类似)类文件中生成一个Entry。BR类文件会在模块包内生成。如果用于Data类的基类不能改变，Observable接口通过方便的PropertyChangeRegistry来实现用于储存和有效地通知监听器。\n\nData Binding的基本用法已经介绍完了，但它 的使用知识点较多，暂且写到这里,对于它在ListView/RecyclerView中的用法、事件处理等稍后再做介绍。\n<br>\n\n\n文中部分资料来源于页底的参考资料。\n\n> 参考资料：\n1. https://github.com/LyndonChin/MasteringAndroidDataBinding\n2. http://www.jianshu.com/p/b1df61a4df77\n3. https://realm.io/cn/news/data-binding-android-boyar-mount/?utm_source=tuicool&utm_medium=referral\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"using-DataBinding","published":1,"updated":"2016-09-20T01:03:37.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuck20040g0g5d5cc4jp7","content":"<p><code>Data Binding</code> 是谷歌提供的 android 数据绑定库，为了而方便开发者实现 MVVM 的架构模式，使用它可以避免我们写大量的<code>findViewByID</code>，降低代码的耦合性。<br><a href=\"https://developer.android.com/topic/libraries/data-binding/index.html\" target=\"_blank\" rel=\"external\">官方介绍</a>(需翻墙)</p>\n<h3 id=\"一、使用环境要求\"><a href=\"#一、使用环境要求\" class=\"headerlink\" title=\"一、使用环境要求\"></a>一、使用环境要求</h3><p>通过查看官方文档，改数据绑定库的使用环境要求如下：</p>\n<ul>\n<li>下载 SDK Manager 中的支持库： Support repository；<a id=\"more\"></a></li>\n<li>android studio 版本在1.3之后；</li>\n<li>gradle 版本在1.5.0-alpha1之后；</li>\n<li>android sdk在android 2.1（API level7 +）以后。</li>\n</ul>\n<h3 id=\"二、具体的使用\"><a href=\"#二、具体的使用\" class=\"headerlink\" title=\"二、具体的使用\"></a>二、具体的使用</h3><h4 id=\"2-1、配置-data-binding\"><a href=\"#2-1、配置-data-binding\" class=\"headerlink\" title=\"2.1、配置 data binding.\"></a>2.1、配置 data binding.</h4><p>在 model 的gradle中的 <code>android</code> 节点下添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataBinding&#123;</span><br><span class=\"line\">    enabled = true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-2、-建立数据对象\"><a href=\"#2-2、-建立数据对象\" class=\"headerlink\" title=\"2.2、 建立数据对象\"></a>2.2、 建立数据对象</h4><p>添加一个POJO类，这里定义的是 User类，添加3个变量（uname，usex，uage）及相应的get,set方法，方便接下来与布局文件惊醒绑定。</p>\n<h4 id=\"2-3、-修改布局文件\"><a href=\"#2-3、-修改布局文件\" class=\"headerlink\" title=\"2.3、 修改布局文件\"></a>2.3、 修改布局文件</h4><p>使用databinding后，布局文件根节点不在是简单的LinearLayout，RelativeLayout等ViewGroup,而是 <code>Layout</code>，同时还增加了 <code>data</code> 元素，来为ui控件提供数据。基本局如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">    &lt;data&gt;</span><br><span class=\"line\">    &lt;/data&gt;</span><br><span class=\"line\">    &lt;!--原先的根节点--&gt;</span><br><span class=\"line\">    &lt;LinearLayout&gt;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    &lt;/LinearLayout&gt;</span><br><span class=\"line\">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>下面简单举例说明，显示用户信息，包括用户名，性别和年龄，布局文件名为<code>activity_main</code>，使用 databinding 的布局代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;layout</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">    &lt;data&gt;</span><br><span class=\"line\">        &lt;variable</span><br><span class=\"line\">            name=&quot;user&quot;</span><br><span class=\"line\">            type=&quot;cn.imtianx.databindingdemo.bean.User&quot;&gt;</span><br><span class=\"line\">        &lt;/variable&gt;</span><br><span class=\"line\">    &lt;/data&gt;</span><br><span class=\"line\">    &lt;LinearLayout</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:text=&quot;@&#123;user.uname&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:text=&quot;@&#123;user.usex&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:text=&quot;@&#123;user.uage&#125;&quot;/&gt;</span><br><span class=\"line\">    &lt;/LinearLayout&gt;</span><br><span class=\"line\">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>该布局主要是三个TextView，来显示信息，在<code>data</code>标签中添加了变量<code>variable</code>,其中<code>name</code>是变量名,<code>type</code>使我们定义的java类（注：需要写完整的包名），通过<code>@{}</code>来为 TextView设置显示的文本。<br>此外，这里的<code>data</code>也可以用<code>import</code>进行导入，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;data&gt;</span><br><span class=\"line\">    &lt;import type=&quot;cn.imtianx.databindingdemo.bean.User&quot;/&gt;</span><br><span class=\"line\">    &lt;variable</span><br><span class=\"line\">        name=&quot;user&quot;</span><br><span class=\"line\">        type=&quot;User&quot;/&gt;</span><br><span class=\"line\">&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果要使用<code>String</code>等<code>java.lang.*</code>下的类，则可以直接使用。</p>\n<h4 id=\"2-4、绑定变量数据\"><a href=\"#2-4、绑定变量数据\" class=\"headerlink\" title=\"2.4、绑定变量数据\"></a>2.4、绑定变量数据</h4><p>编译项目即可根据布局文件名生成相关的Binding类，生成规则是按布局文件名，去掉’_‘，按驼峰法则，并在末尾添加<code>Binding</code>。如，这里的布局文件名为<code>activity_main</code>,则生成的数据绑定类为<code>ActivityMainBinding</code>，它存放在<code>包名.databinding</code>下，然后再 <strong>activity</strong>  的<strong>onCreate</strong>方法中设置变量，代码如如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    super.onCreate(savedInstanceState);</span><br><span class=\"line\">    ActivityMainBinding mainBinding = DataBindingUtil</span><br><span class=\"line\">            .setContentView(this, R.layout.activity_main);</span><br><span class=\"line\">    User user = new User(&quot;imtianx&quot;, &quot;男&quot;, &quot;20&quot;);</span><br><span class=\"line\">    mainBinding.setUser(user);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong> 这里的 ActivityMainBinding 类会根据布局文件中的 variable 生成相应的 <code>set</code>方法。<br>至此，一个简单的数据绑定就实现了，运行程序，会依次显示user中设置的三个字段的值。</p>\n<h3 id=\"三、设置见监听事件\"><a href=\"#三、设置见监听事件\" class=\"headerlink\" title=\"三、设置见监听事件\"></a>三、设置见监听事件</h3><p>这里可以通过两种方式进行绑定事件：<strong>方法引用</strong>和<strong>监听器引用</strong>。如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Presenter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onTextChanged(CharSequence s, int start, int before, int count) &#123;</span><br><span class=\"line\">        mUserBean.setName(s.toString());</span><br><span class=\"line\">        mBinding.setUser(mUserBean);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onClick(View view) &#123;</span><br><span class=\"line\">        Toast.makeText(MainActivity.this, &quot;点击了名字&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onClickListenerBinding(UserBean bean) &#123;</span><br><span class=\"line\">        Toast.makeText(MainActivity.this, bean.getSex(), Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用时首先在xml的data标签下添加变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name=&quot;presenter&quot;</span><br><span class=\"line\">    type=&quot;cn.imtianx.databindingdemo.MainActivity.Presenter&quot;&gt;</span><br><span class=\"line\">&lt;/variable&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-1-方法引用\"><a href=\"#3-1-方法引用\" class=\"headerlink\" title=\"3.1 方法引用\"></a>3.1 方法引用</h4><p>必须使用android 已有的监听的方法名及其参数，如上面的onTextChanged，onClick方法，具体的调用如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:onClick=&quot;@&#123;presenter.onClick&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-2-监听器引用\"><a href=\"#3-2-监听器引用\" class=\"headerlink\" title=\"3.2 监听器引用\"></a>3.2 监听器引用</h4><p>可以方便的丛xml中向java代码中传递数据，可使用lambda表达式,如onClickListenerBinding，具体调用如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:onClick=&quot;@&#123;()-&gt;presenter.onClickListenerBinding(user)&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>采用了lambda表达式的格式。</p>\n<h3 id=\"四、在Fragment中的用法\"><a href=\"#四、在Fragment中的用法\" class=\"headerlink\" title=\"四、在Fragment中的用法\"></a>四、在Fragment中的用法</h3><p>布局文件与上一个一样，在 Fragment 的 onCreateView 中设置相关的属性，具体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private ActivityMainBinding mMainBinding;</span><br><span class=\"line\">    private User user;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Nullable</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        View view = inflater.inflate(R.layout.activity_main, container, false);</span><br><span class=\"line\">        // 方式1,直接用默认生成的Binding类绑定</span><br><span class=\"line\">        mMainBinding = ActivityMainBinding.bind(view);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 方式2，向上转成ViewDataBinding类型</span><br><span class=\"line\">//        ViewDataBinding viewDataBinding = ActivityMainBinding.bind(view);</span><br><span class=\"line\">//        mMainBinding = (ActivityMainBinding) viewDataBinding;</span><br><span class=\"line\"></span><br><span class=\"line\">        //方式3，使用生成的Binding的inflater，</span><br><span class=\"line\">//        mMainBinding = ActivityMainBinding.inflate(inflater);</span><br><span class=\"line\"></span><br><span class=\"line\">        //方式4，使用生成的Binding的inflater,类似Inflater api</span><br><span class=\"line\">//        mMainBinding = ActivityMainBinding.inflate(inflater, container, false);</span><br><span class=\"line\"></span><br><span class=\"line\">        //方式5，某种情况无法生存默认Binding的情况下，并且把对应的layout传入</span><br><span class=\"line\">//        ViewDataBinding viewDataBinding = DataBindingUtil.inflate(inflater, R.layout.activity_main, container, false);</span><br><span class=\"line\">//        mMainBinding = (ActivityMainBinding) viewDataBinding;</span><br><span class=\"line\"></span><br><span class=\"line\">        //方式6，某种情况无法生存默认Binding的情况下</span><br><span class=\"line\">//        ViewDataBinding viewDataBinding = DataBindingUtil.bind(view);</span><br><span class=\"line\"></span><br><span class=\"line\">        user = new User(&quot;imtianx&quot;, &quot;男&quot;, &quot;20&quot;);</span><br><span class=\"line\">        mMainBinding.setUser(user);</span><br><span class=\"line\">        return view;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>总之，它都需要初始化Binding类，初始化model类和数据绑定。</p>\n<h3 id=\"五-、高级用法\"><a href=\"#五-、高级用法\" class=\"headerlink\" title=\"五 、高级用法\"></a>五 、高级用法</h3><h4 id=\"5-1-使用类方法\"><a href=\"#5-1-使用类方法\" class=\"headerlink\" title=\"5.1. 使用类方法\"></a>5.1. 使用类方法</h4><p>首先在布局文件的<code>data</code> 使用<code>import</code>导入方法所在的类的全路径，然后再选要的地方调用，具体使用和java一样。</p>\n<h4 id=\"5-2-类型别名\"><a href=\"#5-2-类型别名\" class=\"headerlink\" title=\"5.2. 类型别名\"></a>5.2. 类型别名</h4><p>在开发中可能会遇到两个用名的类，如果在<code>data</code>下同时导入他们，改如何解决？这里不用担心，可以在<code>import</code>节点下添加<code>alias</code>属性,来区别。如下示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;data&gt;</span><br><span class=\"line\">    &lt;import type=&quot;cn.imtianx.databindingdemo.bean.User&quot; alias=&quot;User1&quot;/&gt;</span><br><span class=\"line\">    &lt;import type=&quot;cn.imtianx.databindingdemo.model.User&quot; /&gt;</span><br><span class=\"line\">    &lt;variable</span><br><span class=\"line\">        name=&quot;user&quot;</span><br><span class=\"line\">        type=&quot;User1&quot;/&gt;</span><br><span class=\"line\">    &lt;variable</span><br><span class=\"line\">        name=&quot;user2&quot;</span><br><span class=\"line\">        type=&quot;User&quot;/&gt;</span><br><span class=\"line\">&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-3-Null-Coalescing-运算符\"><a href=\"#5-3-Null-Coalescing-运算符\" class=\"headerlink\" title=\"5.3. Null Coalescing 运算符\"></a>5.3. Null Coalescing 运算符</h4><p>这个和java中的三木表达式一样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text=&quot;@&#123;user.uage ??user.uage&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>它等价于：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text=&quot;@&#123;user.uage!=null?user.uage:0&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-4-属性值\"><a href=\"#5-4-属性值\" class=\"headerlink\" title=\"5.4. 属性值\"></a>5.4. 属性值</h4><p>使用<code>@{}</code>在xml中使用java 中定义的一些属性值,如下给visibility 设置值，注意需要到如View类，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:visibility=&quot;@&#123;user.display? View.VISIBLE:View.GONE&#125;&quot;</span><br><span class=\"line\">    android:text=&quot;@&#123;user.uage&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-5-使用资源数据\"><a href=\"#5-5-使用资源数据\" class=\"headerlink\" title=\"5.5. 使用资源数据\"></a>5.5. 使用资源数据</h4><p>设置<code>padding</code>的值，需要的dime文件中添加largePadding和smallPadding的item。对于引用 <code>String、drawable</code>等资源类似。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">   android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">   android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">   android:padding=&quot;@&#123;user.display?(int)@dimen/largePadding : (int)@dimen/smallPadding&#125;&quot;</span><br><span class=\"line\">   android:text=&quot;@&#123;user.uage&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-6-使用include\"><a href=\"#5-6-使用include\" class=\"headerlink\" title=\"5.6. 使用include\"></a>5.6. 使用include</h4><p>使用命名空间来传递variable，将当前 variable 的值传递给 include 进来 的布局中。<br>为 layout 添加命名空间：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>include</code>中使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;include</span><br><span class=\"line\">    layout=&quot;@layout/layout_user&quot;</span><br><span class=\"line\">    bind:user=&quot;@&#123;user&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>注意在 <code>layout_user.xml</code>中也要在 variable 中 定义添加 user 变量。</p>\n<h4 id=\"5-7-使用表达式\"><a href=\"#5-7-使用表达式\" class=\"headerlink\" title=\"5.7. 使用表达式\"></a>5.7. 使用表达式</h4><p>java 中的表达式，在这里也是支持的，</p>\n<ul>\n<li>数学 + - / * %</li>\n<li>字符串连接 +</li>\n<li>逻辑 &amp;&amp; ||</li>\n<li>二进制 &amp; | ^</li>\n<li>一元运算 + - ! ~</li>\n<li>移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li>\n<li>比较 == &gt; &lt; &gt;= &lt;=</li>\n<li>instanceof<br>….<br>Data Binding代码生成时自动检查是否为null来避免出现<code>null pointer exceptions</code>错误,<code>String</code> 类型默认值是<code>null</code> ,<code>int</code>类型默认值是 <code>0</code>，<code>boolean</code> 类型默认值是 <code>false</code>。</li>\n</ul>\n<h4 id=\"5-8-集合\"><a href=\"#5-8-集合\" class=\"headerlink\" title=\"5.8. 集合\"></a>5.8. 集合</h4><p>常用的集合：arrays、lists、sparse，lists以及maps，为了简便都可以使用<code>[]</code>来访问。注意,在使用泛型时<code>&lt;</code>需要转义，用<code>&amp;lt;</code>代替，否则会报错。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;data&gt;</span><br><span class=\"line\">  &lt;import type=&quot;android.util.SparseArray&quot;/&gt;</span><br><span class=\"line\">  &lt;import type=&quot;java.util.Map&quot;/&gt;</span><br><span class=\"line\">  &lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class=\"line\">  &lt;variable name=&quot;list&quot; type=&quot;List&amp;lt;String&gt;&quot;/&gt;</span><br><span class=\"line\">  &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&amp;lt;String&gt;&quot;/&gt;</span><br><span class=\"line\">  &lt;variable name=&quot;map&quot; type=&quot;Map&amp;lt;String, String&gt;&quot;/&gt;</span><br><span class=\"line\">  &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;</span><br><span class=\"line\">  &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;</span><br><span class=\"line\">&lt;/data&gt;</span><br><span class=\"line\">…</span><br><span class=\"line\">android:text=&quot;@&#123;list[index]&#125;&quot;</span><br><span class=\"line\">…</span><br><span class=\"line\">android:text=&quot;@&#123;sparse[index]&#125;&quot;</span><br><span class=\"line\">…</span><br><span class=\"line\">android:text=&quot;@&#123;map[key]&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-9-Data对象（数据绑定）\"><a href=\"#5-9-Data对象（数据绑定）\" class=\"headerlink\" title=\"5.9.Data对象（数据绑定）\"></a>5.9.Data对象（数据绑定）</h4><p>Data Binding 的强大之处主要在于双向数据绑定，当POJO对象发生变化时，通知改变Data对象，已达到更新UI的效果。有三种不同的数据变化通知机制：<code>Observable</code>对象、<code>ObservableFields</code>以及<code>observable  collections</code>。<br>这里以 Observable 为例，更改User类。使其继承<code>BaseObservable</code>,在<code>getter</code>方法前添加<code>Bindable</code>注解，在<code>setter</code>方法中调用<code>notifyPropertyChanged</code>进行更新数据。如果只更新某一字段，只需将该字段设置为<code>ObservableFields</code>类型的，如boolean,可用ObservableBoolean代替，但对其的使用需要通过get和set方法。具体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class User extends BaseObservable&#123;</span><br><span class=\"line\">    private String uname;</span><br><span class=\"line\">    private String usex;</span><br><span class=\"line\">    private String uage;</span><br><span class=\"line\">    private boolean isDisplay;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User(String uname, String usex, String uage, boolean isDisplay) &#123;</span><br><span class=\"line\">        this.uname = uname;</span><br><span class=\"line\">        this.usex = usex;</span><br><span class=\"line\">        this.uage = uage;</span><br><span class=\"line\">        this.isDisplay = isDisplay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Bindable</span><br><span class=\"line\">    public String getUname() &#123;</span><br><span class=\"line\">        return uname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUname(String uname) &#123;</span><br><span class=\"line\">        this.uname = uname;</span><br><span class=\"line\">        notifyPropertyChanged(BR.uname);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bindable</span><br><span class=\"line\">    public String getUsex() &#123;</span><br><span class=\"line\">        return usex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUsex(String usex) &#123;</span><br><span class=\"line\">        this.usex = usex;</span><br><span class=\"line\">        notifyPropertyChanged(BR.usex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bindable</span><br><span class=\"line\">    public String getUage() &#123;</span><br><span class=\"line\">        return uage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUage(String uage) &#123;</span><br><span class=\"line\">        this.uage = uage;</span><br><span class=\"line\">        notifyPropertyChanged(BR.uage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bindable</span><br><span class=\"line\">    public boolean isDisplay() &#123;</span><br><span class=\"line\">        return isDisplay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setDisplay(boolean display) &#123;</span><br><span class=\"line\">        isDisplay = display;</span><br><span class=\"line\">        notifyPropertyChanged(BR.display);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在编译期间，Bindable注解在BR(与R文件类似)类文件中生成一个Entry。BR类文件会在模块包内生成。如果用于Data类的基类不能改变，Observable接口通过方便的PropertyChangeRegistry来实现用于储存和有效地通知监听器。</p>\n<p>Data Binding的基本用法已经介绍完了，但它 的使用知识点较多，暂且写到这里,对于它在ListView/RecyclerView中的用法、事件处理等稍后再做介绍。<br><br></p>\n<p>文中部分资料来源于页底的参考资料。</p>\n<blockquote>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://github.com/LyndonChin/MasteringAndroidDataBinding\" target=\"_blank\" rel=\"external\">https://github.com/LyndonChin/MasteringAndroidDataBinding</a></li>\n<li><a href=\"http://www.jianshu.com/p/b1df61a4df77\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/b1df61a4df77</a></li>\n<li><a href=\"https://realm.io/cn/news/data-binding-android-boyar-mount/?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">https://realm.io/cn/news/data-binding-android-boyar-mount/?utm_source=tuicool&amp;utm_medium=referral</a></li>\n</ol>\n</blockquote>\n","excerpt":"<p><code>Data Binding</code> 是谷歌提供的 android 数据绑定库，为了而方便开发者实现 MVVM 的架构模式，使用它可以避免我们写大量的<code>findViewByID</code>，降低代码的耦合性。<br><a href=\"https://developer.android.com/topic/libraries/data-binding/index.html\">官方介绍</a>(需翻墙)</p>\n<h3 id=\"一、使用环境要求\"><a href=\"#一、使用环境要求\" class=\"headerlink\" title=\"一、使用环境要求\"></a>一、使用环境要求</h3><p>通过查看官方文档，改数据绑定库的使用环境要求如下：</p>\n<ul>\n<li>下载 SDK Manager 中的支持库： Support repository；","more":"</li>\n<li>android studio 版本在1.3之后；</li>\n<li>gradle 版本在1.5.0-alpha1之后；</li>\n<li>android sdk在android 2.1（API level7 +）以后。</li>\n</ul>\n<h3 id=\"二、具体的使用\"><a href=\"#二、具体的使用\" class=\"headerlink\" title=\"二、具体的使用\"></a>二、具体的使用</h3><h4 id=\"2-1、配置-data-binding\"><a href=\"#2-1、配置-data-binding\" class=\"headerlink\" title=\"2.1、配置 data binding.\"></a>2.1、配置 data binding.</h4><p>在 model 的gradle中的 <code>android</code> 节点下添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataBinding&#123;</span><br><span class=\"line\">    enabled = true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-2、-建立数据对象\"><a href=\"#2-2、-建立数据对象\" class=\"headerlink\" title=\"2.2、 建立数据对象\"></a>2.2、 建立数据对象</h4><p>添加一个POJO类，这里定义的是 User类，添加3个变量（uname，usex，uage）及相应的get,set方法，方便接下来与布局文件惊醒绑定。</p>\n<h4 id=\"2-3、-修改布局文件\"><a href=\"#2-3、-修改布局文件\" class=\"headerlink\" title=\"2.3、 修改布局文件\"></a>2.3、 修改布局文件</h4><p>使用databinding后，布局文件根节点不在是简单的LinearLayout，RelativeLayout等ViewGroup,而是 <code>Layout</code>，同时还增加了 <code>data</code> 元素，来为ui控件提供数据。基本局如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">    &lt;data&gt;</span><br><span class=\"line\">    &lt;/data&gt;</span><br><span class=\"line\">    &lt;!--原先的根节点--&gt;</span><br><span class=\"line\">    &lt;LinearLayout&gt;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    &lt;/LinearLayout&gt;</span><br><span class=\"line\">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>下面简单举例说明，显示用户信息，包括用户名，性别和年龄，布局文件名为<code>activity_main</code>，使用 databinding 的布局代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;layout</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\">    &lt;data&gt;</span><br><span class=\"line\">        &lt;variable</span><br><span class=\"line\">            name=&quot;user&quot;</span><br><span class=\"line\">            type=&quot;cn.imtianx.databindingdemo.bean.User&quot;&gt;</span><br><span class=\"line\">        &lt;/variable&gt;</span><br><span class=\"line\">    &lt;/data&gt;</span><br><span class=\"line\">    &lt;LinearLayout</span><br><span class=\"line\">        android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:text=&quot;@&#123;user.uname&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:text=&quot;@&#123;user.usex&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">            android:text=&quot;@&#123;user.uage&#125;&quot;/&gt;</span><br><span class=\"line\">    &lt;/LinearLayout&gt;</span><br><span class=\"line\">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>该布局主要是三个TextView，来显示信息，在<code>data</code>标签中添加了变量<code>variable</code>,其中<code>name</code>是变量名,<code>type</code>使我们定义的java类（注：需要写完整的包名），通过<code>@{}</code>来为 TextView设置显示的文本。<br>此外，这里的<code>data</code>也可以用<code>import</code>进行导入，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;data&gt;</span><br><span class=\"line\">    &lt;import type=&quot;cn.imtianx.databindingdemo.bean.User&quot;/&gt;</span><br><span class=\"line\">    &lt;variable</span><br><span class=\"line\">        name=&quot;user&quot;</span><br><span class=\"line\">        type=&quot;User&quot;/&gt;</span><br><span class=\"line\">&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果要使用<code>String</code>等<code>java.lang.*</code>下的类，则可以直接使用。</p>\n<h4 id=\"2-4、绑定变量数据\"><a href=\"#2-4、绑定变量数据\" class=\"headerlink\" title=\"2.4、绑定变量数据\"></a>2.4、绑定变量数据</h4><p>编译项目即可根据布局文件名生成相关的Binding类，生成规则是按布局文件名，去掉’_‘，按驼峰法则，并在末尾添加<code>Binding</code>。如，这里的布局文件名为<code>activity_main</code>,则生成的数据绑定类为<code>ActivityMainBinding</code>，它存放在<code>包名.databinding</code>下，然后再 <strong>activity</strong>  的<strong>onCreate</strong>方法中设置变量，代码如如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    super.onCreate(savedInstanceState);</span><br><span class=\"line\">    ActivityMainBinding mainBinding = DataBindingUtil</span><br><span class=\"line\">            .setContentView(this, R.layout.activity_main);</span><br><span class=\"line\">    User user = new User(&quot;imtianx&quot;, &quot;男&quot;, &quot;20&quot;);</span><br><span class=\"line\">    mainBinding.setUser(user);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong> 这里的 ActivityMainBinding 类会根据布局文件中的 variable 生成相应的 <code>set</code>方法。<br>至此，一个简单的数据绑定就实现了，运行程序，会依次显示user中设置的三个字段的值。</p>\n<h3 id=\"三、设置见监听事件\"><a href=\"#三、设置见监听事件\" class=\"headerlink\" title=\"三、设置见监听事件\"></a>三、设置见监听事件</h3><p>这里可以通过两种方式进行绑定事件：<strong>方法引用</strong>和<strong>监听器引用</strong>。如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Presenter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onTextChanged(CharSequence s, int start, int before, int count) &#123;</span><br><span class=\"line\">        mUserBean.setName(s.toString());</span><br><span class=\"line\">        mBinding.setUser(mUserBean);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onClick(View view) &#123;</span><br><span class=\"line\">        Toast.makeText(MainActivity.this, &quot;点击了名字&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void onClickListenerBinding(UserBean bean) &#123;</span><br><span class=\"line\">        Toast.makeText(MainActivity.this, bean.getSex(), Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用时首先在xml的data标签下添加变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name=&quot;presenter&quot;</span><br><span class=\"line\">    type=&quot;cn.imtianx.databindingdemo.MainActivity.Presenter&quot;&gt;</span><br><span class=\"line\">&lt;/variable&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-1-方法引用\"><a href=\"#3-1-方法引用\" class=\"headerlink\" title=\"3.1 方法引用\"></a>3.1 方法引用</h4><p>必须使用android 已有的监听的方法名及其参数，如上面的onTextChanged，onClick方法，具体的调用如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:onClick=&quot;@&#123;presenter.onClick&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-2-监听器引用\"><a href=\"#3-2-监听器引用\" class=\"headerlink\" title=\"3.2 监听器引用\"></a>3.2 监听器引用</h4><p>可以方便的丛xml中向java代码中传递数据，可使用lambda表达式,如onClickListenerBinding，具体调用如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:onClick=&quot;@&#123;()-&gt;presenter.onClickListenerBinding(user)&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>采用了lambda表达式的格式。</p>\n<h3 id=\"四、在Fragment中的用法\"><a href=\"#四、在Fragment中的用法\" class=\"headerlink\" title=\"四、在Fragment中的用法\"></a>四、在Fragment中的用法</h3><p>布局文件与上一个一样，在 Fragment 的 onCreateView 中设置相关的属性，具体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private ActivityMainBinding mMainBinding;</span><br><span class=\"line\">    private User user;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Nullable</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        View view = inflater.inflate(R.layout.activity_main, container, false);</span><br><span class=\"line\">        // 方式1,直接用默认生成的Binding类绑定</span><br><span class=\"line\">        mMainBinding = ActivityMainBinding.bind(view);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 方式2，向上转成ViewDataBinding类型</span><br><span class=\"line\">//        ViewDataBinding viewDataBinding = ActivityMainBinding.bind(view);</span><br><span class=\"line\">//        mMainBinding = (ActivityMainBinding) viewDataBinding;</span><br><span class=\"line\"></span><br><span class=\"line\">        //方式3，使用生成的Binding的inflater，</span><br><span class=\"line\">//        mMainBinding = ActivityMainBinding.inflate(inflater);</span><br><span class=\"line\"></span><br><span class=\"line\">        //方式4，使用生成的Binding的inflater,类似Inflater api</span><br><span class=\"line\">//        mMainBinding = ActivityMainBinding.inflate(inflater, container, false);</span><br><span class=\"line\"></span><br><span class=\"line\">        //方式5，某种情况无法生存默认Binding的情况下，并且把对应的layout传入</span><br><span class=\"line\">//        ViewDataBinding viewDataBinding = DataBindingUtil.inflate(inflater, R.layout.activity_main, container, false);</span><br><span class=\"line\">//        mMainBinding = (ActivityMainBinding) viewDataBinding;</span><br><span class=\"line\"></span><br><span class=\"line\">        //方式6，某种情况无法生存默认Binding的情况下</span><br><span class=\"line\">//        ViewDataBinding viewDataBinding = DataBindingUtil.bind(view);</span><br><span class=\"line\"></span><br><span class=\"line\">        user = new User(&quot;imtianx&quot;, &quot;男&quot;, &quot;20&quot;);</span><br><span class=\"line\">        mMainBinding.setUser(user);</span><br><span class=\"line\">        return view;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>总之，它都需要初始化Binding类，初始化model类和数据绑定。</p>\n<h3 id=\"五-、高级用法\"><a href=\"#五-、高级用法\" class=\"headerlink\" title=\"五 、高级用法\"></a>五 、高级用法</h3><h4 id=\"5-1-使用类方法\"><a href=\"#5-1-使用类方法\" class=\"headerlink\" title=\"5.1. 使用类方法\"></a>5.1. 使用类方法</h4><p>首先在布局文件的<code>data</code> 使用<code>import</code>导入方法所在的类的全路径，然后再选要的地方调用，具体使用和java一样。</p>\n<h4 id=\"5-2-类型别名\"><a href=\"#5-2-类型别名\" class=\"headerlink\" title=\"5.2. 类型别名\"></a>5.2. 类型别名</h4><p>在开发中可能会遇到两个用名的类，如果在<code>data</code>下同时导入他们，改如何解决？这里不用担心，可以在<code>import</code>节点下添加<code>alias</code>属性,来区别。如下示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;data&gt;</span><br><span class=\"line\">    &lt;import type=&quot;cn.imtianx.databindingdemo.bean.User&quot; alias=&quot;User1&quot;/&gt;</span><br><span class=\"line\">    &lt;import type=&quot;cn.imtianx.databindingdemo.model.User&quot; /&gt;</span><br><span class=\"line\">    &lt;variable</span><br><span class=\"line\">        name=&quot;user&quot;</span><br><span class=\"line\">        type=&quot;User1&quot;/&gt;</span><br><span class=\"line\">    &lt;variable</span><br><span class=\"line\">        name=&quot;user2&quot;</span><br><span class=\"line\">        type=&quot;User&quot;/&gt;</span><br><span class=\"line\">&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-3-Null-Coalescing-运算符\"><a href=\"#5-3-Null-Coalescing-运算符\" class=\"headerlink\" title=\"5.3. Null Coalescing 运算符\"></a>5.3. Null Coalescing 运算符</h4><p>这个和java中的三木表达式一样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text=&quot;@&#123;user.uage ??user.uage&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>它等价于：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text=&quot;@&#123;user.uage!=null?user.uage:0&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-4-属性值\"><a href=\"#5-4-属性值\" class=\"headerlink\" title=\"5.4. 属性值\"></a>5.4. 属性值</h4><p>使用<code>@{}</code>在xml中使用java 中定义的一些属性值,如下给visibility 设置值，注意需要到如View类，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:visibility=&quot;@&#123;user.display? View.VISIBLE:View.GONE&#125;&quot;</span><br><span class=\"line\">    android:text=&quot;@&#123;user.uage&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-5-使用资源数据\"><a href=\"#5-5-使用资源数据\" class=\"headerlink\" title=\"5.5. 使用资源数据\"></a>5.5. 使用资源数据</h4><p>设置<code>padding</code>的值，需要的dime文件中添加largePadding和smallPadding的item。对于引用 <code>String、drawable</code>等资源类似。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">   android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">   android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">   android:padding=&quot;@&#123;user.display?(int)@dimen/largePadding : (int)@dimen/smallPadding&#125;&quot;</span><br><span class=\"line\">   android:text=&quot;@&#123;user.uage&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-6-使用include\"><a href=\"#5-6-使用include\" class=\"headerlink\" title=\"5.6. 使用include\"></a>5.6. 使用include</h4><p>使用命名空间来传递variable，将当前 variable 的值传递给 include 进来 的布局中。<br>为 layout 添加命名空间：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>include</code>中使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;include</span><br><span class=\"line\">    layout=&quot;@layout/layout_user&quot;</span><br><span class=\"line\">    bind:user=&quot;@&#123;user&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>注意在 <code>layout_user.xml</code>中也要在 variable 中 定义添加 user 变量。</p>\n<h4 id=\"5-7-使用表达式\"><a href=\"#5-7-使用表达式\" class=\"headerlink\" title=\"5.7. 使用表达式\"></a>5.7. 使用表达式</h4><p>java 中的表达式，在这里也是支持的，</p>\n<ul>\n<li>数学 + - / * %</li>\n<li>字符串连接 +</li>\n<li>逻辑 &amp;&amp; ||</li>\n<li>二进制 &amp; | ^</li>\n<li>一元运算 + - ! ~</li>\n<li>移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li>\n<li>比较 == &gt; &lt; &gt;= &lt;=</li>\n<li>instanceof<br>….<br>Data Binding代码生成时自动检查是否为null来避免出现<code>null pointer exceptions</code>错误,<code>String</code> 类型默认值是<code>null</code> ,<code>int</code>类型默认值是 <code>0</code>，<code>boolean</code> 类型默认值是 <code>false</code>。</li>\n</ul>\n<h4 id=\"5-8-集合\"><a href=\"#5-8-集合\" class=\"headerlink\" title=\"5.8. 集合\"></a>5.8. 集合</h4><p>常用的集合：arrays、lists、sparse，lists以及maps，为了简便都可以使用<code>[]</code>来访问。注意,在使用泛型时<code>&lt;</code>需要转义，用<code>&amp;lt;</code>代替，否则会报错。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;data&gt;</span><br><span class=\"line\">  &lt;import type=&quot;android.util.SparseArray&quot;/&gt;</span><br><span class=\"line\">  &lt;import type=&quot;java.util.Map&quot;/&gt;</span><br><span class=\"line\">  &lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class=\"line\">  &lt;variable name=&quot;list&quot; type=&quot;List&amp;lt;String&gt;&quot;/&gt;</span><br><span class=\"line\">  &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&amp;lt;String&gt;&quot;/&gt;</span><br><span class=\"line\">  &lt;variable name=&quot;map&quot; type=&quot;Map&amp;lt;String, String&gt;&quot;/&gt;</span><br><span class=\"line\">  &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;</span><br><span class=\"line\">  &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;</span><br><span class=\"line\">&lt;/data&gt;</span><br><span class=\"line\">…</span><br><span class=\"line\">android:text=&quot;@&#123;list[index]&#125;&quot;</span><br><span class=\"line\">…</span><br><span class=\"line\">android:text=&quot;@&#123;sparse[index]&#125;&quot;</span><br><span class=\"line\">…</span><br><span class=\"line\">android:text=&quot;@&#123;map[key]&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-9-Data对象（数据绑定）\"><a href=\"#5-9-Data对象（数据绑定）\" class=\"headerlink\" title=\"5.9.Data对象（数据绑定）\"></a>5.9.Data对象（数据绑定）</h4><p>Data Binding 的强大之处主要在于双向数据绑定，当POJO对象发生变化时，通知改变Data对象，已达到更新UI的效果。有三种不同的数据变化通知机制：<code>Observable</code>对象、<code>ObservableFields</code>以及<code>observable  collections</code>。<br>这里以 Observable 为例，更改User类。使其继承<code>BaseObservable</code>,在<code>getter</code>方法前添加<code>Bindable</code>注解，在<code>setter</code>方法中调用<code>notifyPropertyChanged</code>进行更新数据。如果只更新某一字段，只需将该字段设置为<code>ObservableFields</code>类型的，如boolean,可用ObservableBoolean代替，但对其的使用需要通过get和set方法。具体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class User extends BaseObservable&#123;</span><br><span class=\"line\">    private String uname;</span><br><span class=\"line\">    private String usex;</span><br><span class=\"line\">    private String uage;</span><br><span class=\"line\">    private boolean isDisplay;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User(String uname, String usex, String uage, boolean isDisplay) &#123;</span><br><span class=\"line\">        this.uname = uname;</span><br><span class=\"line\">        this.usex = usex;</span><br><span class=\"line\">        this.uage = uage;</span><br><span class=\"line\">        this.isDisplay = isDisplay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Bindable</span><br><span class=\"line\">    public String getUname() &#123;</span><br><span class=\"line\">        return uname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUname(String uname) &#123;</span><br><span class=\"line\">        this.uname = uname;</span><br><span class=\"line\">        notifyPropertyChanged(BR.uname);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bindable</span><br><span class=\"line\">    public String getUsex() &#123;</span><br><span class=\"line\">        return usex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUsex(String usex) &#123;</span><br><span class=\"line\">        this.usex = usex;</span><br><span class=\"line\">        notifyPropertyChanged(BR.usex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bindable</span><br><span class=\"line\">    public String getUage() &#123;</span><br><span class=\"line\">        return uage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUage(String uage) &#123;</span><br><span class=\"line\">        this.uage = uage;</span><br><span class=\"line\">        notifyPropertyChanged(BR.uage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bindable</span><br><span class=\"line\">    public boolean isDisplay() &#123;</span><br><span class=\"line\">        return isDisplay;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setDisplay(boolean display) &#123;</span><br><span class=\"line\">        isDisplay = display;</span><br><span class=\"line\">        notifyPropertyChanged(BR.display);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>在编译期间，Bindable注解在BR(与R文件类似)类文件中生成一个Entry。BR类文件会在模块包内生成。如果用于Data类的基类不能改变，Observable接口通过方便的PropertyChangeRegistry来实现用于储存和有效地通知监听器。</p>\n<p>Data Binding的基本用法已经介绍完了，但它 的使用知识点较多，暂且写到这里,对于它在ListView/RecyclerView中的用法、事件处理等稍后再做介绍。<br><br></p>\n<p>文中部分资料来源于页底的参考资料。</p>\n<blockquote>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://github.com/LyndonChin/MasteringAndroidDataBinding\">https://github.com/LyndonChin/MasteringAndroidDataBinding</a></li>\n<li><a href=\"http://www.jianshu.com/p/b1df61a4df77\">http://www.jianshu.com/p/b1df61a4df77</a></li>\n<li><a href=\"https://realm.io/cn/news/data-binding-android-boyar-mount/?utm_source=tuicool&amp;utm_medium=referral\">https://realm.io/cn/news/data-binding-android-boyar-mount/?utm_source=tuicool&amp;utm_medium=referral</a></li>\n</ol>\n</blockquote>"},{"title":"Animation 动画详解","date":"2016-04-25T03:00:38.000Z","_content":"在android 开发中，适当的添加动画可以使界面的交互变得更加的友好，特别是在提示，引导类的场景中，合理的使用动画可以带来更好的用户体验。这里，介绍**Animation** 框架的用法。<!--more-->\n\n## 1. 概述\n在 Animation动画框架中提供了四中动画方式，分别为：\n\n - 透明    [AlphaAnimation](https://developer.android.com/reference/android/view/animation/AlphaAnimation.html)\n - 旋转    [RotateAnimation](https://developer.android.com/reference/android/view/animation/RotateAnimation.html)\n - 缩放    [ScaleAnimation](https://developer.android.com/reference/android/view/animation/ScaleAnimation.html)\n - 平移   [TranslateAnimation](https://developer.android.com/reference/android/view/animation/TranslateAnimation.html)\n此外，还提供了[AnimationSet](https://developer.android.com/reference/android/view/animation/AnimationSet.html)动画集合，混合使用多种动画。\n它们对应的 **xml**  的标签分别为：**alpha,rotate,scale,translate和set。**\n**Animation**是他们的基类，有如下的标签和对应的函数：\n**android:duration setDuration(long)** 动画持续时间，以毫秒为单位\n**android:fillAfter setFillAfter(boolean)** 如果设置为 true，控件动画结束时，将保持动画最后时的状态\n**android:fillBefore setFillBefore(boolean)** 如果设置为 true,控件动画结束时，还原到开始动画前的状态\n**android:fillEnabled setFillEnabled(boolean)** 与 android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态\n**android:repeatCount setRepeatCount(int)** 重复次数\n**android:repeatMode setRepeatMode(int)** 重复类型，有 reverse 和 restart 两个值，取值为 RESTART 或 REVERSE，必须与 repeatCount 一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。\n**android:interpolator setInterpolator(Interpolator)** 设定插值器，其实就是指定的动作效果，比如弹跳效果等\n\n## 2. Interpolator 插值器\n对于动画，它的速率变化有快又慢，谷歌给出了**插值器**，来方便我们控制动画的变化。在不同的插值器的作用下，其变化也不一样。官方给的插值器有（谷歌官方）：\n![](/img/article_img/Interpolator.jpg)\n部分资源id为(改图来自网络)：\n![](/img/article_img/Interpolator-resource-id.png)\n\n## 3. xm实现动画\n以**scale**标签为例，其他类似。scale有以下几个属性：\n\n- **android:fromXScale** 起始的 X方向上相对自身的缩放比例，浮点值，比如 1.0 代表自身无变化，0.5 代表起始时缩小一倍，2.0 代表放大一倍；\n- **android:toXScale** 结尾的 X 方向上相对自身的缩放比例，浮点值；\n- **android:fromYScale** 起始的 Y方向上相对自身的缩放比例，浮点值，\n- **android:toYScale** 结尾的 Y 方向上相对自身的缩放比例，浮点值；\n- **android:pivotX** 缩放起点 X 轴坐标，可以是数值、百分数、百分数 p。 三种样式，比如 50、50%、50%p，当为数值时，表示在当前 View的左上角，即原点处加上 50px，做为起始缩放点；如果是 50%，表示在当前控件的左上角加上自己宽度的 50%做为起始点；如果是 50%p，那么就是表示在当前的左上角加上父控件宽度的 50%做为起始点 x 轴坐标。\n- **android:pivotY** 缩放起点 Y 轴坐标，取值及意义跟android:pivotX 一样。\n- **android:interpolator** 就是添加的插值器，通过不同的Resource ID引用不同的插值器类。\n- **android：fillAfter** 保持动画结束的状态，同样的可以保存初始化状态（**fileBefore**）\n- **android:repeatMode** 设定回放类型，重新开始/倒退（restart /reverse）\n在res下新建anim 文件夹，新建scaleanim.xml文件，如下代码（宽高从0放大到1.5倍，开开始和结束速度慢，中间快，停留在结束状态，重复一次）：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<scale\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"\n    android:fromXScale=\"0.0\"\n    android:fromYScale=\"0.0\"\n    android:pivotX=\"50\"\n    android:pivotY=\"50\"\n    android:toXScale=\"1.5\"\n    android:toYScale=\"1.5\"\n    android：fillAfter=\"true\"\n    android:repeatCount=\"1\"  \n    android:repeatMode=\"restart\"  >\n</scale>\n```\n上面定义好了动画，下面就是具体的使用，这里以给textView设置上面的scale动画为例，代码如下：\n```\nAnimation mAnimation = AnimationUtils.loadAnimation(this,R.anim.scaleanim);\n    textView.startAnimation(mAnimation);\n```\n注：对于其他的标签及其属性可以参见[官方文档](https://developer.android.com/reference/android/view/animation/Animation.html),这些标签可以放在一个**set标签**中，来定义动画集合。\n## 4. java 代码实现动画\n这里以**AlphaAnimation**为例，若xml代码为：\n``` \n<?xml version=\"1.0\" encoding=\"utf-8\"?>  \n<alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"  \n    android:interpolator=\"@android:anim/bounce_interpolator\"\n    android:fromAlpha=\"1.0\"  \n    android:toAlpha=\"0.1\"  \n    android:duration=\"3000\"  \n    android:fillBefore=\"true\">  \n</alpha>\n```\n与其有相同效果的java代码为：\n```\nalphaAnim = new AlphaAnimation(1.0f,0.1f);  \nalphaAnim.setDuration(3000);  \nalphaAnim.setFillBefore(true); \nalphaAnim.setInterpolator(new BounceInterpolator());//设置插值器\n```\n 最后，就是给相应的控件设置动画，如下：\n```\ntextView.startAnimation(alphaAnim);\n```\n  \n## 5. 动画回调监听事件\n对于上面的两中方法设置动画，可以添加相应的监听回调，获得动画的开始，结束和重复事件，并对不同的事件作出相应的处理。\n```\nmAnimation.setAnimationListener(new Animation.AnimationListener() {\n        @Override\n        public void onAnimationStart(Animation animation) {\n            //动画开始前的回调处理\n        }\n        @Override\n        public void onAnimationEnd(Animation animation){\n            //动画结束时的回调处理\n        }\n        @Override\n        public void onAnimationRepeat(Animation animation) {\n            //动画重复的回调处理\n        }\n    });\n```\n更多：[属性动画（ValueAnimator 和 ObjectAnimation）](http://imtianx.cn/2016/04/25/Property-animatorValueAnimator_ObjectAnimation)\n\n","source":"_posts/view-Animation.md","raw":"---\ntitle: Animation 动画详解\ndate: 2016-04-25 11:00:38\ncategories: [android,学习笔记]\ntags: [android,Animation,动画]\n---\n在android 开发中，适当的添加动画可以使界面的交互变得更加的友好，特别是在提示，引导类的场景中，合理的使用动画可以带来更好的用户体验。这里，介绍**Animation** 框架的用法。<!--more-->\n\n## 1. 概述\n在 Animation动画框架中提供了四中动画方式，分别为：\n\n - 透明    [AlphaAnimation](https://developer.android.com/reference/android/view/animation/AlphaAnimation.html)\n - 旋转    [RotateAnimation](https://developer.android.com/reference/android/view/animation/RotateAnimation.html)\n - 缩放    [ScaleAnimation](https://developer.android.com/reference/android/view/animation/ScaleAnimation.html)\n - 平移   [TranslateAnimation](https://developer.android.com/reference/android/view/animation/TranslateAnimation.html)\n此外，还提供了[AnimationSet](https://developer.android.com/reference/android/view/animation/AnimationSet.html)动画集合，混合使用多种动画。\n它们对应的 **xml**  的标签分别为：**alpha,rotate,scale,translate和set。**\n**Animation**是他们的基类，有如下的标签和对应的函数：\n**android:duration setDuration(long)** 动画持续时间，以毫秒为单位\n**android:fillAfter setFillAfter(boolean)** 如果设置为 true，控件动画结束时，将保持动画最后时的状态\n**android:fillBefore setFillBefore(boolean)** 如果设置为 true,控件动画结束时，还原到开始动画前的状态\n**android:fillEnabled setFillEnabled(boolean)** 与 android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态\n**android:repeatCount setRepeatCount(int)** 重复次数\n**android:repeatMode setRepeatMode(int)** 重复类型，有 reverse 和 restart 两个值，取值为 RESTART 或 REVERSE，必须与 repeatCount 一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。\n**android:interpolator setInterpolator(Interpolator)** 设定插值器，其实就是指定的动作效果，比如弹跳效果等\n\n## 2. Interpolator 插值器\n对于动画，它的速率变化有快又慢，谷歌给出了**插值器**，来方便我们控制动画的变化。在不同的插值器的作用下，其变化也不一样。官方给的插值器有（谷歌官方）：\n![](/img/article_img/Interpolator.jpg)\n部分资源id为(改图来自网络)：\n![](/img/article_img/Interpolator-resource-id.png)\n\n## 3. xm实现动画\n以**scale**标签为例，其他类似。scale有以下几个属性：\n\n- **android:fromXScale** 起始的 X方向上相对自身的缩放比例，浮点值，比如 1.0 代表自身无变化，0.5 代表起始时缩小一倍，2.0 代表放大一倍；\n- **android:toXScale** 结尾的 X 方向上相对自身的缩放比例，浮点值；\n- **android:fromYScale** 起始的 Y方向上相对自身的缩放比例，浮点值，\n- **android:toYScale** 结尾的 Y 方向上相对自身的缩放比例，浮点值；\n- **android:pivotX** 缩放起点 X 轴坐标，可以是数值、百分数、百分数 p。 三种样式，比如 50、50%、50%p，当为数值时，表示在当前 View的左上角，即原点处加上 50px，做为起始缩放点；如果是 50%，表示在当前控件的左上角加上自己宽度的 50%做为起始点；如果是 50%p，那么就是表示在当前的左上角加上父控件宽度的 50%做为起始点 x 轴坐标。\n- **android:pivotY** 缩放起点 Y 轴坐标，取值及意义跟android:pivotX 一样。\n- **android:interpolator** 就是添加的插值器，通过不同的Resource ID引用不同的插值器类。\n- **android：fillAfter** 保持动画结束的状态，同样的可以保存初始化状态（**fileBefore**）\n- **android:repeatMode** 设定回放类型，重新开始/倒退（restart /reverse）\n在res下新建anim 文件夹，新建scaleanim.xml文件，如下代码（宽高从0放大到1.5倍，开开始和结束速度慢，中间快，停留在结束状态，重复一次）：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<scale\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"\n    android:fromXScale=\"0.0\"\n    android:fromYScale=\"0.0\"\n    android:pivotX=\"50\"\n    android:pivotY=\"50\"\n    android:toXScale=\"1.5\"\n    android:toYScale=\"1.5\"\n    android：fillAfter=\"true\"\n    android:repeatCount=\"1\"  \n    android:repeatMode=\"restart\"  >\n</scale>\n```\n上面定义好了动画，下面就是具体的使用，这里以给textView设置上面的scale动画为例，代码如下：\n```\nAnimation mAnimation = AnimationUtils.loadAnimation(this,R.anim.scaleanim);\n    textView.startAnimation(mAnimation);\n```\n注：对于其他的标签及其属性可以参见[官方文档](https://developer.android.com/reference/android/view/animation/Animation.html),这些标签可以放在一个**set标签**中，来定义动画集合。\n## 4. java 代码实现动画\n这里以**AlphaAnimation**为例，若xml代码为：\n``` \n<?xml version=\"1.0\" encoding=\"utf-8\"?>  \n<alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"  \n    android:interpolator=\"@android:anim/bounce_interpolator\"\n    android:fromAlpha=\"1.0\"  \n    android:toAlpha=\"0.1\"  \n    android:duration=\"3000\"  \n    android:fillBefore=\"true\">  \n</alpha>\n```\n与其有相同效果的java代码为：\n```\nalphaAnim = new AlphaAnimation(1.0f,0.1f);  \nalphaAnim.setDuration(3000);  \nalphaAnim.setFillBefore(true); \nalphaAnim.setInterpolator(new BounceInterpolator());//设置插值器\n```\n 最后，就是给相应的控件设置动画，如下：\n```\ntextView.startAnimation(alphaAnim);\n```\n  \n## 5. 动画回调监听事件\n对于上面的两中方法设置动画，可以添加相应的监听回调，获得动画的开始，结束和重复事件，并对不同的事件作出相应的处理。\n```\nmAnimation.setAnimationListener(new Animation.AnimationListener() {\n        @Override\n        public void onAnimationStart(Animation animation) {\n            //动画开始前的回调处理\n        }\n        @Override\n        public void onAnimationEnd(Animation animation){\n            //动画结束时的回调处理\n        }\n        @Override\n        public void onAnimationRepeat(Animation animation) {\n            //动画重复的回调处理\n        }\n    });\n```\n更多：[属性动画（ValueAnimator 和 ObjectAnimation）](http://imtianx.cn/2016/04/25/Property-animatorValueAnimator_ObjectAnimation)\n\n","slug":"view-Animation","published":1,"updated":"2016-12-25T02:11:03.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuck20044g0g5dkfz52r9","content":"<p>在android 开发中，适当的添加动画可以使界面的交互变得更加的友好，特别是在提示，引导类的场景中，合理的使用动画可以带来更好的用户体验。这里，介绍<strong>Animation</strong> 框架的用法。<a id=\"more\"></a></p>\n<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><p>在 Animation动画框架中提供了四中动画方式，分别为：</p>\n<ul>\n<li>透明    <a href=\"https://developer.android.com/reference/android/view/animation/AlphaAnimation.html\" target=\"_blank\" rel=\"external\">AlphaAnimation</a></li>\n<li>旋转    <a href=\"https://developer.android.com/reference/android/view/animation/RotateAnimation.html\" target=\"_blank\" rel=\"external\">RotateAnimation</a></li>\n<li>缩放    <a href=\"https://developer.android.com/reference/android/view/animation/ScaleAnimation.html\" target=\"_blank\" rel=\"external\">ScaleAnimation</a></li>\n<li>平移   <a href=\"https://developer.android.com/reference/android/view/animation/TranslateAnimation.html\" target=\"_blank\" rel=\"external\">TranslateAnimation</a><br>此外，还提供了<a href=\"https://developer.android.com/reference/android/view/animation/AnimationSet.html\" target=\"_blank\" rel=\"external\">AnimationSet</a>动画集合，混合使用多种动画。<br>它们对应的 <strong>xml</strong>  的标签分别为：<strong>alpha,rotate,scale,translate和set。</strong><br><strong>Animation</strong>是他们的基类，有如下的标签和对应的函数：<br><strong>android:duration setDuration(long)</strong> 动画持续时间，以毫秒为单位<br><strong>android:fillAfter setFillAfter(boolean)</strong> 如果设置为 true，控件动画结束时，将保持动画最后时的状态<br><strong>android:fillBefore setFillBefore(boolean)</strong> 如果设置为 true,控件动画结束时，还原到开始动画前的状态<br><strong>android:fillEnabled setFillEnabled(boolean)</strong> 与 android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态<br><strong>android:repeatCount setRepeatCount(int)</strong> 重复次数<br><strong>android:repeatMode setRepeatMode(int)</strong> 重复类型，有 reverse 和 restart 两个值，取值为 RESTART 或 REVERSE，必须与 repeatCount 一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。<br><strong>android:interpolator setInterpolator(Interpolator)</strong> 设定插值器，其实就是指定的动作效果，比如弹跳效果等</li>\n</ul>\n<h2 id=\"2-Interpolator-插值器\"><a href=\"#2-Interpolator-插值器\" class=\"headerlink\" title=\"2. Interpolator 插值器\"></a>2. Interpolator 插值器</h2><p>对于动画，它的速率变化有快又慢，谷歌给出了<strong>插值器</strong>，来方便我们控制动画的变化。在不同的插值器的作用下，其变化也不一样。官方给的插值器有（谷歌官方）：<br><img src=\"/img/article_img/Interpolator.jpg\" alt=\"\"><br>部分资源id为(改图来自网络)：<br><img src=\"/img/article_img/Interpolator-resource-id.png\" alt=\"\"></p>\n<h2 id=\"3-xm实现动画\"><a href=\"#3-xm实现动画\" class=\"headerlink\" title=\"3. xm实现动画\"></a>3. xm实现动画</h2><p>以<strong>scale</strong>标签为例，其他类似。scale有以下几个属性：</p>\n<ul>\n<li><strong>android:fromXScale</strong> 起始的 X方向上相对自身的缩放比例，浮点值，比如 1.0 代表自身无变化，0.5 代表起始时缩小一倍，2.0 代表放大一倍；</li>\n<li><strong>android:toXScale</strong> 结尾的 X 方向上相对自身的缩放比例，浮点值；</li>\n<li><strong>android:fromYScale</strong> 起始的 Y方向上相对自身的缩放比例，浮点值，</li>\n<li><strong>android:toYScale</strong> 结尾的 Y 方向上相对自身的缩放比例，浮点值；</li>\n<li><strong>android:pivotX</strong> 缩放起点 X 轴坐标，可以是数值、百分数、百分数 p。 三种样式，比如 50、50%、50%p，当为数值时，表示在当前 View的左上角，即原点处加上 50px，做为起始缩放点；如果是 50%，表示在当前控件的左上角加上自己宽度的 50%做为起始点；如果是 50%p，那么就是表示在当前的左上角加上父控件宽度的 50%做为起始点 x 轴坐标。</li>\n<li><strong>android:pivotY</strong> 缩放起点 Y 轴坐标，取值及意义跟android:pivotX 一样。</li>\n<li><strong>android:interpolator</strong> 就是添加的插值器，通过不同的Resource ID引用不同的插值器类。</li>\n<li><strong>android：fillAfter</strong> 保持动画结束的状态，同样的可以保存初始化状态（<strong>fileBefore</strong>）</li>\n<li><strong>android:repeatMode</strong> 设定回放类型，重新开始/倒退（restart /reverse）<br>在res下新建anim 文件夹，新建scaleanim.xml文件，如下代码（宽高从0放大到1.5倍，开开始和结束速度慢，中间快，停留在结束状态，重复一次）：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;scale</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span><br><span class=\"line\">    android:fromXScale=&quot;0.0&quot;</span><br><span class=\"line\">    android:fromYScale=&quot;0.0&quot;</span><br><span class=\"line\">    android:pivotX=&quot;50&quot;</span><br><span class=\"line\">    android:pivotY=&quot;50&quot;</span><br><span class=\"line\">    android:toXScale=&quot;1.5&quot;</span><br><span class=\"line\">    android:toYScale=&quot;1.5&quot;</span><br><span class=\"line\">    android：fillAfter=&quot;true&quot;</span><br><span class=\"line\">    android:repeatCount=&quot;1&quot;  </span><br><span class=\"line\">    android:repeatMode=&quot;restart&quot;  &gt;</span><br><span class=\"line\">&lt;/scale&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面定义好了动画，下面就是具体的使用，这里以给textView设置上面的scale动画为例，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation mAnimation = AnimationUtils.loadAnimation(this,R.anim.scaleanim);</span><br><span class=\"line\">    textView.startAnimation(mAnimation);</span><br></pre></td></tr></table></figure></p>\n<p>注：对于其他的标签及其属性可以参见<a href=\"https://developer.android.com/reference/android/view/animation/Animation.html\" target=\"_blank\" rel=\"external\">官方文档</a>,这些标签可以放在一个<strong>set标签</strong>中，来定义动画集合。</p>\n<h2 id=\"4-java-代码实现动画\"><a href=\"#4-java-代码实现动画\" class=\"headerlink\" title=\"4. java 代码实现动画\"></a>4. java 代码实现动画</h2><p>这里以<strong>AlphaAnimation</strong>为例，若xml代码为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </span><br><span class=\"line\">&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </span><br><span class=\"line\">    android:interpolator=&quot;@android:anim/bounce_interpolator&quot;</span><br><span class=\"line\">    android:fromAlpha=&quot;1.0&quot;  </span><br><span class=\"line\">    android:toAlpha=&quot;0.1&quot;  </span><br><span class=\"line\">    android:duration=&quot;3000&quot;  </span><br><span class=\"line\">    android:fillBefore=&quot;true&quot;&gt;  </span><br><span class=\"line\">&lt;/alpha&gt;</span><br></pre></td></tr></table></figure></p>\n<p>与其有相同效果的java代码为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alphaAnim = new AlphaAnimation(1.0f,0.1f);  </span><br><span class=\"line\">alphaAnim.setDuration(3000);  </span><br><span class=\"line\">alphaAnim.setFillBefore(true); </span><br><span class=\"line\">alphaAnim.setInterpolator(new BounceInterpolator());//设置插值器</span><br></pre></td></tr></table></figure></p>\n<p> 最后，就是给相应的控件设置动画，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">textView.startAnimation(alphaAnim);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-动画回调监听事件\"><a href=\"#5-动画回调监听事件\" class=\"headerlink\" title=\"5. 动画回调监听事件\"></a>5. 动画回调监听事件</h2><p>对于上面的两中方法设置动画，可以添加相应的监听回调，获得动画的开始，结束和重复事件，并对不同的事件作出相应的处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mAnimation.setAnimationListener(new Animation.AnimationListener() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void onAnimationStart(Animation animation) &#123;</span><br><span class=\"line\">            //动画开始前的回调处理</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void onAnimationEnd(Animation animation)&#123;</span><br><span class=\"line\">            //动画结束时的回调处理</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void onAnimationRepeat(Animation animation) &#123;</span><br><span class=\"line\">            //动画重复的回调处理</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>更多：<a href=\"http://imtianx.cn/2016/04/25/Property-animatorValueAnimator_ObjectAnimation\">属性动画（ValueAnimator 和 ObjectAnimation）</a></p>\n","excerpt":"<p>在android 开发中，适当的添加动画可以使界面的交互变得更加的友好，特别是在提示，引导类的场景中，合理的使用动画可以带来更好的用户体验。这里，介绍<strong>Animation</strong> 框架的用法。","more":"</p>\n<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><p>在 Animation动画框架中提供了四中动画方式，分别为：</p>\n<ul>\n<li>透明    <a href=\"https://developer.android.com/reference/android/view/animation/AlphaAnimation.html\">AlphaAnimation</a></li>\n<li>旋转    <a href=\"https://developer.android.com/reference/android/view/animation/RotateAnimation.html\">RotateAnimation</a></li>\n<li>缩放    <a href=\"https://developer.android.com/reference/android/view/animation/ScaleAnimation.html\">ScaleAnimation</a></li>\n<li>平移   <a href=\"https://developer.android.com/reference/android/view/animation/TranslateAnimation.html\">TranslateAnimation</a><br>此外，还提供了<a href=\"https://developer.android.com/reference/android/view/animation/AnimationSet.html\">AnimationSet</a>动画集合，混合使用多种动画。<br>它们对应的 <strong>xml</strong>  的标签分别为：<strong>alpha,rotate,scale,translate和set。</strong><br><strong>Animation</strong>是他们的基类，有如下的标签和对应的函数：<br><strong>android:duration setDuration(long)</strong> 动画持续时间，以毫秒为单位<br><strong>android:fillAfter setFillAfter(boolean)</strong> 如果设置为 true，控件动画结束时，将保持动画最后时的状态<br><strong>android:fillBefore setFillBefore(boolean)</strong> 如果设置为 true,控件动画结束时，还原到开始动画前的状态<br><strong>android:fillEnabled setFillEnabled(boolean)</strong> 与 android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态<br><strong>android:repeatCount setRepeatCount(int)</strong> 重复次数<br><strong>android:repeatMode setRepeatMode(int)</strong> 重复类型，有 reverse 和 restart 两个值，取值为 RESTART 或 REVERSE，必须与 repeatCount 一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。<br><strong>android:interpolator setInterpolator(Interpolator)</strong> 设定插值器，其实就是指定的动作效果，比如弹跳效果等</li>\n</ul>\n<h2 id=\"2-Interpolator-插值器\"><a href=\"#2-Interpolator-插值器\" class=\"headerlink\" title=\"2. Interpolator 插值器\"></a>2. Interpolator 插值器</h2><p>对于动画，它的速率变化有快又慢，谷歌给出了<strong>插值器</strong>，来方便我们控制动画的变化。在不同的插值器的作用下，其变化也不一样。官方给的插值器有（谷歌官方）：<br><img src=\"/img/article_img/Interpolator.jpg\" alt=\"\"><br>部分资源id为(改图来自网络)：<br><img src=\"/img/article_img/Interpolator-resource-id.png\" alt=\"\"></p>\n<h2 id=\"3-xm实现动画\"><a href=\"#3-xm实现动画\" class=\"headerlink\" title=\"3. xm实现动画\"></a>3. xm实现动画</h2><p>以<strong>scale</strong>标签为例，其他类似。scale有以下几个属性：</p>\n<ul>\n<li><strong>android:fromXScale</strong> 起始的 X方向上相对自身的缩放比例，浮点值，比如 1.0 代表自身无变化，0.5 代表起始时缩小一倍，2.0 代表放大一倍；</li>\n<li><strong>android:toXScale</strong> 结尾的 X 方向上相对自身的缩放比例，浮点值；</li>\n<li><strong>android:fromYScale</strong> 起始的 Y方向上相对自身的缩放比例，浮点值，</li>\n<li><strong>android:toYScale</strong> 结尾的 Y 方向上相对自身的缩放比例，浮点值；</li>\n<li><strong>android:pivotX</strong> 缩放起点 X 轴坐标，可以是数值、百分数、百分数 p。 三种样式，比如 50、50%、50%p，当为数值时，表示在当前 View的左上角，即原点处加上 50px，做为起始缩放点；如果是 50%，表示在当前控件的左上角加上自己宽度的 50%做为起始点；如果是 50%p，那么就是表示在当前的左上角加上父控件宽度的 50%做为起始点 x 轴坐标。</li>\n<li><strong>android:pivotY</strong> 缩放起点 Y 轴坐标，取值及意义跟android:pivotX 一样。</li>\n<li><strong>android:interpolator</strong> 就是添加的插值器，通过不同的Resource ID引用不同的插值器类。</li>\n<li><strong>android：fillAfter</strong> 保持动画结束的状态，同样的可以保存初始化状态（<strong>fileBefore</strong>）</li>\n<li><strong>android:repeatMode</strong> 设定回放类型，重新开始/倒退（restart /reverse）<br>在res下新建anim 文件夹，新建scaleanim.xml文件，如下代码（宽高从0放大到1.5倍，开开始和结束速度慢，中间快，停留在结束状态，重复一次）：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;scale</span><br><span class=\"line\">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span><br><span class=\"line\">    android:fromXScale=&quot;0.0&quot;</span><br><span class=\"line\">    android:fromYScale=&quot;0.0&quot;</span><br><span class=\"line\">    android:pivotX=&quot;50&quot;</span><br><span class=\"line\">    android:pivotY=&quot;50&quot;</span><br><span class=\"line\">    android:toXScale=&quot;1.5&quot;</span><br><span class=\"line\">    android:toYScale=&quot;1.5&quot;</span><br><span class=\"line\">    android：fillAfter=&quot;true&quot;</span><br><span class=\"line\">    android:repeatCount=&quot;1&quot;  </span><br><span class=\"line\">    android:repeatMode=&quot;restart&quot;  &gt;</span><br><span class=\"line\">&lt;/scale&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面定义好了动画，下面就是具体的使用，这里以给textView设置上面的scale动画为例，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation mAnimation = AnimationUtils.loadAnimation(this,R.anim.scaleanim);</span><br><span class=\"line\">    textView.startAnimation(mAnimation);</span><br></pre></td></tr></table></figure></p>\n<p>注：对于其他的标签及其属性可以参见<a href=\"https://developer.android.com/reference/android/view/animation/Animation.html\">官方文档</a>,这些标签可以放在一个<strong>set标签</strong>中，来定义动画集合。</p>\n<h2 id=\"4-java-代码实现动画\"><a href=\"#4-java-代码实现动画\" class=\"headerlink\" title=\"4. java 代码实现动画\"></a>4. java 代码实现动画</h2><p>这里以<strong>AlphaAnimation</strong>为例，若xml代码为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </span><br><span class=\"line\">&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </span><br><span class=\"line\">    android:interpolator=&quot;@android:anim/bounce_interpolator&quot;</span><br><span class=\"line\">    android:fromAlpha=&quot;1.0&quot;  </span><br><span class=\"line\">    android:toAlpha=&quot;0.1&quot;  </span><br><span class=\"line\">    android:duration=&quot;3000&quot;  </span><br><span class=\"line\">    android:fillBefore=&quot;true&quot;&gt;  </span><br><span class=\"line\">&lt;/alpha&gt;</span><br></pre></td></tr></table></figure></p>\n<p>与其有相同效果的java代码为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alphaAnim = new AlphaAnimation(1.0f,0.1f);  </span><br><span class=\"line\">alphaAnim.setDuration(3000);  </span><br><span class=\"line\">alphaAnim.setFillBefore(true); </span><br><span class=\"line\">alphaAnim.setInterpolator(new BounceInterpolator());//设置插值器</span><br></pre></td></tr></table></figure></p>\n<p> 最后，就是给相应的控件设置动画，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">textView.startAnimation(alphaAnim);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-动画回调监听事件\"><a href=\"#5-动画回调监听事件\" class=\"headerlink\" title=\"5. 动画回调监听事件\"></a>5. 动画回调监听事件</h2><p>对于上面的两中方法设置动画，可以添加相应的监听回调，获得动画的开始，结束和重复事件，并对不同的事件作出相应的处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mAnimation.setAnimationListener(new Animation.AnimationListener() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void onAnimationStart(Animation animation) &#123;</span><br><span class=\"line\">            //动画开始前的回调处理</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void onAnimationEnd(Animation animation)&#123;</span><br><span class=\"line\">            //动画结束时的回调处理</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void onAnimationRepeat(Animation animation) &#123;</span><br><span class=\"line\">            //动画重复的回调处理</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>更多：<a href=\"http://imtianx.cn/2016/04/25/Property-animatorValueAnimator_ObjectAnimation\">属性动画（ValueAnimator 和 ObjectAnimation）</a></p>"},{"title":"android 中webview的屏幕适配问题","date":"2016-04-23T07:18:40.000Z","_content":"两行代码解决WebView的屏幕适配问题\n<!--more-->\n一个简单的方法，让网页快速适应手机屏幕，代码如下\n```\nWebSettings webSettings= webView.getSettings();\nwebSettings.setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN);\n```\n\n\n说明：\n*LayoutAlgorithm*  是一个枚举，用来控制html的布局，总共有三种类型：<br> **NORMAL**：正常显示，没有渲染变化。<br> **SINGLE_COLUMN**：把所有内容放到WebView组件等宽的一列中。<br> **NARROW_COLUMNS**：可能的话，使所有列的宽度不超过屏幕宽度。","source":"_posts/webview-Screen-adaptation.md","raw":"---\ntitle: android 中webview的屏幕适配问题\ndate: 2016-04-23 15:18:40\ncategories: [android,学习笔记]\ntags: [android,webview,屏幕适配]\n---\n两行代码解决WebView的屏幕适配问题\n<!--more-->\n一个简单的方法，让网页快速适应手机屏幕，代码如下\n```\nWebSettings webSettings= webView.getSettings();\nwebSettings.setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN);\n```\n\n\n说明：\n*LayoutAlgorithm*  是一个枚举，用来控制html的布局，总共有三种类型：<br> **NORMAL**：正常显示，没有渲染变化。<br> **SINGLE_COLUMN**：把所有内容放到WebView组件等宽的一列中。<br> **NARROW_COLUMNS**：可能的话，使所有列的宽度不超过屏幕宽度。","slug":"webview-Screen-adaptation","published":1,"updated":"2016-04-23T07:26:49.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuck20048g0g56f6jqo89","content":"<p>两行代码解决WebView的屏幕适配问题<br><a id=\"more\"></a><br>一个简单的方法，让网页快速适应手机屏幕，代码如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSettings webSettings= webView.getSettings();</span><br><span class=\"line\">webSettings.setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN);</span><br></pre></td></tr></table></figure></p>\n<p>说明：<br><em>LayoutAlgorithm</em>  是一个枚举，用来控制html的布局，总共有三种类型：<br> <strong>NORMAL</strong>：正常显示，没有渲染变化。<br> <strong>SINGLE_COLUMN</strong>：把所有内容放到WebView组件等宽的一列中。<br> <strong>NARROW_COLUMNS</strong>：可能的话，使所有列的宽度不超过屏幕宽度。</p>\n","excerpt":"<p>两行代码解决WebView的屏幕适配问题<br>","more":"<br>一个简单的方法，让网页快速适应手机屏幕，代码如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSettings webSettings= webView.getSettings();</span><br><span class=\"line\">webSettings.setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN);</span><br></pre></td></tr></table></figure></p>\n<p>说明：<br><em>LayoutAlgorithm</em>  是一个枚举，用来控制html的布局，总共有三种类型：<br> <strong>NORMAL</strong>：正常显示，没有渲染变化。<br> <strong>SINGLE_COLUMN</strong>：把所有内容放到WebView组件等宽的一列中。<br> <strong>NARROW_COLUMNS</strong>：可能的话，使所有列的宽度不超过屏幕宽度。</p>"},{"title":"【转】国内一线互联网公司内部面试题库(一)——java篇","date":"2016-11-05T08:06:25.000Z","_content":"本文转自：[国内一线互联网公司内部面试题库](https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md)\n国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库\n\n熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。\n下面是java 部分\n<!--more-->\n\n#### **1.接口的意义**（百度）\n\n规范、扩展、回调\n\n#### **2.抽象类的意义**（乐视）\n\n为其子类提供一个公共的类型\n封装子类中得重复内容\n定义抽象方法，子类虽然有不同的实现 但是定义是一致的\n\n#### **3.内部类的作用**(百度，乐视)\n\n1. 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n2. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n3. 创建内部类对象的时刻并不依赖于外围类对象的创建。\n4. 内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n5. 内部类提供了更好的封装，除了该外围类，其他类都不能访问\n\n#### **4.父类的静态方法能否被子类重写，为什么？**（猎豹）\n\n不能\n\n子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现.\n\n#### **5.举1-2个排序算法，并使用java代码实现**（美团）\n\nhttp://blog.csdn.net/qy1387/article/details/7752973\n\n#### **6.列举java的集合和继承关系**（百度、美团）\n\n![](/img/article_img/2016/collection.png)\n\n#### **7.java虚拟机的特性**（百度、乐视）\n\nJava语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。\n\n#### **8.哪些情况下的对象会被垃圾回收机制处理掉**（乐视、美团、小米）\n\nJava 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。\n\n#### **9.进程和线程的区别**（猎豹）\n\n简而言之,一个程序至少有一个进程,一个进程至少有一个线程。\n\n线程的划分尺度小于进程，使得多线程程序的并发性高。\n\n另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。\n\n\n\n线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n\n从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。\n\n进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.\n\n线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.\n\n一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.\n\n进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。\n\n#### **10.Java中==和equals的区别，equals和hashCode的区别**（乐视）\n\nhttp://blog.csdn.net/tiantiandjava/article/details/46988461\n\n#### **11.常见的排序算法时间复杂度**（小米）\n\n![](/img/article_img/2016/algorithm.png)\n\n#### **12.HashMap的实现原理**（美团）\n\n1. HashMap概述：\n   HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 \n2. HashMap的数据结构：\n\t在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。\n\n![](/img/article_img/2016/hashmap.jpg)\n\t\n从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。\n\n#### **13.java 状态机**\n\nhttp://www.jdon.com/designpatterns/designpattern_State.htm\n\n#### **14.java中int char long各占多少字节数**\n\nbyte 位数 8 字节数 1\n\nshort 16 2\n\nint 32 4\n\nlong 64 8\n\nfloat 32 4\n\ndouble 64 8\n\nchar 16 2\n\n#### **15.java int与integer的区别**\n\nhttp://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html\n\n#### **16.string stringbuffer stringbuilder 区别**（小米、乐视、百度）\n\nString 字符串常量\n\nStringBuffer 字符串变量（线程安全）\n\nStringBuilder 字符串变量（非线程安全）\n\n简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。\n\n而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：\n\nString S1 = “This is only a” + “ simple” + “ test”;\n\nStringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);\n你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个\n String S1 = “This is only a” + “ simple” + “test”; 其实就是：\n String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：\n String S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n这时候 JVM 会规规矩矩的按照原来的方式去做\n\n\n在大部分情况下 StringBuffer > String\n\nStringBuffer\n\nJava.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。\n\n可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。\n\nStringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。\n\n例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(\"le\") 会使字符串缓冲区包含“startle”，而 z.insert(4, \"le\") 将更改字符串缓冲区，使之包含“starlet”。\n\n在大部分情况下 StringBuilder > StringBuffer\n\njava.lang.StringBuilder\n\njava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同\n\n#### **17.Java多态**（乐视）\n\nJava多态性理解\n\nJava中多态性的实现\n\n什么是多态\n\n面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。\n\n多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）\n\n实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实\n际类型，根据其实际的类型调用其相应的方法。\n\n多态的作用：消除类型之间的耦合关系。\n\n现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。\n下面是多态存在的三个必要条件，要求大家做梦时都能背出来！\n\n多态存在的三个必要条件\n一、要有继承；\n二、要有重写；\n三、父类引用指向子类对象。\n\n 多态的好处：\n\n1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。\n\n2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。\n\n3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。\n\n4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。\n\n5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。\n\nJava中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。\n\n#### **18.什么导致线程阻塞**（58、美团）\n\n线程的阻塞\n\n为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.\n\n阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。\n\n1. sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。\n典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。\n2. suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。\n3. yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.\n4. wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.\n\n初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。\n\n上述的核心区别导致了一系列的细节上的区别。\n\n首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。\n\n其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。\n\nwait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。\n\n关于 wait() 和 notify() 方法最后再说明两点：\n\n第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。\n\n第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。\n\n谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。\n\n以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。\n\n#### **19.抽象类接口区别**（360）\n\n1. 默认的方法实现\n抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现\n\n2. 实现\n子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。\t\n子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现\n\n3. 构造器\t\n抽象类可以有构造器\t\n接口不能有构造器\n\n4. 与正常Java类的区别\t\n除了你不能实例化抽象类之外，它和普通Java类没有任何区\n接口是完全不同的类型\n\n5. 访问修饰符\t\n抽象方法可以有public、protected和default这些修饰符\n接口方法默认修饰符是public。你不可以使用其它修饰符。\n\n6. main方法\t\n抽象方法可以有main方法并且我们可以运行它\t\n接口没有main方法，因此我们不能运行它。\n\n7. 多继承\t\n抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。\n\n8. 速度\t\n它比接口速度要快\t\n接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。\n\n9. 添加新方法\t\n如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。\t\n如果你往接口中添加方法，那么你必须改变实现该接口的类。\n\n#### **20.容器类之间的区别**（乐视、美团）\n\nhttp://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html\nhttp://alexyyek.github.io/2015/04/06/Collection/\nhttp://tianmaying.com/tutorial/java_collection\n\n#### **21.java 内部类**（小米）\n\nhttp://www.cnblogs.com/chenssy/p/3388487.html\n\n**22.Java中hashmap和hashtable的区别**（乐视、小米）\n\nhttp://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html\n\n**23.ArrayMap VS HashMap**\n\nhttp://lvable.com/?p=217\n\n","source":"_posts/国内一线互联网公司内部面试题库(一)-java.md","raw":"---\ntitle: 【转】国内一线互联网公司内部面试题库(一)——java篇\ndate: 2016-11-05 16:06:25\ncategories: [面试]\ntags: [android,java,面试]\n---\n本文转自：[国内一线互联网公司内部面试题库](https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md)\n国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库\n\n熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。\n下面是java 部分\n<!--more-->\n\n#### **1.接口的意义**（百度）\n\n规范、扩展、回调\n\n#### **2.抽象类的意义**（乐视）\n\n为其子类提供一个公共的类型\n封装子类中得重复内容\n定义抽象方法，子类虽然有不同的实现 但是定义是一致的\n\n#### **3.内部类的作用**(百度，乐视)\n\n1. 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n2. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n3. 创建内部类对象的时刻并不依赖于外围类对象的创建。\n4. 内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n5. 内部类提供了更好的封装，除了该外围类，其他类都不能访问\n\n#### **4.父类的静态方法能否被子类重写，为什么？**（猎豹）\n\n不能\n\n子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现.\n\n#### **5.举1-2个排序算法，并使用java代码实现**（美团）\n\nhttp://blog.csdn.net/qy1387/article/details/7752973\n\n#### **6.列举java的集合和继承关系**（百度、美团）\n\n![](/img/article_img/2016/collection.png)\n\n#### **7.java虚拟机的特性**（百度、乐视）\n\nJava语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。\n\n#### **8.哪些情况下的对象会被垃圾回收机制处理掉**（乐视、美团、小米）\n\nJava 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。\n\n#### **9.进程和线程的区别**（猎豹）\n\n简而言之,一个程序至少有一个进程,一个进程至少有一个线程。\n\n线程的划分尺度小于进程，使得多线程程序的并发性高。\n\n另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。\n\n\n\n线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n\n从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。\n\n进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.\n\n线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.\n\n一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.\n\n进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。\n\n#### **10.Java中==和equals的区别，equals和hashCode的区别**（乐视）\n\nhttp://blog.csdn.net/tiantiandjava/article/details/46988461\n\n#### **11.常见的排序算法时间复杂度**（小米）\n\n![](/img/article_img/2016/algorithm.png)\n\n#### **12.HashMap的实现原理**（美团）\n\n1. HashMap概述：\n   HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 \n2. HashMap的数据结构：\n\t在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。\n\n![](/img/article_img/2016/hashmap.jpg)\n\t\n从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。\n\n#### **13.java 状态机**\n\nhttp://www.jdon.com/designpatterns/designpattern_State.htm\n\n#### **14.java中int char long各占多少字节数**\n\nbyte 位数 8 字节数 1\n\nshort 16 2\n\nint 32 4\n\nlong 64 8\n\nfloat 32 4\n\ndouble 64 8\n\nchar 16 2\n\n#### **15.java int与integer的区别**\n\nhttp://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html\n\n#### **16.string stringbuffer stringbuilder 区别**（小米、乐视、百度）\n\nString 字符串常量\n\nStringBuffer 字符串变量（线程安全）\n\nStringBuilder 字符串变量（非线程安全）\n\n简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。\n\n而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：\n\nString S1 = “This is only a” + “ simple” + “ test”;\n\nStringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);\n你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个\n String S1 = “This is only a” + “ simple” + “test”; 其实就是：\n String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：\n String S2 = “This is only a”;\nString S3 = “ simple”;\nString S4 = “ test”;\nString S1 = S2 +S3 + S4;\n这时候 JVM 会规规矩矩的按照原来的方式去做\n\n\n在大部分情况下 StringBuffer > String\n\nStringBuffer\n\nJava.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。\n\n可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。\n\nStringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。\n\n例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(\"le\") 会使字符串缓冲区包含“startle”，而 z.insert(4, \"le\") 将更改字符串缓冲区，使之包含“starlet”。\n\n在大部分情况下 StringBuilder > StringBuffer\n\njava.lang.StringBuilder\n\njava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同\n\n#### **17.Java多态**（乐视）\n\nJava多态性理解\n\nJava中多态性的实现\n\n什么是多态\n\n面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。\n\n多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）\n\n实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实\n际类型，根据其实际的类型调用其相应的方法。\n\n多态的作用：消除类型之间的耦合关系。\n\n现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。\n下面是多态存在的三个必要条件，要求大家做梦时都能背出来！\n\n多态存在的三个必要条件\n一、要有继承；\n二、要有重写；\n三、父类引用指向子类对象。\n\n 多态的好处：\n\n1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。\n\n2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。\n\n3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。\n\n4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。\n\n5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。\n\nJava中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。\n\n#### **18.什么导致线程阻塞**（58、美团）\n\n线程的阻塞\n\n为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.\n\n阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。\n\n1. sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。\n典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。\n2. suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。\n3. yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.\n4. wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.\n\n初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。\n\n上述的核心区别导致了一系列的细节上的区别。\n\n首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。\n\n其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。\n\nwait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。\n\n关于 wait() 和 notify() 方法最后再说明两点：\n\n第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。\n\n第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。\n\n谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。\n\n以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。\n\n#### **19.抽象类接口区别**（360）\n\n1. 默认的方法实现\n抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现\n\n2. 实现\n子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。\t\n子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现\n\n3. 构造器\t\n抽象类可以有构造器\t\n接口不能有构造器\n\n4. 与正常Java类的区别\t\n除了你不能实例化抽象类之外，它和普通Java类没有任何区\n接口是完全不同的类型\n\n5. 访问修饰符\t\n抽象方法可以有public、protected和default这些修饰符\n接口方法默认修饰符是public。你不可以使用其它修饰符。\n\n6. main方法\t\n抽象方法可以有main方法并且我们可以运行它\t\n接口没有main方法，因此我们不能运行它。\n\n7. 多继承\t\n抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。\n\n8. 速度\t\n它比接口速度要快\t\n接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。\n\n9. 添加新方法\t\n如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。\t\n如果你往接口中添加方法，那么你必须改变实现该接口的类。\n\n#### **20.容器类之间的区别**（乐视、美团）\n\nhttp://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html\nhttp://alexyyek.github.io/2015/04/06/Collection/\nhttp://tianmaying.com/tutorial/java_collection\n\n#### **21.java 内部类**（小米）\n\nhttp://www.cnblogs.com/chenssy/p/3388487.html\n\n**22.Java中hashmap和hashtable的区别**（乐视、小米）\n\nhttp://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html\n\n**23.ArrayMap VS HashMap**\n\nhttp://lvable.com/?p=217\n\n","slug":"国内一线互联网公司内部面试题库(一)-java","published":1,"updated":"2016-11-07T12:02:00.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuck2004cg0g5dvsa28fs","content":"<p>本文转自：<a href=\"https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md\" target=\"_blank\" rel=\"external\">国内一线互联网公司内部面试题库</a><br>国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库</p>\n<p>熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。<br>下面是java 部分<br><a id=\"more\"></a></p>\n<h4 id=\"1-接口的意义（百度）\"><a href=\"#1-接口的意义（百度）\" class=\"headerlink\" title=\"1.接口的意义（百度）\"></a><strong>1.接口的意义</strong>（百度）</h4><p>规范、扩展、回调</p>\n<h4 id=\"2-抽象类的意义（乐视）\"><a href=\"#2-抽象类的意义（乐视）\" class=\"headerlink\" title=\"2.抽象类的意义（乐视）\"></a><strong>2.抽象类的意义</strong>（乐视）</h4><p>为其子类提供一个公共的类型<br>封装子类中得重复内容<br>定义抽象方法，子类虽然有不同的实现 但是定义是一致的</p>\n<h4 id=\"3-内部类的作用-百度，乐视\"><a href=\"#3-内部类的作用-百度，乐视\" class=\"headerlink\" title=\"3.内部类的作用(百度，乐视)\"></a><strong>3.内部类的作用</strong>(百度，乐视)</h4><ol>\n<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>\n<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>\n<li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li>\n<li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>\n<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问</li>\n</ol>\n<h4 id=\"4-父类的静态方法能否被子类重写，为什么？（猎豹）\"><a href=\"#4-父类的静态方法能否被子类重写，为什么？（猎豹）\" class=\"headerlink\" title=\"4.父类的静态方法能否被子类重写，为什么？（猎豹）\"></a><strong>4.父类的静态方法能否被子类重写，为什么？</strong>（猎豹）</h4><p>不能</p>\n<p>子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现.</p>\n<h4 id=\"5-举1-2个排序算法，并使用java代码实现（美团）\"><a href=\"#5-举1-2个排序算法，并使用java代码实现（美团）\" class=\"headerlink\" title=\"5.举1-2个排序算法，并使用java代码实现（美团）\"></a><strong>5.举1-2个排序算法，并使用java代码实现</strong>（美团）</h4><p><a href=\"http://blog.csdn.net/qy1387/article/details/7752973\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/qy1387/article/details/7752973</a></p>\n<h4 id=\"6-列举java的集合和继承关系（百度、美团）\"><a href=\"#6-列举java的集合和继承关系（百度、美团）\" class=\"headerlink\" title=\"6.列举java的集合和继承关系（百度、美团）\"></a><strong>6.列举java的集合和继承关系</strong>（百度、美团）</h4><p><img src=\"/img/article_img/2016/collection.png\" alt=\"\"></p>\n<h4 id=\"7-java虚拟机的特性（百度、乐视）\"><a href=\"#7-java虚拟机的特性（百度、乐视）\" class=\"headerlink\" title=\"7.java虚拟机的特性（百度、乐视）\"></a><strong>7.java虚拟机的特性</strong>（百度、乐视）</h4><p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p>\n<h4 id=\"8-哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）\"><a href=\"#8-哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）\" class=\"headerlink\" title=\"8.哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）\"></a><strong>8.哪些情况下的对象会被垃圾回收机制处理掉</strong>（乐视、美团、小米）</h4><p>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。</p>\n<h4 id=\"9-进程和线程的区别（猎豹）\"><a href=\"#9-进程和线程的区别（猎豹）\" class=\"headerlink\" title=\"9.进程和线程的区别（猎豹）\"></a><strong>9.进程和线程的区别</strong>（猎豹）</h4><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。</p>\n<p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p>\n<p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>\n<p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>\n<p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>\n<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p>\n<p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p>\n<p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>\n<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。</p>\n<h4 id=\"10-Java中-和equals的区别，equals和hashCode的区别（乐视）\"><a href=\"#10-Java中-和equals的区别，equals和hashCode的区别（乐视）\" class=\"headerlink\" title=\"10.Java中==和equals的区别，equals和hashCode的区别（乐视）\"></a><strong>10.Java中==和equals的区别，equals和hashCode的区别</strong>（乐视）</h4><p><a href=\"http://blog.csdn.net/tiantiandjava/article/details/46988461\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/tiantiandjava/article/details/46988461</a></p>\n<h4 id=\"11-常见的排序算法时间复杂度（小米）\"><a href=\"#11-常见的排序算法时间复杂度（小米）\" class=\"headerlink\" title=\"11.常见的排序算法时间复杂度（小米）\"></a><strong>11.常见的排序算法时间复杂度</strong>（小米）</h4><p><img src=\"/img/article_img/2016/algorithm.png\" alt=\"\"></p>\n<h4 id=\"12-HashMap的实现原理（美团）\"><a href=\"#12-HashMap的实现原理（美团）\" class=\"headerlink\" title=\"12.HashMap的实现原理（美团）\"></a><strong>12.HashMap的实现原理</strong>（美团）</h4><ol>\n<li>HashMap概述：<br>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 </li>\n<li>HashMap的数据结构：<br> 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</li>\n</ol>\n<p><img src=\"/img/article_img/2016/hashmap.jpg\" alt=\"\"></p>\n<p>从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p>\n<h4 id=\"13-java-状态机\"><a href=\"#13-java-状态机\" class=\"headerlink\" title=\"13.java 状态机\"></a><strong>13.java 状态机</strong></h4><p><a href=\"http://www.jdon.com/designpatterns/designpattern_State.htm\" target=\"_blank\" rel=\"external\">http://www.jdon.com/designpatterns/designpattern_State.htm</a></p>\n<h4 id=\"14-java中int-char-long各占多少字节数\"><a href=\"#14-java中int-char-long各占多少字节数\" class=\"headerlink\" title=\"14.java中int char long各占多少字节数\"></a><strong>14.java中int char long各占多少字节数</strong></h4><p>byte 位数 8 字节数 1</p>\n<p>short 16 2</p>\n<p>int 32 4</p>\n<p>long 64 8</p>\n<p>float 32 4</p>\n<p>double 64 8</p>\n<p>char 16 2</p>\n<h4 id=\"15-java-int与integer的区别\"><a href=\"#15-java-int与integer的区别\" class=\"headerlink\" title=\"15.java int与integer的区别\"></a><strong>15.java int与integer的区别</strong></h4><p><a href=\"http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html</a></p>\n<h4 id=\"16-string-stringbuffer-stringbuilder-区别（小米、乐视、百度）\"><a href=\"#16-string-stringbuffer-stringbuilder-区别（小米、乐视、百度）\" class=\"headerlink\" title=\"16.string stringbuffer stringbuilder 区别（小米、乐视、百度）\"></a><strong>16.string stringbuffer stringbuilder 区别</strong>（小米、乐视、百度）</h4><p>String 字符串常量</p>\n<p>StringBuffer 字符串变量（线程安全）</p>\n<p>StringBuilder 字符串变量（非线程安全）</p>\n<p>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</p>\n<p>而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>\n<p>String S1 = “This is only a” + “ simple” + “ test”;</p>\n<p>StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);<br>你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br> String S1 = “This is only a” + “ simple” + “test”; 其实就是：<br> String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：<br> String S2 = “This is only a”;<br>String S3 = “ simple”;<br>String S4 = “ test”;<br>String S1 = S2 +S3 + S4;<br>这时候 JVM 会规规矩矩的按照原来的方式去做</p>\n<p>在大部分情况下 StringBuffer &gt; String</p>\n<p>StringBuffer</p>\n<p>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p>\n<p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。</p>\n<p>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p>\n<p>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。</p>\n<p>在大部分情况下 StringBuilder &gt; StringBuffer</p>\n<p>java.lang.StringBuilder</p>\n<p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同</p>\n<h4 id=\"17-Java多态（乐视）\"><a href=\"#17-Java多态（乐视）\" class=\"headerlink\" title=\"17.Java多态（乐视）\"></a><strong>17.Java多态</strong>（乐视）</h4><p>Java多态性理解</p>\n<p>Java中多态性的实现</p>\n<p>什么是多态</p>\n<p>面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。</p>\n<p>多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p>\n<p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实<br>际类型，根据其实际的类型调用其相应的方法。</p>\n<p>多态的作用：消除类型之间的耦合关系。</p>\n<p>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。<br>下面是多态存在的三个必要条件，要求大家做梦时都能背出来！</p>\n<p>多态存在的三个必要条件<br>一、要有继承；<br>二、要有重写；<br>三、父类引用指向子类对象。</p>\n<p> 多态的好处：</p>\n<p>1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。</p>\n<p>2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。</p>\n<p>3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。</p>\n<p>4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。</p>\n<p>5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p>\n<p>Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。</p>\n<h4 id=\"18-什么导致线程阻塞（58、美团）\"><a href=\"#18-什么导致线程阻塞（58、美团）\" class=\"headerlink\" title=\"18.什么导致线程阻塞（58、美团）\"></a><strong>18.什么导致线程阻塞</strong>（58、美团）</h4><p>线程的阻塞</p>\n<p>为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.</p>\n<p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p>\n<ol>\n<li>sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。<br>典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。</li>\n<li>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</li>\n<li>yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.</li>\n<li>wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</li>\n</ol>\n<p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。</p>\n<p>上述的核心区别导致了一系列的细节上的区别。</p>\n<p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p>\n<p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p>\n<p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。</p>\n<p>关于 wait() 和 notify() 方法最后再说明两点：</p>\n<p>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p>\n<p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p>\n<p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p>\n<p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p>\n<h4 id=\"19-抽象类接口区别（360）\"><a href=\"#19-抽象类接口区别（360）\" class=\"headerlink\" title=\"19.抽象类接口区别（360）\"></a><strong>19.抽象类接口区别</strong>（360）</h4><ol>\n<li><p>默认的方法实现<br>抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现</p>\n</li>\n<li><p>实现<br>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。<br>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</p>\n</li>\n<li><p>构造器<br>抽象类可以有构造器<br>接口不能有构造器</p>\n</li>\n<li><p>与正常Java类的区别<br>除了你不能实例化抽象类之外，它和普通Java类没有任何区<br>接口是完全不同的类型</p>\n</li>\n<li><p>访问修饰符<br>抽象方法可以有public、protected和default这些修饰符<br>接口方法默认修饰符是public。你不可以使用其它修饰符。</p>\n</li>\n<li><p>main方法<br>抽象方法可以有main方法并且我们可以运行它<br>接口没有main方法，因此我们不能运行它。</p>\n</li>\n<li><p>多继承<br>抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。</p>\n</li>\n<li><p>速度<br>它比接口速度要快<br>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</p>\n</li>\n<li><p>添加新方法<br>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。<br>如果你往接口中添加方法，那么你必须改变实现该接口的类。</p>\n</li>\n</ol>\n<h4 id=\"20-容器类之间的区别（乐视、美团）\"><a href=\"#20-容器类之间的区别（乐视、美团）\" class=\"headerlink\" title=\"20.容器类之间的区别（乐视、美团）\"></a><strong>20.容器类之间的区别</strong>（乐视、美团）</h4><p><a href=\"http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html</a><br><a href=\"http://alexyyek.github.io/2015/04/06/Collection/\" target=\"_blank\" rel=\"external\">http://alexyyek.github.io/2015/04/06/Collection/</a><br><a href=\"http://tianmaying.com/tutorial/java_collection\" target=\"_blank\" rel=\"external\">http://tianmaying.com/tutorial/java_collection</a></p>\n<h4 id=\"21-java-内部类（小米）\"><a href=\"#21-java-内部类（小米）\" class=\"headerlink\" title=\"21.java 内部类（小米）\"></a><strong>21.java 内部类</strong>（小米）</h4><p><a href=\"http://www.cnblogs.com/chenssy/p/3388487.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/chenssy/p/3388487.html</a></p>\n<p><strong>22.Java中hashmap和hashtable的区别</strong>（乐视、小米）</p>\n<p><a href=\"http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html\" target=\"_blank\" rel=\"external\">http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html</a></p>\n<p><strong>23.ArrayMap VS HashMap</strong></p>\n<p><a href=\"http://lvable.com/?p=217\" target=\"_blank\" rel=\"external\">http://lvable.com/?p=217</a></p>\n","excerpt":"<p>本文转自：<a href=\"https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md\">国内一线互联网公司内部面试题库</a><br>国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库</p>\n<p>熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。<br>下面是java 部分<br>","more":"</p>\n<h4 id=\"1-接口的意义（百度）\"><a href=\"#1-接口的意义（百度）\" class=\"headerlink\" title=\"1.接口的意义（百度）\"></a><strong>1.接口的意义</strong>（百度）</h4><p>规范、扩展、回调</p>\n<h4 id=\"2-抽象类的意义（乐视）\"><a href=\"#2-抽象类的意义（乐视）\" class=\"headerlink\" title=\"2.抽象类的意义（乐视）\"></a><strong>2.抽象类的意义</strong>（乐视）</h4><p>为其子类提供一个公共的类型<br>封装子类中得重复内容<br>定义抽象方法，子类虽然有不同的实现 但是定义是一致的</p>\n<h4 id=\"3-内部类的作用-百度，乐视\"><a href=\"#3-内部类的作用-百度，乐视\" class=\"headerlink\" title=\"3.内部类的作用(百度，乐视)\"></a><strong>3.内部类的作用</strong>(百度，乐视)</h4><ol>\n<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>\n<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>\n<li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li>\n<li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>\n<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问</li>\n</ol>\n<h4 id=\"4-父类的静态方法能否被子类重写，为什么？（猎豹）\"><a href=\"#4-父类的静态方法能否被子类重写，为什么？（猎豹）\" class=\"headerlink\" title=\"4.父类的静态方法能否被子类重写，为什么？（猎豹）\"></a><strong>4.父类的静态方法能否被子类重写，为什么？</strong>（猎豹）</h4><p>不能</p>\n<p>子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现.</p>\n<h4 id=\"5-举1-2个排序算法，并使用java代码实现（美团）\"><a href=\"#5-举1-2个排序算法，并使用java代码实现（美团）\" class=\"headerlink\" title=\"5.举1-2个排序算法，并使用java代码实现（美团）\"></a><strong>5.举1-2个排序算法，并使用java代码实现</strong>（美团）</h4><p><a href=\"http://blog.csdn.net/qy1387/article/details/7752973\">http://blog.csdn.net/qy1387/article/details/7752973</a></p>\n<h4 id=\"6-列举java的集合和继承关系（百度、美团）\"><a href=\"#6-列举java的集合和继承关系（百度、美团）\" class=\"headerlink\" title=\"6.列举java的集合和继承关系（百度、美团）\"></a><strong>6.列举java的集合和继承关系</strong>（百度、美团）</h4><p><img src=\"/img/article_img/2016/collection.png\" alt=\"\"></p>\n<h4 id=\"7-java虚拟机的特性（百度、乐视）\"><a href=\"#7-java虚拟机的特性（百度、乐视）\" class=\"headerlink\" title=\"7.java虚拟机的特性（百度、乐视）\"></a><strong>7.java虚拟机的特性</strong>（百度、乐视）</h4><p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p>\n<h4 id=\"8-哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）\"><a href=\"#8-哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）\" class=\"headerlink\" title=\"8.哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）\"></a><strong>8.哪些情况下的对象会被垃圾回收机制处理掉</strong>（乐视、美团、小米）</h4><p>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。</p>\n<h4 id=\"9-进程和线程的区别（猎豹）\"><a href=\"#9-进程和线程的区别（猎豹）\" class=\"headerlink\" title=\"9.进程和线程的区别（猎豹）\"></a><strong>9.进程和线程的区别</strong>（猎豹）</h4><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。</p>\n<p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p>\n<p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>\n<p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>\n<p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>\n<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p>\n<p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p>\n<p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>\n<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。</p>\n<h4 id=\"10-Java中-和equals的区别，equals和hashCode的区别（乐视）\"><a href=\"#10-Java中-和equals的区别，equals和hashCode的区别（乐视）\" class=\"headerlink\" title=\"10.Java中==和equals的区别，equals和hashCode的区别（乐视）\"></a><strong>10.Java中==和equals的区别，equals和hashCode的区别</strong>（乐视）</h4><p><a href=\"http://blog.csdn.net/tiantiandjava/article/details/46988461\">http://blog.csdn.net/tiantiandjava/article/details/46988461</a></p>\n<h4 id=\"11-常见的排序算法时间复杂度（小米）\"><a href=\"#11-常见的排序算法时间复杂度（小米）\" class=\"headerlink\" title=\"11.常见的排序算法时间复杂度（小米）\"></a><strong>11.常见的排序算法时间复杂度</strong>（小米）</h4><p><img src=\"/img/article_img/2016/algorithm.png\" alt=\"\"></p>\n<h4 id=\"12-HashMap的实现原理（美团）\"><a href=\"#12-HashMap的实现原理（美团）\" class=\"headerlink\" title=\"12.HashMap的实现原理（美团）\"></a><strong>12.HashMap的实现原理</strong>（美团）</h4><ol>\n<li>HashMap概述：<br>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 </li>\n<li>HashMap的数据结构：<br> 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</li>\n</ol>\n<p><img src=\"/img/article_img/2016/hashmap.jpg\" alt=\"\"></p>\n<p>从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p>\n<h4 id=\"13-java-状态机\"><a href=\"#13-java-状态机\" class=\"headerlink\" title=\"13.java 状态机\"></a><strong>13.java 状态机</strong></h4><p><a href=\"http://www.jdon.com/designpatterns/designpattern_State.htm\">http://www.jdon.com/designpatterns/designpattern_State.htm</a></p>\n<h4 id=\"14-java中int-char-long各占多少字节数\"><a href=\"#14-java中int-char-long各占多少字节数\" class=\"headerlink\" title=\"14.java中int char long各占多少字节数\"></a><strong>14.java中int char long各占多少字节数</strong></h4><p>byte 位数 8 字节数 1</p>\n<p>short 16 2</p>\n<p>int 32 4</p>\n<p>long 64 8</p>\n<p>float 32 4</p>\n<p>double 64 8</p>\n<p>char 16 2</p>\n<h4 id=\"15-java-int与integer的区别\"><a href=\"#15-java-int与integer的区别\" class=\"headerlink\" title=\"15.java int与integer的区别\"></a><strong>15.java int与integer的区别</strong></h4><p><a href=\"http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html\">http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html</a></p>\n<h4 id=\"16-string-stringbuffer-stringbuilder-区别（小米、乐视、百度）\"><a href=\"#16-string-stringbuffer-stringbuilder-区别（小米、乐视、百度）\" class=\"headerlink\" title=\"16.string stringbuffer stringbuilder 区别（小米、乐视、百度）\"></a><strong>16.string stringbuffer stringbuilder 区别</strong>（小米、乐视、百度）</h4><p>String 字符串常量</p>\n<p>StringBuffer 字符串变量（线程安全）</p>\n<p>StringBuilder 字符串变量（非线程安全）</p>\n<p>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</p>\n<p>而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>\n<p>String S1 = “This is only a” + “ simple” + “ test”;</p>\n<p>StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);<br>你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br> String S1 = “This is only a” + “ simple” + “test”; 其实就是：<br> String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：<br> String S2 = “This is only a”;<br>String S3 = “ simple”;<br>String S4 = “ test”;<br>String S1 = S2 +S3 + S4;<br>这时候 JVM 会规规矩矩的按照原来的方式去做</p>\n<p>在大部分情况下 StringBuffer &gt; String</p>\n<p>StringBuffer</p>\n<p>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p>\n<p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。</p>\n<p>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p>\n<p>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。</p>\n<p>在大部分情况下 StringBuilder &gt; StringBuffer</p>\n<p>java.lang.StringBuilder</p>\n<p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同</p>\n<h4 id=\"17-Java多态（乐视）\"><a href=\"#17-Java多态（乐视）\" class=\"headerlink\" title=\"17.Java多态（乐视）\"></a><strong>17.Java多态</strong>（乐视）</h4><p>Java多态性理解</p>\n<p>Java中多态性的实现</p>\n<p>什么是多态</p>\n<p>面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。</p>\n<p>多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p>\n<p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实<br>际类型，根据其实际的类型调用其相应的方法。</p>\n<p>多态的作用：消除类型之间的耦合关系。</p>\n<p>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。<br>下面是多态存在的三个必要条件，要求大家做梦时都能背出来！</p>\n<p>多态存在的三个必要条件<br>一、要有继承；<br>二、要有重写；<br>三、父类引用指向子类对象。</p>\n<p> 多态的好处：</p>\n<p>1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。</p>\n<p>2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。</p>\n<p>3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。</p>\n<p>4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。</p>\n<p>5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p>\n<p>Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。</p>\n<h4 id=\"18-什么导致线程阻塞（58、美团）\"><a href=\"#18-什么导致线程阻塞（58、美团）\" class=\"headerlink\" title=\"18.什么导致线程阻塞（58、美团）\"></a><strong>18.什么导致线程阻塞</strong>（58、美团）</h4><p>线程的阻塞</p>\n<p>为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.</p>\n<p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p>\n<ol>\n<li>sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。<br>典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。</li>\n<li>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</li>\n<li>yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.</li>\n<li>wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</li>\n</ol>\n<p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。</p>\n<p>上述的核心区别导致了一系列的细节上的区别。</p>\n<p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p>\n<p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p>\n<p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。</p>\n<p>关于 wait() 和 notify() 方法最后再说明两点：</p>\n<p>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p>\n<p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p>\n<p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p>\n<p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p>\n<h4 id=\"19-抽象类接口区别（360）\"><a href=\"#19-抽象类接口区别（360）\" class=\"headerlink\" title=\"19.抽象类接口区别（360）\"></a><strong>19.抽象类接口区别</strong>（360）</h4><ol>\n<li><p>默认的方法实现<br>抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现</p>\n</li>\n<li><p>实现<br>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。<br>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</p>\n</li>\n<li><p>构造器<br>抽象类可以有构造器<br>接口不能有构造器</p>\n</li>\n<li><p>与正常Java类的区别<br>除了你不能实例化抽象类之外，它和普通Java类没有任何区<br>接口是完全不同的类型</p>\n</li>\n<li><p>访问修饰符<br>抽象方法可以有public、protected和default这些修饰符<br>接口方法默认修饰符是public。你不可以使用其它修饰符。</p>\n</li>\n<li><p>main方法<br>抽象方法可以有main方法并且我们可以运行它<br>接口没有main方法，因此我们不能运行它。</p>\n</li>\n<li><p>多继承<br>抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。</p>\n</li>\n<li><p>速度<br>它比接口速度要快<br>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</p>\n</li>\n<li><p>添加新方法<br>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。<br>如果你往接口中添加方法，那么你必须改变实现该接口的类。</p>\n</li>\n</ol>\n<h4 id=\"20-容器类之间的区别（乐视、美团）\"><a href=\"#20-容器类之间的区别（乐视、美团）\" class=\"headerlink\" title=\"20.容器类之间的区别（乐视、美团）\"></a><strong>20.容器类之间的区别</strong>（乐视、美团）</h4><p><a href=\"http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html\">http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html</a><br><a href=\"http://alexyyek.github.io/2015/04/06/Collection/\">http://alexyyek.github.io/2015/04/06/Collection/</a><br><a href=\"http://tianmaying.com/tutorial/java_collection\">http://tianmaying.com/tutorial/java_collection</a></p>\n<h4 id=\"21-java-内部类（小米）\"><a href=\"#21-java-内部类（小米）\" class=\"headerlink\" title=\"21.java 内部类（小米）\"></a><strong>21.java 内部类</strong>（小米）</h4><p><a href=\"http://www.cnblogs.com/chenssy/p/3388487.html\">http://www.cnblogs.com/chenssy/p/3388487.html</a></p>\n<p><strong>22.Java中hashmap和hashtable的区别</strong>（乐视、小米）</p>\n<p><a href=\"http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html\">http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html</a></p>\n<p><strong>23.ArrayMap VS HashMap</strong></p>\n<p><a href=\"http://lvable.com/?p=217\">http://lvable.com/?p=217</a></p>"},{"title":"【转】国内一线互联网公司内部面试题库(二)——android 篇","date":"2016-11-06T08:06:25.000Z","_content":"本文转自：[国内一线互联网公司内部面试题库](https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md)\n国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库\n\n熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。\n下面是 android 部分\n<!--more-->\n\n#### **1.数据库的操作类型有哪些，如何导入外部数据库？**\n\n把原数据库包括在项目源码的 res/raw \n\nandroid系统下数据库应该存放在 /data/data/com.*.*（package name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录.\n\n#### **2.是否使用过本地广播，和全局广播有什么差别？**\n\n因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。\n不用担心别的应用伪造广播，造成安全隐患。\n相比在系统内发送全局广播，它更高效。\n\n#### **3.是否使用过intentService，作用是什么，AIDL解决了什么问题？**(小米)\n\n\n生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt。\n\n生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。\n\n该服务提供了一个onBind()方法的默认实现，它返回null\n\n提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。\n\nAIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。\nAIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。\n\n#### **4.Activity、Window、View三者的差别，fragment的特点？**（360）\n\nActivity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）\nLayoutInflater像剪刀，Xml配置像窗花图纸。\n\n1. 在Activity中调用attach，创建了一个Window\n2. 创建的window是其子类PhoneWindow，在attach中创建PhoneWindow\n3. 在Activity中调用setContentView(R.layout.xxx)\n4. 其中实际上是调用的getWindow().setContentView()\n5. 调用PhoneWindow中的setContentView方法\n6. 创建ParentView：作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）\n7. 将指定的R.layout.xxx进行填充通过布局填充器进行填充【其中的parent指的就是DecorView】\n8. 调用到ViewGroup\n9. 调用ViewGroup的removeAllView()，先将所有的view移除掉\n10. 添加新的view：addView()\n\n**fragment 特点**\n\n* Fragment可以作为Activity界面的一部分组成出现；\n* 可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用；\n* 在Activity运行过程中，可以添加、移除或者替换Fragment；\n* Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。\n\n#### **5.描述一次网络请求的流程**（新浪）\n\n![](/img/article_img/2016/http.png)\n\n#### **6.Handler、Thread和HandlerThread的差别**（小米）\n\nhttp://blog.csdn.net/guolin_blog/article/details/9991569\n\nhttp://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/\n\n从Android中Thread（java.lang.Thread -> java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -> java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。\n\nandroid.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也是就HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。\n\n#### **7.低版本SDK实现高版本api**（小米）\n\n自己实现或@TargetApi annotation\n\n#### **8.Ubuntu编译安卓系统**（百度）\n\n1. 进入源码根目录\n2. . build/envsetup.sh\n3. lunch\n4. full(编译全部)\n5. userdebug(选择编译版本)\n6. make -j8(开启8个线程编译)\n\n#### **9.launch mode应用场景**（百度、小米、乐视）\n\nstandard，创建一个新的Activity。\n\nsingleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。\n\nsingleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。\n\n注意:\n\n 1. 设置了\"singleTask\"启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在； 如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了\"singleTask\"启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。\n 2. 如果设置了\"singleTask\"启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。\n 3. 在一个任务栈中只有一个”singleTask”启动模式的Activity存在。他的上面可以有其他的Activity。这点与singleInstance是有区别的。\n\nsingleInstance，回退栈中，只有这一个Activity，没有其他Activity。\n\nsingleTop适合接收通知启动的内容显示页面。\n\n例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。\n\nsingleTask适合作为程序入口点。\n\n例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。\n\nsingleInstance应用场景：\n\n闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。\n\n#### **10.touch 事件传递流程**（小米）\n\nhttp://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/\n\n#### **11.view绘制流程**（百度）\n\nhttp://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f\n\n#### **12.多线程**（360）\n\n* Activity.runOnUiThread(Runnable)\n* View.post(Runnable),View.postDelay(Runnable,long)\n* Handler\n* AsyncTask\n\n#### **13.线程同步**（百度）\n\nhttp://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more\n\nhttp://www.juwends.com/tech/android/android-inter-thread-comm.html\n\n单例\n\n```\npublic class Singleton{\nprivate volatile static Singleton mSingleton;\nprivate Singleton(){\n}\npublic static Singleton getInstance(){\n  if(mSingleton == null){\\\\A\n    synchronized(Singleton.class){\\\\C\n     if(mSingleton == null)\n      mSingleton = new Singleton();\\\\B\n      }\n    }\n    return mSingleton;\n  }\n}\n```\n#### **14.什么情况导致内存泄漏**（美团）\n\n1.资源对象没关闭造成的内存泄漏\n\n描述：\n资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。\n程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。\n\n2.构造Adapter时，没有使用缓存的convertView\n\n描述：\n以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：\npublic View getView(int position, ViewconvertView, ViewGroup parent)\n来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看:\nandroid.widget.AbsListView.java --> voidaddScrapView(View scrap) 方法。\n示例代码：\n\n```\npublic View getView(int position, ViewconvertView, ViewGroup parent) {\nView view = new Xxx(...); \n... ... \nreturn view; \n} \n```\n\n修正示例代码：\n\n```\npublic View getView(int position, ViewconvertView, ViewGroup parent) {\nView view = null; \nif (convertView != null) { \nview = convertView; \npopulate(view, getItem(position)); \n... \n} else { \nview = new Xxx(...); \n... \n} \nreturn view; \n} \n```\n\n3.Bitmap对象不在使用时调用recycle()释放内存\n\n描述：\n有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：\n```\n/** \nFree up the memory associated with thisbitmap's pixels, and mark the bitmap as \"dead\", meaning itwill throw an exception if getPixels() or setPixels() is called, and will drawnothing. This operation cannot be reversed, so it should only be called ifyou are sure there are no further uses for the bitmap. This is anadvanced call, and normally need not be called, since the normal GCprocess will free up this memory when there are no more references to thisbitmap. \n*/ \n```\n\n4.试着使用关于application的context来替代和activity相关的context\n\n这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免\nAndroid内存泄漏。\n\n5.注册没取消造成的内存泄漏\n\n一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。\n比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。\n但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。\n虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。\n\n6.集合中对象没清理造成的内存泄漏\n\n我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。\n\n#### **15.ANR定位和修正**\n\n如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。\n\n* 主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。\n* 主线程中存在耗时的计算\n* 主线程中错误的操作，比如Thread.wait或者Thread.sleep等\nAndroid系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框\n* 应用在5秒内未响应用户的输入事件（如按键或者触摸）\n* BroadcastReceiver未在10秒内完成相关的处理\n* Service在特定的时间内无法处理完成 20秒\n\n* 使用AsyncTask处理耗时IO操作。\n* 使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。\n* 使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。\n* Activity的onCreate和onResume回调中尽量避免耗时的代码\n* BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。\n\n\n#### **16.什么情况导致oom**（乐视、美团）\n\nhttp://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html\n\n1）使用更加轻量的数据结构\n2）Android里面使用Enum\n3）Bitmap对象的内存占用\n4）更大的图片\n5）onDraw方法里面执行对象的创建\n6）StringBuilder\n\n#### **17.Android Service与Activity之间通信的几种方式**\n\n* 通过Binder对象\n* 通过broadcast(广播)的形式\n\n#### **18.Android各个版本API的区别**\n\nhttp://blog.csdn.net/lijun952048910/article/details/7980562\n\n#### **19. Android代码中实现WAP方式联网**（360）\n\nhttp://blog.csdn.net/asce1885/article/details/7844159\n\n#### **20.如何保证service在后台不被kill**\n\n一、onStartCommand方法，返回START_STICKY\n\n1. START_STICKY\n在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。\n\n2. START_NOT_STICKY\n在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。\n\n3. START_REDELIVER_INTENT\n在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。\n\n二、提升service优先级\n\n在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = \"1000\"这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。\n\n三、提升service进程优先级\n\nAndroid中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是:\n\n1. 前台进程( FOREGROUND_APP)\n2. 可视进程(VISIBLE_APP )\n3. 次要服务进程(SECONDARY_SERVER )\n4. 后台进程 (HIDDEN_APP)\n5. 内容供应节点(CONTENT_PROVIDER)\n6. 空进程(EMPTY_APP)\n\n当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。\n\n四、onDestroy方法里重启service\n\nservice +broadcast  方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；\n\n五、Application加上Persistent属性\n\n六、监听系统广播判断Service状态\n\n通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。\n\n#### **21.Requestlayout，onlayout，onDraw，DrawChild区别与联系**（猎豹）\n\nrequestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。\n说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制\n任何视图包括该调用者本身。\n\nonLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局)\n\n调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)\n\ndrawChild()去重新回调每个子视图的draw()方法\n\n#### **22.invalidate()和postInvalidate() 的区别及使用**（百度）\n\nhttp://blog.csdn.net/mars2639/article/details/6650876\n\n#### **23.Android动画框架实现原理**\n\nAnimation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。\n\n#### **24.Android为每个应用程序分配的内存大小是多少？**（美团）\n\nandroid程序内存一般限制在16M，也有的是24M\n\n#### **25.Android View刷新机制**（百度、美团）\n\n由ViewRoot对象的performTraversals()方法调用draw()方法发起绘制该View树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。\n\n调用流程 ：\n\nmView.draw()开始绘制，draw()方法实现的功能如下：\n\n1. 绘制该View的背景\n2. 为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框)          \n3. 调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)\n4. 调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。\n\n#### **26.LinearLayout对比RelativeLayout**（百度）\n\n1. RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure\n2. RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。\n3. 在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。\n\n最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。\n\n#### **27.优化自定义view**（百度、乐视、小米）\n\n为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。\n\n你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。\n\n另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。\n\n如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。\n\n#### **28.ContentProvider**（乐视）\n\nhttp://blog.csdn.net/coder_pig/article/details/47858489\n\n#### **29.fragment生命周期**\n\n![](/img/article_img/2016/fragment-life.png)\n\n#### **30.volley解析**（美团、乐视）\n\nhttp://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\n\n#### **31.Android Glide源码解析**\n\nhttp://www.lightskystreet.com/2015/10/12/glide_source_analysis/\nhttp://frodoking.github.io/2015/10/10/android-glide/\n\n#### **32.Android 设计模式**\n\nhttp://blog.csdn.net/bboyfeiyu/article/details/44563871\n\n#### **33.架构设计**（搜狐）\n\n![](/img/article_img/2016/architucture.png)\n\nhttp://www.tianmaying.com/tutorial/AndroidMVC\n\n#### **34.Android属性动画特性**（乐视、小米）\n\n如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。\n\n注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。\n\n然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。\n\n最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。\n","source":"_posts/国内一线互联网公司内部面试题库(二)-android.md","raw":"---\ntitle: 【转】国内一线互联网公司内部面试题库(二)——android 篇\ndate: 2016-11-06 16:06:25\ncategories: [面试]\ntags: [android,面试]\n---\n本文转自：[国内一线互联网公司内部面试题库](https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md)\n国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库\n\n熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。\n下面是 android 部分\n<!--more-->\n\n#### **1.数据库的操作类型有哪些，如何导入外部数据库？**\n\n把原数据库包括在项目源码的 res/raw \n\nandroid系统下数据库应该存放在 /data/data/com.*.*（package name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录.\n\n#### **2.是否使用过本地广播，和全局广播有什么差别？**\n\n因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。\n不用担心别的应用伪造广播，造成安全隐患。\n相比在系统内发送全局广播，它更高效。\n\n#### **3.是否使用过intentService，作用是什么，AIDL解决了什么问题？**(小米)\n\n\n生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt。\n\n生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。\n\n该服务提供了一个onBind()方法的默认实现，它返回null\n\n提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。\n\nAIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。\nAIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。\n\n#### **4.Activity、Window、View三者的差别，fragment的特点？**（360）\n\nActivity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）\nLayoutInflater像剪刀，Xml配置像窗花图纸。\n\n1. 在Activity中调用attach，创建了一个Window\n2. 创建的window是其子类PhoneWindow，在attach中创建PhoneWindow\n3. 在Activity中调用setContentView(R.layout.xxx)\n4. 其中实际上是调用的getWindow().setContentView()\n5. 调用PhoneWindow中的setContentView方法\n6. 创建ParentView：作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）\n7. 将指定的R.layout.xxx进行填充通过布局填充器进行填充【其中的parent指的就是DecorView】\n8. 调用到ViewGroup\n9. 调用ViewGroup的removeAllView()，先将所有的view移除掉\n10. 添加新的view：addView()\n\n**fragment 特点**\n\n* Fragment可以作为Activity界面的一部分组成出现；\n* 可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用；\n* 在Activity运行过程中，可以添加、移除或者替换Fragment；\n* Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。\n\n#### **5.描述一次网络请求的流程**（新浪）\n\n![](/img/article_img/2016/http.png)\n\n#### **6.Handler、Thread和HandlerThread的差别**（小米）\n\nhttp://blog.csdn.net/guolin_blog/article/details/9991569\n\nhttp://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/\n\n从Android中Thread（java.lang.Thread -> java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -> java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。\n\nandroid.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也是就HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。\n\n#### **7.低版本SDK实现高版本api**（小米）\n\n自己实现或@TargetApi annotation\n\n#### **8.Ubuntu编译安卓系统**（百度）\n\n1. 进入源码根目录\n2. . build/envsetup.sh\n3. lunch\n4. full(编译全部)\n5. userdebug(选择编译版本)\n6. make -j8(开启8个线程编译)\n\n#### **9.launch mode应用场景**（百度、小米、乐视）\n\nstandard，创建一个新的Activity。\n\nsingleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。\n\nsingleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。\n\n注意:\n\n 1. 设置了\"singleTask\"启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在； 如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了\"singleTask\"启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。\n 2. 如果设置了\"singleTask\"启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。\n 3. 在一个任务栈中只有一个”singleTask”启动模式的Activity存在。他的上面可以有其他的Activity。这点与singleInstance是有区别的。\n\nsingleInstance，回退栈中，只有这一个Activity，没有其他Activity。\n\nsingleTop适合接收通知启动的内容显示页面。\n\n例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。\n\nsingleTask适合作为程序入口点。\n\n例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。\n\nsingleInstance应用场景：\n\n闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。\n\n#### **10.touch 事件传递流程**（小米）\n\nhttp://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/\n\n#### **11.view绘制流程**（百度）\n\nhttp://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f\n\n#### **12.多线程**（360）\n\n* Activity.runOnUiThread(Runnable)\n* View.post(Runnable),View.postDelay(Runnable,long)\n* Handler\n* AsyncTask\n\n#### **13.线程同步**（百度）\n\nhttp://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more\n\nhttp://www.juwends.com/tech/android/android-inter-thread-comm.html\n\n单例\n\n```\npublic class Singleton{\nprivate volatile static Singleton mSingleton;\nprivate Singleton(){\n}\npublic static Singleton getInstance(){\n  if(mSingleton == null){\\\\A\n    synchronized(Singleton.class){\\\\C\n     if(mSingleton == null)\n      mSingleton = new Singleton();\\\\B\n      }\n    }\n    return mSingleton;\n  }\n}\n```\n#### **14.什么情况导致内存泄漏**（美团）\n\n1.资源对象没关闭造成的内存泄漏\n\n描述：\n资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。\n程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。\n\n2.构造Adapter时，没有使用缓存的convertView\n\n描述：\n以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：\npublic View getView(int position, ViewconvertView, ViewGroup parent)\n来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看:\nandroid.widget.AbsListView.java --> voidaddScrapView(View scrap) 方法。\n示例代码：\n\n```\npublic View getView(int position, ViewconvertView, ViewGroup parent) {\nView view = new Xxx(...); \n... ... \nreturn view; \n} \n```\n\n修正示例代码：\n\n```\npublic View getView(int position, ViewconvertView, ViewGroup parent) {\nView view = null; \nif (convertView != null) { \nview = convertView; \npopulate(view, getItem(position)); \n... \n} else { \nview = new Xxx(...); \n... \n} \nreturn view; \n} \n```\n\n3.Bitmap对象不在使用时调用recycle()释放内存\n\n描述：\n有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：\n```\n/** \nFree up the memory associated with thisbitmap's pixels, and mark the bitmap as \"dead\", meaning itwill throw an exception if getPixels() or setPixels() is called, and will drawnothing. This operation cannot be reversed, so it should only be called ifyou are sure there are no further uses for the bitmap. This is anadvanced call, and normally need not be called, since the normal GCprocess will free up this memory when there are no more references to thisbitmap. \n*/ \n```\n\n4.试着使用关于application的context来替代和activity相关的context\n\n这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免\nAndroid内存泄漏。\n\n5.注册没取消造成的内存泄漏\n\n一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。\n比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。\n但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。\n虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。\n\n6.集合中对象没清理造成的内存泄漏\n\n我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。\n\n#### **15.ANR定位和修正**\n\n如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。\n\n* 主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。\n* 主线程中存在耗时的计算\n* 主线程中错误的操作，比如Thread.wait或者Thread.sleep等\nAndroid系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框\n* 应用在5秒内未响应用户的输入事件（如按键或者触摸）\n* BroadcastReceiver未在10秒内完成相关的处理\n* Service在特定的时间内无法处理完成 20秒\n\n* 使用AsyncTask处理耗时IO操作。\n* 使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。\n* 使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。\n* Activity的onCreate和onResume回调中尽量避免耗时的代码\n* BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。\n\n\n#### **16.什么情况导致oom**（乐视、美团）\n\nhttp://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html\n\n1）使用更加轻量的数据结构\n2）Android里面使用Enum\n3）Bitmap对象的内存占用\n4）更大的图片\n5）onDraw方法里面执行对象的创建\n6）StringBuilder\n\n#### **17.Android Service与Activity之间通信的几种方式**\n\n* 通过Binder对象\n* 通过broadcast(广播)的形式\n\n#### **18.Android各个版本API的区别**\n\nhttp://blog.csdn.net/lijun952048910/article/details/7980562\n\n#### **19. Android代码中实现WAP方式联网**（360）\n\nhttp://blog.csdn.net/asce1885/article/details/7844159\n\n#### **20.如何保证service在后台不被kill**\n\n一、onStartCommand方法，返回START_STICKY\n\n1. START_STICKY\n在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。\n\n2. START_NOT_STICKY\n在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。\n\n3. START_REDELIVER_INTENT\n在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。\n\n二、提升service优先级\n\n在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = \"1000\"这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。\n\n三、提升service进程优先级\n\nAndroid中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是:\n\n1. 前台进程( FOREGROUND_APP)\n2. 可视进程(VISIBLE_APP )\n3. 次要服务进程(SECONDARY_SERVER )\n4. 后台进程 (HIDDEN_APP)\n5. 内容供应节点(CONTENT_PROVIDER)\n6. 空进程(EMPTY_APP)\n\n当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。\n\n四、onDestroy方法里重启service\n\nservice +broadcast  方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；\n\n五、Application加上Persistent属性\n\n六、监听系统广播判断Service状态\n\n通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。\n\n#### **21.Requestlayout，onlayout，onDraw，DrawChild区别与联系**（猎豹）\n\nrequestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。\n说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制\n任何视图包括该调用者本身。\n\nonLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局)\n\n调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)\n\ndrawChild()去重新回调每个子视图的draw()方法\n\n#### **22.invalidate()和postInvalidate() 的区别及使用**（百度）\n\nhttp://blog.csdn.net/mars2639/article/details/6650876\n\n#### **23.Android动画框架实现原理**\n\nAnimation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。\n\n#### **24.Android为每个应用程序分配的内存大小是多少？**（美团）\n\nandroid程序内存一般限制在16M，也有的是24M\n\n#### **25.Android View刷新机制**（百度、美团）\n\n由ViewRoot对象的performTraversals()方法调用draw()方法发起绘制该View树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。\n\n调用流程 ：\n\nmView.draw()开始绘制，draw()方法实现的功能如下：\n\n1. 绘制该View的背景\n2. 为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框)          \n3. 调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)\n4. 调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。\n\n#### **26.LinearLayout对比RelativeLayout**（百度）\n\n1. RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure\n2. RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。\n3. 在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。\n\n最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。\n\n#### **27.优化自定义view**（百度、乐视、小米）\n\n为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。\n\n你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。\n\n另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。\n\n如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。\n\n#### **28.ContentProvider**（乐视）\n\nhttp://blog.csdn.net/coder_pig/article/details/47858489\n\n#### **29.fragment生命周期**\n\n![](/img/article_img/2016/fragment-life.png)\n\n#### **30.volley解析**（美团、乐视）\n\nhttp://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\n\n#### **31.Android Glide源码解析**\n\nhttp://www.lightskystreet.com/2015/10/12/glide_source_analysis/\nhttp://frodoking.github.io/2015/10/10/android-glide/\n\n#### **32.Android 设计模式**\n\nhttp://blog.csdn.net/bboyfeiyu/article/details/44563871\n\n#### **33.架构设计**（搜狐）\n\n![](/img/article_img/2016/architucture.png)\n\nhttp://www.tianmaying.com/tutorial/AndroidMVC\n\n#### **34.Android属性动画特性**（乐视、小米）\n\n如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。\n\n注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。\n\n然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。\n\n最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。\n","slug":"国内一线互联网公司内部面试题库(二)-android","published":1,"updated":"2016-11-07T12:02:56.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuckh004gg0g5cbwodtph","content":"<p>本文转自：<a href=\"https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md\" target=\"_blank\" rel=\"external\">国内一线互联网公司内部面试题库</a><br>国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库</p>\n<p>熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。<br>下面是 android 部分<br><a id=\"more\"></a></p>\n<h4 id=\"1-数据库的操作类型有哪些，如何导入外部数据库？\"><a href=\"#1-数据库的操作类型有哪些，如何导入外部数据库？\" class=\"headerlink\" title=\"1.数据库的操作类型有哪些，如何导入外部数据库？\"></a><strong>1.数据库的操作类型有哪些，如何导入外部数据库？</strong></h4><p>把原数据库包括在项目源码的 res/raw </p>\n<p>android系统下数据库应该存放在 /data/data/com.<em>.</em>（package name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录.</p>\n<h4 id=\"2-是否使用过本地广播，和全局广播有什么差别？\"><a href=\"#2-是否使用过本地广播，和全局广播有什么差别？\" class=\"headerlink\" title=\"2.是否使用过本地广播，和全局广播有什么差别？\"></a><strong>2.是否使用过本地广播，和全局广播有什么差别？</strong></h4><p>因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。<br>不用担心别的应用伪造广播，造成安全隐患。<br>相比在系统内发送全局广播，它更高效。</p>\n<h4 id=\"3-是否使用过intentService，作用是什么，AIDL解决了什么问题？-小米\"><a href=\"#3-是否使用过intentService，作用是什么，AIDL解决了什么问题？-小米\" class=\"headerlink\" title=\"3.是否使用过intentService，作用是什么，AIDL解决了什么问题？(小米)\"></a><strong>3.是否使用过intentService，作用是什么，AIDL解决了什么问题？</strong>(小米)</h4><p>生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt。</p>\n<p>生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。</p>\n<p>该服务提供了一个onBind()方法的默认实现，它返回null</p>\n<p>提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。</p>\n<p>AIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。<br>AIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。</p>\n<h4 id=\"4-Activity、Window、View三者的差别，fragment的特点？（360）\"><a href=\"#4-Activity、Window、View三者的差别，fragment的特点？（360）\" class=\"headerlink\" title=\"4.Activity、Window、View三者的差别，fragment的特点？（360）\"></a><strong>4.Activity、Window、View三者的差别，fragment的特点？</strong>（360）</h4><p>Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）<br>LayoutInflater像剪刀，Xml配置像窗花图纸。</p>\n<ol>\n<li>在Activity中调用attach，创建了一个Window</li>\n<li>创建的window是其子类PhoneWindow，在attach中创建PhoneWindow</li>\n<li>在Activity中调用setContentView(R.layout.xxx)</li>\n<li>其中实际上是调用的getWindow().setContentView()</li>\n<li>调用PhoneWindow中的setContentView方法</li>\n<li>创建ParentView：作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）</li>\n<li>将指定的R.layout.xxx进行填充通过布局填充器进行填充【其中的parent指的就是DecorView】</li>\n<li>调用到ViewGroup</li>\n<li>调用ViewGroup的removeAllView()，先将所有的view移除掉</li>\n<li>添加新的view：addView()</li>\n</ol>\n<p><strong>fragment 特点</strong></p>\n<ul>\n<li>Fragment可以作为Activity界面的一部分组成出现；</li>\n<li>可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用；</li>\n<li>在Activity运行过程中，可以添加、移除或者替换Fragment；</li>\n<li>Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。</li>\n</ul>\n<h4 id=\"5-描述一次网络请求的流程（新浪）\"><a href=\"#5-描述一次网络请求的流程（新浪）\" class=\"headerlink\" title=\"5.描述一次网络请求的流程（新浪）\"></a><strong>5.描述一次网络请求的流程</strong>（新浪）</h4><p><img src=\"/img/article_img/2016/http.png\" alt=\"\"></p>\n<h4 id=\"6-Handler、Thread和HandlerThread的差别（小米）\"><a href=\"#6-Handler、Thread和HandlerThread的差别（小米）\" class=\"headerlink\" title=\"6.Handler、Thread和HandlerThread的差别（小米）\"></a><strong>6.Handler、Thread和HandlerThread的差别</strong>（小米）</h4><p><a href=\"http://blog.csdn.net/guolin_blog/article/details/9991569\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p>\n<p><a href=\"http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/\" target=\"_blank\" rel=\"external\">http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/</a></p>\n<p>从Android中Thread（java.lang.Thread -&gt; java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -&gt; java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。</p>\n<p>android.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也是就HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。</p>\n<h4 id=\"7-低版本SDK实现高版本api（小米）\"><a href=\"#7-低版本SDK实现高版本api（小米）\" class=\"headerlink\" title=\"7.低版本SDK实现高版本api（小米）\"></a><strong>7.低版本SDK实现高版本api</strong>（小米）</h4><p>自己实现或@TargetApi annotation</p>\n<h4 id=\"8-Ubuntu编译安卓系统（百度）\"><a href=\"#8-Ubuntu编译安卓系统（百度）\" class=\"headerlink\" title=\"8.Ubuntu编译安卓系统（百度）\"></a><strong>8.Ubuntu编译安卓系统</strong>（百度）</h4><ol>\n<li>进入源码根目录</li>\n<li>. build/envsetup.sh</li>\n<li>lunch</li>\n<li>full(编译全部)</li>\n<li>userdebug(选择编译版本)</li>\n<li>make -j8(开启8个线程编译)</li>\n</ol>\n<h4 id=\"9-launch-mode应用场景（百度、小米、乐视）\"><a href=\"#9-launch-mode应用场景（百度、小米、乐视）\" class=\"headerlink\" title=\"9.launch mode应用场景（百度、小米、乐视）\"></a><strong>9.launch mode应用场景</strong>（百度、小米、乐视）</h4><p>standard，创建一个新的Activity。</p>\n<p>singleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。</p>\n<p>singleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。</p>\n<p>注意:</p>\n<ol>\n<li>设置了”singleTask”启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在； 如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了”singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。</li>\n<li>如果设置了”singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。</li>\n<li>在一个任务栈中只有一个”singleTask”启动模式的Activity存在。他的上面可以有其他的Activity。这点与singleInstance是有区别的。</li>\n</ol>\n<p>singleInstance，回退栈中，只有这一个Activity，没有其他Activity。</p>\n<p>singleTop适合接收通知启动的内容显示页面。</p>\n<p>例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。</p>\n<p>singleTask适合作为程序入口点。</p>\n<p>例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p>\n<p>singleInstance应用场景：</p>\n<p>闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。</p>\n<h4 id=\"10-touch-事件传递流程（小米）\"><a href=\"#10-touch-事件传递流程（小米）\" class=\"headerlink\" title=\"10.touch 事件传递流程（小米）\"></a><strong>10.touch 事件传递流程</strong>（小米）</h4><p><a href=\"http://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"external\">http://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</a></p>\n<h4 id=\"11-view绘制流程（百度）\"><a href=\"#11-view绘制流程（百度）\" class=\"headerlink\" title=\"11.view绘制流程（百度）\"></a><strong>11.view绘制流程</strong>（百度）</h4><p><a href=\"http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f\" target=\"_blank\" rel=\"external\">http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f</a></p>\n<h4 id=\"12-多线程（360）\"><a href=\"#12-多线程（360）\" class=\"headerlink\" title=\"12.多线程（360）\"></a><strong>12.多线程</strong>（360）</h4><ul>\n<li>Activity.runOnUiThread(Runnable)</li>\n<li>View.post(Runnable),View.postDelay(Runnable,long)</li>\n<li>Handler</li>\n<li>AsyncTask</li>\n</ul>\n<h4 id=\"13-线程同步（百度）\"><a href=\"#13-线程同步（百度）\" class=\"headerlink\" title=\"13.线程同步（百度）\"></a><strong>13.线程同步</strong>（百度）</h4><p><a href=\"http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more\" target=\"_blank\" rel=\"external\">http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more</a></p>\n<p><a href=\"http://www.juwends.com/tech/android/android-inter-thread-comm.html\" target=\"_blank\" rel=\"external\">http://www.juwends.com/tech/android/android-inter-thread-comm.html</a></p>\n<p>单例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton&#123;</span><br><span class=\"line\">private volatile static Singleton mSingleton;</span><br><span class=\"line\">private Singleton()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public static Singleton getInstance()&#123;</span><br><span class=\"line\">  if(mSingleton == null)&#123;\\\\A</span><br><span class=\"line\">    synchronized(Singleton.class)&#123;\\\\C</span><br><span class=\"line\">     if(mSingleton == null)</span><br><span class=\"line\">      mSingleton = new Singleton();\\\\B</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return mSingleton;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"14-什么情况导致内存泄漏（美团）\"><a href=\"#14-什么情况导致内存泄漏（美团）\" class=\"headerlink\" title=\"14.什么情况导致内存泄漏（美团）\"></a><strong>14.什么情况导致内存泄漏</strong>（美团）</h4><p>1.资源对象没关闭造成的内存泄漏</p>\n<p>描述：<br>资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。<br>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。</p>\n<p>2.构造Adapter时，没有使用缓存的convertView</p>\n<p>描述：<br>以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：<br>public View getView(int position, ViewconvertView, ViewGroup parent)<br>来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看:<br>android.widget.AbsListView.java –&gt; voidaddScrapView(View scrap) 方法。<br>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public View getView(int position, ViewconvertView, ViewGroup parent) &#123;</span><br><span class=\"line\">View view = new Xxx(...); </span><br><span class=\"line\">... ... </span><br><span class=\"line\">return view; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修正示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public View getView(int position, ViewconvertView, ViewGroup parent) &#123;</span><br><span class=\"line\">View view = null; </span><br><span class=\"line\">if (convertView != null) &#123; </span><br><span class=\"line\">view = convertView; </span><br><span class=\"line\">populate(view, getItem(position)); </span><br><span class=\"line\">... </span><br><span class=\"line\">&#125; else &#123; </span><br><span class=\"line\">view = new Xxx(...); </span><br><span class=\"line\">... </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">return view; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.Bitmap对象不在使用时调用recycle()释放内存</p>\n<p>描述：<br>有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** </span><br><span class=\"line\">Free up the memory associated with thisbitmap&apos;s pixels, and mark the bitmap as &quot;dead&quot;, meaning itwill throw an exception if getPixels() or setPixels() is called, and will drawnothing. This operation cannot be reversed, so it should only be called ifyou are sure there are no further uses for the bitmap. This is anadvanced call, and normally need not be called, since the normal GCprocess will free up this memory when there are no more references to thisbitmap. </span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n<p>4.试着使用关于application的context来替代和activity相关的context</p>\n<p>这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免<br>Android内存泄漏。</p>\n<p>5.注册没取消造成的内存泄漏</p>\n<p>一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。<br>比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。<br>但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。<br>虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。</p>\n<p>6.集合中对象没清理造成的内存泄漏</p>\n<p>我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。</p>\n<h4 id=\"15-ANR定位和修正\"><a href=\"#15-ANR定位和修正\" class=\"headerlink\" title=\"15.ANR定位和修正\"></a><strong>15.ANR定位和修正</strong></h4><p>如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。</p>\n<ul>\n<li>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。</li>\n<li>主线程中存在耗时的计算</li>\n<li>主线程中错误的操作，比如Thread.wait或者Thread.sleep等<br>Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框</li>\n<li>应用在5秒内未响应用户的输入事件（如按键或者触摸）</li>\n<li>BroadcastReceiver未在10秒内完成相关的处理</li>\n<li><p>Service在特定的时间内无法处理完成 20秒</p>\n</li>\n<li><p>使用AsyncTask处理耗时IO操作。</p>\n</li>\n<li>使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。</li>\n<li>使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。</li>\n<li>Activity的onCreate和onResume回调中尽量避免耗时的代码</li>\n<li>BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。</li>\n</ul>\n<h4 id=\"16-什么情况导致oom（乐视、美团）\"><a href=\"#16-什么情况导致oom（乐视、美团）\" class=\"headerlink\" title=\"16.什么情况导致oom（乐视、美团）\"></a><strong>16.什么情况导致oom</strong>（乐视、美团）</h4><p><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html\" target=\"_blank\" rel=\"external\">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html</a></p>\n<p>1）使用更加轻量的数据结构<br>2）Android里面使用Enum<br>3）Bitmap对象的内存占用<br>4）更大的图片<br>5）onDraw方法里面执行对象的创建<br>6）StringBuilder</p>\n<h4 id=\"17-Android-Service与Activity之间通信的几种方式\"><a href=\"#17-Android-Service与Activity之间通信的几种方式\" class=\"headerlink\" title=\"17.Android Service与Activity之间通信的几种方式\"></a><strong>17.Android Service与Activity之间通信的几种方式</strong></h4><ul>\n<li>通过Binder对象</li>\n<li>通过broadcast(广播)的形式</li>\n</ul>\n<h4 id=\"18-Android各个版本API的区别\"><a href=\"#18-Android各个版本API的区别\" class=\"headerlink\" title=\"18.Android各个版本API的区别\"></a><strong>18.Android各个版本API的区别</strong></h4><p><a href=\"http://blog.csdn.net/lijun952048910/article/details/7980562\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lijun952048910/article/details/7980562</a></p>\n<h4 id=\"19-Android代码中实现WAP方式联网（360）\"><a href=\"#19-Android代码中实现WAP方式联网（360）\" class=\"headerlink\" title=\"19. Android代码中实现WAP方式联网（360）\"></a><strong>19. Android代码中实现WAP方式联网</strong>（360）</h4><p><a href=\"http://blog.csdn.net/asce1885/article/details/7844159\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/asce1885/article/details/7844159</a></p>\n<h4 id=\"20-如何保证service在后台不被kill\"><a href=\"#20-如何保证service在后台不被kill\" class=\"headerlink\" title=\"20.如何保证service在后台不被kill\"></a><strong>20.如何保证service在后台不被kill</strong></h4><p>一、onStartCommand方法，返回START_STICKY</p>\n<ol>\n<li><p>START_STICKY<br>在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。</p>\n</li>\n<li><p>START_NOT_STICKY<br>在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。</p>\n</li>\n<li><p>START_REDELIVER_INTENT<br>在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。</p>\n</li>\n</ol>\n<p>二、提升service优先级</p>\n<p>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p>\n<p>三、提升service进程优先级</p>\n<p>Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是:</p>\n<ol>\n<li>前台进程( FOREGROUND_APP)</li>\n<li>可视进程(VISIBLE_APP )</li>\n<li>次要服务进程(SECONDARY_SERVER )</li>\n<li>后台进程 (HIDDEN_APP)</li>\n<li>内容供应节点(CONTENT_PROVIDER)</li>\n<li>空进程(EMPTY_APP)</li>\n</ol>\n<p>当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。</p>\n<p>四、onDestroy方法里重启service</p>\n<p>service +broadcast  方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；</p>\n<p>五、Application加上Persistent属性</p>\n<p>六、监听系统广播判断Service状态</p>\n<p>通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。</p>\n<h4 id=\"21-Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）\"><a href=\"#21-Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）\" class=\"headerlink\" title=\"21.Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）\"></a><strong>21.Requestlayout，onlayout，onDraw，DrawChild区别与联系</strong>（猎豹）</h4><p>requestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。<br>说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制<br>任何视图包括该调用者本身。</p>\n<p>onLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局)</p>\n<p>调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)</p>\n<p>drawChild()去重新回调每个子视图的draw()方法</p>\n<h4 id=\"22-invalidate-和postInvalidate-的区别及使用（百度）\"><a href=\"#22-invalidate-和postInvalidate-的区别及使用（百度）\" class=\"headerlink\" title=\"22.invalidate()和postInvalidate() 的区别及使用（百度）\"></a><strong>22.invalidate()和postInvalidate() 的区别及使用</strong>（百度）</h4><p><a href=\"http://blog.csdn.net/mars2639/article/details/6650876\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/mars2639/article/details/6650876</a></p>\n<h4 id=\"23-Android动画框架实现原理\"><a href=\"#23-Android动画框架实现原理\" class=\"headerlink\" title=\"23.Android动画框架实现原理\"></a><strong>23.Android动画框架实现原理</strong></h4><p>Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。</p>\n<h4 id=\"24-Android为每个应用程序分配的内存大小是多少？（美团）\"><a href=\"#24-Android为每个应用程序分配的内存大小是多少？（美团）\" class=\"headerlink\" title=\"24.Android为每个应用程序分配的内存大小是多少？（美团）\"></a><strong>24.Android为每个应用程序分配的内存大小是多少？</strong>（美团）</h4><p>android程序内存一般限制在16M，也有的是24M</p>\n<h4 id=\"25-Android-View刷新机制（百度、美团）\"><a href=\"#25-Android-View刷新机制（百度、美团）\" class=\"headerlink\" title=\"25.Android View刷新机制（百度、美团）\"></a><strong>25.Android View刷新机制</strong>（百度、美团）</h4><p>由ViewRoot对象的performTraversals()方法调用draw()方法发起绘制该View树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。</p>\n<p>调用流程 ：</p>\n<p>mView.draw()开始绘制，draw()方法实现的功能如下：</p>\n<ol>\n<li>绘制该View的背景</li>\n<li>为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框)          </li>\n<li>调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)</li>\n<li>调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。</li>\n</ol>\n<h4 id=\"26-LinearLayout对比RelativeLayout（百度）\"><a href=\"#26-LinearLayout对比RelativeLayout（百度）\" class=\"headerlink\" title=\"26.LinearLayout对比RelativeLayout（百度）\"></a><strong>26.LinearLayout对比RelativeLayout</strong>（百度）</h4><ol>\n<li>RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure</li>\n<li>RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。</li>\n<li>在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。</li>\n</ol>\n<p>最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。</p>\n<h4 id=\"27-优化自定义view（百度、乐视、小米）\"><a href=\"#27-优化自定义view（百度、乐视、小米）\" class=\"headerlink\" title=\"27.优化自定义view（百度、乐视、小米）\"></a><strong>27.优化自定义view</strong>（百度、乐视、小米）</h4><p>为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。</p>\n<p>你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。</p>\n<p>另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。</p>\n<p>如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。</p>\n<h4 id=\"28-ContentProvider（乐视）\"><a href=\"#28-ContentProvider（乐视）\" class=\"headerlink\" title=\"28.ContentProvider（乐视）\"></a><strong>28.ContentProvider</strong>（乐视）</h4><p><a href=\"http://blog.csdn.net/coder_pig/article/details/47858489\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/coder_pig/article/details/47858489</a></p>\n<h4 id=\"29-fragment生命周期\"><a href=\"#29-fragment生命周期\" class=\"headerlink\" title=\"29.fragment生命周期\"></a><strong>29.fragment生命周期</strong></h4><p><img src=\"/img/article_img/2016/fragment-life.png\" alt=\"\"></p>\n<h4 id=\"30-volley解析（美团、乐视）\"><a href=\"#30-volley解析（美团、乐视）\" class=\"headerlink\" title=\"30.volley解析（美团、乐视）\"></a><strong>30.volley解析</strong>（美团、乐视）</h4><p><a href=\"http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\" target=\"_blank\" rel=\"external\">http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</a></p>\n<h4 id=\"31-Android-Glide源码解析\"><a href=\"#31-Android-Glide源码解析\" class=\"headerlink\" title=\"31.Android Glide源码解析\"></a><strong>31.Android Glide源码解析</strong></h4><p><a href=\"http://www.lightskystreet.com/2015/10/12/glide_source_analysis/\" target=\"_blank\" rel=\"external\">http://www.lightskystreet.com/2015/10/12/glide_source_analysis/</a><br><a href=\"http://frodoking.github.io/2015/10/10/android-glide/\" target=\"_blank\" rel=\"external\">http://frodoking.github.io/2015/10/10/android-glide/</a></p>\n<h4 id=\"32-Android-设计模式\"><a href=\"#32-Android-设计模式\" class=\"headerlink\" title=\"32.Android 设计模式\"></a><strong>32.Android 设计模式</strong></h4><p><a href=\"http://blog.csdn.net/bboyfeiyu/article/details/44563871\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/bboyfeiyu/article/details/44563871</a></p>\n<h4 id=\"33-架构设计（搜狐）\"><a href=\"#33-架构设计（搜狐）\" class=\"headerlink\" title=\"33.架构设计（搜狐）\"></a><strong>33.架构设计</strong>（搜狐）</h4><p><img src=\"/img/article_img/2016/architucture.png\" alt=\"\"></p>\n<p><a href=\"http://www.tianmaying.com/tutorial/AndroidMVC\" target=\"_blank\" rel=\"external\">http://www.tianmaying.com/tutorial/AndroidMVC</a></p>\n<h4 id=\"34-Android属性动画特性（乐视、小米）\"><a href=\"#34-Android属性动画特性（乐视、小米）\" class=\"headerlink\" title=\"34.Android属性动画特性（乐视、小米）\"></a><strong>34.Android属性动画特性</strong>（乐视、小米）</h4><p>如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。</p>\n<p>注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。</p>\n<p>然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。</p>\n<p>最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。</p>\n","excerpt":"<p>本文转自：<a href=\"https://github.com/imtianx/AndroidInterview-Q-A/blob/master/README-CN.md\">国内一线互联网公司内部面试题库</a><br>国内一线互联网公司内部面试题库,以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库</p>\n<p>熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。<br>下面是 android 部分<br>","more":"</p>\n<h4 id=\"1-数据库的操作类型有哪些，如何导入外部数据库？\"><a href=\"#1-数据库的操作类型有哪些，如何导入外部数据库？\" class=\"headerlink\" title=\"1.数据库的操作类型有哪些，如何导入外部数据库？\"></a><strong>1.数据库的操作类型有哪些，如何导入外部数据库？</strong></h4><p>把原数据库包括在项目源码的 res/raw </p>\n<p>android系统下数据库应该存放在 /data/data/com.<em>.</em>（package name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录.</p>\n<h4 id=\"2-是否使用过本地广播，和全局广播有什么差别？\"><a href=\"#2-是否使用过本地广播，和全局广播有什么差别？\" class=\"headerlink\" title=\"2.是否使用过本地广播，和全局广播有什么差别？\"></a><strong>2.是否使用过本地广播，和全局广播有什么差别？</strong></h4><p>因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。<br>不用担心别的应用伪造广播，造成安全隐患。<br>相比在系统内发送全局广播，它更高效。</p>\n<h4 id=\"3-是否使用过intentService，作用是什么，AIDL解决了什么问题？-小米\"><a href=\"#3-是否使用过intentService，作用是什么，AIDL解决了什么问题？-小米\" class=\"headerlink\" title=\"3.是否使用过intentService，作用是什么，AIDL解决了什么问题？(小米)\"></a><strong>3.是否使用过intentService，作用是什么，AIDL解决了什么问题？</strong>(小米)</h4><p>生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt。</p>\n<p>生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。</p>\n<p>该服务提供了一个onBind()方法的默认实现，它返回null</p>\n<p>提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。</p>\n<p>AIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。<br>AIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。</p>\n<h4 id=\"4-Activity、Window、View三者的差别，fragment的特点？（360）\"><a href=\"#4-Activity、Window、View三者的差别，fragment的特点？（360）\" class=\"headerlink\" title=\"4.Activity、Window、View三者的差别，fragment的特点？（360）\"></a><strong>4.Activity、Window、View三者的差别，fragment的特点？</strong>（360）</h4><p>Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）<br>LayoutInflater像剪刀，Xml配置像窗花图纸。</p>\n<ol>\n<li>在Activity中调用attach，创建了一个Window</li>\n<li>创建的window是其子类PhoneWindow，在attach中创建PhoneWindow</li>\n<li>在Activity中调用setContentView(R.layout.xxx)</li>\n<li>其中实际上是调用的getWindow().setContentView()</li>\n<li>调用PhoneWindow中的setContentView方法</li>\n<li>创建ParentView：作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）</li>\n<li>将指定的R.layout.xxx进行填充通过布局填充器进行填充【其中的parent指的就是DecorView】</li>\n<li>调用到ViewGroup</li>\n<li>调用ViewGroup的removeAllView()，先将所有的view移除掉</li>\n<li>添加新的view：addView()</li>\n</ol>\n<p><strong>fragment 特点</strong></p>\n<ul>\n<li>Fragment可以作为Activity界面的一部分组成出现；</li>\n<li>可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用；</li>\n<li>在Activity运行过程中，可以添加、移除或者替换Fragment；</li>\n<li>Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。</li>\n</ul>\n<h4 id=\"5-描述一次网络请求的流程（新浪）\"><a href=\"#5-描述一次网络请求的流程（新浪）\" class=\"headerlink\" title=\"5.描述一次网络请求的流程（新浪）\"></a><strong>5.描述一次网络请求的流程</strong>（新浪）</h4><p><img src=\"/img/article_img/2016/http.png\" alt=\"\"></p>\n<h4 id=\"6-Handler、Thread和HandlerThread的差别（小米）\"><a href=\"#6-Handler、Thread和HandlerThread的差别（小米）\" class=\"headerlink\" title=\"6.Handler、Thread和HandlerThread的差别（小米）\"></a><strong>6.Handler、Thread和HandlerThread的差别</strong>（小米）</h4><p><a href=\"http://blog.csdn.net/guolin_blog/article/details/9991569\">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p>\n<p><a href=\"http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/\">http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/</a></p>\n<p>从Android中Thread（java.lang.Thread -&gt; java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -&gt; java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。</p>\n<p>android.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也是就HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。</p>\n<h4 id=\"7-低版本SDK实现高版本api（小米）\"><a href=\"#7-低版本SDK实现高版本api（小米）\" class=\"headerlink\" title=\"7.低版本SDK实现高版本api（小米）\"></a><strong>7.低版本SDK实现高版本api</strong>（小米）</h4><p>自己实现或@TargetApi annotation</p>\n<h4 id=\"8-Ubuntu编译安卓系统（百度）\"><a href=\"#8-Ubuntu编译安卓系统（百度）\" class=\"headerlink\" title=\"8.Ubuntu编译安卓系统（百度）\"></a><strong>8.Ubuntu编译安卓系统</strong>（百度）</h4><ol>\n<li>进入源码根目录</li>\n<li>. build/envsetup.sh</li>\n<li>lunch</li>\n<li>full(编译全部)</li>\n<li>userdebug(选择编译版本)</li>\n<li>make -j8(开启8个线程编译)</li>\n</ol>\n<h4 id=\"9-launch-mode应用场景（百度、小米、乐视）\"><a href=\"#9-launch-mode应用场景（百度、小米、乐视）\" class=\"headerlink\" title=\"9.launch mode应用场景（百度、小米、乐视）\"></a><strong>9.launch mode应用场景</strong>（百度、小米、乐视）</h4><p>standard，创建一个新的Activity。</p>\n<p>singleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。</p>\n<p>singleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。</p>\n<p>注意:</p>\n<ol>\n<li>设置了”singleTask”启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在； 如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了”singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。</li>\n<li>如果设置了”singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。</li>\n<li>在一个任务栈中只有一个”singleTask”启动模式的Activity存在。他的上面可以有其他的Activity。这点与singleInstance是有区别的。</li>\n</ol>\n<p>singleInstance，回退栈中，只有这一个Activity，没有其他Activity。</p>\n<p>singleTop适合接收通知启动的内容显示页面。</p>\n<p>例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。</p>\n<p>singleTask适合作为程序入口点。</p>\n<p>例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p>\n<p>singleInstance应用场景：</p>\n<p>闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。</p>\n<h4 id=\"10-touch-事件传递流程（小米）\"><a href=\"#10-touch-事件传递流程（小米）\" class=\"headerlink\" title=\"10.touch 事件传递流程（小米）\"></a><strong>10.touch 事件传递流程</strong>（小米）</h4><p><a href=\"http://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/\">http://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</a></p>\n<h4 id=\"11-view绘制流程（百度）\"><a href=\"#11-view绘制流程（百度）\" class=\"headerlink\" title=\"11.view绘制流程（百度）\"></a><strong>11.view绘制流程</strong>（百度）</h4><p><a href=\"http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f\">http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f</a></p>\n<h4 id=\"12-多线程（360）\"><a href=\"#12-多线程（360）\" class=\"headerlink\" title=\"12.多线程（360）\"></a><strong>12.多线程</strong>（360）</h4><ul>\n<li>Activity.runOnUiThread(Runnable)</li>\n<li>View.post(Runnable),View.postDelay(Runnable,long)</li>\n<li>Handler</li>\n<li>AsyncTask</li>\n</ul>\n<h4 id=\"13-线程同步（百度）\"><a href=\"#13-线程同步（百度）\" class=\"headerlink\" title=\"13.线程同步（百度）\"></a><strong>13.线程同步</strong>（百度）</h4><p><a href=\"http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more\">http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more</a></p>\n<p><a href=\"http://www.juwends.com/tech/android/android-inter-thread-comm.html\">http://www.juwends.com/tech/android/android-inter-thread-comm.html</a></p>\n<p>单例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton&#123;</span><br><span class=\"line\">private volatile static Singleton mSingleton;</span><br><span class=\"line\">private Singleton()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public static Singleton getInstance()&#123;</span><br><span class=\"line\">  if(mSingleton == null)&#123;\\\\A</span><br><span class=\"line\">    synchronized(Singleton.class)&#123;\\\\C</span><br><span class=\"line\">     if(mSingleton == null)</span><br><span class=\"line\">      mSingleton = new Singleton();\\\\B</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return mSingleton;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"14-什么情况导致内存泄漏（美团）\"><a href=\"#14-什么情况导致内存泄漏（美团）\" class=\"headerlink\" title=\"14.什么情况导致内存泄漏（美团）\"></a><strong>14.什么情况导致内存泄漏</strong>（美团）</h4><p>1.资源对象没关闭造成的内存泄漏</p>\n<p>描述：<br>资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。<br>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。</p>\n<p>2.构造Adapter时，没有使用缓存的convertView</p>\n<p>描述：<br>以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：<br>public View getView(int position, ViewconvertView, ViewGroup parent)<br>来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看:<br>android.widget.AbsListView.java –&gt; voidaddScrapView(View scrap) 方法。<br>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public View getView(int position, ViewconvertView, ViewGroup parent) &#123;</span><br><span class=\"line\">View view = new Xxx(...); </span><br><span class=\"line\">... ... </span><br><span class=\"line\">return view; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修正示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public View getView(int position, ViewconvertView, ViewGroup parent) &#123;</span><br><span class=\"line\">View view = null; </span><br><span class=\"line\">if (convertView != null) &#123; </span><br><span class=\"line\">view = convertView; </span><br><span class=\"line\">populate(view, getItem(position)); </span><br><span class=\"line\">... </span><br><span class=\"line\">&#125; else &#123; </span><br><span class=\"line\">view = new Xxx(...); </span><br><span class=\"line\">... </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">return view; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.Bitmap对象不在使用时调用recycle()释放内存</p>\n<p>描述：<br>有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** </span><br><span class=\"line\">Free up the memory associated with thisbitmap&apos;s pixels, and mark the bitmap as &quot;dead&quot;, meaning itwill throw an exception if getPixels() or setPixels() is called, and will drawnothing. This operation cannot be reversed, so it should only be called ifyou are sure there are no further uses for the bitmap. This is anadvanced call, and normally need not be called, since the normal GCprocess will free up this memory when there are no more references to thisbitmap. </span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n<p>4.试着使用关于application的context来替代和activity相关的context</p>\n<p>这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免<br>Android内存泄漏。</p>\n<p>5.注册没取消造成的内存泄漏</p>\n<p>一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。<br>比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。<br>但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。<br>虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。</p>\n<p>6.集合中对象没清理造成的内存泄漏</p>\n<p>我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。</p>\n<h4 id=\"15-ANR定位和修正\"><a href=\"#15-ANR定位和修正\" class=\"headerlink\" title=\"15.ANR定位和修正\"></a><strong>15.ANR定位和修正</strong></h4><p>如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。</p>\n<ul>\n<li>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。</li>\n<li>主线程中存在耗时的计算</li>\n<li>主线程中错误的操作，比如Thread.wait或者Thread.sleep等<br>Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框</li>\n<li>应用在5秒内未响应用户的输入事件（如按键或者触摸）</li>\n<li>BroadcastReceiver未在10秒内完成相关的处理</li>\n<li><p>Service在特定的时间内无法处理完成 20秒</p>\n</li>\n<li><p>使用AsyncTask处理耗时IO操作。</p>\n</li>\n<li>使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。</li>\n<li>使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。</li>\n<li>Activity的onCreate和onResume回调中尽量避免耗时的代码</li>\n<li>BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。</li>\n</ul>\n<h4 id=\"16-什么情况导致oom（乐视、美团）\"><a href=\"#16-什么情况导致oom（乐视、美团）\" class=\"headerlink\" title=\"16.什么情况导致oom（乐视、美团）\"></a><strong>16.什么情况导致oom</strong>（乐视、美团）</h4><p><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html\">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html</a></p>\n<p>1）使用更加轻量的数据结构<br>2）Android里面使用Enum<br>3）Bitmap对象的内存占用<br>4）更大的图片<br>5）onDraw方法里面执行对象的创建<br>6）StringBuilder</p>\n<h4 id=\"17-Android-Service与Activity之间通信的几种方式\"><a href=\"#17-Android-Service与Activity之间通信的几种方式\" class=\"headerlink\" title=\"17.Android Service与Activity之间通信的几种方式\"></a><strong>17.Android Service与Activity之间通信的几种方式</strong></h4><ul>\n<li>通过Binder对象</li>\n<li>通过broadcast(广播)的形式</li>\n</ul>\n<h4 id=\"18-Android各个版本API的区别\"><a href=\"#18-Android各个版本API的区别\" class=\"headerlink\" title=\"18.Android各个版本API的区别\"></a><strong>18.Android各个版本API的区别</strong></h4><p><a href=\"http://blog.csdn.net/lijun952048910/article/details/7980562\">http://blog.csdn.net/lijun952048910/article/details/7980562</a></p>\n<h4 id=\"19-Android代码中实现WAP方式联网（360）\"><a href=\"#19-Android代码中实现WAP方式联网（360）\" class=\"headerlink\" title=\"19. Android代码中实现WAP方式联网（360）\"></a><strong>19. Android代码中实现WAP方式联网</strong>（360）</h4><p><a href=\"http://blog.csdn.net/asce1885/article/details/7844159\">http://blog.csdn.net/asce1885/article/details/7844159</a></p>\n<h4 id=\"20-如何保证service在后台不被kill\"><a href=\"#20-如何保证service在后台不被kill\" class=\"headerlink\" title=\"20.如何保证service在后台不被kill\"></a><strong>20.如何保证service在后台不被kill</strong></h4><p>一、onStartCommand方法，返回START_STICKY</p>\n<ol>\n<li><p>START_STICKY<br>在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。</p>\n</li>\n<li><p>START_NOT_STICKY<br>在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。</p>\n</li>\n<li><p>START_REDELIVER_INTENT<br>在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。</p>\n</li>\n</ol>\n<p>二、提升service优先级</p>\n<p>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p>\n<p>三、提升service进程优先级</p>\n<p>Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是:</p>\n<ol>\n<li>前台进程( FOREGROUND_APP)</li>\n<li>可视进程(VISIBLE_APP )</li>\n<li>次要服务进程(SECONDARY_SERVER )</li>\n<li>后台进程 (HIDDEN_APP)</li>\n<li>内容供应节点(CONTENT_PROVIDER)</li>\n<li>空进程(EMPTY_APP)</li>\n</ol>\n<p>当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。</p>\n<p>四、onDestroy方法里重启service</p>\n<p>service +broadcast  方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；</p>\n<p>五、Application加上Persistent属性</p>\n<p>六、监听系统广播判断Service状态</p>\n<p>通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。</p>\n<h4 id=\"21-Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）\"><a href=\"#21-Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）\" class=\"headerlink\" title=\"21.Requestlayout，onlayout，onDraw，DrawChild区别与联系（猎豹）\"></a><strong>21.Requestlayout，onlayout，onDraw，DrawChild区别与联系</strong>（猎豹）</h4><p>requestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。<br>说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制<br>任何视图包括该调用者本身。</p>\n<p>onLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局)</p>\n<p>调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)</p>\n<p>drawChild()去重新回调每个子视图的draw()方法</p>\n<h4 id=\"22-invalidate-和postInvalidate-的区别及使用（百度）\"><a href=\"#22-invalidate-和postInvalidate-的区别及使用（百度）\" class=\"headerlink\" title=\"22.invalidate()和postInvalidate() 的区别及使用（百度）\"></a><strong>22.invalidate()和postInvalidate() 的区别及使用</strong>（百度）</h4><p><a href=\"http://blog.csdn.net/mars2639/article/details/6650876\">http://blog.csdn.net/mars2639/article/details/6650876</a></p>\n<h4 id=\"23-Android动画框架实现原理\"><a href=\"#23-Android动画框架实现原理\" class=\"headerlink\" title=\"23.Android动画框架实现原理\"></a><strong>23.Android动画框架实现原理</strong></h4><p>Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。</p>\n<h4 id=\"24-Android为每个应用程序分配的内存大小是多少？（美团）\"><a href=\"#24-Android为每个应用程序分配的内存大小是多少？（美团）\" class=\"headerlink\" title=\"24.Android为每个应用程序分配的内存大小是多少？（美团）\"></a><strong>24.Android为每个应用程序分配的内存大小是多少？</strong>（美团）</h4><p>android程序内存一般限制在16M，也有的是24M</p>\n<h4 id=\"25-Android-View刷新机制（百度、美团）\"><a href=\"#25-Android-View刷新机制（百度、美团）\" class=\"headerlink\" title=\"25.Android View刷新机制（百度、美团）\"></a><strong>25.Android View刷新机制</strong>（百度、美团）</h4><p>由ViewRoot对象的performTraversals()方法调用draw()方法发起绘制该View树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。</p>\n<p>调用流程 ：</p>\n<p>mView.draw()开始绘制，draw()方法实现的功能如下：</p>\n<ol>\n<li>绘制该View的背景</li>\n<li>为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框)          </li>\n<li>调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)</li>\n<li>调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。</li>\n</ol>\n<h4 id=\"26-LinearLayout对比RelativeLayout（百度）\"><a href=\"#26-LinearLayout对比RelativeLayout（百度）\" class=\"headerlink\" title=\"26.LinearLayout对比RelativeLayout（百度）\"></a><strong>26.LinearLayout对比RelativeLayout</strong>（百度）</h4><ol>\n<li>RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure</li>\n<li>RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。</li>\n<li>在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。</li>\n</ol>\n<p>最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。</p>\n<h4 id=\"27-优化自定义view（百度、乐视、小米）\"><a href=\"#27-优化自定义view（百度、乐视、小米）\" class=\"headerlink\" title=\"27.优化自定义view（百度、乐视、小米）\"></a><strong>27.优化自定义view</strong>（百度、乐视、小米）</h4><p>为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。</p>\n<p>你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。</p>\n<p>另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。</p>\n<p>如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。</p>\n<h4 id=\"28-ContentProvider（乐视）\"><a href=\"#28-ContentProvider（乐视）\" class=\"headerlink\" title=\"28.ContentProvider（乐视）\"></a><strong>28.ContentProvider</strong>（乐视）</h4><p><a href=\"http://blog.csdn.net/coder_pig/article/details/47858489\">http://blog.csdn.net/coder_pig/article/details/47858489</a></p>\n<h4 id=\"29-fragment生命周期\"><a href=\"#29-fragment生命周期\" class=\"headerlink\" title=\"29.fragment生命周期\"></a><strong>29.fragment生命周期</strong></h4><p><img src=\"/img/article_img/2016/fragment-life.png\" alt=\"\"></p>\n<h4 id=\"30-volley解析（美团、乐视）\"><a href=\"#30-volley解析（美团、乐视）\" class=\"headerlink\" title=\"30.volley解析（美团、乐视）\"></a><strong>30.volley解析</strong>（美团、乐视）</h4><p><a href=\"http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\">http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</a></p>\n<h4 id=\"31-Android-Glide源码解析\"><a href=\"#31-Android-Glide源码解析\" class=\"headerlink\" title=\"31.Android Glide源码解析\"></a><strong>31.Android Glide源码解析</strong></h4><p><a href=\"http://www.lightskystreet.com/2015/10/12/glide_source_analysis/\">http://www.lightskystreet.com/2015/10/12/glide_source_analysis/</a><br><a href=\"http://frodoking.github.io/2015/10/10/android-glide/\">http://frodoking.github.io/2015/10/10/android-glide/</a></p>\n<h4 id=\"32-Android-设计模式\"><a href=\"#32-Android-设计模式\" class=\"headerlink\" title=\"32.Android 设计模式\"></a><strong>32.Android 设计模式</strong></h4><p><a href=\"http://blog.csdn.net/bboyfeiyu/article/details/44563871\">http://blog.csdn.net/bboyfeiyu/article/details/44563871</a></p>\n<h4 id=\"33-架构设计（搜狐）\"><a href=\"#33-架构设计（搜狐）\" class=\"headerlink\" title=\"33.架构设计（搜狐）\"></a><strong>33.架构设计</strong>（搜狐）</h4><p><img src=\"/img/article_img/2016/architucture.png\" alt=\"\"></p>\n<p><a href=\"http://www.tianmaying.com/tutorial/AndroidMVC\">http://www.tianmaying.com/tutorial/AndroidMVC</a></p>\n<h4 id=\"34-Android属性动画特性（乐视、小米）\"><a href=\"#34-Android属性动画特性（乐视、小米）\" class=\"headerlink\" title=\"34.Android属性动画特性（乐视、小米）\"></a><strong>34.Android属性动画特性</strong>（乐视、小米）</h4><p>如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。</p>\n<p>注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。</p>\n<p>然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。</p>\n<p>最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。</p>"},{"title":"天盾app项目总结","date":"2016-10-23T13:48:25.000Z","_content":"\n经过几个星期的努力，天盾app2.0版正式发布。再次记录下自己在开发中遇到的问题：\n\n 1. 拍照图片oom\n 2. listview 图片错位\n 3. xutils 数据库的使用与升级\n<!--more-->\n\n### 1. 拍照显示图片oom\n由于该app中有快递单的采集，用RecyclerView 展示，并且每条可能需要拍照录入三张图片，这些图片需要显示并保存到文件便于上传。\n目前，各个各个手机拍照后生成的图片比较大，分辨率也很高，直接显示很容易出现oom,使用BitmapFactory创建bitmap显示图片，每次使用都会分配内存，通过设置它的**采样率**，以避免。通过使用下面的工具类来加载图片：\n```\npublic class BitmapUtil {\nprivate static final boolean DEBUG = false;\nprivate static final String TAG = BitmapUtil.class.getSimpleName();\n\nprivate BitmapUtil() {\n    throw new Error(\"Do not need instantiate!\");\n}\n\n/**\n * 图片压缩处理（使用Options的方法）\n * <p/>\n * @param reqWidth  目标宽度\n * @param reqHeight 目标高度\n */\npublic static BitmapFactory.Options calculateInSampleSize(\n        final BitmapFactory.Options options, final int reqWidth,\n        final int reqHeight) {\n    // 源图片的高度和宽度\n    final int height = options.outHeight;\n    final int width = options.outWidth;\n    int inSampleSize = 1;\n    if (height > 400 || width > 450) {\n        if (height > reqHeight || width > reqWidth) {\n            // 计算出实际宽高和目标宽高的比率\n            final int heightRatio = Math.round((float) height\n                    / (float) reqHeight);\n            final int widthRatio = Math.round((float) width\n                    / (float) reqWidth);\n            // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高\n            // 一定都会大于等于目标的宽和高。\n            inSampleSize = heightRatio < widthRatio ? heightRatio\n                    : widthRatio;\n        }\n    }\n    // 设置压缩比例\n    options.inSampleSize = inSampleSize;\n    options.inJustDecodeBounds = false;\n    return options;\n}\n\n\n\n/**\n * 获取一个指定大小的bitmap\n *\n * @param reqWidth  目标宽度\n * @param reqHeight 目标高度\n */\npublic static Bitmap getBitmapFromFile(String pathName, int reqWidth,\n                                       int reqHeight) {\n    BitmapFactory.Options options = new BitmapFactory.Options();\n    options.inJustDecodeBounds = true;\n    BitmapFactory.decodeFile(pathName, options);\n    options = calculateInSampleSize(options, reqWidth, reqHeight);\n    return BitmapFactory.decodeFile(pathName, options);\n}\n}\n```\n这里只列出了计算采样率和从文件中加载显示的方法，如需了解更多该工具，请[点击此处查看](https://github.com/l123456789jy/Lazy/blob/master/lazylibrary/src/main/java/com/github/lazylibrary/util/BitmapUtil.java)\n具体使用如下：\n```\nint width = mImageView.getWidth();\nint height = mImageView.getHeight();\n//picPath 为图片存储路径\nmImageView.setImageBitmap(BitmapUtil.getBitmapFromFile(picPath, width, height));\n```\n进过测试，连续拍照10多张并显示，内存的消耗物明显变化，大约有2M的多动，测试手机为Nexus 6,至此，oom完美解决，性能也十分好。\n\n### 2. Listview 加载网络图片错位\n在app登陆前，需要选择相应的快递和分部，而快递列表的设计是显示快递图片和快递公司名称，该部分数据是由网络获取的，展示在listView中。当图片地址为空时，无图片的item就会显示其他的图片，而且随着屏幕的滚动而变化，出现错位的现象。这种情况**主要是由于ListView适配器 中getView的convertView复用导致的，解决办法是为imageview设置tag标记，这里以图片的url作为标记。**如下，getView的代码：\n```\n@Override\npublic View getView(int position, View convertView, ViewGroup parent) {\n    ViewHolder holder;\n    if (convertView == null) {\n        convertView = LayoutInflater.from(parent.getContext())\n                .inflate(R.layout.list_item_express, parent, false);\n        holder = new ViewHolder(convertView);\n        convertView.setTag(holder);\n    } else {\n        holder = (ViewHolder) convertView.getTag();\n    }\n\n    String imgUrl = mDatas.get(position).getExpressIco();\n    holder.imgExpressIcon.setTag(imgUrl);\n\n\t//这里注意图片地址的判断，被 \"\" 坑了好久\n    if (holder.imgExpressIcon.getTag() == null || holder.imgExpressIcon.getTag().equals(\"\")) {\n\t\t//若无网络图片，显示错误图片\n        holder.imgExpressIcon.setImageResource(R.drawable.express_error);\n    } else if (holder.imgExpressIcon.getTag().equals(imgUrl)) {\n        x.image().bind(holder.imgExpressIcon, Constants.BASE_URL + imgUrl);\n    }\n    holder.tvExpressName.setText(mDatas.get(position).getExpressName());\n\n    return convertView;\n}\n```\n\n### 3. xutils3 数据库的使用与升级\n为了节省流量，将采集的数据保存在本地，便于在wifi情况下同一上传，只有该功能需要数据库，加上项目中使用的有xutils，带有数据库模块，便没有自己写或者使用 GreenDao，Ralem等其他的数据库框架。\n此处简单的记录下改数据库框架的使用。\n\n- 在Application中配置\n在自己的application类（或者使用的activity）中添加配置信息，这里为了方便，在Application类中添加，并通过单利类访问使用。\n如下部分代码：\n```\npublic class SNApplication extends Application {\n\n    private static DbManager.DaoConfig mDaoConfig = null;\n\n    /**\n     * 获取数据库配置对象\n     *\n     * @return\n     */\n    public static DbManager.DaoConfig getDaoConfig() {\n        if (mDaoConfig == null) {\n            mDaoConfig = new DbManager.DaoConfig()\n                    .setDbName(\"ygjexpress.db\")\n                    .setDbVersion(2)\n                    .setDbOpenListener(new DbManager.DbOpenListener() {\n                        @Override\n                        public void onDbOpened(DbManager db) {\n                            // 开启WAL, 提升写入速度\n                            db.getDatabase().enableWriteAheadLogging();\n                        }\n                    })\n                    .setDbUpgradeListener(new DbManager.DbUpgradeListener() {\n                        @Override\n                        public void onUpgrade(DbManager db, int oldVersion, int newVersion) {\n                            //升级数据库\n                            try {\n\t\t\t\t\t\t\t\t//添加 user_id ，避免同一手机登陆多个账号出现数据混乱\n                                db.addColumn(PickupDbItem.class,\"user_id\");\n                            } catch (DbException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                    });\n\n        }\n        return mDaoConfig;\n    }\n}\n```\n- 创建数据表对应的实体类\n通过注解，来指定数据表名（Table）和字段名（Column），isId 指定是否为id,property设置是否唯一。\n```\n@Table(name = \"pickup_item\")\npublic class PickupDbItem {\n    @Column(name = \"id\", isId = true)\n    private int id;\n    @Column(name = \"sender_idcrad_id\")\n    private String senderIdcradID;//身份证id\n    @Column(name = \"express_no\")\n    private String expressNo;//快递编号\n    @Column(name = \"pic_bale_before\")\n    private String picBaleBefore;//打包前\n    @Column(name = \"pic_bale_after\")\n    private String picBaleAfter;//打包后图片\n    @Column(name = \"pic_bale_complete\")\n    private String picBaleComplete;//贴快递单后图片\n\n    @Column(name = \"user_id\")\n    private String userId; //当前登录的用户id\n\n   //此处省略构造方法和getter和setter方法\n```\n- 具体的使用\n```\n//获取数据库配置\nprivate static DbManager mDbManager = x.getDb(SNApplication.getDaoConfig());\n//插入一条\n mDbManager.save(pickupDbItem);\n //查找-条\n pickupDbItem = mDbManager.selector(PickupDbItem.class)\n                        .where(\"express_no\", \"=\", expressNo)\n                        .findFirst();\n//查找所有\nmDbManager.selector(PickupDbItem.class).findAll();\n//更新三个字段\n mDbManager.update(pickupDbItem, \"sender_idcrad_id\", \"pic_bale_before\", \"pic_bale_after\", \"pic_bale_complete\");\n //删除\n mDbManager.delete(pickupDbItem);\n```\n用法很简单，负责的查询条件可以使用`WhereBuilder`类来构造。更多的请参见[此处](https://github.com/imtianx/xUtils3/blob/master/sample/src/main/java/org/xutils/sample/DbFragment.java)。\n\n-  数据库的升级\n\n在配置文件中**增加版本号，在 setDbUpgradeListener 中的 onUpgrade 方法中添加或删除列，最后在实体中添加相应的字段即可**。\n\n项目比较小，遇到的问题也就这些，需要查看该app的，请访问[内测平台](https://www.pgyer.com/ygjexpress)\n\n\n","source":"_posts/天盾app项目总结.md","raw":"---\ntitle: 天盾app项目总结\ndate: 2016-010-23 21:48:25\ncategories: [android,项目总结]\ntags: [拍照oom,图片错位,xutils3]\n---\n\n经过几个星期的努力，天盾app2.0版正式发布。再次记录下自己在开发中遇到的问题：\n\n 1. 拍照图片oom\n 2. listview 图片错位\n 3. xutils 数据库的使用与升级\n<!--more-->\n\n### 1. 拍照显示图片oom\n由于该app中有快递单的采集，用RecyclerView 展示，并且每条可能需要拍照录入三张图片，这些图片需要显示并保存到文件便于上传。\n目前，各个各个手机拍照后生成的图片比较大，分辨率也很高，直接显示很容易出现oom,使用BitmapFactory创建bitmap显示图片，每次使用都会分配内存，通过设置它的**采样率**，以避免。通过使用下面的工具类来加载图片：\n```\npublic class BitmapUtil {\nprivate static final boolean DEBUG = false;\nprivate static final String TAG = BitmapUtil.class.getSimpleName();\n\nprivate BitmapUtil() {\n    throw new Error(\"Do not need instantiate!\");\n}\n\n/**\n * 图片压缩处理（使用Options的方法）\n * <p/>\n * @param reqWidth  目标宽度\n * @param reqHeight 目标高度\n */\npublic static BitmapFactory.Options calculateInSampleSize(\n        final BitmapFactory.Options options, final int reqWidth,\n        final int reqHeight) {\n    // 源图片的高度和宽度\n    final int height = options.outHeight;\n    final int width = options.outWidth;\n    int inSampleSize = 1;\n    if (height > 400 || width > 450) {\n        if (height > reqHeight || width > reqWidth) {\n            // 计算出实际宽高和目标宽高的比率\n            final int heightRatio = Math.round((float) height\n                    / (float) reqHeight);\n            final int widthRatio = Math.round((float) width\n                    / (float) reqWidth);\n            // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高\n            // 一定都会大于等于目标的宽和高。\n            inSampleSize = heightRatio < widthRatio ? heightRatio\n                    : widthRatio;\n        }\n    }\n    // 设置压缩比例\n    options.inSampleSize = inSampleSize;\n    options.inJustDecodeBounds = false;\n    return options;\n}\n\n\n\n/**\n * 获取一个指定大小的bitmap\n *\n * @param reqWidth  目标宽度\n * @param reqHeight 目标高度\n */\npublic static Bitmap getBitmapFromFile(String pathName, int reqWidth,\n                                       int reqHeight) {\n    BitmapFactory.Options options = new BitmapFactory.Options();\n    options.inJustDecodeBounds = true;\n    BitmapFactory.decodeFile(pathName, options);\n    options = calculateInSampleSize(options, reqWidth, reqHeight);\n    return BitmapFactory.decodeFile(pathName, options);\n}\n}\n```\n这里只列出了计算采样率和从文件中加载显示的方法，如需了解更多该工具，请[点击此处查看](https://github.com/l123456789jy/Lazy/blob/master/lazylibrary/src/main/java/com/github/lazylibrary/util/BitmapUtil.java)\n具体使用如下：\n```\nint width = mImageView.getWidth();\nint height = mImageView.getHeight();\n//picPath 为图片存储路径\nmImageView.setImageBitmap(BitmapUtil.getBitmapFromFile(picPath, width, height));\n```\n进过测试，连续拍照10多张并显示，内存的消耗物明显变化，大约有2M的多动，测试手机为Nexus 6,至此，oom完美解决，性能也十分好。\n\n### 2. Listview 加载网络图片错位\n在app登陆前，需要选择相应的快递和分部，而快递列表的设计是显示快递图片和快递公司名称，该部分数据是由网络获取的，展示在listView中。当图片地址为空时，无图片的item就会显示其他的图片，而且随着屏幕的滚动而变化，出现错位的现象。这种情况**主要是由于ListView适配器 中getView的convertView复用导致的，解决办法是为imageview设置tag标记，这里以图片的url作为标记。**如下，getView的代码：\n```\n@Override\npublic View getView(int position, View convertView, ViewGroup parent) {\n    ViewHolder holder;\n    if (convertView == null) {\n        convertView = LayoutInflater.from(parent.getContext())\n                .inflate(R.layout.list_item_express, parent, false);\n        holder = new ViewHolder(convertView);\n        convertView.setTag(holder);\n    } else {\n        holder = (ViewHolder) convertView.getTag();\n    }\n\n    String imgUrl = mDatas.get(position).getExpressIco();\n    holder.imgExpressIcon.setTag(imgUrl);\n\n\t//这里注意图片地址的判断，被 \"\" 坑了好久\n    if (holder.imgExpressIcon.getTag() == null || holder.imgExpressIcon.getTag().equals(\"\")) {\n\t\t//若无网络图片，显示错误图片\n        holder.imgExpressIcon.setImageResource(R.drawable.express_error);\n    } else if (holder.imgExpressIcon.getTag().equals(imgUrl)) {\n        x.image().bind(holder.imgExpressIcon, Constants.BASE_URL + imgUrl);\n    }\n    holder.tvExpressName.setText(mDatas.get(position).getExpressName());\n\n    return convertView;\n}\n```\n\n### 3. xutils3 数据库的使用与升级\n为了节省流量，将采集的数据保存在本地，便于在wifi情况下同一上传，只有该功能需要数据库，加上项目中使用的有xutils，带有数据库模块，便没有自己写或者使用 GreenDao，Ralem等其他的数据库框架。\n此处简单的记录下改数据库框架的使用。\n\n- 在Application中配置\n在自己的application类（或者使用的activity）中添加配置信息，这里为了方便，在Application类中添加，并通过单利类访问使用。\n如下部分代码：\n```\npublic class SNApplication extends Application {\n\n    private static DbManager.DaoConfig mDaoConfig = null;\n\n    /**\n     * 获取数据库配置对象\n     *\n     * @return\n     */\n    public static DbManager.DaoConfig getDaoConfig() {\n        if (mDaoConfig == null) {\n            mDaoConfig = new DbManager.DaoConfig()\n                    .setDbName(\"ygjexpress.db\")\n                    .setDbVersion(2)\n                    .setDbOpenListener(new DbManager.DbOpenListener() {\n                        @Override\n                        public void onDbOpened(DbManager db) {\n                            // 开启WAL, 提升写入速度\n                            db.getDatabase().enableWriteAheadLogging();\n                        }\n                    })\n                    .setDbUpgradeListener(new DbManager.DbUpgradeListener() {\n                        @Override\n                        public void onUpgrade(DbManager db, int oldVersion, int newVersion) {\n                            //升级数据库\n                            try {\n\t\t\t\t\t\t\t\t//添加 user_id ，避免同一手机登陆多个账号出现数据混乱\n                                db.addColumn(PickupDbItem.class,\"user_id\");\n                            } catch (DbException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                    });\n\n        }\n        return mDaoConfig;\n    }\n}\n```\n- 创建数据表对应的实体类\n通过注解，来指定数据表名（Table）和字段名（Column），isId 指定是否为id,property设置是否唯一。\n```\n@Table(name = \"pickup_item\")\npublic class PickupDbItem {\n    @Column(name = \"id\", isId = true)\n    private int id;\n    @Column(name = \"sender_idcrad_id\")\n    private String senderIdcradID;//身份证id\n    @Column(name = \"express_no\")\n    private String expressNo;//快递编号\n    @Column(name = \"pic_bale_before\")\n    private String picBaleBefore;//打包前\n    @Column(name = \"pic_bale_after\")\n    private String picBaleAfter;//打包后图片\n    @Column(name = \"pic_bale_complete\")\n    private String picBaleComplete;//贴快递单后图片\n\n    @Column(name = \"user_id\")\n    private String userId; //当前登录的用户id\n\n   //此处省略构造方法和getter和setter方法\n```\n- 具体的使用\n```\n//获取数据库配置\nprivate static DbManager mDbManager = x.getDb(SNApplication.getDaoConfig());\n//插入一条\n mDbManager.save(pickupDbItem);\n //查找-条\n pickupDbItem = mDbManager.selector(PickupDbItem.class)\n                        .where(\"express_no\", \"=\", expressNo)\n                        .findFirst();\n//查找所有\nmDbManager.selector(PickupDbItem.class).findAll();\n//更新三个字段\n mDbManager.update(pickupDbItem, \"sender_idcrad_id\", \"pic_bale_before\", \"pic_bale_after\", \"pic_bale_complete\");\n //删除\n mDbManager.delete(pickupDbItem);\n```\n用法很简单，负责的查询条件可以使用`WhereBuilder`类来构造。更多的请参见[此处](https://github.com/imtianx/xUtils3/blob/master/sample/src/main/java/org/xutils/sample/DbFragment.java)。\n\n-  数据库的升级\n\n在配置文件中**增加版本号，在 setDbUpgradeListener 中的 onUpgrade 方法中添加或删除列，最后在实体中添加相应的字段即可**。\n\n项目比较小，遇到的问题也就这些，需要查看该app的，请访问[内测平台](https://www.pgyer.com/ygjexpress)\n\n\n","slug":"天盾app项目总结","published":1,"updated":"2016-10-23T13:56:24.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0opuckh004kg0g59iwpjtxv","content":"<p>经过几个星期的努力，天盾app2.0版正式发布。再次记录下自己在开发中遇到的问题：</p>\n<ol>\n<li>拍照图片oom</li>\n<li>listview 图片错位</li>\n<li>xutils 数据库的使用与升级<a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"1-拍照显示图片oom\"><a href=\"#1-拍照显示图片oom\" class=\"headerlink\" title=\"1. 拍照显示图片oom\"></a>1. 拍照显示图片oom</h3><p>由于该app中有快递单的采集，用RecyclerView 展示，并且每条可能需要拍照录入三张图片，这些图片需要显示并保存到文件便于上传。<br>目前，各个各个手机拍照后生成的图片比较大，分辨率也很高，直接显示很容易出现oom,使用BitmapFactory创建bitmap显示图片，每次使用都会分配内存，通过设置它的<strong>采样率</strong>，以避免。通过使用下面的工具类来加载图片：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BitmapUtil &#123;</span><br><span class=\"line\">private static final boolean DEBUG = false;</span><br><span class=\"line\">private static final String TAG = BitmapUtil.class.getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">private BitmapUtil() &#123;</span><br><span class=\"line\">    throw new Error(&quot;Do not need instantiate!&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 图片压缩处理（使用Options的方法）</span><br><span class=\"line\"> * &lt;p/&gt;</span><br><span class=\"line\"> * @param reqWidth  目标宽度</span><br><span class=\"line\"> * @param reqHeight 目标高度</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static BitmapFactory.Options calculateInSampleSize(</span><br><span class=\"line\">        final BitmapFactory.Options options, final int reqWidth,</span><br><span class=\"line\">        final int reqHeight) &#123;</span><br><span class=\"line\">    // 源图片的高度和宽度</span><br><span class=\"line\">    final int height = options.outHeight;</span><br><span class=\"line\">    final int width = options.outWidth;</span><br><span class=\"line\">    int inSampleSize = 1;</span><br><span class=\"line\">    if (height &gt; 400 || width &gt; 450) &#123;</span><br><span class=\"line\">        if (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class=\"line\">            // 计算出实际宽高和目标宽高的比率</span><br><span class=\"line\">            final int heightRatio = Math.round((float) height</span><br><span class=\"line\">                    / (float) reqHeight);</span><br><span class=\"line\">            final int widthRatio = Math.round((float) width</span><br><span class=\"line\">                    / (float) reqWidth);</span><br><span class=\"line\">            // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高</span><br><span class=\"line\">            // 一定都会大于等于目标的宽和高。</span><br><span class=\"line\">            inSampleSize = heightRatio &lt; widthRatio ? heightRatio</span><br><span class=\"line\">                    : widthRatio;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 设置压缩比例</span><br><span class=\"line\">    options.inSampleSize = inSampleSize;</span><br><span class=\"line\">    options.inJustDecodeBounds = false;</span><br><span class=\"line\">    return options;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 获取一个指定大小的bitmap</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param reqWidth  目标宽度</span><br><span class=\"line\"> * @param reqHeight 目标高度</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static Bitmap getBitmapFromFile(String pathName, int reqWidth,</span><br><span class=\"line\">                                       int reqHeight) &#123;</span><br><span class=\"line\">    BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class=\"line\">    options.inJustDecodeBounds = true;</span><br><span class=\"line\">    BitmapFactory.decodeFile(pathName, options);</span><br><span class=\"line\">    options = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class=\"line\">    return BitmapFactory.decodeFile(pathName, options);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里只列出了计算采样率和从文件中加载显示的方法，如需了解更多该工具，请<a href=\"https://github.com/l123456789jy/Lazy/blob/master/lazylibrary/src/main/java/com/github/lazylibrary/util/BitmapUtil.java\" target=\"_blank\" rel=\"external\">点击此处查看</a><br>具体使用如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int width = mImageView.getWidth();</span><br><span class=\"line\">int height = mImageView.getHeight();</span><br><span class=\"line\">//picPath 为图片存储路径</span><br><span class=\"line\">mImageView.setImageBitmap(BitmapUtil.getBitmapFromFile(picPath, width, height));</span><br></pre></td></tr></table></figure></p>\n<p>进过测试，连续拍照10多张并显示，内存的消耗物明显变化，大约有2M的多动，测试手机为Nexus 6,至此，oom完美解决，性能也十分好。</p>\n<h3 id=\"2-Listview-加载网络图片错位\"><a href=\"#2-Listview-加载网络图片错位\" class=\"headerlink\" title=\"2. Listview 加载网络图片错位\"></a>2. Listview 加载网络图片错位</h3><p>在app登陆前，需要选择相应的快递和分部，而快递列表的设计是显示快递图片和快递公司名称，该部分数据是由网络获取的，展示在listView中。当图片地址为空时，无图片的item就会显示其他的图片，而且随着屏幕的滚动而变化，出现错位的现象。这种情况<strong>主要是由于ListView适配器 中getView的convertView复用导致的，解决办法是为imageview设置tag标记，这里以图片的url作为标记。</strong>如下，getView的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class=\"line\">    ViewHolder holder;</span><br><span class=\"line\">    if (convertView == null) &#123;</span><br><span class=\"line\">        convertView = LayoutInflater.from(parent.getContext())</span><br><span class=\"line\">                .inflate(R.layout.list_item_express, parent, false);</span><br><span class=\"line\">        holder = new ViewHolder(convertView);</span><br><span class=\"line\">        convertView.setTag(holder);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        holder = (ViewHolder) convertView.getTag();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String imgUrl = mDatas.get(position).getExpressIco();</span><br><span class=\"line\">    holder.imgExpressIcon.setTag(imgUrl);</span><br><span class=\"line\"></span><br><span class=\"line\">\t//这里注意图片地址的判断，被 &quot;&quot; 坑了好久</span><br><span class=\"line\">    if (holder.imgExpressIcon.getTag() == null || holder.imgExpressIcon.getTag().equals(&quot;&quot;)) &#123;</span><br><span class=\"line\">\t\t//若无网络图片，显示错误图片</span><br><span class=\"line\">        holder.imgExpressIcon.setImageResource(R.drawable.express_error);</span><br><span class=\"line\">    &#125; else if (holder.imgExpressIcon.getTag().equals(imgUrl)) &#123;</span><br><span class=\"line\">        x.image().bind(holder.imgExpressIcon, Constants.BASE_URL + imgUrl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    holder.tvExpressName.setText(mDatas.get(position).getExpressName());</span><br><span class=\"line\"></span><br><span class=\"line\">    return convertView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-xutils3-数据库的使用与升级\"><a href=\"#3-xutils3-数据库的使用与升级\" class=\"headerlink\" title=\"3. xutils3 数据库的使用与升级\"></a>3. xutils3 数据库的使用与升级</h3><p>为了节省流量，将采集的数据保存在本地，便于在wifi情况下同一上传，只有该功能需要数据库，加上项目中使用的有xutils，带有数据库模块，便没有自己写或者使用 GreenDao，Ralem等其他的数据库框架。<br>此处简单的记录下改数据库框架的使用。</p>\n<ul>\n<li><p>在Application中配置<br>在自己的application类（或者使用的activity）中添加配置信息，这里为了方便，在Application类中添加，并通过单利类访问使用。<br>如下部分代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SNApplication extends Application &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static DbManager.DaoConfig mDaoConfig = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取数据库配置对象</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static DbManager.DaoConfig getDaoConfig() &#123;</span><br><span class=\"line\">        if (mDaoConfig == null) &#123;</span><br><span class=\"line\">            mDaoConfig = new DbManager.DaoConfig()</span><br><span class=\"line\">                    .setDbName(&quot;ygjexpress.db&quot;)</span><br><span class=\"line\">                    .setDbVersion(2)</span><br><span class=\"line\">                    .setDbOpenListener(new DbManager.DbOpenListener() &#123;</span><br><span class=\"line\">                        @Override</span><br><span class=\"line\">                        public void onDbOpened(DbManager db) &#123;</span><br><span class=\"line\">                            // 开启WAL, 提升写入速度</span><br><span class=\"line\">                            db.getDatabase().enableWriteAheadLogging();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                    .setDbUpgradeListener(new DbManager.DbUpgradeListener() &#123;</span><br><span class=\"line\">                        @Override</span><br><span class=\"line\">                        public void onUpgrade(DbManager db, int oldVersion, int newVersion) &#123;</span><br><span class=\"line\">                            //升级数据库</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t//添加 user_id ，避免同一手机登陆多个账号出现数据混乱</span><br><span class=\"line\">                                db.addColumn(PickupDbItem.class,&quot;user_id&quot;);</span><br><span class=\"line\">                            &#125; catch (DbException e) &#123;</span><br><span class=\"line\">                                e.printStackTrace();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return mDaoConfig;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建数据表对应的实体类<br>通过注解，来指定数据表名（Table）和字段名（Column），isId 指定是否为id,property设置是否唯一。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Table(name = &quot;pickup_item&quot;)</span><br><span class=\"line\">public class PickupDbItem &#123;</span><br><span class=\"line\">    @Column(name = &quot;id&quot;, isId = true)</span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    @Column(name = &quot;sender_idcrad_id&quot;)</span><br><span class=\"line\">    private String senderIdcradID;//身份证id</span><br><span class=\"line\">    @Column(name = &quot;express_no&quot;)</span><br><span class=\"line\">    private String expressNo;//快递编号</span><br><span class=\"line\">    @Column(name = &quot;pic_bale_before&quot;)</span><br><span class=\"line\">    private String picBaleBefore;//打包前</span><br><span class=\"line\">    @Column(name = &quot;pic_bale_after&quot;)</span><br><span class=\"line\">    private String picBaleAfter;//打包后图片</span><br><span class=\"line\">    @Column(name = &quot;pic_bale_complete&quot;)</span><br><span class=\"line\">    private String picBaleComplete;//贴快递单后图片</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(name = &quot;user_id&quot;)</span><br><span class=\"line\">    private String userId; //当前登录的用户id</span><br><span class=\"line\"></span><br><span class=\"line\">   //此处省略构造方法和getter和setter方法</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>具体的使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取数据库配置</span><br><span class=\"line\">private static DbManager mDbManager = x.getDb(SNApplication.getDaoConfig());</span><br><span class=\"line\">//插入一条</span><br><span class=\"line\"> mDbManager.save(pickupDbItem);</span><br><span class=\"line\"> //查找-条</span><br><span class=\"line\"> pickupDbItem = mDbManager.selector(PickupDbItem.class)</span><br><span class=\"line\">                        .where(&quot;express_no&quot;, &quot;=&quot;, expressNo)</span><br><span class=\"line\">                        .findFirst();</span><br><span class=\"line\">//查找所有</span><br><span class=\"line\">mDbManager.selector(PickupDbItem.class).findAll();</span><br><span class=\"line\">//更新三个字段</span><br><span class=\"line\"> mDbManager.update(pickupDbItem, &quot;sender_idcrad_id&quot;, &quot;pic_bale_before&quot;, &quot;pic_bale_after&quot;, &quot;pic_bale_complete&quot;);</span><br><span class=\"line\"> //删除</span><br><span class=\"line\"> mDbManager.delete(pickupDbItem);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>用法很简单，负责的查询条件可以使用<code>WhereBuilder</code>类来构造。更多的请参见<a href=\"https://github.com/imtianx/xUtils3/blob/master/sample/src/main/java/org/xutils/sample/DbFragment.java\" target=\"_blank\" rel=\"external\">此处</a>。</p>\n<ul>\n<li>数据库的升级</li>\n</ul>\n<p>在配置文件中<strong>增加版本号，在 setDbUpgradeListener 中的 onUpgrade 方法中添加或删除列，最后在实体中添加相应的字段即可</strong>。</p>\n<p>项目比较小，遇到的问题也就这些，需要查看该app的，请访问<a href=\"https://www.pgyer.com/ygjexpress\" target=\"_blank\" rel=\"external\">内测平台</a></p>\n","excerpt":"<p>经过几个星期的努力，天盾app2.0版正式发布。再次记录下自己在开发中遇到的问题：</p>\n<ol>\n<li>拍照图片oom</li>\n<li>listview 图片错位</li>\n<li>xutils 数据库的使用与升级","more":"</li>\n</ol>\n<h3 id=\"1-拍照显示图片oom\"><a href=\"#1-拍照显示图片oom\" class=\"headerlink\" title=\"1. 拍照显示图片oom\"></a>1. 拍照显示图片oom</h3><p>由于该app中有快递单的采集，用RecyclerView 展示，并且每条可能需要拍照录入三张图片，这些图片需要显示并保存到文件便于上传。<br>目前，各个各个手机拍照后生成的图片比较大，分辨率也很高，直接显示很容易出现oom,使用BitmapFactory创建bitmap显示图片，每次使用都会分配内存，通过设置它的<strong>采样率</strong>，以避免。通过使用下面的工具类来加载图片：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BitmapUtil &#123;</span><br><span class=\"line\">private static final boolean DEBUG = false;</span><br><span class=\"line\">private static final String TAG = BitmapUtil.class.getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">private BitmapUtil() &#123;</span><br><span class=\"line\">    throw new Error(&quot;Do not need instantiate!&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 图片压缩处理（使用Options的方法）</span><br><span class=\"line\"> * &lt;p/&gt;</span><br><span class=\"line\"> * @param reqWidth  目标宽度</span><br><span class=\"line\"> * @param reqHeight 目标高度</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static BitmapFactory.Options calculateInSampleSize(</span><br><span class=\"line\">        final BitmapFactory.Options options, final int reqWidth,</span><br><span class=\"line\">        final int reqHeight) &#123;</span><br><span class=\"line\">    // 源图片的高度和宽度</span><br><span class=\"line\">    final int height = options.outHeight;</span><br><span class=\"line\">    final int width = options.outWidth;</span><br><span class=\"line\">    int inSampleSize = 1;</span><br><span class=\"line\">    if (height &gt; 400 || width &gt; 450) &#123;</span><br><span class=\"line\">        if (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class=\"line\">            // 计算出实际宽高和目标宽高的比率</span><br><span class=\"line\">            final int heightRatio = Math.round((float) height</span><br><span class=\"line\">                    / (float) reqHeight);</span><br><span class=\"line\">            final int widthRatio = Math.round((float) width</span><br><span class=\"line\">                    / (float) reqWidth);</span><br><span class=\"line\">            // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高</span><br><span class=\"line\">            // 一定都会大于等于目标的宽和高。</span><br><span class=\"line\">            inSampleSize = heightRatio &lt; widthRatio ? heightRatio</span><br><span class=\"line\">                    : widthRatio;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 设置压缩比例</span><br><span class=\"line\">    options.inSampleSize = inSampleSize;</span><br><span class=\"line\">    options.inJustDecodeBounds = false;</span><br><span class=\"line\">    return options;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 获取一个指定大小的bitmap</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param reqWidth  目标宽度</span><br><span class=\"line\"> * @param reqHeight 目标高度</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static Bitmap getBitmapFromFile(String pathName, int reqWidth,</span><br><span class=\"line\">                                       int reqHeight) &#123;</span><br><span class=\"line\">    BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class=\"line\">    options.inJustDecodeBounds = true;</span><br><span class=\"line\">    BitmapFactory.decodeFile(pathName, options);</span><br><span class=\"line\">    options = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class=\"line\">    return BitmapFactory.decodeFile(pathName, options);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里只列出了计算采样率和从文件中加载显示的方法，如需了解更多该工具，请<a href=\"https://github.com/l123456789jy/Lazy/blob/master/lazylibrary/src/main/java/com/github/lazylibrary/util/BitmapUtil.java\">点击此处查看</a><br>具体使用如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int width = mImageView.getWidth();</span><br><span class=\"line\">int height = mImageView.getHeight();</span><br><span class=\"line\">//picPath 为图片存储路径</span><br><span class=\"line\">mImageView.setImageBitmap(BitmapUtil.getBitmapFromFile(picPath, width, height));</span><br></pre></td></tr></table></figure></p>\n<p>进过测试，连续拍照10多张并显示，内存的消耗物明显变化，大约有2M的多动，测试手机为Nexus 6,至此，oom完美解决，性能也十分好。</p>\n<h3 id=\"2-Listview-加载网络图片错位\"><a href=\"#2-Listview-加载网络图片错位\" class=\"headerlink\" title=\"2. Listview 加载网络图片错位\"></a>2. Listview 加载网络图片错位</h3><p>在app登陆前，需要选择相应的快递和分部，而快递列表的设计是显示快递图片和快递公司名称，该部分数据是由网络获取的，展示在listView中。当图片地址为空时，无图片的item就会显示其他的图片，而且随着屏幕的滚动而变化，出现错位的现象。这种情况<strong>主要是由于ListView适配器 中getView的convertView复用导致的，解决办法是为imageview设置tag标记，这里以图片的url作为标记。</strong>如下，getView的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class=\"line\">    ViewHolder holder;</span><br><span class=\"line\">    if (convertView == null) &#123;</span><br><span class=\"line\">        convertView = LayoutInflater.from(parent.getContext())</span><br><span class=\"line\">                .inflate(R.layout.list_item_express, parent, false);</span><br><span class=\"line\">        holder = new ViewHolder(convertView);</span><br><span class=\"line\">        convertView.setTag(holder);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        holder = (ViewHolder) convertView.getTag();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String imgUrl = mDatas.get(position).getExpressIco();</span><br><span class=\"line\">    holder.imgExpressIcon.setTag(imgUrl);</span><br><span class=\"line\"></span><br><span class=\"line\">\t//这里注意图片地址的判断，被 &quot;&quot; 坑了好久</span><br><span class=\"line\">    if (holder.imgExpressIcon.getTag() == null || holder.imgExpressIcon.getTag().equals(&quot;&quot;)) &#123;</span><br><span class=\"line\">\t\t//若无网络图片，显示错误图片</span><br><span class=\"line\">        holder.imgExpressIcon.setImageResource(R.drawable.express_error);</span><br><span class=\"line\">    &#125; else if (holder.imgExpressIcon.getTag().equals(imgUrl)) &#123;</span><br><span class=\"line\">        x.image().bind(holder.imgExpressIcon, Constants.BASE_URL + imgUrl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    holder.tvExpressName.setText(mDatas.get(position).getExpressName());</span><br><span class=\"line\"></span><br><span class=\"line\">    return convertView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-xutils3-数据库的使用与升级\"><a href=\"#3-xutils3-数据库的使用与升级\" class=\"headerlink\" title=\"3. xutils3 数据库的使用与升级\"></a>3. xutils3 数据库的使用与升级</h3><p>为了节省流量，将采集的数据保存在本地，便于在wifi情况下同一上传，只有该功能需要数据库，加上项目中使用的有xutils，带有数据库模块，便没有自己写或者使用 GreenDao，Ralem等其他的数据库框架。<br>此处简单的记录下改数据库框架的使用。</p>\n<ul>\n<li><p>在Application中配置<br>在自己的application类（或者使用的activity）中添加配置信息，这里为了方便，在Application类中添加，并通过单利类访问使用。<br>如下部分代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SNApplication extends Application &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static DbManager.DaoConfig mDaoConfig = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取数据库配置对象</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static DbManager.DaoConfig getDaoConfig() &#123;</span><br><span class=\"line\">        if (mDaoConfig == null) &#123;</span><br><span class=\"line\">            mDaoConfig = new DbManager.DaoConfig()</span><br><span class=\"line\">                    .setDbName(&quot;ygjexpress.db&quot;)</span><br><span class=\"line\">                    .setDbVersion(2)</span><br><span class=\"line\">                    .setDbOpenListener(new DbManager.DbOpenListener() &#123;</span><br><span class=\"line\">                        @Override</span><br><span class=\"line\">                        public void onDbOpened(DbManager db) &#123;</span><br><span class=\"line\">                            // 开启WAL, 提升写入速度</span><br><span class=\"line\">                            db.getDatabase().enableWriteAheadLogging();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                    .setDbUpgradeListener(new DbManager.DbUpgradeListener() &#123;</span><br><span class=\"line\">                        @Override</span><br><span class=\"line\">                        public void onUpgrade(DbManager db, int oldVersion, int newVersion) &#123;</span><br><span class=\"line\">                            //升级数据库</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t//添加 user_id ，避免同一手机登陆多个账号出现数据混乱</span><br><span class=\"line\">                                db.addColumn(PickupDbItem.class,&quot;user_id&quot;);</span><br><span class=\"line\">                            &#125; catch (DbException e) &#123;</span><br><span class=\"line\">                                e.printStackTrace();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return mDaoConfig;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建数据表对应的实体类<br>通过注解，来指定数据表名（Table）和字段名（Column），isId 指定是否为id,property设置是否唯一。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Table(name = &quot;pickup_item&quot;)</span><br><span class=\"line\">public class PickupDbItem &#123;</span><br><span class=\"line\">    @Column(name = &quot;id&quot;, isId = true)</span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    @Column(name = &quot;sender_idcrad_id&quot;)</span><br><span class=\"line\">    private String senderIdcradID;//身份证id</span><br><span class=\"line\">    @Column(name = &quot;express_no&quot;)</span><br><span class=\"line\">    private String expressNo;//快递编号</span><br><span class=\"line\">    @Column(name = &quot;pic_bale_before&quot;)</span><br><span class=\"line\">    private String picBaleBefore;//打包前</span><br><span class=\"line\">    @Column(name = &quot;pic_bale_after&quot;)</span><br><span class=\"line\">    private String picBaleAfter;//打包后图片</span><br><span class=\"line\">    @Column(name = &quot;pic_bale_complete&quot;)</span><br><span class=\"line\">    private String picBaleComplete;//贴快递单后图片</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(name = &quot;user_id&quot;)</span><br><span class=\"line\">    private String userId; //当前登录的用户id</span><br><span class=\"line\"></span><br><span class=\"line\">   //此处省略构造方法和getter和setter方法</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>具体的使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取数据库配置</span><br><span class=\"line\">private static DbManager mDbManager = x.getDb(SNApplication.getDaoConfig());</span><br><span class=\"line\">//插入一条</span><br><span class=\"line\"> mDbManager.save(pickupDbItem);</span><br><span class=\"line\"> //查找-条</span><br><span class=\"line\"> pickupDbItem = mDbManager.selector(PickupDbItem.class)</span><br><span class=\"line\">                        .where(&quot;express_no&quot;, &quot;=&quot;, expressNo)</span><br><span class=\"line\">                        .findFirst();</span><br><span class=\"line\">//查找所有</span><br><span class=\"line\">mDbManager.selector(PickupDbItem.class).findAll();</span><br><span class=\"line\">//更新三个字段</span><br><span class=\"line\"> mDbManager.update(pickupDbItem, &quot;sender_idcrad_id&quot;, &quot;pic_bale_before&quot;, &quot;pic_bale_after&quot;, &quot;pic_bale_complete&quot;);</span><br><span class=\"line\"> //删除</span><br><span class=\"line\"> mDbManager.delete(pickupDbItem);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>用法很简单，负责的查询条件可以使用<code>WhereBuilder</code>类来构造。更多的请参见<a href=\"https://github.com/imtianx/xUtils3/blob/master/sample/src/main/java/org/xutils/sample/DbFragment.java\">此处</a>。</p>\n<ul>\n<li>数据库的升级</li>\n</ul>\n<p>在配置文件中<strong>增加版本号，在 setDbUpgradeListener 中的 onUpgrade 方法中添加或删除列，最后在实体中添加相应的字段即可</strong>。</p>\n<p>项目比较小，遇到的问题也就这些，需要查看该app的，请访问<a href=\"https://www.pgyer.com/ygjexpress\">内测平台</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj0opuceu0009g0g5zz2u4bdb","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucfq000ug0g5umyey953"},{"post_id":"cj0opuceu0009g0g5zz2u4bdb","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucg5000yg0g560idqxty"},{"post_id":"cj0opucfq000ng0g57d0ikmrb","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucg50010g0g53nftl21i"},{"post_id":"cj0opucfq000ng0g57d0ikmrb","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucg50014g0g59dvxbsg5"},{"post_id":"cj0opucfq000rg0g58urm3p6t","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucg50017g0g591np156a"},{"post_id":"cj0opucfq000rg0g58urm3p6t","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucgl001cg0g53k3y2cp5"},{"post_id":"cj0opucdz0001g0g51a3vla5g","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucgl001fg0g5uzqpx0tv"},{"post_id":"cj0opucdz0001g0g51a3vla5g","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuch0001ig0g570kxz33t"},{"post_id":"cj0opucfq000tg0g5cyl5xlfe","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuch0001lg0g5pmre01ih"},{"post_id":"cj0opucfq000tg0g5cyl5xlfe","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuchg001og0g5wvdl160a"},{"post_id":"cj0opucg5000xg0g5id4tolgd","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuchg001rg0g5fgoxg5fk"},{"post_id":"cj0opucg5000xg0g5id4tolgd","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuchg001vg0g50t4j7xf9"},{"post_id":"cj0opuceu000bg0g54i5aro9j","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuchw001zg0g50fbf0fge"},{"post_id":"cj0opuceu000bg0g54i5aro9j","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuchw0023g0g55brx3nan"},{"post_id":"cj0opucg5000zg0g5sdoblqaz","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuchw0026g0g5ywuulut1"},{"post_id":"cj0opucg5000zg0g5sdoblqaz","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucib002ag0g5ocloiwth"},{"post_id":"cj0opucg50013g0g5fhtlka9i","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucib002dg0g5q5emid4m"},{"post_id":"cj0opucg50013g0g5fhtlka9i","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucib002hg0g5k886dl9r"},{"post_id":"cj0opucfa000dg0g5x3buf32v","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucib002jg0g5ec2hgvb7"},{"post_id":"cj0opucfa000dg0g5x3buf32v","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucib002ng0g5qglti8ms"},{"post_id":"cj0opucg50016g0g5ri2d0c3i","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucib002qg0g5i4gola58"},{"post_id":"cj0opucg50016g0g5ri2d0c3i","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucir002vg0g5i6wqj6kx"},{"post_id":"cj0opucg5001bg0g5mzr2w7rg","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucir002xg0g5wkelf9re"},{"post_id":"cj0opucg5001bg0g5mzr2w7rg","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucir0031g0g56vnb4zrv"},{"post_id":"cj0opucdz0003g0g57bvkihsd","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucir0034g0g58u9598vv"},{"post_id":"cj0opucdz0003g0g57bvkihsd","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucir0037g0g5trr4qg3g"},{"post_id":"cj0opucfa000eg0g5pz5kkt2j","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucj7003cg0g570itbatl"},{"post_id":"cj0opucfa000eg0g5pz5kkt2j","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucj7003eg0g5epvjiwoc"},{"post_id":"cj0opuch0001ng0g50v9q1cnh","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucj7003ig0g5qlomdkbk"},{"post_id":"cj0opuch0001ng0g50v9q1cnh","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucjm003lg0g5oryv5eh5"},{"post_id":"cj0opucfa000hg0g5hb352hag","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucjm003qg0g53yjiidvm"},{"post_id":"cj0opucfa000hg0g5hb352hag","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucjm003tg0g5uvw41b7k"},{"post_id":"cj0opuchg001qg0g53ckqz67f","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucjm003yg0g50yfmm3hj"},{"post_id":"cj0opuchg001qg0g53ckqz67f","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuck20041g0g5gntihs7f"},{"post_id":"cj0opuchg001ug0g57rl2ywe4","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuck20045g0g5xkgco4op"},{"post_id":"cj0opuchg001ug0g57rl2ywe4","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuck20049g0g56gna6tn9"},{"post_id":"cj0opucef0007g0g5tliq2emk","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuck2004dg0g5zawfibr8"},{"post_id":"cj0opucef0007g0g5tliq2emk","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckh004hg0g5a34s53m6"},{"post_id":"cj0opuchg001yg0g5tr23q13a","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckh004lg0g5bafbfxry"},{"post_id":"cj0opuchg001yg0g5tr23q13a","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckh004ng0g53frqi7hx"},{"post_id":"cj0opuchw0022g0g51f4qizuw","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckh004qg0g5vfndlynr"},{"post_id":"cj0opuchw0022g0g51f4qizuw","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckh004tg0g56xsy8bxj"},{"post_id":"cj0opucfa000ig0g50y8t7uyl","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckh004vg0g5qsdnozea"},{"post_id":"cj0opucfa000ig0g50y8t7uyl","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckh004wg0g5mfgyr0g4"},{"post_id":"cj0opucgl001eg0g5k4yq5q7i","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckh004zg0g5jcgqe23t"},{"post_id":"cj0opucgl001eg0g5k4yq5q7i","category_id":"cj0opucib002fg0g5y207so8l","_id":"cj0opuckh0050g0g5u3q6mq48"},{"post_id":"cj0opucgl001hg0g5dh5gksg6","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckh0053g0g5dz5vd9en"},{"post_id":"cj0opucgl001hg0g5dh5gksg6","category_id":"cj0opucib002lg0g5ysge362j","_id":"cj0opuckh0055g0g5wlk8rfwi"},{"post_id":"cj0opuch0001kg0g59lgv0aeb","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckx0059g0g5xkj909y6"},{"post_id":"cj0opuch0001kg0g59lgv0aeb","category_id":"cj0opucib002lg0g5ysge362j","_id":"cj0opuckx005bg0g534wyofp7"},{"post_id":"cj0opucir0033g0g5c0a4pfkn","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckx005eg0g5zr4w5egz"},{"post_id":"cj0opucir0033g0g5c0a4pfkn","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckx005gg0g53zj2cne6"},{"post_id":"cj0opucir0036g0g54g9vdvn6","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckx005ig0g5qsg19kml"},{"post_id":"cj0opucir0036g0g54g9vdvn6","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckx005mg0g5kqwpv8k3"},{"post_id":"cj0opucj7003bg0g52rkgz8hm","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckx005og0g5xq7v9xkz"},{"post_id":"cj0opucj7003bg0g52rkgz8hm","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckx005sg0g5ie3shtmo"},{"post_id":"cj0opucj7003dg0g55sal9vmf","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckx005tg0g5b8mrwe4j"},{"post_id":"cj0opucj7003dg0g55sal9vmf","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckx005wg0g571fwdzcg"},{"post_id":"cj0opucj7003hg0g56fg3d1j9","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckx005xg0g5qnjjw675"},{"post_id":"cj0opucj7003hg0g56fg3d1j9","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckx0060g0g5ypcr1adg"},{"post_id":"cj0opucfq000lg0g524jsatk8","category_id":"cj0opuchw0027g0g5d9d9iall","_id":"cj0opuckx0062g0g5wufotz3k"},{"post_id":"cj0opucfq000lg0g524jsatk8","category_id":"cj0opucj7003fg0g5tyc3ldz6","_id":"cj0opuckx0065g0g5hp4uj0ri"},{"post_id":"cj0opucjm003pg0g5m0kn1cbu","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckx0068g0g5n84o2lyr"},{"post_id":"cj0opucjm003pg0g5m0kn1cbu","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckx006ag0g55rlvx5pb"},{"post_id":"cj0opucjm003sg0g5zfoct8a2","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckx006cg0g5oyrx8qls"},{"post_id":"cj0opucjm003sg0g5zfoct8a2","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckx006eg0g5gwd8lygd"},{"post_id":"cj0opucjm003xg0g55w5wcb2v","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opuckx006gg0g5gbscegrz"},{"post_id":"cj0opucjm003xg0g55w5wcb2v","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opuckx006ig0g53hq3vv43"},{"post_id":"cj0opuck20040g0g5d5cc4jp7","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucld006mg0g54m1mh4ru"},{"post_id":"cj0opuck20040g0g5d5cc4jp7","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucld006og0g5kn8w7dk9"},{"post_id":"cj0opuck20044g0g5dkfz52r9","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucld006qg0g5rhna7wx1"},{"post_id":"cj0opuck20044g0g5dkfz52r9","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucld006tg0g5p2fh509t"},{"post_id":"cj0opuck20048g0g56f6jqo89","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucld006wg0g5n9varbrd"},{"post_id":"cj0opuck20048g0g56f6jqo89","category_id":"cj0opucfa000jg0g53m971q29","_id":"cj0opucld006zg0g5xnnk6us8"},{"post_id":"cj0opuchw0025g0g5imsdrmv8","category_id":"cj0opucir0030g0g5p6g1kgmc","_id":"cj0opucld0071g0g5zj8s9nt4"},{"post_id":"cj0opuchw0025g0g5imsdrmv8","category_id":"cj0opuckh0052g0g556s0hga9","_id":"cj0opucld0073g0g5wzf9bk56"},{"post_id":"cj0opuchw0029g0g5dy1wl9f4","category_id":"cj0opucir0030g0g5p6g1kgmc","_id":"cj0opucld0075g0g5sykgok2m"},{"post_id":"cj0opuchw0029g0g5dy1wl9f4","category_id":"cj0opuckh0052g0g556s0hga9","_id":"cj0opucld0078g0g5hx97gdey"},{"post_id":"cj0opucj7003kg0g55x9e137d","category_id":"cj0opucir0030g0g5p6g1kgmc","_id":"cj0opucld0079g0g50frw9fxb"},{"post_id":"cj0opucj7003kg0g55x9e137d","category_id":"cj0opuckx005dg0g545mnom1u","_id":"cj0opucld007ag0g5f1lneifn"},{"post_id":"cj0opucib002cg0g5zg1oxwc0","category_id":"cj0opucjm003ng0g5371zqwog","_id":"cj0opucld007dg0g5bpq2xr95"},{"post_id":"cj0opucib002cg0g5zg1oxwc0","category_id":"cj0opuckx005kg0g52dl8gca1","_id":"cj0opucld007fg0g535bs1496"},{"post_id":"cj0opucib002gg0g5fg5cph94","category_id":"cj0opucjm003ng0g5371zqwog","_id":"cj0opucld007ig0g5hyn96lo1"},{"post_id":"cj0opucib002gg0g5fg5cph94","category_id":"cj0opuckx005qg0g5m9ibkixz","_id":"cj0opucls007kg0g5ewdtj8j3"},{"post_id":"cj0opucib002ig0g5saakc8u8","category_id":"cj0opucjm003ng0g5371zqwog","_id":"cj0opucls007ng0g5wgfqobra"},{"post_id":"cj0opucib002ig0g5saakc8u8","category_id":"cj0opuckx005qg0g5m9ibkixz","_id":"cj0opucls007pg0g57qbypqqi"},{"post_id":"cj0opuck2004cg0g5dvsa28fs","category_id":"cj0opuckx005yg0g5fhk34np8","_id":"cj0opucls007sg0g53y47maj9"},{"post_id":"cj0opuckh004gg0g5cbwodtph","category_id":"cj0opuckx005yg0g5fhk34np8","_id":"cj0opucls007ug0g5akszpae0"},{"post_id":"cj0opucib002mg0g53jnqke6j","category_id":"cj0opucjm003ng0g5371zqwog","_id":"cj0opucls007xg0g5sn54lsqz"},{"post_id":"cj0opucib002mg0g53jnqke6j","category_id":"cj0opuckx005qg0g5m9ibkixz","_id":"cj0opucls007zg0g5duig93fk"},{"post_id":"cj0opuckh004kg0g59iwpjtxv","category_id":"cj0opucef0005g0g5j0xbgnni","_id":"cj0opucls0082g0g53z4qg7i3"},{"post_id":"cj0opuckh004kg0g59iwpjtxv","category_id":"cj0opuckx006dg0g5yukldigr","_id":"cj0opucls0083g0g5xk9ihenm"},{"post_id":"cj0opucib002pg0g5gmfo79gv","category_id":"cj0opucjm003ng0g5371zqwog","_id":"cj0opucls0084g0g5pcmlzd27"},{"post_id":"cj0opucib002pg0g5gmfo79gv","category_id":"cj0opuckx005qg0g5m9ibkixz","_id":"cj0opucls0087g0g5ffyc7kf5"},{"post_id":"cj0opucir002tg0g5l4ja2gnx","category_id":"cj0opucjm003ng0g5371zqwog","_id":"cj0opucls0089g0g5hiixh20k"},{"post_id":"cj0opucir002tg0g5l4ja2gnx","category_id":"cj0opuckx005qg0g5m9ibkixz","_id":"cj0opucls008bg0g5gn2ben7n"},{"post_id":"cj0opucir002wg0g5kp0vbonu","category_id":"cj0opucjm003ng0g5371zqwog","_id":"cj0opucls008dg0g5gcv0x7i8"},{"post_id":"cj0opucir002wg0g5kp0vbonu","category_id":"cj0opuckx005qg0g5m9ibkixz","_id":"cj0opucls008gg0g5oo24x3re"},{"post_id":"cj0opucir002zg0g5vuvfkj1w","category_id":"cj0opucjm003ng0g5371zqwog","_id":"cj0opucls008ig0g5uu62972q"},{"post_id":"cj0opucir002zg0g5vuvfkj1w","category_id":"cj0opuckx005qg0g5m9ibkixz","_id":"cj0opucls008lg0g5ev1u4ym0"}],"PostTag":[{"post_id":"cj0opucdz0001g0g51a3vla5g","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucfq000mg0g5q4i72spl"},{"post_id":"cj0opucdz0001g0g51a3vla5g","tag_id":"cj0opuceu000ag0g579qh2hea","_id":"cj0opucfq000og0g5v421qr6i"},{"post_id":"cj0opucdz0001g0g51a3vla5g","tag_id":"cj0opucfa000gg0g5blhh5tox","_id":"cj0opucfq000sg0g5dur2nq1o"},{"post_id":"cj0opucdz0003g0g57bvkihsd","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucg50015g0g5y1qkukhp"},{"post_id":"cj0opucdz0003g0g57bvkihsd","tag_id":"cj0opuceu000ag0g579qh2hea","_id":"cj0opucg50019g0g5s7yt4bv8"},{"post_id":"cj0opucdz0003g0g57bvkihsd","tag_id":"cj0opucfq000wg0g5bnfe4o1v","_id":"cj0opucgl001dg0g54btue6q7"},{"post_id":"cj0opucef0007g0g5tliq2emk","tag_id":"cj0opucg50012g0g5wf5tyj0k","_id":"cj0opuchg001sg0g5li46qdwn"},{"post_id":"cj0opucef0007g0g5tliq2emk","tag_id":"cj0opucg5001ag0g50emyvy3d","_id":"cj0opuchg001wg0g510jz0nv6"},{"post_id":"cj0opucef0007g0g5tliq2emk","tag_id":"cj0opuch0001jg0g5t6mhj5c0","_id":"cj0opuchw0020g0g58k5m6sjo"},{"post_id":"cj0opuceu0009g0g5zz2u4bdb","tag_id":"cj0opuchg001pg0g54u85oph4","_id":"cj0opuchw0028g0g5phmihlf0"},{"post_id":"cj0opuceu0009g0g5zz2u4bdb","tag_id":"cj0opuchg001xg0g5bblute14","_id":"cj0opucib002bg0g5rson55gl"},{"post_id":"cj0opuceu000bg0g54i5aro9j","tag_id":"cj0opuchw0024g0g5r92nvev4","_id":"cj0opucib002og0g5r1dm55q1"},{"post_id":"cj0opuceu000bg0g54i5aro9j","tag_id":"cj0opucib002eg0g5rnh1crrl","_id":"cj0opucib002rg0g5khw44tbf"},{"post_id":"cj0opucfa000dg0g5x3buf32v","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucir0032g0g59l2s6xbl"},{"post_id":"cj0opucfa000dg0g5x3buf32v","tag_id":"cj0opucib002kg0g5sv642g1d","_id":"cj0opucir0035g0g5ojlipqxq"},{"post_id":"cj0opucfa000dg0g5x3buf32v","tag_id":"cj0opucir002sg0g5azzm1yz2","_id":"cj0opucj7003ag0g5thc0uiaq"},{"post_id":"cj0opucfa000eg0g5pz5kkt2j","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucj7003jg0g5gmh05vsi"},{"post_id":"cj0opucfa000eg0g5pz5kkt2j","tag_id":"cj0opucir002yg0g5i5l5jqnp","_id":"cj0opucjm003mg0g5nf0kdh2q"},{"post_id":"cj0opucfa000eg0g5pz5kkt2j","tag_id":"cj0opucir0038g0g5bifbv85l","_id":"cj0opucjm003rg0g5e3onkvw1"},{"post_id":"cj0opucj7003dg0g55sal9vmf","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucjm003ug0g54wn4yw4q"},{"post_id":"cj0opucj7003dg0g55sal9vmf","tag_id":"cj0opucib002eg0g5rnh1crrl","_id":"cj0opuck2003zg0g5kft3qayv"},{"post_id":"cj0opucj7003hg0g56fg3d1j9","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opuck20042g0g5ti3qpf0x"},{"post_id":"cj0opucj7003hg0g56fg3d1j9","tag_id":"cj0opucib002eg0g5rnh1crrl","_id":"cj0opuck20047g0g5uhobbn38"},{"post_id":"cj0opucfa000hg0g5hb352hag","tag_id":"cj0opucj7003gg0g5oowiyj7n","_id":"cj0opuck2004ag0g5glbla7ok"},{"post_id":"cj0opucfa000hg0g5hb352hag","tag_id":"cj0opucjm003og0g5do1hso7e","_id":"cj0opuck2004eg0g5shk40y5p"},{"post_id":"cj0opucfa000hg0g5hb352hag","tag_id":"cj0opucjm003wg0g5zr9d90z6","_id":"cj0opuckh004ig0g5cipqsy7z"},{"post_id":"cj0opucfa000ig0g50y8t7uyl","tag_id":"cj0opuck20046g0g5bcsch9cn","_id":"cj0opuckh004og0g5kudt0j34"},{"post_id":"cj0opucfa000ig0g50y8t7uyl","tag_id":"cj0opuck2004fg0g5jqasknwz","_id":"cj0opuckh004rg0g5tijsugem"},{"post_id":"cj0opucfq000lg0g524jsatk8","tag_id":"cj0opuckh004mg0g5hblfn9ez","_id":"cj0opuckh0054g0g5qdxs3wyi"},{"post_id":"cj0opucfq000lg0g524jsatk8","tag_id":"cj0opuckh004sg0g5h7bedlru","_id":"cj0opuckh0056g0g5sdnl6f65"},{"post_id":"cj0opucfq000lg0g524jsatk8","tag_id":"cj0opuckh004xg0g5h4jutcrk","_id":"cj0opuckx005ag0g5nkihtws4"},{"post_id":"cj0opucfq000ng0g57d0ikmrb","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opuckx005fg0g5ppvgyn1q"},{"post_id":"cj0opucfq000ng0g57d0ikmrb","tag_id":"cj0opuckh0051g0g5lysx4eiz","_id":"cj0opuckx005hg0g5z4b8wc4g"},{"post_id":"cj0opucfq000ng0g57d0ikmrb","tag_id":"cj0opuckh0057g0g59eq8n58b","_id":"cj0opuckx005lg0g5oiz89ap5"},{"post_id":"cj0opucfq000rg0g58urm3p6t","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opuckx005ng0g5d5xous3u"},{"post_id":"cj0opucfq000rg0g58urm3p6t","tag_id":"cj0opuckx005cg0g5iutt1ei4","_id":"cj0opuckx005rg0g58dert1so"},{"post_id":"cj0opucfq000tg0g5cyl5xlfe","tag_id":"cj0opuckx005jg0g5mx46jb7c","_id":"cj0opuckx0061g0g52esycaum"},{"post_id":"cj0opucfq000tg0g5cyl5xlfe","tag_id":"cj0opuckx005pg0g5id036rh0","_id":"cj0opuckx0063g0g55o2zn51x"},{"post_id":"cj0opucfq000tg0g5cyl5xlfe","tag_id":"cj0opuckx005ug0g59ryqyezr","_id":"cj0opuckx0067g0g59teir943"},{"post_id":"cj0opucg5000xg0g5id4tolgd","tag_id":"cj0opuckx005zg0g5ozbx4qqk","_id":"cj0opuckx006hg0g56rwvwbwf"},{"post_id":"cj0opucg5000xg0g5id4tolgd","tag_id":"cj0opuckx0066g0g5fkhxf43x","_id":"cj0opucld006kg0g51wm12y3r"},{"post_id":"cj0opucg5000xg0g5id4tolgd","tag_id":"cj0opuckx006bg0g5sls7dtcq","_id":"cj0opucld006ng0g5df6txbbs"},{"post_id":"cj0opucg5000zg0g5sdoblqaz","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucld006sg0g5hg8wkto3"},{"post_id":"cj0opucg5000zg0g5sdoblqaz","tag_id":"cj0opuckx006fg0g5fz3wczc3","_id":"cj0opucld006vg0g5xqtz4ohk"},{"post_id":"cj0opucg5000zg0g5sdoblqaz","tag_id":"cj0opucld006lg0g52ucagxeg","_id":"cj0opucld006yg0g565qpd5q0"},{"post_id":"cj0opucg50013g0g5fhtlka9i","tag_id":"cj0opucld006rg0g5hi9dsqbg","_id":"cj0opucld0074g0g5x5ouzaap"},{"post_id":"cj0opucg50013g0g5fhtlka9i","tag_id":"cj0opucld006xg0g5dhtaqgru","_id":"cj0opucld0076g0g52mbg0oju"},{"post_id":"cj0opucg50016g0g5ri2d0c3i","tag_id":"cj0opucg50012g0g5wf5tyj0k","_id":"cj0opucld007cg0g5rwbuwxxy"},{"post_id":"cj0opucg50016g0g5ri2d0c3i","tag_id":"cj0opucld0072g0g5gufz87tr","_id":"cj0opucld007eg0g5xebr061l"},{"post_id":"cj0opucg50016g0g5ri2d0c3i","tag_id":"cj0opucld0077g0g53qk582bi","_id":"cj0opucld007hg0g5bogur96a"},{"post_id":"cj0opucg5001bg0g5mzr2w7rg","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucld007jg0g500f3sxaz"},{"post_id":"cj0opucg5001bg0g5mzr2w7rg","tag_id":"cj0opucld007bg0g52z8x9aip","_id":"cj0opucls007mg0g5pwslez0x"},{"post_id":"cj0opucgl001eg0g5k4yq5q7i","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucls007og0g5xcjudb4v"},{"post_id":"cj0opucgl001eg0g5k4yq5q7i","tag_id":"cj0opucib002eg0g5rnh1crrl","_id":"cj0opucls007rg0g55oj3jqgd"},{"post_id":"cj0opucgl001hg0g5dh5gksg6","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucls007tg0g5w7d15mpl"},{"post_id":"cj0opucgl001hg0g5dh5gksg6","tag_id":"cj0opucls007lg0g541ru0a0u","_id":"cj0opucls007wg0g5jvmuw4pn"},{"post_id":"cj0opuch0001kg0g59lgv0aeb","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucls007yg0g5nbrz4ptu"},{"post_id":"cj0opuch0001kg0g59lgv0aeb","tag_id":"cj0opucls007lg0g541ru0a0u","_id":"cj0opucls0081g0g5uz4uw12j"},{"post_id":"cj0opuch0001ng0g50v9q1cnh","tag_id":"cj0opucls007vg0g55af7oonw","_id":"cj0opucls0086g0g52779hj7d"},{"post_id":"cj0opuch0001ng0g50v9q1cnh","tag_id":"cj0opucls0080g0g5k1tgthq9","_id":"cj0opucls0088g0g529yqhup0"},{"post_id":"cj0opuchg001qg0g53ckqz67f","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucls008cg0g544s5s3pf"},{"post_id":"cj0opuchg001qg0g53ckqz67f","tag_id":"cj0opucls0085g0g550815vm9","_id":"cj0opucls008eg0g5qvmerc2r"},{"post_id":"cj0opuchg001ug0g57rl2ywe4","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucls008hg0g5p3m5nryr"},{"post_id":"cj0opuchg001ug0g57rl2ywe4","tag_id":"cj0opucls008ag0g5iwqzrnvf","_id":"cj0opucls008jg0g54uok64ud"},{"post_id":"cj0opuchg001yg0g5tr23q13a","tag_id":"cj0opucls008fg0g5x3r2d97u","_id":"cj0opucls008ng0g5esv1zmi3"},{"post_id":"cj0opuchg001yg0g5tr23q13a","tag_id":"cj0opucls008kg0g5sdk5qgs5","_id":"cj0opucls008og0g5uf6k7qcj"},{"post_id":"cj0opuchw0022g0g51f4qizuw","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucls008qg0g5cnsd4c8e"},{"post_id":"cj0opuchw0022g0g51f4qizuw","tag_id":"cj0opucls008mg0g5uf6v5tvs","_id":"cj0opucls008rg0g5nupn14k1"},{"post_id":"cj0opuchw0025g0g5imsdrmv8","tag_id":"cj0opucls008pg0g54vwojcfd","_id":"cj0opucls008ug0g5gtm6wmp5"},{"post_id":"cj0opuchw0025g0g5imsdrmv8","tag_id":"cj0opucls008sg0g5xzctuw32","_id":"cj0opucls008vg0g5fy25kzv9"},{"post_id":"cj0opuchw0029g0g5dy1wl9f4","tag_id":"cj0opucls008tg0g5pdf5jg46","_id":"cj0opucm8008yg0g5ez9g33k0"},{"post_id":"cj0opuchw0029g0g5dy1wl9f4","tag_id":"cj0opucls008wg0g5t30m0zmq","_id":"cj0opucm8008zg0g5chzg5kgv"},{"post_id":"cj0opucib002cg0g5zg1oxwc0","tag_id":"cj0opucls008xg0g5jwgt6nn9","_id":"cj0opucm80093g0g54q5v1786"},{"post_id":"cj0opucib002cg0g5zg1oxwc0","tag_id":"cj0opucm80090g0g5yyv8axja","_id":"cj0opucm80094g0g5mtq3yi50"},{"post_id":"cj0opucib002cg0g5zg1oxwc0","tag_id":"cj0opucm80091g0g5itrihps5","_id":"cj0opucm80096g0g5abirbecr"},{"post_id":"cj0opucib002gg0g5fg5cph94","tag_id":"cj0opucls008xg0g5jwgt6nn9","_id":"cj0opucm80098g0g5c50m7z7a"},{"post_id":"cj0opucib002gg0g5fg5cph94","tag_id":"cj0opucm80095g0g5tdeqq4i6","_id":"cj0opucm80099g0g5p8kv9lc0"},{"post_id":"cj0opucib002ig0g5saakc8u8","tag_id":"cj0opucls008xg0g5jwgt6nn9","_id":"cj0opucm8009dg0g5dgnmnng7"},{"post_id":"cj0opucib002ig0g5saakc8u8","tag_id":"cj0opucm8009ag0g52jul0902","_id":"cj0opucm8009eg0g5kh7e29ln"},{"post_id":"cj0opucib002ig0g5saakc8u8","tag_id":"cj0opucm8009bg0g5vcguukso","_id":"cj0opucm8009gg0g5cjc86kt3"},{"post_id":"cj0opucib002mg0g53jnqke6j","tag_id":"cj0opucls008xg0g5jwgt6nn9","_id":"cj0opucm8009ig0g56ky3mnox"},{"post_id":"cj0opucib002mg0g53jnqke6j","tag_id":"cj0opucm8009fg0g56nhmknht","_id":"cj0opucm8009jg0g54rdb0d7g"},{"post_id":"cj0opucib002pg0g5gmfo79gv","tag_id":"cj0opucls008xg0g5jwgt6nn9","_id":"cj0opucm8009ng0g51tdnx923"},{"post_id":"cj0opucib002pg0g5gmfo79gv","tag_id":"cj0opucm8009kg0g5a7icjxuq","_id":"cj0opucm8009og0g5r6w9jckf"},{"post_id":"cj0opucib002pg0g5gmfo79gv","tag_id":"cj0opucm8009bg0g5vcguukso","_id":"cj0opucm8009qg0g5fej6akvz"},{"post_id":"cj0opucir002tg0g5l4ja2gnx","tag_id":"cj0opucls008xg0g5jwgt6nn9","_id":"cj0opucm8009tg0g5y1ux1ffs"},{"post_id":"cj0opucir002tg0g5l4ja2gnx","tag_id":"cj0opucm8009pg0g53l8qo707","_id":"cj0opucm8009ug0g5lr4j9b3z"},{"post_id":"cj0opucir002tg0g5l4ja2gnx","tag_id":"cj0opucm8009bg0g5vcguukso","_id":"cj0opucm8009wg0g51x35nou5"},{"post_id":"cj0opucir002wg0g5kp0vbonu","tag_id":"cj0opucls008xg0g5jwgt6nn9","_id":"cj0opucmo009zg0g5r3is3240"},{"post_id":"cj0opucir002wg0g5kp0vbonu","tag_id":"cj0opucm8009vg0g5dixn9lv8","_id":"cj0opucmo00a0g0g5j549sa7b"},{"post_id":"cj0opucir002wg0g5kp0vbonu","tag_id":"cj0opucm8009xg0g51j3mwxdm","_id":"cj0opucmo00a2g0g5odlpeict"},{"post_id":"cj0opucir002zg0g5vuvfkj1w","tag_id":"cj0opucls008xg0g5jwgt6nn9","_id":"cj0opucmo00a5g0g5v1gnrhuz"},{"post_id":"cj0opucir002zg0g5vuvfkj1w","tag_id":"cj0opucmo00a1g0g5r9hhiok3","_id":"cj0opucmo00a6g0g5dyybqycp"},{"post_id":"cj0opucir002zg0g5vuvfkj1w","tag_id":"cj0opucmo00a3g0g5ngq4fvrt","_id":"cj0opucmo00a8g0g5y0r4ml3g"},{"post_id":"cj0opucir0033g0g5c0a4pfkn","tag_id":"cj0opucmo00a4g0g5b75gl6kd","_id":"cj0opucmo00aag0g531t54ino"},{"post_id":"cj0opucir0033g0g5c0a4pfkn","tag_id":"cj0opucmo00a7g0g5egxz2elw","_id":"cj0opucmo00abg0g5wrd9xlae"},{"post_id":"cj0opucir0036g0g54g9vdvn6","tag_id":"cj0opucmo00a9g0g578nbcxqv","_id":"cj0opucn300aeg0g5ehv8lkhq"},{"post_id":"cj0opucir0036g0g54g9vdvn6","tag_id":"cj0opucmo00acg0g5b42xedxk","_id":"cj0opucn300afg0g5ic63dk87"},{"post_id":"cj0opucj7003bg0g52rkgz8hm","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucn300ahg0g5lh2e40aw"},{"post_id":"cj0opucj7003bg0g52rkgz8hm","tag_id":"cj0opucn300adg0g524uq49ek","_id":"cj0opucn300aig0g55arsp0gn"},{"post_id":"cj0opucj7003kg0g55x9e137d","tag_id":"cj0opucn300agg0g5b1ztsnpu","_id":"cj0opucn300alg0g5uwi15xbm"},{"post_id":"cj0opucj7003kg0g55x9e137d","tag_id":"cj0opucn300ajg0g5ih844z26","_id":"cj0opucn300amg0g5lt36uaok"},{"post_id":"cj0opucjm003pg0g5m0kn1cbu","tag_id":"cj0opucn300akg0g5icu52u79","_id":"cj0opucn300apg0g5z2kalsyo"},{"post_id":"cj0opucjm003pg0g5m0kn1cbu","tag_id":"cj0opucn300ang0g5kjt1gwhr","_id":"cj0opucn300aqg0g5t05s13ti"},{"post_id":"cj0opucjm003sg0g5zfoct8a2","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucn300asg0g5wit4xzsy"},{"post_id":"cj0opucjm003sg0g5zfoct8a2","tag_id":"cj0opucn300aog0g59jcg72y6","_id":"cj0opucn300atg0g5h4motc61"},{"post_id":"cj0opucjm003xg0g55w5wcb2v","tag_id":"cj0opucn300arg0g5zufs3v4o","_id":"cj0opucn300awg0g5zng9ptf5"},{"post_id":"cj0opucjm003xg0g55w5wcb2v","tag_id":"cj0opucn300aug0g5n8wopj4j","_id":"cj0opucn300axg0g5w3s83kf0"},{"post_id":"cj0opuck20040g0g5d5cc4jp7","tag_id":"cj0opucn300avg0g5455ok9y5","_id":"cj0opucn300b0g0g5d3vlp4pq"},{"post_id":"cj0opuck20040g0g5d5cc4jp7","tag_id":"cj0opucn300ayg0g5h6drfqv9","_id":"cj0opucn300b1g0g5utybxbzt"},{"post_id":"cj0opuck20044g0g5dkfz52r9","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucn300b4g0g5y3tqm31y"},{"post_id":"cj0opuck20044g0g5dkfz52r9","tag_id":"cj0opucn300azg0g5lr4wu09b","_id":"cj0opucn300b5g0g5s0btxl39"},{"post_id":"cj0opuck20044g0g5dkfz52r9","tag_id":"cj0opucn300b2g0g54hsuc2nz","_id":"cj0opucnj00b7g0g51offszey"},{"post_id":"cj0opuck20048g0g56f6jqo89","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucnj00b9g0g5r62g1jbo"},{"post_id":"cj0opuck20048g0g56f6jqo89","tag_id":"cj0opucn300b3g0g5f484bexu","_id":"cj0opucnj00bag0g5782p14l9"},{"post_id":"cj0opuck20048g0g56f6jqo89","tag_id":"cj0opucn300aog0g59jcg72y6","_id":"cj0opucnj00bcg0g5spz9bcn8"},{"post_id":"cj0opuck2004cg0g5dvsa28fs","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucnj00beg0g5vrsk5p3l"},{"post_id":"cj0opuck2004cg0g5dvsa28fs","tag_id":"cj0opucls008xg0g5jwgt6nn9","_id":"cj0opucnj00bfg0g5wwutbb91"},{"post_id":"cj0opuck2004cg0g5dvsa28fs","tag_id":"cj0opucnj00bbg0g5q5mqspk3","_id":"cj0opucnj00bhg0g5h7bm8laq"},{"post_id":"cj0opuckh004gg0g5cbwodtph","tag_id":"cj0opucef0004g0g5klip8hqh","_id":"cj0opucnj00big0g5fmm3bgvt"},{"post_id":"cj0opuckh004gg0g5cbwodtph","tag_id":"cj0opucnj00bbg0g5q5mqspk3","_id":"cj0opucnj00bkg0g5p2uuk0yq"},{"post_id":"cj0opuckh004kg0g59iwpjtxv","tag_id":"cj0opucnj00bgg0g5u4yg4d35","_id":"cj0opucnj00bmg0g5kzdok3ct"},{"post_id":"cj0opuckh004kg0g59iwpjtxv","tag_id":"cj0opucnj00bjg0g5lp7lzuq8","_id":"cj0opucnj00bng0g5pofsqg3n"},{"post_id":"cj0opuckh004kg0g59iwpjtxv","tag_id":"cj0opucnj00blg0g5nmh70im1","_id":"cj0opucnj00bog0g53tmxlnva"}],"Tag":[{"name":"android","_id":"cj0opucef0004g0g5klip8hqh"},{"name":"蓝牙","_id":"cj0opuceu000ag0g579qh2hea"},{"name":"通信","_id":"cj0opucfa000gg0g5blhh5tox"},{"name":"聊天","_id":"cj0opucfq000wg0g5bnfe4o1v"},{"name":"View","_id":"cj0opucg50012g0g5wf5tyj0k"},{"name":"事件分发","_id":"cj0opucg5001ag0g50emyvy3d"},{"name":"滑动冲突","_id":"cj0opuch0001jg0g5t6mhj5c0"},{"name":"AsyncTask","_id":"cj0opuchg001pg0g54u85oph4"},{"name":"线程池","_id":"cj0opuchg001xg0g5bblute14"},{"name":"Eventbus","_id":"cj0opuchw0024g0g5r92nvev4"},{"name":"开源框架","_id":"cj0opucib002eg0g5rnh1crrl"},{"name":"图片缩放","_id":"cj0opucib002kg0g5sv642g1d"},{"name":"gif","_id":"cj0opucir002sg0g5azzm1yz2"},{"name":"Animator","_id":"cj0opucir002yg0g5i5l5jqnp"},{"name":"属性动画","_id":"cj0opucir0038g0g5bifbv85l"},{"name":"5.X新特新","_id":"cj0opucj7003gg0g5oowiyj7n"},{"name":"RecyclerView","_id":"cj0opucjm003og0g5do1hso7e"},{"name":"CardView","_id":"cj0opucjm003wg0g5zr9d90z6"},{"name":"5.X新特性","_id":"cj0opuck20046g0g5bcsch9cn"},{"name":"TabLayout","_id":"cj0opuck2004fg0g5jqasknwz"},{"name":"tomcat","_id":"cj0opuckh004mg0g5hblfn9ez"},{"name":"域名解析","_id":"cj0opuckh004sg0g5h7bedlru"},{"name":"二级域名","_id":"cj0opuckh004xg0g5h4jutcrk"},{"name":"Activity","_id":"cj0opuckh0051g0g5lysx4eiz"},{"name":"生命周期","_id":"cj0opuckh0057g0g59eq8n58b"},{"name":"多渠道打包","_id":"cj0opuckx005cg0g5iutt1ei4"},{"name":"android7.0","_id":"cj0opuckx005jg0g5mx46jb7c"},{"name":"拍照适配","_id":"cj0opuckx005pg0g5id036rh0"},{"name":"相册","_id":"cj0opuckx005ug0g59ryqyezr"},{"name":"IPC","_id":"cj0opuckx005zg0g5ozbx4qqk"},{"name":"AIDL","_id":"cj0opuckx0066g0g5fkhxf43x"},{"name":"进程通信","_id":"cj0opuckx006bg0g5sls7dtcq"},{"name":"aar","_id":"cj0opuckx006fg0g5fz3wczc3"},{"name":"jar","_id":"cj0opucld006lg0g52ucagxeg"},{"name":"消息机制","_id":"cj0opucld006rg0g5hi9dsqbg"},{"name":"Handler","_id":"cj0opucld006xg0g5dhtaqgru"},{"name":"自定义","_id":"cj0opucld0072g0g5gufz87tr"},{"name":"原理","_id":"cj0opucld0077g0g53qk582bi"},{"name":"异常捕获","_id":"cj0opucld007bg0g52z8x9aip"},{"name":"SQLit","_id":"cj0opucls007lg0g541ru0a0u"},{"name":"androidstudio","_id":"cj0opucls007vg0g55af7oonw"},{"name":"快捷键","_id":"cj0opucls0080g0g5k1tgthq9"},{"name":"验证码","_id":"cj0opucls0085g0g550815vm9"},{"name":"blog","_id":"cj0opucls008ag0g5iwqzrnvf"},{"name":"真机调试","_id":"cj0opucls008fg0g5x3r2d97u"},{"name":"offline","_id":"cj0opucls008kg0g5sdk5qgs5"},{"name":"widget","_id":"cj0opucls008mg0g5uf6v5tvs"},{"name":"软件","_id":"cj0opucls008pg0g54vwojcfd"},{"name":"gihub","_id":"cj0opucls008sg0g5xzctuw32"},{"name":"hexo","_id":"cj0opucls008tg0g5pdf5jg46"},{"name":"写博客","_id":"cj0opucls008wg0g5t30m0zmq"},{"name":"java","_id":"cj0opucls008xg0g5jwgt6nn9"},{"name":"继承","_id":"cj0opucm80090g0g5yyv8axja"},{"name":"多态","_id":"cj0opucm80091g0g5itrihps5"},{"name":"内存回收","_id":"cj0opucm80095g0g5tdeqq4i6"},{"name":"集合","_id":"cj0opucm8009ag0g52jul0902"},{"name":"内存管理","_id":"cj0opucm8009bg0g5vcguukso"},{"name":"反射","_id":"cj0opucm8009fg0g56nhmknht"},{"name":"对象","_id":"cj0opucm8009kg0g5a7icjxuq"},{"name":"数组","_id":"cj0opucm8009pg0g53l8qo707"},{"name":"注解","_id":"cj0opucm8009vg0g5dixn9lv8"},{"name":"自定义注解","_id":"cj0opucm8009xg0g51j3mwxdm"},{"name":"拆装箱","_id":"cj0opucmo00a1g0g5r9hhiok3"},{"name":"Integer缓存","_id":"cj0opucmo00a3g0g5ngq4fvrt"},{"name":"ScrollView","_id":"cj0opucmo00a4g0g5b75gl6kd"},{"name":"ListView","_id":"cj0opucmo00a7g0g5egxz2elw"},{"name":"Listview","_id":"cj0opucmo00a9g0g578nbcxqv"},{"name":"性能优化","_id":"cj0opucmo00acg0g5b42xedxk"},{"name":"打开应用","_id":"cj0opucn300adg0g524uq49ek"},{"name":"oracle","_id":"cj0opucn300agg0g5b1ztsnpu"},{"name":"PL/SQL","_id":"cj0opucn300ajg0g5ih844z26"},{"name":"gradle","_id":"cj0opucn300akg0g5icu52u79"},{"name":"jcenter","_id":"cj0opucn300ang0g5kjt1gwhr"},{"name":"屏幕适配","_id":"cj0opucn300aog0g59jcg72y6"},{"name":"学习路线","_id":"cj0opucn300arg0g5zufs3v4o"},{"name":"总结","_id":"cj0opucn300aug0g5n8wopj4j"},{"name":"DataBinding","_id":"cj0opucn300avg0g5455ok9y5"},{"name":"数据绑定","_id":"cj0opucn300ayg0g5h6drfqv9"},{"name":"Animation","_id":"cj0opucn300azg0g5lr4wu09b"},{"name":"动画","_id":"cj0opucn300b2g0g54hsuc2nz"},{"name":"webview","_id":"cj0opucn300b3g0g5f484bexu"},{"name":"面试","_id":"cj0opucnj00bbg0g5q5mqspk3"},{"name":"拍照oom","_id":"cj0opucnj00bgg0g5u4yg4d35"},{"name":"图片错位","_id":"cj0opucnj00bjg0g5lp7lzuq8"},{"name":"xutils3","_id":"cj0opucnj00blg0g5nmh70im1"}]}}